###############################################################################
#
#                                                         22/Sep/2022  08:40:14
# IAR ANSI C/C++ Compiler V9.20.3.326/W64 for ARM Functional Safety
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode                 =  thumb
#    Endian                   =  little
#    Source file              =  C:\D\Git_Hub\STM_IAR_SIL_Change\Library\QBuf.c
#    Command line             =
#        -f C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Library\QBuf.o.rsp
#        (C:\D\Git_Hub\STM_IAR_SIL_Change\Library\QBuf.c -D USE_HAL_DRIVER -D
#        STM32F407xx -lC C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Library
#        -o C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Library --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e
#        --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.0 EWARM FS 9.20.3\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/App\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Core/Inc\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Include\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/display\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Library\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.0 EWARM FS 9.20.3\arm\CMSIS\Core\Include\\")
#        --dependencies=n
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Library\QBuf.o.d
#    Locale                   =  C
#    List file                =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Library\QBuf.lst
#    Object file              =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Library\QBuf.o
#    Runtime model:              
#      __CPP_Runtime          =  1
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  1
#      __dlib_version         =  6
#      __iar_require _Printf  =  flags,widths
#
###############################################################################

C:\D\Git_Hub\STM_IAR_SIL_Change\Library\QBuf.c
      1          /*------------------------------------------------------------------------------------------
      2          	Project			: It Library
      3          	Description		: Queue
      4          
      5          	Writer			: $Author: zlkit $
      6          	Revision		: $Rev: 1891 $
      7          	Date			: 2019. 10.
      8          	Copyright		: Piranti Corp.	( zlkit@piranti.co.kr )
      9          	 
     10          	Revision History 
     11          	1. 2019. 10.	: Created
     12          -------------------------------------------------------------------------------------------*/
     13          
     14          //========================================================================
     15          // Header
     16          
     17          #include <stdio.h>			//	printf()
     18          #include <string.h>			//	memcpy()
     19          
     20          #include <stdio.h>			//	printf()
     21          
     22          #include <stdint.h>			//	uint32_t
     23          
     24          #include <string.h>			//	memset()
     25          
     26          #include "typedef.h"			//	uint32_t, ...
     27          #include "compiler_defs.h"		//	U8,

  # warning unrecognized compiler
    ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\compiler_defs.h",744  Warning[Pa183]: 
          #warning directive: unrecognized compiler

  typedef unsigned char U8;
                        ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\compiler_defs.h",788  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int U16;
                       ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\compiler_defs.h",789  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned long U32;
                        ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\compiler_defs.h",790  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed char S8;
                      ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\compiler_defs.h",792  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed int S16;
                     ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\compiler_defs.h",793  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed long S32;
                      ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\compiler_defs.h",794  Warning[Pe301]: 
          typedef name has already been declared (with same type)
     28          
     29          #include "QBuf.h"
     30          
     31          #include "Adafruit_SSD1306.h"
     32          
     33          //========================================================================
     34          // Define
     35          
     36          
     37          //========================================================================
     38          // Function
     39          
     40          //------------------------------------------------------------------------------
     41          //         serial queue functions
     42          //------------------------------------------------------------------------------
     43          
     44          
     45          //===========================================================================

   \                                 In section .text, align 2, keep-with-next
     46          void init_queue( Queue_t *q )
     47          //===========================================================================
     48          {
     49          	q->front = q->rear = 0;
   \                     init_queue: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0xF8A0 0x1102      STRH     R1,[R0, #+258]
   \        0x6   0xF8B0 0x1102      LDRH     R1,[R0, #+258]
   \        0xA   0xF8A0 0x1100      STRH     R1,[R0, #+256]
     50          }
   \        0xE   0x4770             BX       LR
     51          
     52          //===========================================================================

   \                                 In section .text, align 2, keep-with-next
     53          void clear_queue( Queue_t *q )
     54          //===========================================================================
     55          {
     56          	q->front = q->rear;
   \                     clear_queue: (+1)
   \        0x0   0xF8B0 0x1102      LDRH     R1,[R0, #+258]
   \        0x4   0xF8A0 0x1100      STRH     R1,[R0, #+256]
     57          }
   \        0x8   0x4770             BX       LR
     58          
     59          //===========================================================================

   \                                 In section .text, align 2, keep-with-next
     60          uint8_t qcount( Queue_t *q )
     61          //===========================================================================
     62          {
     63          	return (((q->rear+QMAX)-q->front) % QMAX);
   \                     qcount: (+1)
   \        0x0   0xF8B0 0x1102      LDRH     R1,[R0, #+258]
   \        0x4   0xF511 0x7180      ADDS     R1,R1,#+256
   \        0x8   0xF8B0 0x0100      LDRH     R0,[R0, #+256]
   \        0xC   0x1A08             SUBS     R0,R1,R0
   \        0xE   0xF44F 0x7180      MOV      R1,#+256
   \       0x12   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \       0x16   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0x4770             BX       LR
     64          }
     65          
     66          //===========================================================================

   \                                 In section .text, align 2, keep-with-next
     67          uint8_t qput( Queue_t *q, S8 k )
     68          //===========================================================================
     69          {
   \                     qput: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0002             MOVS     R2,R0
     70          	if ( (q->rear + 1) % QMAX == q->front )
   \        0x4   0xF8B2 0x3102      LDRH     R3,[R2, #+258]
   \        0x8   0x1C5B             ADDS     R3,R3,#+1
   \        0xA   0xF44F 0x7080      MOV      R0,#+256
   \        0xE   0xFB93 0xF4F0      SDIV     R4,R3,R0
   \       0x12   0xFB00 0x3314      MLS      R3,R0,R4,R3
   \       0x16   0xF8B2 0x4100      LDRH     R4,[R2, #+256]
   \       0x1A   0x42A3             CMP      R3,R4
   \       0x1C   0xD101             BNE.N    ??qput_0
     71          	{
     72          //		printf( "\n\tCircular Queue Overflow." );
     73          //		printf( "\n\tQOver" );
     74          		return -1;
   \       0x1E   0x20FF             MOVS     R0,#+255
   \       0x20   0xE00D             B.N      ??qput_1
     75          	}
     76          	q->queue[q->rear] = k;
   \                     ??qput_0: (+1)
   \       0x22   0xF8B2 0x3102      LDRH     R3,[R2, #+258]
   \       0x26   0x54D1             STRB     R1,[R2, R3]
     77          	q->rear = (q->rear + 1) % QMAX;
   \       0x28   0xF8B2 0x3102      LDRH     R3,[R2, #+258]
   \       0x2C   0x1C5B             ADDS     R3,R3,#+1
   \       0x2E   0xFB93 0xF4F0      SDIV     R4,R3,R0
   \       0x32   0xFB00 0x3014      MLS      R0,R0,R4,R3
   \       0x36   0xF8A2 0x0102      STRH     R0,[R2, #+258]
     78          	return k;
   \       0x3A   0x0008             MOVS     R0,R1
   \       0x3C   0xB2C0             UXTB     R0,R0
   \                     ??qput_1: (+1)
   \       0x3E   0xBC10             POP      {R4}
   \       0x40   0x4770             BX       LR
     79          }
     80          
     81          //===========================================================================

   \                                 In section .text, align 2, keep-with-next
     82          uint8_t qget( Queue_t *q )
     83          //===========================================================================
     84          {
   \                     qget: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0001             MOVS     R1,R0
     85          	unsigned char i;
     86          	/*
     87          	if(front == rear){
     88          		printf("\n\tCircular Queue Underflow.");
     89          		return -1;
     90          	}
     91          	*/
     92          	i = q->queue[q->front];
   \        0x4   0xF8B1 0x0100      LDRH     R0,[R1, #+256]
   \        0x8   0x5C08             LDRB     R0,[R1, R0]
     93          	q->front = (q->front + 1) % QMAX;
   \        0xA   0xF8B1 0x2100      LDRH     R2,[R1, #+256]
   \        0xE   0x1C52             ADDS     R2,R2,#+1
   \       0x10   0xF44F 0x7380      MOV      R3,#+256
   \       0x14   0xFB92 0xF4F3      SDIV     R4,R2,R3
   \       0x18   0xFB03 0x2214      MLS      R2,R3,R4,R2
   \       0x1C   0xF8A1 0x2100      STRH     R2,[R1, #+256]
     94          
     95          	return i;
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0xBC10             POP      {R4}
   \       0x24   0x4770             BX       LR
     96          }
     97          //------------------------------------------------------------------------------
     98          
     99          
    100          //===========================================================================

   \                                 In section .text, align 2, keep-with-next
    101          void qBufInit( QBuf_t *q, uint8_t *_qBuf, uint16_t _size )
    102          //===========================================================================
    103          {
    104          	q->front = q->rear = 0;
   \                     qBufInit: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x8103             STRH     R3,[R0, #+8]
   \        0x4   0x8903             LDRH     R3,[R0, #+8]
   \        0x6   0x80C3             STRH     R3,[R0, #+6]
    105          
    106          	q->qBuf = _qBuf;
   \        0x8   0x6001             STR      R1,[R0, #+0]
    107          	q->size = _size;
   \        0xA   0x8082             STRH     R2,[R0, #+4]
    108          
    109          //	printf( "%s(%d) - q(%p) / _qBuf(%p) / _size(%d)\n", __func__, __LINE__,
    110          //		q, _qBuf, _size);
    111          }
   \        0xC   0x4770             BX       LR
    112          
    113          //===========================================================================

   \                                 In section .text, align 2, keep-with-next
    114          void qBufClear( QBuf_t *q )
    115          //===========================================================================
    116          {
    117          	q->front = q->rear;
   \                     qBufClear: (+1)
   \        0x0   0x8901             LDRH     R1,[R0, #+8]
   \        0x2   0x80C1             STRH     R1,[R0, #+6]
    118          }
   \        0x4   0x4770             BX       LR
    119          
    120          //===========================================================================

   \                                 In section .text, align 2, keep-with-next
    121          uint8_t qBufCnt( QBuf_t *q )
    122          //===========================================================================
    123          {
   \                     qBufCnt: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    124          	return ( ( ( q->rear + q->size ) - q->front ) % q->size );
   \        0x2   0x8908             LDRH     R0,[R1, #+8]
   \        0x4   0x888A             LDRH     R2,[R1, #+4]
   \        0x6   0x1812             ADDS     R2,R2,R0
   \        0x8   0x88C8             LDRH     R0,[R1, #+6]
   \        0xA   0x1A10             SUBS     R0,R2,R0
   \        0xC   0x8889             LDRH     R1,[R1, #+4]
   \        0xE   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \       0x12   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0x4770             BX       LR
    125          }
    126          
    127          //===========================================================================

   \                                 In section .text, align 2, keep-with-next
    128          uint8_t qBufPut( QBuf_t *q, uint8_t *pBuf, uint16_t size )
    129          //===========================================================================
    130          {
   \                     qBufPut: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    131          	if ( ( q->rear + size ) % q->size == q->front )
   \        0xA   0x8920             LDRH     R0,[R4, #+8]
   \        0xC   0xFA10 0xF086      UXTAH    R0,R0,R6
   \       0x10   0x88A1             LDRH     R1,[R4, #+4]
   \       0x12   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \       0x16   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \       0x1A   0x88E1             LDRH     R1,[R4, #+6]
   \       0x1C   0x4288             CMP      R0,R1
   \       0x1E   0xD101             BNE.N    ??qBufPut_0
    132          	{
    133          //		printf( "\n\tCircular Queue Overflow." );
    134          		return -1;
   \       0x20   0x20FF             MOVS     R0,#+255
   \       0x22   0xE016             B.N      ??qBufPut_1
    135          	}
    136          
    137          	memcpy( &q->qBuf[q->rear], pBuf, size );
   \                     ??qBufPut_0: (+1)
   \       0x24   0x0037             MOVS     R7,R6
   \       0x26   0xB2BF             UXTH     R7,R7
   \       0x28   0x46A8             MOV      R8,R5
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x8921             LDRH     R1,[R4, #+8]
   \       0x2E   0xEB00 0x0901      ADD      R9,R0,R1
   \       0x32   0x003A             MOVS     R2,R7
   \       0x34   0x4641             MOV      R1,R8
   \       0x36   0x4648             MOV      R0,R9
   \       0x38   0x.... 0x....      BL       __aeabi_memcpy
    138          //	q->qBuf[q->rear] = k;
    139          	q->rear = ( q->rear + size ) % q->size;
   \       0x3C   0x8920             LDRH     R0,[R4, #+8]
   \       0x3E   0xFA10 0xF086      UXTAH    R0,R0,R6
   \       0x42   0x88A1             LDRH     R1,[R4, #+4]
   \       0x44   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \       0x48   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \       0x4C   0x8120             STRH     R0,[R4, #+8]
    140          
    141          //	printf( "%s(%d) - q(%p) / q->rear(%d) / q->front(%d)\n", __func__, __LINE__,
    142          //		q, q->rear, q->front );
    143          
    144          	return size;
   \       0x4E   0x0030             MOVS     R0,R6
   \       0x50   0xB2C0             UXTB     R0,R0
   \                     ??qBufPut_1: (+1)
   \       0x52   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    145          }
    146          
    147          //===========================================================================

   \                                 In section .text, align 2, keep-with-next
    148          uint8_t qBufGet( QBuf_t *q, uint8_t *pBuf, uint16_t size )
    149          //===========================================================================
    150          {
   \                     qBufGet: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    151          	//*
    152          	if ( q->front == q->rear )
   \        0xA   0x88E0             LDRH     R0,[R4, #+6]
   \        0xC   0x8921             LDRH     R1,[R4, #+8]
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xD101             BNE.N    ??qBufGet_0
    153          	{
    154          //		printf( "\n\tCircular Queue Underflow." );
    155          		return -1;
   \       0x12   0x20FF             MOVS     R0,#+255
   \       0x14   0xE016             B.N      ??qBufGet_1
    156          	}
    157          	//	*/
    158          
    159          	memcpy( pBuf, &q->qBuf[q->front], size );
   \                     ??qBufGet_0: (+1)
   \       0x16   0x0037             MOVS     R7,R6
   \       0x18   0xB2BF             UXTH     R7,R7
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x88E1             LDRH     R1,[R4, #+6]
   \       0x1E   0xEB00 0x0801      ADD      R8,R0,R1
   \       0x22   0x46A9             MOV      R9,R5
   \       0x24   0x003A             MOVS     R2,R7
   \       0x26   0x4641             MOV      R1,R8
   \       0x28   0x4648             MOV      R0,R9
   \       0x2A   0x.... 0x....      BL       __aeabi_memcpy
    160          
    161          	q->front = ( q->front + size ) % q->size;
   \       0x2E   0x88E0             LDRH     R0,[R4, #+6]
   \       0x30   0xFA10 0xF086      UXTAH    R0,R0,R6
   \       0x34   0x88A1             LDRH     R1,[R4, #+4]
   \       0x36   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \       0x3A   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \       0x3E   0x80E0             STRH     R0,[R4, #+6]
    162          
    163          //	printf( "%s(%d) - q(%p) / q->rear(%d) / q->front(%d)\n", __func__, __LINE__,
    164          //		q, q->rear, q->front );
    165          
    166          	return size;
   \       0x40   0x0030             MOVS     R0,R6
   \       0x42   0xB2C0             UXTB     R0,R0
   \                     ??qBufGet_1: (+1)
   \       0x44   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    167          }
    168          
    169          
    170          //===========================================================================

   \                                 In section .text, align 2, keep-with-next
    171          void	QBufTest	( QBuf_t *q, uint16_t blkSize )
    172          //===========================================================================
    173          {
   \                     QBufTest: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB0C0             SUB      SP,SP,#+256
   \        0x6   0x0004             MOVS     R4,R0
   \        0x8   0x000D             MOVS     R5,R1
    174          	int i, j;
    175          	int idx;
    176          
    177          	uint8_t	bufPut[128];
    178          	uint8_t	bufGet[128];
    179          
    180          
    181          	for ( i = 0, idx = 0; i < 20; i++, idx++ )
   \        0xA   0x2600             MOVS     R6,#+0
   \        0xC   0x2700             MOVS     R7,#+0
   \                     ??QBufTest_0: (+1)
   \        0xE   0x2E14             CMP      R6,#+20
   \       0x10   0xDA45             BGE.N    ??QBufTest_1
    182          	{
    183          		//===========================================================================
    184          		memset( bufPut, idx, blkSize );
   \       0x12   0x46AA             MOV      R10,R5
   \       0x14   0xFA1F 0xFA8A      UXTH     R10,R10
   \       0x18   0x46BB             MOV      R11,R7
   \       0x1A   0xF10D 0x0880      ADD      R8,SP,#+128
   \       0x1E   0x465A             MOV      R2,R11
   \       0x20   0x4651             MOV      R1,R10
   \       0x22   0x4640             MOV      R0,R8
   \       0x24   0x.... 0x....      BL       __aeabi_memset
    185          
    186          		printf( "Put : " );
   \       0x28   0x....             LDR.N    R0,??DataTable1_1
   \       0x2A   0x.... 0x....      BL       printf
    187          		for ( j = 0; j < blkSize; j++ )
   \       0x2E   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??QBufTest_2: (+1)
   \       0x32   0x0028             MOVS     R0,R5
   \       0x34   0xB280             UXTH     R0,R0
   \       0x36   0x4580             CMP      R8,R0
   \       0x38   0xDA08             BGE.N    ??QBufTest_3
    188          		{
    189          			printf( "%02X ", bufPut[j] );
   \       0x3A   0xA820             ADD      R0,SP,#+128
   \       0x3C   0xF810 0x1008      LDRB     R1,[R0, R8]
   \       0x40   0x....             LDR.N    R0,??DataTable1_2
   \       0x42   0x.... 0x....      BL       printf
    190          		}
   \       0x46   0xF118 0x0801      ADDS     R8,R8,#+1
   \       0x4A   0xE7F2             B.N      ??QBufTest_2
    191          		printf( "\n" );
   \                     ??QBufTest_3: (+1)
   \       0x4C   0x.... 0x....      ADR.W    R10,??DataTable1
   \       0x50   0x4650             MOV      R0,R10
   \       0x52   0x.... 0x....      BL       printf
    192          
    193          		qBufPut( q, bufPut, blkSize );
   \       0x56   0x002A             MOVS     R2,R5
   \       0x58   0xB292             UXTH     R2,R2
   \       0x5A   0xA920             ADD      R1,SP,#+128
   \       0x5C   0x0020             MOVS     R0,R4
   \       0x5E   0x.... 0x....      BL       qBufPut
    194          
    195          		//===========================================================================
    196          		qBufGet( q, bufGet, blkSize );
   \       0x62   0x002A             MOVS     R2,R5
   \       0x64   0xB292             UXTH     R2,R2
   \       0x66   0x4669             MOV      R1,SP
   \       0x68   0x0020             MOVS     R0,R4
   \       0x6A   0x.... 0x....      BL       qBufGet
    197          
    198          		printf( "Get : " );
   \       0x6E   0x....             LDR.N    R0,??DataTable1_3
   \       0x70   0x.... 0x....      BL       printf
    199          		for ( j = 0; j < blkSize; j++ )
   \       0x74   0xF05F 0x0900      MOVS     R9,#+0
   \                     ??QBufTest_4: (+1)
   \       0x78   0x0028             MOVS     R0,R5
   \       0x7A   0xB280             UXTH     R0,R0
   \       0x7C   0x4581             CMP      R9,R0
   \       0x7E   0xDA08             BGE.N    ??QBufTest_5
    200          		{
    201          			printf( "%02X ", bufGet[j] );
   \       0x80   0x4668             MOV      R0,SP
   \       0x82   0xF810 0x1009      LDRB     R1,[R0, R9]
   \       0x86   0x....             LDR.N    R0,??DataTable1_2
   \       0x88   0x.... 0x....      BL       printf
    202          		}
   \       0x8C   0xF119 0x0901      ADDS     R9,R9,#+1
   \       0x90   0xE7F2             B.N      ??QBufTest_4
    203          		printf( "\n" );
   \                     ??QBufTest_5: (+1)
   \       0x92   0x4650             MOV      R0,R10
   \       0x94   0x.... 0x....      BL       printf
    204          
    205          		//===========================================================================
    206          	}
   \       0x98   0x1C76             ADDS     R6,R6,#+1
   \       0x9A   0x1C7F             ADDS     R7,R7,#+1
   \       0x9C   0xE7B7             B.N      ??QBufTest_0
    207          }
   \                     ??QBufTest_1: (+1)
   \       0x9E   0xB041             ADD      SP,SP,#+260
   \       0xA0   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x0A 0x00          DC8      "\n",0x0,0x0   

   \              0x00 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x50 0x75          DC8 "Put : "

   \              0x74 0x20    

   \              0x3A 0x20    

   \              0x00
   \        0x7                      DS8 1

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x25 0x30          DC8 "%02X "

   \              0x32 0x58    

   \              0x20 0x00
   \        0x6                      DS8 2

   \                                 In section .rodata, align 2
   \        0x0   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x47 0x65          DC8 "Get : "

   \              0x74 0x20    

   \              0x3A 0x20    

   \              0x00
   \        0x7                      DS8 1
    208          
    209          //========================================================================

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     296   QBufTest
       296   -> __aeabi_memset
       296   -> printf
       296   -> qBufGet
       296   -> qBufPut
       0   clear_queue
       0   init_queue
       0   qBufClear
       0   qBufCnt
      32   qBufGet
        32   -> __aeabi_memcpy
       0   qBufInit
      32   qBufPut
        32   -> __aeabi_memcpy
       0   qcount
       4   qget
       4   qput


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       8  ?_0
       8  ?_1
       2  ?_2
       8  ?_3
     164  QBufTest
      10  clear_queue
      16  init_queue
       6  qBufClear
      26  qBufCnt
      72  qBufGet
      14  qBufInit
      86  qBufPut
      30  qcount
      38  qget
      66  qput

 
  26 bytes in section .rodata
 544 bytes in section .text
 
 544 bytes of CODE  memory
  26 bytes of CONST memory

Errors: none
Warnings: 7
