###############################################################################
#
#                                                         06/Oct/2022  13:55:46
# IAR ANSI C/C++ Compiler V9.20.3.326/W64 for ARM Functional Safety
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode                 =  thumb
#    Endian                   =  little
#    Source file              =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\Library\keypad.c
#    Command line             =
#        -f C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Library\keypad.o.rsp
#        (C:\D\Git_Hub\STM_IAR_SIL_Change\Library\keypad.c -D USE_HAL_DRIVER -D
#        STM32F407xx -lC C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Library
#        -o C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Library --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e
#        --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.0 EWARM FS 9.20.3\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/App\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Core/Inc\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Include\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/display\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Library\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.0 EWARM FS 9.20.3\arm\CMSIS\Core\Include\\")
#        --dependencies=n
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Library\keypad.o.d
#    Locale                   =  C
#    List file                =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Library\keypad.lst
#    Object file              =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Library\keypad.o
#    Runtime model:              
#      __CPP_Runtime          =  1
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  1
#      __dlib_version         =  6
#      __iar_require _Printf     
#
###############################################################################

C:\D\Git_Hub\STM_IAR_SIL_Change\Library\keypad.c
      1          /*------------------------------------------------------------------------------------------
      2          	Project			: RFM
      3          	Description		:
      4          
      5          	Writer			: $Author: zlkit $
      6          	Revision		: $Rev: 1891 $
      7          	Date			: 2019. 10.
      8          	Copyright		: Piranti Corp.	( sw@piranti.co.kr )
      9          	 
     10          	Revision History 
     11          	1. 2020. 02.	: Created
     12          -------------------------------------------------------------------------------------------*/
     13          
     14          //========================================================================
     15          // Header
     16          
     17          //#include <stdarg.h>
     18          #include <stdio.h>			//	printf()
     19          
     20          #include <stdint.h>			//	uint32_t
     21          
     22          #include <string.h>			//	memset()
     23          
     24          #include "typedef.h"			//	uint32_t, ...
     25          #include "compiler_defs.h"		//	U8,

  # warning unrecognized compiler
    ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\compiler_defs.h",744  Warning[Pa183]: 
          #warning directive: unrecognized compiler

  typedef unsigned char U8;
                        ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\compiler_defs.h",788  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int U16;
                       ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\compiler_defs.h",789  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned long U32;
                        ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\compiler_defs.h",790  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed char S8;
                      ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\compiler_defs.h",792  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed int S16;
                     ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\compiler_defs.h",793  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed long S32;
                      ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\compiler_defs.h",794  Warning[Pe301]: 
          typedef name has already been declared (with same type)
     26          
     27          #include <stdio.h>
     28          
     29          #include "main.h"				//	DOME_GPIO_Port, ...
     30          
     31          #include "rfm.h"				//	g_nSpkLevel, ...

  	};
  	 ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Library\RFMProtocol.h",293  Warning[Pe040]: 
          expected an identifier

  	};
  	 ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Library\RFMProtocol.h",311  Warning[Pe040]: 
          expected an identifier

  	};
  	 ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Library\RFMProtocol.h",419  Warning[Pe040]: 
          expected an identifier

  	};
  	 ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Library\RFMProtocol.h",457  Warning[Pe040]: 
          expected an identifier

  	};
  	 ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Library\RFMProtocol.h",462  Warning[Pe040]: 
          expected an identifier

  	};
  	 ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Library\RFMProtocol.h",484  Warning[Pe040]: 
          expected an identifier

  	};
  	 ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Library\RFMProtocol.h",510  Warning[Pe040]: 
          expected an identifier

  	};
  	 ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Library\RFMProtocol.h",518  Warning[Pe040]: 
          expected an identifier
     32          
     33          #include "keypad.h"
     34          
     35          #include "Adafruit_SSD1306.h"	//	OLED Display
     36          
     37          #include "menu.h"				//	g_bEnMenuMaint
     38          
     39          #include "audio.h"
     40          
     41          //#include "audio.h"				//	Audio Function
     42          
     43          //========================================================================
     44          // Define
     45          
     46          
     47          //========================================================================
     48          // Function
     49          

   \                                 In section .bss, align 4
     50          static uint8_t s_btnStat[9] = { 0, };	//	Default ( 1 - pull-up )
   \                     s_btnStat:
   \        0x0                      DS8 12
     51          
     52          //========================================================================

   \                                 In section .text, align 2, keep-with-next
     53          uint8_t	GetKey( uint8_t eKey )
     54          //========================================================================
     55          {
     56          	return (uint8_t)(s_btnStat[eKey]);
   \                     GetKey: (+1)
   \        0x0   0x.... 0x....      LDR.W    R1,??DataTable12
   \        0x4   0xB2C0             UXTB     R0,R0
   \        0x6   0x5C08             LDRB     R0,[R1, R0]
   \        0x8   0x4770             BX       LR
     57          }
     58          
     59          
     60          //========================================================================

   \                                 In section .text, align 2, keep-with-next
     61          void GetKeyStat( uint8_t *btnStat )
     62          //========================================================================
     63          {
   \                     GetKeyStat: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
     64          	//	Pull-Up ( Active Low )
     65          
     66          	if(( HAL_GPIO_ReadPin( DOME1_GPIO_Port, DOME1_Pin ) == 0 ))
   \        0x4   0x.... 0x....      LDR.W    R5,??DataTable12_1
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA   0x0028             MOVS     R0,R5
   \        0xC   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD101             BNE.N    ??GetKeyStat_0
     67          	{
     68          		btnStat[0] = 1;;	//	Menu
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x7020             STRB     R0,[R4, #+0]
     69          	}
     70          
     71          	if(( HAL_GPIO_ReadPin( DOME2_GPIO_Port, DOME2_Pin ) == 0 ))
   \                     ??GetKeyStat_0: (+1)
   \       0x18   0x2102             MOVS     R1,#+2
   \       0x1A   0x0028             MOVS     R0,R5
   \       0x1C   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD101             BNE.N    ??GetKeyStat_1
     72          	{
     73          		btnStat[1] = 1 ;	//	Up
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x7060             STRB     R0,[R4, #+1]
     74          	}
     75          
     76          	if(( HAL_GPIO_ReadPin( DOME3_GPIO_Port, DOME3_Pin )== 0 ))
   \                     ??GetKeyStat_1: (+1)
   \       0x28   0x2104             MOVS     R1,#+4
   \       0x2A   0x0028             MOVS     R0,R5
   \       0x2C   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD101             BNE.N    ??GetKeyStat_2
     77          	{
     78          		btnStat[2] = 1;	//	OK
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0x70A0             STRB     R0,[R4, #+2]
     79          	}
     80          
     81          	if(( HAL_GPIO_ReadPin( DOME4_GPIO_Port, DOME4_Pin )== 0 ))
   \                     ??GetKeyStat_2: (+1)
   \       0x38   0x2108             MOVS     R1,#+8
   \       0x3A   0x0028             MOVS     R0,R5
   \       0x3C   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD101             BNE.N    ??GetKeyStat_3
     82          	{
     83          		btnStat[3] = 1;	//	Light
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0x70E0             STRB     R0,[R4, #+3]
     84          	}
     85          
     86          	if(( HAL_GPIO_ReadPin( DOME5_GPIO_Port, DOME5_Pin )== 0 ))
   \                     ??GetKeyStat_3: (+1)
   \       0x48   0x2110             MOVS     R1,#+16
   \       0x4A   0x0028             MOVS     R0,R5
   \       0x4C   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD101             BNE.N    ??GetKeyStat_4
     87          	{
     88          		btnStat[4] = 1;	//	Down
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0x7120             STRB     R0,[R4, #+4]
     89          	}
     90          
     91          	if(( HAL_GPIO_ReadPin( DOME6_GPIO_Port, DOME6_Pin )== 0 ))
   \                     ??GetKeyStat_4: (+1)
   \       0x58   0x2120             MOVS     R1,#+32
   \       0x5A   0x0028             MOVS     R0,R5
   \       0x5C   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD101             BNE.N    ??GetKeyStat_5
     92          	{
     93          		btnStat[5] = 1;	//	Vol
   \       0x64   0x2001             MOVS     R0,#+1
   \       0x66   0x7160             STRB     R0,[R4, #+5]
     94          	}
     95          
     96          	if(( HAL_GPIO_ReadPin( PTT_KEY_GPIO_Port, PTT_KEY_Pin )== 0 ))
   \                     ??GetKeyStat_5: (+1)
   \       0x68   0x2180             MOVS     R1,#+128
   \       0x6A   0x0028             MOVS     R0,R5
   \       0x6C   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD101             BNE.N    ??GetKeyStat_6
     97          	{
     98          		btnStat[6] = 1;
   \       0x74   0x2001             MOVS     R0,#+1
   \       0x76   0x71A0             STRB     R0,[R4, #+6]
     99          	}
    100          
    101          	if(( HAL_GPIO_ReadPin( SOS_KEY_GPIO_Port, SOS_KEY_Pin )== 0 ))
   \                     ??GetKeyStat_6: (+1)
   \       0x78   0x2140             MOVS     R1,#+64
   \       0x7A   0x0028             MOVS     R0,R5
   \       0x7C   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD101             BNE.N    ??GetKeyStat_7
    102          	{
    103          		btnStat[7] = 1;
   \       0x84   0x2001             MOVS     R0,#+1
   \       0x86   0x71E0             STRB     R0,[R4, #+7]
    104          	}
    105          
    106          
    107          		//	Pull-Down ( Active High )
    108          	btnStat[8] = ( HAL_GPIO_ReadPin( ON_OFF_KEY_GPIO_Port, ON_OFF_KEY_Pin ) );
   \                     ??GetKeyStat_7: (+1)
   \       0x88   0xF44F 0x7100      MOV      R1,#+512
   \       0x8C   0x0028             MOVS     R0,R5
   \       0x8E   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \       0x92   0x7220             STRB     R0,[R4, #+8]
    109          
    110          
    111          }
   \       0x94   0xBD31             POP      {R0,R4,R5,PC}
    112          
    113          #include <string.h>		//	memcmp()
    114          
    115          //========================================================================

   \                                 In section .text, align 2, keep-with-next
    116          void LoopProcKey ( uint16_t tickCurr )
    117          //========================================================================
    118          {
   \                     LoopProcKey: (+1)
   \        0x0   0xE92D 0x41FF      PUSH     {R0-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
    119          	//========================================================================
    120          	static uint32_t tickBase = 0;
    121          	uint8_t 	btnStat[9];
    122          
    123          	//    if( ( HAL_GetTick() - tickBase ) >= 1000 )
    124          	if ( ( tickCurr - tickBase ) >= 100 )
   \        0x6   0x.... 0x....      LDR.W    R5,??DataTable12_2
   \        0xA   0x0021             MOVS     R1,R4
   \        0xC   0xB289             UXTH     R1,R1
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x1A09             SUBS     R1,R1,R0
   \       0x12   0x2964             CMP      R1,#+100
   \       0x14   0xD357             BCC.N    ??LoopProcKey_0
    125          	{
    126          		//========================================================================
    127          		//  Period : 100 ms
    128          
    129          		//========================================================================
    130          		//	Key 값 얻기.
    131          		GetKeyStat( btnStat );
   \       0x16   0x4668             MOV      R0,SP
   \       0x18   0x.... 0x....      BL       GetKeyStat
    132          
    133          		if ( memcmp( s_btnStat, btnStat, sizeof( btnStat ) ) != 0 )
   \       0x1C   0x.... 0x....      LDR.W    R6,??DataTable12
   \       0x20   0x2209             MOVS     R2,#+9
   \       0x22   0x4669             MOV      R1,SP
   \       0x24   0x0030             MOVS     R0,R6
   \       0x26   0x.... 0x....      BL       memcmp
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD048             BEQ.N    ??LoopProcKey_1
    134          		{
    135          			//	Key Value Changed.
    136          //			int i;
    137          //			printf("[s_btnStat] ");
    138          //			for( i = 0; i < 9; i++ ) printf("%d ", s_btnStat[i]);
    139          //			printf("\n");
    140          //			printf("[btnStat] ");
    141          //			for( i = 0; i < 9; i++ ) printf("%d ", btnStat[i]);
    142          //			printf("\n");
    143          
    144          			if ( s_btnStat[0] != btnStat[0] )
   \       0x2E   0x7830             LDRB     R0,[R6, #+0]
   \       0x30   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x34   0x4288             CMP      R0,R1
   \       0x36   0xD003             BEQ.N    ??LoopProcKey_2
    145          			{
    146          				KeyMenu		( btnStat[0] );	//	DOME1
   \       0x38   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x3C   0x.... 0x....      BL       KeyMenu
    147          			}
    148          			if ( s_btnStat[1] != btnStat[1] )
   \                     ??LoopProcKey_2: (+1)
   \       0x40   0x466F             MOV      R7,SP
   \       0x42   0x7870             LDRB     R0,[R6, #+1]
   \       0x44   0x7879             LDRB     R1,[R7, #+1]
   \       0x46   0x4288             CMP      R0,R1
   \       0x48   0xD002             BEQ.N    ??LoopProcKey_3
    149          			{
    150          				KeyUp		( btnStat[1] );	//	DOME2
   \       0x4A   0x7878             LDRB     R0,[R7, #+1]
   \       0x4C   0x.... 0x....      BL       KeyUp
    151          			}
    152          			if ( s_btnStat[2] != btnStat[2] )
   \                     ??LoopProcKey_3: (+1)
   \       0x50   0x78B0             LDRB     R0,[R6, #+2]
   \       0x52   0x78B9             LDRB     R1,[R7, #+2]
   \       0x54   0x4288             CMP      R0,R1
   \       0x56   0xD002             BEQ.N    ??LoopProcKey_4
    153          			{
    154          				KeyOK		( btnStat[2] );	//	DOME3
   \       0x58   0x78B8             LDRB     R0,[R7, #+2]
   \       0x5A   0x.... 0x....      BL       KeyOK
    155          			}
    156          			if ( s_btnStat[3] != btnStat[3] )
   \                     ??LoopProcKey_4: (+1)
   \       0x5E   0x78F0             LDRB     R0,[R6, #+3]
   \       0x60   0x78F9             LDRB     R1,[R7, #+3]
   \       0x62   0x4288             CMP      R0,R1
   \       0x64   0xD002             BEQ.N    ??LoopProcKey_5
    157          			{
    158          				KeyLight	( btnStat[3] );	//	DOME4
   \       0x66   0x78F8             LDRB     R0,[R7, #+3]
   \       0x68   0x.... 0x....      BL       KeyLight
    159          			}
    160          			if ( s_btnStat[4] != btnStat[4] )
   \                     ??LoopProcKey_5: (+1)
   \       0x6C   0x7930             LDRB     R0,[R6, #+4]
   \       0x6E   0x7939             LDRB     R1,[R7, #+4]
   \       0x70   0x4288             CMP      R0,R1
   \       0x72   0xD002             BEQ.N    ??LoopProcKey_6
    161          			{
    162          				KeyDown		( btnStat[4] );	//	DOME5
   \       0x74   0x7938             LDRB     R0,[R7, #+4]
   \       0x76   0x.... 0x....      BL       KeyDown
    163          			}
    164          			if ( s_btnStat[5] != btnStat[5] )
   \                     ??LoopProcKey_6: (+1)
   \       0x7A   0x7970             LDRB     R0,[R6, #+5]
   \       0x7C   0x7979             LDRB     R1,[R7, #+5]
   \       0x7E   0x4288             CMP      R0,R1
   \       0x80   0xD002             BEQ.N    ??LoopProcKey_7
    165          			{
    166          				KeyVol		( btnStat[5] );	//	DOME6
   \       0x82   0x7978             LDRB     R0,[R7, #+5]
   \       0x84   0x.... 0x....      BL       KeyVol
    167          
    168          			}
    169          			if ( s_btnStat[6] != btnStat[6] )
   \                     ??LoopProcKey_7: (+1)
   \       0x88   0x79B0             LDRB     R0,[R6, #+6]
   \       0x8A   0x79B9             LDRB     R1,[R7, #+6]
   \       0x8C   0x4288             CMP      R0,R1
   \       0x8E   0xD002             BEQ.N    ??LoopProcKey_8
    170          			{
    171          				KeyPtt		( btnStat[6] );	//	PTT
   \       0x90   0x79B8             LDRB     R0,[R7, #+6]
   \       0x92   0x.... 0x....      BL       KeyPtt
    172          			}
    173          			if ( s_btnStat[7] != btnStat[7] )
   \                     ??LoopProcKey_8: (+1)
   \       0x96   0x79F0             LDRB     R0,[R6, #+7]
   \       0x98   0x79F9             LDRB     R1,[R7, #+7]
   \       0x9A   0x4288             CMP      R0,R1
   \       0x9C   0xD002             BEQ.N    ??LoopProcKey_9
    174          			{
    175          				KeySos		( btnStat[7] );	//	SOS
   \       0x9E   0x79F8             LDRB     R0,[R7, #+7]
   \       0xA0   0x.... 0x....      BL       KeySos
    176          			}
    177          			if ( s_btnStat[8] != btnStat[8] )
   \                     ??LoopProcKey_9: (+1)
   \       0xA4   0x7A30             LDRB     R0,[R6, #+8]
   \       0xA6   0x7A39             LDRB     R1,[R7, #+8]
   \       0xA8   0x4288             CMP      R0,R1
   \       0xAA   0xD002             BEQ.N    ??LoopProcKey_10
    178          			{
    179          				KeyPwrOnOff	( btnStat[8] );	//	ON/OFF
   \       0xAC   0x7A38             LDRB     R0,[R7, #+8]
   \       0xAE   0x.... 0x....      BL       KeyPwrOnOff
    180          			}
    181          
    182          			//	값 저장.
    183          			memcpy( s_btnStat, btnStat, sizeof( btnStat ) );
   \                     ??LoopProcKey_10: (+1)
   \       0xB2   0x2709             MOVS     R7,#+9
   \       0xB4   0x46E8             MOV      R8,SP
   \       0xB6   0x003A             MOVS     R2,R7
   \       0xB8   0x4641             MOV      R1,R8
   \       0xBA   0x0030             MOVS     R0,R6
   \       0xBC   0x.... 0x....      BL       __aeabi_memcpy
    184          		}
    185          
    186          		tickBase = tickCurr;
   \                     ??LoopProcKey_1: (+1)
   \       0xC0   0x0020             MOVS     R0,R4
   \       0xC2   0xB280             UXTH     R0,R0
   \       0xC4   0x6028             STR      R0,[R5, #+0]
    187          	}
    188          
    189          	//========================================================================
    190          	//	* [송신기][MENU] : 유지보수 메뉴 진입 기능 추가.
    191          	//		- [OK]버튼을 누른상태에서 [MENU]버튼을 3초간 누를 경우 Maintance모드로 진입함.
    192          
    193          	static uint32_t tickBase2 = 0;
    194          
    195          	if ( ( tickCurr - tickBase2 ) >= (1000 & IsMenuMaint()) )
   \                     ??LoopProcKey_0: (+1)
   \       0xC6   0x....             LDR.N    R5,??DataTable12_3
   \       0xC8   0x.... 0x....      BL       IsMenuMaint
   \       0xCC   0xF410 0x707A      ANDS     R0,R0,#0x3E8
   \       0xD0   0x0022             MOVS     R2,R4
   \       0xD2   0xB292             UXTH     R2,R2
   \       0xD4   0x6829             LDR      R1,[R5, #+0]
   \       0xD6   0x1A52             SUBS     R2,R2,R1
   \       0xD8   0x4282             CMP      R2,R0
   \       0xDA   0xD318             BCC.N    ??LoopProcKey_11
    196          	{
    197          		//	Period : 1 sec
    198          		static uint8_t s_cntKeyOkMenu = 0;
    199          		if ( (s_btnStat[eKeyOk] != 0) && (s_btnStat[eKeyMenu] != 0) )
   \       0xDC   0x....             LDR.N    R1,??DataTable12
   \       0xDE   0x7888             LDRB     R0,[R1, #+2]
   \       0xE0   0x2800             CMP      R0,#+0
   \       0xE2   0xD007             BEQ.N    ??LoopProcKey_12
   \       0xE4   0x7808             LDRB     R0,[R1, #+0]
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0xD004             BEQ.N    ??LoopProcKey_12
    200          		{
    201          			s_cntKeyOkMenu++;
   \       0xEA   0x....             LDR.N    R0,??DataTable12_4
   \       0xEC   0x7801             LDRB     R1,[R0, #+0]
   \       0xEE   0x1C49             ADDS     R1,R1,#+1
   \       0xF0   0x7001             STRB     R1,[R0, #+0]
   \       0xF2   0xE002             B.N      ??LoopProcKey_13
    202          		}
    203          		else
    204          		{
    205          			s_cntKeyOkMenu = 0;
   \                     ??LoopProcKey_12: (+1)
   \       0xF4   0x2000             MOVS     R0,#+0
   \       0xF6   0x....             LDR.N    R1,??DataTable12_4
   \       0xF8   0x7008             STRB     R0,[R1, #+0]
    206          		}
    207          
    208          		if ( s_cntKeyOkMenu > 3 )	//	3초 이상 누를 경우.
   \                     ??LoopProcKey_13: (+1)
   \       0xFA   0x....             LDR.N    R0,??DataTable12_4
   \       0xFC   0x7800             LDRB     R0,[R0, #+0]
   \       0xFE   0x2804             CMP      R0,#+4
   \      0x100   0xDB02             BLT.N    ??LoopProcKey_14
    209          		{
    210          			EnableMenuMaint((uint8_t) 1 );
   \      0x102   0x2001             MOVS     R0,#+1
   \      0x104   0x.... 0x....      BL       EnableMenuMaint
    211          		}
    212          
    213          		tickBase2 = tickCurr;
   \                     ??LoopProcKey_14: (+1)
   \      0x108   0x0020             MOVS     R0,R4
   \      0x10A   0xB280             UXTH     R0,R0
   \      0x10C   0x6028             STR      R0,[R5, #+0]
    214          	}
    215          
    216          	//========================================================================
    217          
    218          
    219          #if defined(USE_FREERTOS)
    220          	osDelay( 1 );		//	1 msec
    221          #else
    222          //        HAL_Delay( 1 );
    223          #endif
    224          }
   \                     ??LoopProcKey_11: (+1)
   \      0x10E   0xE8BD 0x81FF      POP      {R0-R8,PC}

   \                                 In section .bss, align 4
   \                     `LoopProcKey::tickBase`:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \                     `LoopProcKey::tickBase2`:
   \        0x0                      DS8 4

   \                                 In section .bss, align 1
   \                     `LoopProcKey{13}{14}::s_cntKeyOkMenu`:
   \        0x0                      DS8 1
    225          
    226          //========================================================================
    227          //		KeyPad ( Dome Button )
    228          //========================================================================
    229          
    230          //========================================================================

   \                                 In section .text, align 2, keep-with-next
    231          void KeyMenu( uint8_t bValue )
    232          //========================================================================
    233          {
   \                     KeyMenu: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    234          	//========================================================================
    235          	//	bValue : 0(Up) / 1(Down)
    236          	printf( "%s(%d) - %d\n", __func__, __LINE__, bValue );
   \        0x4   0x0023             MOVS     R3,R4
   \        0x6   0xB2DB             UXTB     R3,R3
   \        0x8   0x22EC             MOVS     R2,#+236
   \        0xA   0x....             LDR.N    R1,??DataTable12_5
   \        0xC   0x....             LDR.N    R0,??DataTable12_6
   \        0xE   0x.... 0x....      BL       printf
    237          
    238          	if ( bValue != 0 )
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD001             BEQ.N    ??KeyMenu_0
    239          	{
    240          //		LCDMenu();
    241          		ProcBtnMenu();
   \       0x1A   0x.... 0x....      BL       ProcBtnMenu
    242          	}
    243          }
   \                     ??KeyMenu_0: (+1)
   \       0x1E   0xBD10             POP      {R4,PC}
    244          
    245          //========================================================================

   \                                 In section .text, align 2, keep-with-next
    246          void KeyOK( uint8_t bValue )
    247          //========================================================================
    248          {
   \                     KeyOK: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    249          	//========================================================================
    250          	//	bValue : 0(Up) / 1(Down)
    251          	printf( "%s(%d) - %d\n", __func__, __LINE__, bValue );
   \        0x4   0x0023             MOVS     R3,R4
   \        0x6   0xB2DB             UXTB     R3,R3
   \        0x8   0x22FB             MOVS     R2,#+251
   \        0xA   0x....             LDR.N    R1,??DataTable12_7
   \        0xC   0x....             LDR.N    R0,??DataTable12_6
   \        0xE   0x.... 0x....      BL       printf
    252          
    253          	if ( bValue != 0)
   \       0x12   0x0020             MOVS     R0,R4
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD001             BEQ.N    ??KeyOK_0
    254          	{
    255          		ProcBtnOK();
   \       0x1A   0x.... 0x....      BL       ProcBtnOK
    256          	}
    257          }
   \                     ??KeyOK_0: (+1)
   \       0x1E   0xBD10             POP      {R4,PC}
    258          
    259          
    260          //========================================================================

   \                                 In section .text, align 2, keep-with-next
    261          void KeyLight( uint8_t bValue )
    262          //========================================================================
    263          {
   \                     KeyLight: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    264          	//========================================================================
    265          	//	bValue : 0(Up) / 1(Down)
    266          	printf( "%s(%d) - %d\n", __func__, __LINE__, bValue );
   \        0x4   0x0023             MOVS     R3,R4
   \        0x6   0xB2DB             UXTB     R3,R3
   \        0x8   0xF44F 0x7285      MOV      R2,#+266
   \        0xC   0x....             LDR.N    R1,??DataTable12_8
   \        0xE   0x....             LDR.N    R0,??DataTable12_6
   \       0x10   0x.... 0x....      BL       printf
    267          
    268          	//========================================================================
    269          	//	Light On/Off Toggle
    270          	static uint8_t bOnOff = 0;
    271          
    272          	//========================================================================
    273          	//	GPIO제어.
    274          	if ( bValue != 0 )
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD01A             BEQ.N    ??KeyLight_0
    275          	{
    276          		if ( bOnOff == 0 )
   \       0x1C   0x....             LDR.N    R5,??DataTable12_9
   \       0x1E   0x7828             LDRB     R0,[R5, #+0]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD10B             BNE.N    ??KeyLight_1
    277          		{
    278          			//	Flash Light On
    279          			HAL_GPIO_WritePin( FLASH_ON_GPIO_Port, FLASH_ON_Pin, GPIO_PIN_SET );
   \       0x24   0x2201             MOVS     R2,#+1
   \       0x26   0xF44F 0x7180      MOV      R1,#+256
   \       0x2A   0x....             LDR.N    R0,??DataTable12_10
   \       0x2C   0x.... 0x....      BL       HAL_GPIO_WritePin
    280          
    281          			LCDLight( 1 );
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x.... 0x....      BL       LCDLight
    282          			bOnOff = 1;
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0x7028             STRB     R0,[R5, #+0]
   \       0x3A   0xE00A             B.N      ??KeyLight_0
    283          		}
    284          		else
    285          		{
    286          			//	Flash Light Off
    287          			HAL_GPIO_WritePin( FLASH_ON_GPIO_Port, FLASH_ON_Pin, GPIO_PIN_RESET );
   \                     ??KeyLight_1: (+1)
   \       0x3C   0x2200             MOVS     R2,#+0
   \       0x3E   0xF44F 0x7180      MOV      R1,#+256
   \       0x42   0x....             LDR.N    R0,??DataTable12_10
   \       0x44   0x.... 0x....      BL       HAL_GPIO_WritePin
    288          
    289          			LCDLight( 0 );
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x.... 0x....      BL       LCDLight
    290          			bOnOff = 0;
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x7028             STRB     R0,[R5, #+0]
    291          		}
    292          	}
    293          }
   \                     ??KeyLight_0: (+1)
   \       0x52   0xBD31             POP      {R0,R4,R5,PC}

   \                                 In section .bss, align 1
   \                     `KeyLight::bOnOff`:
   \        0x0                      DS8 1
    294          
    295          //========================================================================

   \                                 In section .text, align 2, keep-with-next
    296          void KeyUp( uint8_t bValue )
    297          //========================================================================
    298          {
   \                     KeyUp: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    299          	//========================================================================
    300          	//	bValue : 0(Up) / 1(Down)
    301          	printf( "%s(%d) - %d\n", __func__, __LINE__, bValue );
   \        0x4   0x0023             MOVS     R3,R4
   \        0x6   0xB2DB             UXTB     R3,R3
   \        0x8   0xF240 0x122D      MOVW     R2,#+301
   \        0xC   0x....             LDR.N    R1,??DataTable12_11
   \        0xE   0x....             LDR.N    R0,??DataTable12_6
   \       0x10   0x.... 0x....      BL       printf
    302          
    303          	if( bValue != 0)
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD001             BEQ.N    ??KeyUp_0
    304          	{
    305          		ProcBtnUp();
   \       0x1C   0x.... 0x....      BL       ProcBtnUp
    306          	}
    307          }
   \                     ??KeyUp_0: (+1)
   \       0x20   0xBD10             POP      {R4,PC}
    308          
    309          //========================================================================

   \                                 In section .text, align 2, keep-with-next
    310          void KeyDown( uint8_t bValue )
    311          //========================================================================
    312          {
   \                     KeyDown: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    313          	//========================================================================
    314          	//	bValue : 0(Up) / 1(Down)
    315          	printf( "%s(%d) - %d\n", __func__, __LINE__, bValue );
   \        0x4   0x0023             MOVS     R3,R4
   \        0x6   0xB2DB             UXTB     R3,R3
   \        0x8   0xF240 0x123B      MOVW     R2,#+315
   \        0xC   0x....             LDR.N    R1,??DataTable12_12
   \        0xE   0x....             LDR.N    R0,??DataTable12_6
   \       0x10   0x.... 0x....      BL       printf
    316          
    317          	if( bValue != 0)
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD001             BEQ.N    ??KeyDown_0
    318          	{
    319          		ProcBtnDown();
   \       0x1C   0x.... 0x....      BL       ProcBtnDown
    320          	}
    321          }
   \                     ??KeyDown_0: (+1)
   \       0x20   0xBD10             POP      {R4,PC}
    322          
    323          //========================================================================

   \                                 In section .text, align 2, keep-with-next
    324          void KeyVol( uint8_t bValue )
    325          //========================================================================
    326          {
   \                     KeyVol: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    327          	//========================================================================
    328          	//	bValue : 0(Up) / 1(Down)
    329          	printf( "%s(%d) - %d\n", __func__, __LINE__, bValue );
   \        0x4   0x0023             MOVS     R3,R4
   \        0x6   0xB2DB             UXTB     R3,R3
   \        0x8   0xF240 0x1249      MOVW     R2,#+329
   \        0xC   0x....             LDR.N    R1,??DataTable12_13
   \        0xE   0x....             LDR.N    R0,??DataTable12_6
   \       0x10   0x.... 0x....      BL       printf
    330          
    331          	if( bValue != 0 )
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD01B             BEQ.N    ??KeyVol_0
    332          	{
    333          
    334          		g_nSpkLevel = ( g_nSpkLevel + 1 ) % 4;  //  0, 1, 2, 3
   \       0x1C   0x....             LDR.N    R5,??DataTable12_14
   \       0x1E   0x7828             LDRB     R0,[R5, #+0]
   \       0x20   0x1C40             ADDS     R0,R0,#+1
   \       0x22   0x2104             MOVS     R1,#+4
   \       0x24   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \       0x28   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \       0x2C   0x7028             STRB     R0,[R5, #+0]
    335          
    336          		//========================================================================
    337          		SetSpkVol( g_nSpkLevel );
   \       0x2E   0x7828             LDRB     R0,[R5, #+0]
   \       0x30   0x.... 0x....      BL       SetSpkVol
    338          		//========================================================================
    339          
    340          		if ( g_nSpkLevel != 0 )
   \       0x34   0x7828             LDRB     R0,[R5, #+0]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD006             BEQ.N    ??KeyVol_1
    341          		{
    342          			//	RFM SPK On
    343          //				HAL_GPIO_WritePin( SPK_ON_GPIO_Port, SPK_ON_Pin, GPIO_PIN_SET );
    344          			//	RFM SPK Off
    345          //			HAL_GPIO_WritePin( SPK_ON_GPIO_Port, SPK_ON_Pin, GPIO_PIN_RESET );
    346          			RFM_Spk((uint8_t)0);
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x.... 0x....      BL       RFM_Spk
    347          
    348          			LCDSpeaker( g_nSpkLevel );
   \       0x40   0x7828             LDRB     R0,[R5, #+0]
   \       0x42   0x.... 0x....      BL       LCDSpeaker
   \       0x46   0xE005             B.N      ??KeyVol_0
    349          		}
    350          		else
    351          		{
    352          			//	RFM SPK Off
    353          //			HAL_GPIO_WritePin( SPK_ON_GPIO_Port, SPK_ON_Pin, GPIO_PIN_RESET );
    354          			RFM_Spk((uint8_t)0);
   \                     ??KeyVol_1: (+1)
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x.... 0x....      BL       RFM_Spk
    355          
    356          			LCDSpeaker( (uint8_t)0 );
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x.... 0x....      BL       LCDSpeaker
    357          		}
    358          	}
    359          }
   \                     ??KeyVol_0: (+1)
   \       0x54   0xBD31             POP      {R0,R4,R5,PC}
    360          
    361          //========================================================================
    362          //		Side Button
    363          //========================================================================
    364          
    365          
    366          //========================================================================

   \                                 In section .text, align 2, keep-with-next
    367          void KeyPtt( uint8_t bValue )
    368          //========================================================================
    369          {
   \                     KeyPtt: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0004             MOVS     R4,R0
    370          	//========================================================================
    371          #if defined( USE_TEST_PTT_AUDIO_LOOP )
    372          
    373          	//	Audio Loopback Test
    374          	KeyTestLoopback( bValue );
    375          
    376          	return ;
    377          #endif
    378          	//========================================================================
    379          
    380          	//========================================================================
    381          	//	bValue : 0(Up) / 1(Down)
    382          	printf( "%s(%d) - %d\n", __func__, __LINE__, bValue );
   \        0x6   0x0023             MOVS     R3,R4
   \        0x8   0xB2DB             UXTB     R3,R3
   \        0xA   0xF44F 0x72BF      MOV      R2,#+382
   \        0xE   0x....             LDR.N    R1,??DataTable12_15
   \       0x10   0x....             LDR.N    R0,??DataTable12_6
   \       0x12   0x.... 0x....      BL       printf
    383          
    384          	//	송신기 -> 수신기	:	방송
    385          
    386          	if ( bValue != 0)
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0xB2C0             UXTB     R0,R0
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD02D             BEQ.N    ??KeyPtt_0
    387          	{
    388          #if defined(USE_CH_ISO_DEV)
    389          		SetChPA( GetChNearRFM() );		//	가장 가까운 수신기 설정.
   \       0x1E   0x.... 0x....      BL       GetChNearRFM
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0x.... 0x....      BL       SetChPA
    390          
    391          		SetChPARFT( GetChNearRFT() );	//	가까운 송신기 설정.
   \       0x28   0x.... 0x....      BL       GetChNearRFT
   \       0x2C   0xB2C0             UXTB     R0,R0
   \       0x2E   0x.... 0x....      BL       SetChPARFT
    392          #endif
    393          
    394          		LCDSetCursor( 20, 13 );
   \       0x32   0x210D             MOVS     R1,#+13
   \       0x34   0x2014             MOVS     R0,#+20
   \       0x36   0x.... 0x....      BL       LCDSetCursor
    395          
    396          		if ( IsMenuMaint() )
   \       0x3A   0x.... 0x....      BL       IsMenuMaint
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD00B             BEQ.N    ??KeyPtt_1
    397          		{
    398          			//	Maint Mode : 송신채널 표시.
    399          			S8 sBuf[20];
    400          			sprintf( sBuf, "방송중...(%d)", GetChPA() );
                 			         ^
Warning[Pe167]: argument of type "S8 *" is incompatible with parameter of type
          "char *"
   \       0x42   0x.... 0x....      BL       GetChPA
   \       0x46   0x0002             MOVS     R2,R0
   \       0x48   0xB2D2             UXTB     R2,R2
   \       0x4A   0x....             LDR.N    R1,??DataTable12_16
   \       0x4C   0x4668             MOV      R0,SP
   \       0x4E   0x.... 0x....      BL       sprintf
    401          			LCDPrintf( sBuf );
                 			           ^
Warning[Pe167]: argument of type "S8 *" is incompatible with parameter of type
          "char *"
   \       0x52   0x4668             MOV      R0,SP
   \       0x54   0x.... 0x....      BL       LCDPrintf
   \       0x58   0xE002             B.N      ??KeyPtt_2
    402          		}
    403          		else
    404          		{
    405          			LCDPrintf( "방송중..." );
   \                     ??KeyPtt_1: (+1)
   \       0x5A   0x....             LDR.N    R0,??DataTable12_17
   \       0x5C   0x.... 0x....      BL       LCDPrintf
    406          		}
    407          
    408          		SetRFMMode( (uint8_t)RFMModeTx );
   \                     ??KeyPtt_2: (+1)
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0x.... 0x....      BL       SetRFMMode
    409          
    410          		//  Green LED On
    411          		HAL_GPIO_WritePin ( LED_ON_A_GPIO_Port, LED_ON_A_Pin, GPIO_PIN_SET ); //  Green LED
   \       0x66   0x2201             MOVS     R2,#+1
   \       0x68   0xF44F 0x5100      MOV      R1,#+8192
   \       0x6C   0x....             LDR.N    R0,??DataTable12_10
   \       0x6E   0x.... 0x....      BL       HAL_GPIO_WritePin
    412          
    413          		//	방송 - 시작
    414          		SendPA((uint8_t) 1 );		//	SendRF - Send PA ( 송신기 -> 수신기 )
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0x.... 0x....      BL       SendPA
   \       0x78   0xE017             B.N      ??KeyPtt_3
    415          	}
    416          	else
    417          	{
    418          		//========================================================================
    419          		//  편성 : XXX
    420          		UpdateLCDMain();
   \                     ??KeyPtt_0: (+1)
   \       0x7A   0x.... 0x....      BL       UpdateLCDMain
    421          
    422          		SetRFMMode( (uint8_t)RFMModeNormal );
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0x.... 0x....      BL       SetRFMMode
    423          
    424          #if defined(USE_CH_ISO_DEV)
    425          		SetChPA( GetChNearRFM() );		//	가장 가까운 수신기 설정.
   \       0x84   0x.... 0x....      BL       GetChNearRFM
   \       0x88   0xB2C0             UXTB     R0,R0
   \       0x8A   0x.... 0x....      BL       SetChPA
    426          
    427          		SetChPARFT( GetChNearRFT() );	//	가까운 송신기 설정.
   \       0x8E   0x.... 0x....      BL       GetChNearRFT
   \       0x92   0xB2C0             UXTB     R0,R0
   \       0x94   0x.... 0x....      BL       SetChPARFT
    428          #endif
    429          
    430          		//  Green LED Off
    431          		HAL_GPIO_WritePin ( LED_ON_A_GPIO_Port, LED_ON_A_Pin, GPIO_PIN_RESET ); //  Green LED
   \       0x98   0x2200             MOVS     R2,#+0
   \       0x9A   0xF44F 0x5100      MOV      R1,#+8192
   \       0x9E   0x....             LDR.N    R0,??DataTable12_10
   \       0xA0   0x.... 0x....      BL       HAL_GPIO_WritePin
    432          
    433          		//	방송 - 종료
    434          		SendPA((uint8_t) 0 );		//	SendRF - Send PA ( 송신기 -> 수신기 )
   \       0xA4   0x2000             MOVS     R0,#+0
   \       0xA6   0x.... 0x....      BL       SendPA
    435          	}
    436          }
   \                     ??KeyPtt_3: (+1)
   \       0xAA   0xB006             ADD      SP,SP,#+24
   \       0xAC   0xBD10             POP      {R4,PC}
    437          
    438          
    439          //========================================================================

   \                                 In section .text, align 2, keep-with-next
    440          void KeySos( uint8_t bValue )
    441          //========================================================================
    442          {
   \                     KeySos: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    443          	//	bValue : 0(Up) / 1(Down)
    444          	printf( "%s(%d) - %d\n", __func__, __LINE__, bValue );
   \        0x4   0x0023             MOVS     R3,R4
   \        0x6   0xB2DB             UXTB     R3,R3
   \        0x8   0xF44F 0x72DE      MOV      R2,#+444
   \        0xC   0x....             LDR.N    R1,??DataTable12_18
   \        0xE   0x....             LDR.N    R0,??DataTable12_6
   \       0x10   0x.... 0x....      BL       printf
    445          
    446          	//	송신기 -> 송신기	:	통화
    447          
    448          	if ( bValue != 0 )
   \       0x14   0x0020             MOVS     R0,R4
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD017             BEQ.N    ??KeySos_0
    449          	{
    450          #if defined(USE_CH_ISO_DEV)
    451          		SetChPARFT( GetChNearRFT() );	//	가까운 송신기 설정.
   \       0x1C   0x.... 0x....      BL       GetChNearRFT
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x.... 0x....      BL       SetChPARFT
    452          
    453          		SetChPA( GetChNearRFM() );		//	가장 가까운 수신기 설정.
   \       0x26   0x.... 0x....      BL       GetChNearRFM
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x.... 0x....      BL       SetChPA
    454          #endif
    455          
    456          		//	송신중
    457          		LCDSetCursor( 20, 13 );
   \       0x30   0x210D             MOVS     R1,#+13
   \       0x32   0x2014             MOVS     R0,#+20
   \       0x34   0x.... 0x....      BL       LCDSetCursor
    458          		LCDPrintf( "통화중..." );
   \       0x38   0x....             LDR.N    R0,??DataTable12_19
   \       0x3A   0x.... 0x....      BL       LCDPrintf
    459          
    460          		SetRFMMode((uint8_t) RFMModeTx );
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0x.... 0x....      BL       SetRFMMode
    461          
    462          		//	통화 - 시작
    463          		SendCall((uint8_t) CtrlStart );		//	SendRF - Send Call ( 송신기 -> 송신기 )
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0x.... 0x....      BL       SendCall
   \       0x4A   0xE011             B.N      ??KeySos_1
    464          	}
    465          	else
    466          	{
    467          #if defined(USE_CH_ISO_DEV)
    468          		SetChPARFT( GetChNearRFT() );	//	가까운 송신기 설정.
   \                     ??KeySos_0: (+1)
   \       0x4C   0x.... 0x....      BL       GetChNearRFT
   \       0x50   0xB2C0             UXTB     R0,R0
   \       0x52   0x.... 0x....      BL       SetChPARFT
    469          
    470          		SetChPA( GetChNearRFM() );		//	가장 가까운 수신기 설정.
   \       0x56   0x.... 0x....      BL       GetChNearRFM
   \       0x5A   0xB2C0             UXTB     R0,R0
   \       0x5C   0x.... 0x....      BL       SetChPA
    471          #endif
    472          
    473          		//    편성 : 100
    474          		UpdateLCDMain();
   \       0x60   0x.... 0x....      BL       UpdateLCDMain
    475          //		LCDSetCursor( 20, 13 );
    476          //		LCDPrintf( "편성 : 100" );
    477          
    478          		SetRFMMode( (uint8_t)RFMModeNormal );
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x.... 0x....      BL       SetRFMMode
    479          
    480          		//	통화 - 종료
    481          		SendCall( (uint8_t)CtrlStop );		//	SendRF - Send Call ( 송신기 -> 송신기 )
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x.... 0x....      BL       SendCall
    482          	}
    483          }
   \                     ??KeySos_1: (+1)
   \       0x70   0xBD10             POP      {R4,PC}
    484          
    485          
    486          //========================================================================
    487          //		Power Button
    488          //========================================================================
    489          
    490          //========================================================================

   \                                 In section .text, align 2, keep-with-next
    491          void	KeyPwrOnOff		( uint8_t bValue )
    492          //========================================================================
    493          {
   \                     KeyPwrOnOff: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    494          	//	bValue : 0(Up) / 1(Down)
    495          	printf( "%s(%d) - %d\n", __func__, __LINE__, bValue );
   \        0x4   0x....             LDR.N    R5,??DataTable12_20
   \        0x6   0x0023             MOVS     R3,R4
   \        0x8   0xB2DB             UXTB     R3,R3
   \        0xA   0xF240 0x12EF      MOVW     R2,#+495
   \        0xE   0x0029             MOVS     R1,R5
   \       0x10   0x....             LDR.N    R0,??DataTable12_6
   \       0x12   0x.... 0x....      BL       printf
    496          
    497          	static uint8_t bPowerOn = 0;
    498          
    499          	if ( bValue != 0)
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0xB2C0             UXTB     R0,R0
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD003             BEQ.N    ??KeyPwrOnOff_0
    500          	{
    501          		bPowerOn = 1;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0x....             LDR.N    R1,??DataTable12_21
   \       0x22   0x7008             STRB     R0,[R1, #+0]
   \       0x24   0xE00F             B.N      ??KeyPwrOnOff_1
    502          	}
    503          	else
    504          	{
    505          		if( bPowerOn != 0)
   \                     ??KeyPwrOnOff_0: (+1)
   \       0x26   0x....             LDR.N    R0,??DataTable12_21
   \       0x28   0x7800             LDRB     R0,[R0, #+0]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD00B             BEQ.N    ??KeyPwrOnOff_1
    506          		{
    507          			//========================================================================
    508          			//	Power Off
    509          			printf( "%s(%d) - Power Off\n", __func__, __LINE__  );
   \       0x2E   0xF240 0x12FD      MOVW     R2,#+509
   \       0x32   0x0029             MOVS     R1,R5
   \       0x34   0x....             LDR.N    R0,??DataTable12_22
   \       0x36   0x.... 0x....      BL       printf
    510          
    511          			HAL_GPIO_WritePin( ON_OFF_EN_GPIO_Port, ON_OFF_EN_Pin, GPIO_PIN_RESET );
   \       0x3A   0x2200             MOVS     R2,#+0
   \       0x3C   0xF44F 0x6180      MOV      R1,#+1024
   \       0x40   0x....             LDR.N    R0,??DataTable12_1
   \       0x42   0x.... 0x....      BL       HAL_GPIO_WritePin
    512          		}
    513          	}
    514          }
   \                     ??KeyPwrOnOff_1: (+1)
   \       0x46   0xBD31             POP      {R0,R4,R5,PC}

   \                                 In section .bss, align 1
   \                     `KeyPwrOnOff::bPowerOn`:
   \        0x0                      DS8 1
    515          
    516          //========================================================================
    517          
    518          
    519          //========================================================================
    520          //		Power Button
    521          //========================================================================
    522          
    523          

   \                                 In section .text, align 2, keep-with-next
    524          void	KeyTestLoopback( uint8_t bValue )
    525          {
   \                     KeyTestLoopback: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    526          
    527          #if 1
    528          
    529          	//	Speex Loopback Test
    530          	//	Audio Loopback Proc
    531          
    532          	if ( bValue != 0 )
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB2C0             UXTB     R0,R0
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD00E             BEQ.N    ??KeyTestLoopback_0
    533          	{
    534          		//	송신중
    535          		LCDSetCursor( 10, 13 );
   \        0xC   0x210D             MOVS     R1,#+13
   \        0xE   0x200A             MOVS     R0,#+10
   \       0x10   0x.... 0x....      BL       LCDSetCursor
    536          		LCDPrintf( "Audio Loop" );
   \       0x14   0x....             LDR.N    R0,??DataTable12_23
   \       0x16   0x.... 0x....      BL       LCDPrintf
    537          
    538          		//	Spk On
    539          //		LCDSpeaker( 1 );
    540          //		LCDSpeaker( 1 );
    541          
    542          		HAL_GPIO_WritePin( SPK_ON_GPIO_Port, SPK_ON_Pin, GPIO_PIN_SET );
   \       0x1A   0x2201             MOVS     R2,#+1
   \       0x1C   0x2120             MOVS     R1,#+32
   \       0x1E   0x....             LDR.N    R0,??DataTable12_24
   \       0x20   0x.... 0x....      BL       HAL_GPIO_WritePin
    543          
    544          		//	Codec Loopback On
    545          //		AudioRxTxLoop();
    546          		AudioDMALoopback();
   \       0x24   0x.... 0x....      BL       AudioDMALoopback
   \       0x28   0xE008             B.N      ??KeyTestLoopback_1
    547          
    548          		//	Codec Loopback On
    549          //		AudioPlayDMASine();
    550          
    551          //DEL		AudioLoopbackDMASpeex();
    552          		//	-> Speex는 성능문제로 사용 X
    553          //		AudioLoopbackDMACompress();
    554          	}
    555          	else
    556          	{
    557          		//    편성 : 100
    558          		UpdateLCDMain();
   \                     ??KeyTestLoopback_0: (+1)
   \       0x2A   0x.... 0x....      BL       UpdateLCDMain
    559          //		LCDSetCursor( 20, 13 );
    560          //		LCDPrintf( "편성 : 100" );
    561          
    562          		//	Spk Off
    563          //		LCDSpeaker( 0 );
    564          
    565          		HAL_GPIO_WritePin( SPK_ON_GPIO_Port, SPK_ON_Pin, GPIO_PIN_RESET );
   \       0x2E   0x2200             MOVS     R2,#+0
   \       0x30   0x2120             MOVS     R1,#+32
   \       0x32   0x....             LDR.N    R0,??DataTable12_24
   \       0x34   0x.... 0x....      BL       HAL_GPIO_WritePin
    566          
    567          		//	Codec Loopback Off
    568          		AudioStop();
   \       0x38   0x.... 0x....      BL       AudioStop
    569          	}
    570          #endif
    571          
    572          }
   \                     ??KeyTestLoopback_1: (+1)
   \       0x3C   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x....'....        DC32     s_btnStat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x4002'0C00        DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x....'....        DC32     `LoopProcKey::tickBase`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0x....'....        DC32     `LoopProcKey::tickBase2`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \        0x0   0x....'....        DC32     `LoopProcKey{13}{14}::s_cntKeyOkMenu`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \        0x0   0x....'....        DC32     `KeyMenu::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \        0x0   0x....'....        DC32     `KeyOK::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \        0x0   0x....'....        DC32     `KeyLight::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \        0x0   0x....'....        DC32     `KeyLight::bOnOff`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \        0x0   0x4002'0400        DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \        0x0   0x....'....        DC32     `KeyUp::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \        0x0   0x....'....        DC32     `KeyDown::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \        0x0   0x....'....        DC32     `KeyVol::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \        0x0   0x....'....        DC32     g_nSpkLevel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_15:
   \        0x0   0x....'....        DC32     `KeyPtt::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_16:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_17:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_18:
   \        0x0   0x....'....        DC32     `KeySos::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_19:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_20:
   \        0x0   0x....'....        DC32     `KeyPwrOnOff::__func__`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_21:
   \        0x0   0x....'....        DC32     `KeyPwrOnOff::bPowerOn`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_22:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_23:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_24:
   \        0x0   0x4002'1000        DC32     0x40021000

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x25 0x73          DC8 "%s(%d) - %d\012"

   \              0x28 0x25    

   \              0x64 0x29    

   \              0x20 0x2D    

   \              0x20 0x25    

   \              0x64 0x0A    

   \              0x00
   \        0xD                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0xEB 0xB0          DC8 "\353\260\251\354\206\241\354\244\221...(%d)"

   \              0xA9 0xEC    

   \              0x86 0xA1    

   \              0xEC 0xA4    

   \              0x91 0x2E    

   \              0x2E 0x2E    

   \              0x28 0x25    

   \              0x64 0x29    

   \              0x00
   \       0x11                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0xEB 0xB0          DC8 "\353\260\251\354\206\241\354\244\221..."

   \              0xA9 0xEC    

   \              0x86 0xA1    

   \              0xEC 0xA4    

   \              0x91 0x2E    

   \              0x2E 0x2E    

   \              0x00
   \        0xD                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0xED 0x86          DC8 "\355\206\265\355\231\224\354\244\221..."

   \              0xB5 0xED    

   \              0x99 0x94    

   \              0xEC 0xA4    

   \              0x91 0x2E    

   \              0x2E 0x2E    

   \              0x00
   \        0xD                      DS8 3

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x25 0x73          DC8 "%s(%d) - Power Off\012"

   \              0x28 0x25    

   \              0x64 0x29    

   \              0x20 0x2D    

   \              0x20 0x50    

   \              0x6F 0x77    

   \              0x65 0x72    

   \              0x20 0x4F    

   \              0x66 0x66    

   \              0x0A 0x00

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0x41 0x75          DC8 "Audio Loop"

   \              0x64 0x69    

   \              0x6F 0x20    

   \              0x4C 0x6F    

   \              0x6F 0x70    

   \              0x00
   \        0xB                      DS8 1
    573          
    574          
    575          //========================================================================

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   GetKey
      16   GetKeyStat
        16   -> HAL_GPIO_ReadPin
       8   KeyDown
         8   -> ProcBtnDown
         8   -> printf
      16   KeyLight
        16   -> HAL_GPIO_WritePin
        16   -> LCDLight
        16   -> printf
       8   KeyMenu
         8   -> ProcBtnMenu
         8   -> printf
       8   KeyOK
         8   -> ProcBtnOK
         8   -> printf
      32   KeyPtt
        32   -> GetChNearRFM
        32   -> GetChNearRFT
        32   -> GetChPA
        32   -> HAL_GPIO_WritePin
        32   -> IsMenuMaint
        32   -> LCDPrintf
        32   -> LCDSetCursor
        32   -> SendPA
        32   -> SetChPA
        32   -> SetChPARFT
        32   -> SetRFMMode
        32   -> UpdateLCDMain
        32   -> printf
        32   -> sprintf
      16   KeyPwrOnOff
        16   -> HAL_GPIO_WritePin
        16   -> printf
       8   KeySos
         8   -> GetChNearRFM
         8   -> GetChNearRFT
         8   -> LCDPrintf
         8   -> LCDSetCursor
         8   -> SendCall
         8   -> SetChPA
         8   -> SetChPARFT
         8   -> SetRFMMode
         8   -> UpdateLCDMain
         8   -> printf
       8   KeyTestLoopback
         8   -> AudioDMALoopback
         8   -> AudioStop
         8   -> HAL_GPIO_WritePin
         8   -> LCDPrintf
         8   -> LCDSetCursor
         8   -> UpdateLCDMain
       8   KeyUp
         8   -> ProcBtnUp
         8   -> printf
      16   KeyVol
        16   -> LCDSpeaker
        16   -> RFM_Spk
        16   -> SetSpkVol
        16   -> printf
      40   LoopProcKey
        40   -> EnableMenuMaint
        40   -> GetKeyStat
        40   -> IsMenuMaint
        40   -> KeyDown
        40   -> KeyLight
        40   -> KeyMenu
        40   -> KeyOK
        40   -> KeyPtt
        40   -> KeyPwrOnOff
        40   -> KeySos
        40   -> KeyUp
        40   -> KeyVol
        40   -> __aeabi_memcpy
        40   -> memcmp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_18
       4  ??DataTable12_19
       4  ??DataTable12_2
       4  ??DataTable12_20
       4  ??DataTable12_21
       4  ??DataTable12_22
       4  ??DataTable12_23
       4  ??DataTable12_24
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
      16  ?_0
      20  ?_1
      16  ?_2
      16  ?_3
      20  ?_4
      12  ?_5
      10  GetKey
     150  GetKeyStat
      34  KeyDown
      84  KeyLight
      32  KeyMenu
      32  KeyOK
     174  KeyPtt
      72  KeyPwrOnOff
     114  KeySos
      62  KeyTestLoopback
      34  KeyUp
      86  KeyVol
     274  LoopProcKey
       1  bOnOff
       1  bPowerOn
      12  s_btnStat
       1  s_cntKeyOkMenu
       4  tickBase
       4  tickBase2
      80  -- Other

 
    23 bytes in section .bss
   180 bytes in section .rodata
 1'258 bytes in section .text
 
 1'258 bytes of CODE  memory
   180 bytes of CONST memory
    23 bytes of DATA  memory

Errors: none
Warnings: 17
