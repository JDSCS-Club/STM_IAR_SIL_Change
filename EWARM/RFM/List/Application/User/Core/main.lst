###############################################################################
#
#                                                         06/Oct/2022  13:55:47
# IAR ANSI C/C++ Compiler V9.20.3.326/W64 for ARM Functional Safety
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode                 =  thumb
#    Endian                   =  little
#    Source file              =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Src\main.c
#    Command line             =
#        -f
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Application\User\Core\main.o.rsp
#        (C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Src\main.c -D USE_HAL_DRIVER -D
#        STM32F407xx -lC
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Application\User\Core
#        -o C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Application\User\Core
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0 EWARM FS
#        9.20.3\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/App\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Core/Inc\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Include\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/display\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Library\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.0 EWARM FS 9.20.3\arm\CMSIS\Core\Include\\")
#        --dependencies=n
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Application\User\Core\main.o.d
#    Locale                   =  C
#    List file                =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Application\User\Core\main.lst
#    Object file              =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Application\User\Core\main.o
#    Runtime model:              
#      __CPP_Runtime          =  1
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  1
#      __dlib_version         =  6
#
###############################################################################

C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Src\main.c
      1          /* USER CODE BEGIN Header */
      2          /**
      3            ******************************************************************************
      4            * @file           : main.c
      5            * @brief          : Main program body
      6            ******************************************************************************
      7            * @attention
      8            *
      9            * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
     10            * All rights reserved.</center></h2>
     11            *
     12            * This software component is licensed by ST under BSD 3-Clause license,
     13            * the "License"; You may not use this file except in compliance with the
     14            * License. You may obtain a copy of the License at:
     15            *                        opensource.org/licenses/BSD-3-Clause
     16            *
     17            ******************************************************************************
     18            */
     19          
     20          #include <stdio.h>
     21          #include <stdint.h>         //  uint16_t
     22          
     23          /* USER CODE END Header */
     24          /* Includes ------------------------------------------------------------------*/
     25          #include "main.h"

  # warning unrecognized compiler
    ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\compiler_defs.h",744  Warning[Pa183]: 
          #warning directive: unrecognized compiler
     26          //#include "usb_device.h"
     27          
     28          /* Private includes ----------------------------------------------------------*/
     29          /* USER CODE BEGIN Includes */
     30          
     31          #include "typedef.h"	//	TRUE, FALSE, ...

  typedef unsigned char       BYTE;
                              ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",73  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned short      WORD;
                              ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",77  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned char 		BIT;
                        		^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",83  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned char 		U8;
                        		^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",84  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int 		U16;
                       		^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",85  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned long 		U32;
                        		^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",86  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed char 		S8;
                      		^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",88  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed int 			S16;
                     			^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",89  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed long 		S32;
                      		^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",90  Warning[Pe301]: 
          typedef name has already been declared (with same type)
     32          
     33          /* USER CODE END Includes */
     34          
     35          /* Private typedef -----------------------------------------------------------*/
     36          /* USER CODE BEGIN PTD */
     37          
     38          /* USER CODE END PTD */
     39          
     40          /* Private define ------------------------------------------------------------*/
     41          /* USER CODE BEGIN PD */
     42          /* USER CODE END PD */
     43          
     44          /* Private macro -------------------------------------------------------------*/
     45          /* USER CODE BEGIN PM */
     46          
     47          /* USER CODE END PM */
     48          
     49          /* Private variables ---------------------------------------------------------*/

   \                                 In section .bss, align 4
     50          ADC_HandleTypeDef hadc1;
   \                     hadc1:
   \        0x0                      DS8 72
     51          

   \                                 In section .bss, align 4
     52          I2C_HandleTypeDef hi2c1;
   \                     hi2c1:
   \        0x0                      DS8 84

   \                                 In section .bss, align 4
     53          I2C_HandleTypeDef hi2c3;
   \                     hi2c3:
   \        0x0                      DS8 84
     54          

   \                                 In section .bss, align 4
     55          I2S_HandleTypeDef hi2s3;
   \                     hi2s3:
   \        0x0                      DS8 72

   \                                 In section .bss, align 4
     56          DMA_HandleTypeDef hdma_i2s3_ext_rx;
   \                     hdma_i2s3_ext_rx:
   \        0x0                      DS8 96

   \                                 In section .bss, align 4
     57          DMA_HandleTypeDef hdma_spi3_tx;
   \                     hdma_spi3_tx:
   \        0x0                      DS8 96
     58          

   \                                 In section .bss, align 4
     59          IWDG_HandleTypeDef hiwdg;
   \                     hiwdg:
   \        0x0                      DS8 12
     60          

   \                                 In section .bss, align 4
     61          SPI_HandleTypeDef hspi1;
   \                     hspi1:
   \        0x0                      DS8 88

   \                                 In section .bss, align 4
     62          SPI_HandleTypeDef hspi2;
   \                     hspi2:
   \        0x0                      DS8 88

   \                                 In section .bss, align 4
     63          DMA_HandleTypeDef hdma_spi1_tx;
   \                     hdma_spi1_tx:
   \        0x0                      DS8 96

   \                                 In section .bss, align 4
     64          DMA_HandleTypeDef hdma_spi1_rx;
   \                     hdma_spi1_rx:
   \        0x0                      DS8 96
     65          

   \                                 In section .bss, align 4
     66          TIM_HandleTypeDef htim3;
   \                     htim3:
   \        0x0                      DS8 64
     67          

   \                                 In section .bss, align 4
     68          TIM_HandleTypeDef htim1;
   \                     htim1:
   \        0x0                      DS8 64
     69          
     70          

   \                                 In section .bss, align 4
     71          UART_HandleTypeDef huart1;
   \                     huart1:
   \        0x0                      DS8 64

   \                                 In section .bss, align 4
     72          UART_HandleTypeDef huart2;
   \                     huart2:
   \        0x0                      DS8 64
     73          
     74          /* USER CODE BEGIN PV */
     75          
     76          /* USER CODE END PV */
     77          
     78          /* Private function prototypes -----------------------------------------------*/
     79          void SystemClock_Config(void);
     80          static void MX_GPIO_Init(void);
     81          static void MX_DMA_Init(void);
     82          static void MX_I2C1_Init(void);
     83          static void MX_SPI1_Init(void);
     84          static void MX_SPI2_Init(void);
     85          static void MX_USART1_UART_Init(void);
     86          static void MX_USART2_UART_Init(void);
     87          static void MX_I2S3_Init(void);
     88          static void MX_TIM3_Init(void);
     89          static void MX_ADC1_Init(void);
     90          static void MX_I2C3_Init(void);
     91          static void MX_IWDG_Init(void);
     92          /* USER CODE BEGIN PFP */
     93          
     94          /* USER CODE END PFP */
     95          
     96          /* Private user code ---------------------------------------------------------*/
     97          /* USER CODE BEGIN 0 */
     98          
     99          #if	defined(USE_BOOTLOADER)
    100          
    101          #include "bootloader.h"
    102          
    103          #else	//	defined(USE_BOOTLOADER)
    104          
    105          
    106          #include "serial.h"
    107          
    108          #include "Adafruit_SSD1306.h"   //  I2C LCD
    109          
    110          #include "radio_hal.h"			//	RF_NIRQ
    111          #include "si446x_api_lib.h"		//	si446x_part_info()
    112          
    113          #include "keypad.h"				//	RFM Keypad
    114          
    115          #include "audio.h"				//	MAX9860

  	};
  	 ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Library\RFMProtocol.h",293  Warning[Pe040]: 
          expected an identifier

  	};
  	 ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Library\RFMProtocol.h",311  Warning[Pe040]: 
          expected an identifier

  	};
  	 ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Library\RFMProtocol.h",419  Warning[Pe040]: 
          expected an identifier

  	};
  	 ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Library\RFMProtocol.h",457  Warning[Pe040]: 
          expected an identifier

  	};
  	 ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Library\RFMProtocol.h",462  Warning[Pe040]: 
          expected an identifier

  	};
  	 ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Library\RFMProtocol.h",484  Warning[Pe040]: 
          expected an identifier

  	};
  	 ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Library\RFMProtocol.h",510  Warning[Pe040]: 
          expected an identifier

  	};
  	 ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Library\RFMProtocol.h",518  Warning[Pe040]: 
          expected an identifier
    116          
    117          #include "rfm.h"				//	SetDevID()
    118          
    119          
    120          //si4463 Interrupt
    121          

   \                                 In section .bss, align 1
    122          uint8_t RF_NIRQ;
   \                     RF_NIRQ:
   \        0x0                      DS8 1
    123          
    124          
    125          
    126          //========================================================================

   \                                 In section .text, align 2, keep-with-next
    127          void HAL_GPIO_EXTI_Callback ( uint16_t GPIO_Pin )
    128          //========================================================================
    129          {
   \                     HAL_GPIO_EXTI_Callback: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    130              uint8_t st;
    131          
    132          //    printf( " HAL_GPIO_EXTI_Callback\n" );
    133          
    134              st = HAL_GPIO_ReadPin ( RF_INT_GPIO_Port, RF_INT_Pin );
   \        0x4   0x2110             MOVS     R1,#+16
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable14
   \        0xA   0x.... 0x....      BL       HAL_GPIO_ReadPin
    135              if ( st )	//	rising edge
   \        0xE   0x0001             MOVS     R1,R0
   \       0x10   0xB2C9             UXTB     R1,R1
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD004             BEQ.N    ??HAL_GPIO_EXTI_Callback_0
    136              {
    137                  RF_NIRQ = TRUE;
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0x.... 0x....      LDR.W    R2,??DataTable14_1
   \       0x1C   0x7011             STRB     R1,[R2, #+0]
   \       0x1E   0xE003             B.N      ??HAL_GPIO_EXTI_Callback_1
    138              }
    139              else		//	falling edge
    140              {
    141                  RF_NIRQ = FALSE;
   \                     ??HAL_GPIO_EXTI_Callback_0: (+1)
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x.... 0x....      LDR.W    R2,??DataTable14_1
   \       0x26   0x7011             STRB     R1,[R2, #+0]
    142              }
    143          }
   \                     ??HAL_GPIO_EXTI_Callback_1: (+1)
   \       0x28   0xBD10             POP      {R4,PC}
    144          
    145          //========================================================================

   \                                 In section .text, align 2, keep-with-next
    146          void LoopProcMain( uint16_t nTick )
    147          //========================================================================
    148          {
    149          	//	Watchdog Reload
    150          	__HAL_IWDG_RELOAD_COUNTER(&hiwdg);
   \                     LoopProcMain: (+1)
   \        0x0   0xF64A 0x21AA      MOVW     R1,#+43690
   \        0x4   0x.... 0x....      LDR.W    R2,??DataTable14_2
   \        0x8   0x6812             LDR      R2,[R2, #+0]
   \        0xA   0x6011             STR      R1,[R2, #+0]
    151          
    152          //	static int s_nTick = 0;
    153          //
    154          //	if ( ( nTick - s_nTick ) >= 1000 )
    155          //	{
    156          //		char *sTest = "USB 가나다라\n\r";
    157          //		CDC_Transmit_FS(sTest, strlen(sTest) + 1);
    158          //		s_nTick = nTick;
    159          //	}
    160          }
   \        0xC   0x4770             BX       LR
    161          
    162          #endif
    163          
    164          //========================================================================

   \                                 In section .text, align 2, keep-with-next
    165          void MX_IWDG_Disable( void )
    166          //========================================================================
    167          {
    168          	//	iWdg : iWatchdog의 경우 처음 시작 이후에 Stop 불가.
    169          	//			-> Reset이후에만 종료됨.
    170          //	IWDG_DISABLE_WRITE_ACCESS( &hiwdg );
    171          }
   \                     MX_IWDG_Disable: (+1)
   \        0x0   0x4770             BX       LR
    172          
    173          
    174          
    175          
    176          
    177          /* USER CODE END 0 */
    178          
    179          /**
    180            * @brief  The application entry point.
    181            * @retval int
    182            */

   \                                 In section .text, align 2, keep-with-next
    183          int main(void)
    184          {
   \                     main: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    185            /* USER CODE BEGIN 1 */
    186          
    187            /* USER CODE END 1 */
    188          
    189            /* MCU Configuration--------------------------------------------------------*/
    190          
    191            /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
    192            HAL_Init();
   \        0x2   0x.... 0x....      BL       HAL_Init
    193          
    194            /* USER CODE BEGIN Init */
    195          
    196            /* USER CODE END Init */
    197          
    198            /* Configure the system clock */
    199            SystemClock_Config();
   \        0x6   0x.... 0x....      BL       SystemClock_Config
    200          
    201            /* USER CODE BEGIN SysInit */
    202          
    203          #if	defined(USE_BOOTLOADER)
    204          
    205            MX_GPIO_Init();
    206            MX_DMA_Init();
    207            MX_I2C1_Init();
    208            MX_SPI1_Init();
    209            MX_SPI2_Init();
    210            //MX_USART1_UART_Init();
    211            MX_USART2_UART_Init();
    212            MX_I2S3_Init();
    213            MX_TIM3_Init();
    214          //  MX_ADC1_Init();
    215            MX_I2C3_Init();
    216          //  MX_IWDG_Init();
    217          //DEL  MX_USB_DEVICE_Init();
    218          
    219          #else	//	Application
    220          
    221            /* USER CODE END SysInit */
    222          
    223            /* Initialize all configured peripherals */
    224            MX_GPIO_Init();
   \        0xA   0x.... 0x....      BL       MX_GPIO_Init
    225            MX_DMA_Init();
   \        0xE   0x.... 0x....      BL       MX_DMA_Init
    226            MX_I2C1_Init();
   \       0x12   0x.... 0x....      BL       MX_I2C1_Init
    227            MX_SPI1_Init();
   \       0x16   0x.... 0x....      BL       MX_SPI1_Init
    228            MX_SPI2_Init();
   \       0x1A   0x.... 0x....      BL       MX_SPI2_Init
    229            //MX_USART1_UART_Init();
    230            MX_USART2_UART_Init();
   \       0x1E   0x.... 0x....      BL       MX_USART2_UART_Init
    231            MX_I2S3_Init();
   \       0x22   0x.... 0x....      BL       MX_I2S3_Init
    232            MX_TIM3_Init();
   \       0x26   0x.... 0x....      BL       MX_TIM3_Init
    233            MX_ADC1_Init();
   \       0x2A   0x.... 0x....      BL       MX_ADC1_Init
    234            MX_I2C3_Init();
   \       0x2E   0x.... 0x....      BL       MX_I2C3_Init
    235            MX_IWDG_Init();
   \       0x32   0x.... 0x....      BL       MX_IWDG_Init
    236            //MX_USB_DEVICE_Init();
    237            /* USER CODE BEGIN 2 */
    238          
    239          #endif	//	Application
    240          
    241          
    242              
    243              
    244              
    245              
    246          //    RCC_ClkInitTypeDef    clkconfig;
    247          //    
    248          //    uint32_t              uwTimclock = 0;
    249          //    uint32_t              uwPrescalerValue = 0; 
    250          //    uint32_t              pFLatency;
    251          //    
    252          // 
    253          //     
    254          //     
    255          //    /* Get clock configuration */
    256          //    HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
    257          //  
    258          //
    259          //    uwTimclock = HAL_RCC_GetPCLK2Freq();
    260          //    uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
    261          //
    262          //    /* Initialize TIM1 */
    263          //    htim1.Instance = TIM1;
    264          //
    265          //    /* Initialize TIMx peripheral as follow:
    266          //    + Period = [(TIM1CLK/1000) - 1]. to have a (1/1000) s time base.
    267          //    + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
    268          //    + ClockDivision = 0
    269          //    + Counter direction = Up
    270          //    */
    271          //    htim1.Init.Period = 10000-1;
    272          //    htim1.Init.Prescaler = (uint32_t) ((SystemCoreClock/2)/10000000) - 1;;
    273          //    htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    274          //    htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
    275          //    
    276          //    if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
    277          //    {
    278          //        /* Start the TIM time Base generation in interrupt mode */
    279          //        return HAL_TIM_Base_Start_IT(&htim1);
    280          //    }
    281              
    282              
    283              //========================================================================
    284          	//    Start PWM
    285          
    286          	//    I2S MCLK - 12 MHz
    287            	//		72000000 / 3 / 2 = 12000000 ( 12MHz ) - MCLK ( MAX9860+ )
    288          	HAL_TIM_PWM_Start( &htim3, TIM_CHANNEL_2 );       //      12 MHz
   \       0x36   0x.... 0x....      LDR.W    R6,??DataTable14_3
   \       0x3A   0x2104             MOVS     R1,#+4
   \       0x3C   0x0030             MOVS     R0,R6
   \       0x3E   0x.... 0x....      BL       HAL_TIM_PWM_Start
    289          	HAL_TIMEx_PWMN_Start( &htim3, TIM_CHANNEL_2 );
   \       0x42   0x2104             MOVS     R1,#+4
   \       0x44   0x0030             MOVS     R0,R6
   \       0x46   0x.... 0x....      BL       HAL_TIMEx_PWMN_Start
    290          
    291          	//========================================================================
    292          	//    Initial
    293          
    294          	//	Serial
    295          	SerialInit( NULL, &huart2 );   //  Init Serial Handle
   \       0x4A   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x.... 0x....      BL       SerialInit
    296          	//SerialInit( NULL, &huart2 );   //  Init Serial Handle
    297          	setbuf ( stdout, NULL );		            //	1024 byte buffer clear
   \       0x54   0x.... 0x....      LDR.W    R6,??DataTable14_5
   \       0x58   0x2100             MOVS     R1,#+0
   \       0x5A   0x0030             MOVS     R0,R6
   \       0x5C   0x.... 0x....      BL       setbuf
    298          	//  setvbuf ( stdout, NULL, _IOLBF, NULL );	//	Line Buffer
    299          	setvbuf ( stdout, NULL, _IONBF, NULL );	//	No Buffer
   \       0x60   0x2300             MOVS     R3,#+0
   \       0x62   0x2202             MOVS     R2,#+2
   \       0x64   0x2100             MOVS     R1,#+0
   \       0x66   0x0030             MOVS     R0,R6
   \       0x68   0x.... 0x....      BL       setvbuf
    300          
    301          	//printf( "%s(%d) - Start\n", __func__, __LINE__ );
    302              
    303            
    304            
    305          
    306          #if	defined(USE_BOOTLOADER)
    307          
    308          	BootLoaderTask();
    309          
    310          #else	//	RFM
    311          
    312          	//========================================================================
    313          	//    RFM Main Routine
    314          
    315          	RFM_main();
   \       0x6C   0x.... 0x....      BL       RFM_main
    316          
    317          	//========================================================================
    318          
    319            /* USER CODE END 2 */
    320          
    321            /* Infinite loop */
    322            /* USER CODE BEGIN WHILE */
    323              
    324          
    325              
    326              
    327            int nCurrTick;
    328            int nCurrTickRe;
    329            static int nLedTick = 0;
    330          
    331            static int nCallTimeCnt = 1;
    332          
    333          
    334            while (nCallTimeCnt)
   \                     ??main_0: (+1)
   \       0x70   0x.... 0x....      LDR.W    R1,??DataTable14_6
   \       0x74   0x6808             LDR      R0,[R1, #+0]
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD01E             BEQ.N    ??main_1
    335            {
    336              /* USER CODE END WHILE */
    337          
    338              /* USER CODE BEGIN 3 */
    339          
    340          	if((nCurrTick + 10) < nCurrTickRe){nCallTimeCnt = 0;  }
   \       0x7A   0xF114 0x000A      ADDS     R0,R4,#+10
   \       0x7E   0x42A8             CMP      R0,R5
   \       0x80   0xDA01             BGE.N    ??main_2
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0x6008             STR      R0,[R1, #+0]
    341          
    342          	nCurrTick = HAL_GetTick();
   \                     ??main_2: (+1)
   \       0x86   0x.... 0x....      BL       HAL_GetTick
   \       0x8A   0x0004             MOVS     R4,R0
    343          
    344          	LoopProcKey( nCurrTick );
   \       0x8C   0x0020             MOVS     R0,R4
   \       0x8E   0xB280             UXTH     R0,R0
   \       0x90   0x.... 0x....      BL       LoopProcKey
    345          
    346          	if ( ( nCurrTick - nLedTick ) >= 1000 )
   \       0x94   0x.... 0x....      LDR.W    R6,??DataTable14_7
   \       0x98   0x6830             LDR      R0,[R6, #+0]
   \       0x9A   0x1A20             SUBS     R0,R4,R0
   \       0x9C   0xF5B0 0x7F7A      CMP      R0,#+1000
   \       0xA0   0xDB06             BLT.N    ??main_3
    347          	{
    348          	    HAL_GPIO_TogglePin( LED_ST_GPIO_Port, LED_ST_Pin );
   \       0xA2   0xF44F 0x4100      MOV      R1,#+32768
   \       0xA6   0x.... 0x....      LDR.W    R0,??DataTable14_8
   \       0xAA   0x.... 0x....      BL       HAL_GPIO_TogglePin
    349          
    350          	    //printf( "%s(%d) - Loop(%d)\n", __func__, __LINE__, nCurrTick );
    351          
    352          	    nLedTick = nCurrTick;
   \       0xAE   0x6034             STR      R4,[R6, #+0]
    353          	}
    354          
    355          	nCurrTickRe = HAL_GetTick();
   \                     ??main_3: (+1)
   \       0xB0   0x.... 0x....      BL       HAL_GetTick
   \       0xB4   0x0005             MOVS     R5,R0
   \       0xB6   0xE7DB             B.N      ??main_0
    356          
    357          
    358            }
    359          
    360          #endif
    361          
    362          
    363            /* USER CODE END 3 */
    364          }
   \                     ??main_1: (+1)
   \       0xB8   0x2000             MOVS     R0,#+0
   \       0xBA   0xBD70             POP      {R4-R6,PC}

   \                                 In section .bss, align 4
   \                     `main::nLedTick`:
   \        0x0                      DS8 4

   \                                 In section .data, align 4
   \                     `main::nCallTimeCnt`:
   \        0x0   0x0000'0001        DC32 1
    365          
    366          /**
    367            * @brief System Clock Configuration
    368            * @retval None
    369            */

   \                                 In section .text, align 2, keep-with-next
    370          void SystemClock_Config(void)
    371          {
   \                     SystemClock_Config: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0xB096             SUB      SP,SP,#+88
   \        0x4   0x2230             MOVS     R2,#+48
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0xA80A             ADD      R0,SP,#+40
   \        0xA   0x.... 0x....      BL       memset
   \        0xE   0x2214             MOVS     R2,#+20
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0xA805             ADD      R0,SP,#+20
   \       0x14   0x.... 0x....      BL       memset
   \       0x18   0x2210             MOVS     R2,#+16
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0xA801             ADD      R0,SP,#+4
   \       0x1E   0x.... 0x....      BL       memset
    372            RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    373            RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
    374            RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
    375          
    376            /** Configure the main internal regulator output voltage
    377            */
    378            __HAL_RCC_PWR_CLK_ENABLE();
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x9000             STR      R0,[SP, #+0]
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable14_9
   \       0x2A   0x6801             LDR      R1,[R0, #+0]
   \       0x2C   0xF051 0x5180      ORRS     R1,R1,#0x10000000
   \       0x30   0x6001             STR      R1,[R0, #+0]
   \       0x32   0x6800             LDR      R0,[R0, #+0]
   \       0x34   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \       0x38   0x9000             STR      R0,[SP, #+0]
   \       0x3A   0x9800             LDR      R0,[SP, #+0]
    379            __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x9000             STR      R0,[SP, #+0]
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable14_10
   \       0x44   0x6801             LDR      R1,[R0, #+0]
   \       0x46   0xF451 0x4180      ORRS     R1,R1,#0x4000
   \       0x4A   0x6001             STR      R1,[R0, #+0]
   \       0x4C   0x6800             LDR      R0,[R0, #+0]
   \       0x4E   0xF410 0x4080      ANDS     R0,R0,#0x4000
   \       0x52   0x9000             STR      R0,[SP, #+0]
   \       0x54   0x9800             LDR      R0,[SP, #+0]
    380            /** Initializes the RCC Oscillators according to the specified parameters
    381            * in the RCC_OscInitTypeDef structure.
    382            */
    383            RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
   \       0x56   0x2009             MOVS     R0,#+9
   \       0x58   0x900A             STR      R0,[SP, #+40]
    384            RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
   \       0x5A   0xF45F 0x20A0      MOVS     R0,#+327680
   \       0x5E   0x900B             STR      R0,[SP, #+44]
    385            RCC_OscInitStruct.LSIState = RCC_LSI_ON;
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0x900F             STR      R0,[SP, #+60]
    386            RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
   \       0x64   0x2002             MOVS     R0,#+2
   \       0x66   0x9010             STR      R0,[SP, #+64]
    387            RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
   \       0x68   0xF45F 0x0080      MOVS     R0,#+4194304
   \       0x6C   0x9011             STR      R0,[SP, #+68]
    388            RCC_OscInitStruct.PLL.PLLM = 15;
   \       0x6E   0x200F             MOVS     R0,#+15
   \       0x70   0x9012             STR      R0,[SP, #+72]
    389            RCC_OscInitStruct.PLL.PLLN = 72;
   \       0x72   0x2048             MOVS     R0,#+72
   \       0x74   0x9013             STR      R0,[SP, #+76]
    390            RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
   \       0x76   0x2002             MOVS     R0,#+2
   \       0x78   0x9014             STR      R0,[SP, #+80]
    391            RCC_OscInitStruct.PLL.PLLQ = 3;
   \       0x7A   0x2003             MOVS     R0,#+3
   \       0x7C   0x9015             STR      R0,[SP, #+84]
    392            if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
   \       0x7E   0xA80A             ADD      R0,SP,#+40
   \       0x80   0x.... 0x....      BL       HAL_RCC_OscConfig
   \       0x84   0x2800             CMP      R0,#+0
   \       0x86   0xD001             BEQ.N    ??SystemClock_Config_0
    393            {
    394              Error_Handler();
   \       0x88   0x.... 0x....      BL       Error_Handler
    395            }
    396            /** Initializes the CPU, AHB and APB buses clocks
    397            */
    398            RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
    399                                        |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
   \                     ??SystemClock_Config_0: (+1)
   \       0x8C   0x200F             MOVS     R0,#+15
   \       0x8E   0x9005             STR      R0,[SP, #+20]
    400            RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
   \       0x90   0x2002             MOVS     R0,#+2
   \       0x92   0x9006             STR      R0,[SP, #+24]
    401            RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
   \       0x94   0x2000             MOVS     R0,#+0
   \       0x96   0x9007             STR      R0,[SP, #+28]
    402            RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
   \       0x98   0xF44F 0x5080      MOV      R0,#+4096
   \       0x9C   0x9008             STR      R0,[SP, #+32]
    403            RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x9009             STR      R0,[SP, #+36]
    404          
    405            if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
   \       0xA2   0x2102             MOVS     R1,#+2
   \       0xA4   0xA805             ADD      R0,SP,#+20
   \       0xA6   0x.... 0x....      BL       HAL_RCC_ClockConfig
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD001             BEQ.N    ??SystemClock_Config_1
    406            {
    407              Error_Handler();
   \       0xAE   0x.... 0x....      BL       Error_Handler
    408            }
    409            
    410            
    411            PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2S;
   \                     ??SystemClock_Config_1: (+1)
   \       0xB2   0x2001             MOVS     R0,#+1
   \       0xB4   0x9001             STR      R0,[SP, #+4]
    412            PeriphClkInitStruct.PLLI2S.PLLI2SN = 128;
   \       0xB6   0x2080             MOVS     R0,#+128
   \       0xB8   0x9002             STR      R0,[SP, #+8]
    413            PeriphClkInitStruct.PLLI2S.PLLI2SR = 5;
   \       0xBA   0x2005             MOVS     R0,#+5
   \       0xBC   0x9003             STR      R0,[SP, #+12]
    414            if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
   \       0xBE   0xA801             ADD      R0,SP,#+4
   \       0xC0   0x.... 0x....      BL       HAL_RCCEx_PeriphCLKConfig
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xD001             BEQ.N    ??SystemClock_Config_2
    415            {
    416              Error_Handler();
   \       0xC8   0x.... 0x....      BL       Error_Handler
    417            }
    418          }
   \                     ??SystemClock_Config_2: (+1)
   \       0xCC   0xB017             ADD      SP,SP,#+92
   \       0xCE   0xBD00             POP      {PC}
    419          
    420          /**
    421            * @brief ADC1 Initialization Function
    422            * @param None
    423            * @retval None
    424            */

   \                                 In section .text, align 2, keep-with-next
    425          static void MX_ADC1_Init(void)
    426          {
   \                     MX_ADC1_Init: (+1)
   \        0x0   0xB51F             PUSH     {R0-R4,LR}
   \        0x2   0x2210             MOVS     R2,#+16
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x4668             MOV      R0,SP
   \        0x8   0x.... 0x....      BL       memset
    427          
    428            /* USER CODE BEGIN ADC1_Init 0 */
    429          
    430            /* USER CODE END ADC1_Init 0 */
    431          
    432            ADC_ChannelConfTypeDef sConfig = {0};
    433          
    434            /* USER CODE BEGIN ADC1_Init 1 */
    435          
    436            /* USER CODE END ADC1_Init 1 */
    437            /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)
    438            */
    439            hadc1.Instance = ADC1;
   \        0xC   0x.... 0x....      LDR.W    R4,??DataTable14_11
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable14_12
   \       0x14   0x6020             STR      R0,[R4, #+0]
    440            hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV2;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x6060             STR      R0,[R4, #+4]
    441            hadc1.Init.Resolution = ADC_RESOLUTION_12B;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x60A0             STR      R0,[R4, #+8]
    442            hadc1.Init.ScanConvMode = DISABLE;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x6120             STR      R0,[R4, #+16]
    443            hadc1.Init.ContinuousConvMode = DISABLE;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x7620             STRB     R0,[R4, #+24]
    444            hadc1.Init.DiscontinuousConvMode = DISABLE;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xF884 0x0020      STRB     R0,[R4, #+32]
    445            hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x62E0             STR      R0,[R4, #+44]
    446            hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
   \       0x30   0x.... 0x....      LDR.W    R0,??DataTable14_13
   \       0x34   0x62A0             STR      R0,[R4, #+40]
    447            hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x60E0             STR      R0,[R4, #+12]
    448            hadc1.Init.NbrOfConversion = 1;
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0x61E0             STR      R0,[R4, #+28]
    449            hadc1.Init.DMAContinuousRequests = DISABLE;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xF884 0x0030      STRB     R0,[R4, #+48]
    450            hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0x6160             STR      R0,[R4, #+20]
    451            if (HAL_ADC_Init(&hadc1) != HAL_OK)
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x.... 0x....      BL       HAL_ADC_Init
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD001             BEQ.N    ??MX_ADC1_Init_0
    452            {
    453              Error_Handler();
   \       0x52   0x.... 0x....      BL       Error_Handler
    454            }
    455            /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.
    456            */
    457            sConfig.Channel = ADC_CHANNEL_11;
   \                     ??MX_ADC1_Init_0: (+1)
   \       0x56   0x200B             MOVS     R0,#+11
   \       0x58   0x9000             STR      R0,[SP, #+0]
    458            sConfig.Rank = 1;
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0x9001             STR      R0,[SP, #+4]
    459            sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x9002             STR      R0,[SP, #+8]
    460            if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
   \       0x62   0x4669             MOV      R1,SP
   \       0x64   0x0020             MOVS     R0,R4
   \       0x66   0x.... 0x....      BL       HAL_ADC_ConfigChannel
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD001             BEQ.N    ??MX_ADC1_Init_1
    461            {
    462              Error_Handler();
   \       0x6E   0x.... 0x....      BL       Error_Handler
    463            }
    464            /* USER CODE BEGIN ADC1_Init 2 */
    465          
    466            /* USER CODE END ADC1_Init 2 */
    467          
    468          }
   \                     ??MX_ADC1_Init_1: (+1)
   \       0x72   0xBD1F             POP      {R0-R4,PC}
    469          
    470          /**
    471            * @brief I2C1 Initialization Function
    472            * @param None
    473            * @retval None
    474            */

   \                                 In section .text, align 2, keep-with-next
    475          static void MX_I2C1_Init(void)
    476          {
   \                     MX_I2C1_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    477          
    478            /* USER CODE BEGIN I2C1_Init 0 */
    479          
    480            /* USER CODE END I2C1_Init 0 */
    481          
    482            /* USER CODE BEGIN I2C1_Init 1 */
    483          
    484            /* USER CODE END I2C1_Init 1 */
    485              
    486            hi2c1.Instance = I2C1;
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable14_14
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable14_15
   \        0xA   0x6001             STR      R1,[R0, #+0]
    487            hi2c1.Init.ClockSpeed = 100000;
   \        0xC   0x.... 0x....      LDR.W    R1,??DataTable14_16
   \       0x10   0x6041             STR      R1,[R0, #+4]
    488            hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x6081             STR      R1,[R0, #+8]
    489            hi2c1.Init.OwnAddress1 = 0;
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0x60C1             STR      R1,[R0, #+12]
    490            hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
   \       0x1A   0xF44F 0x4180      MOV      R1,#+16384
   \       0x1E   0x6101             STR      R1,[R0, #+16]
    491            hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x6141             STR      R1,[R0, #+20]
    492            hi2c1.Init.OwnAddress2 = 0;
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x6181             STR      R1,[R0, #+24]
    493            hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x61C1             STR      R1,[R0, #+28]
    494            hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x6201             STR      R1,[R0, #+32]
    495            if (HAL_I2C_Init(&hi2c1) != HAL_OK)
   \       0x30   0x.... 0x....      BL       HAL_I2C_Init
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD001             BEQ.N    ??MX_I2C1_Init_0
    496            {
    497              Error_Handler();
   \       0x38   0x.... 0x....      BL       Error_Handler
    498            }
    499            /* USER CODE BEGIN I2C1_Init 2 */
    500          
    501            /* USER CODE END I2C1_Init 2 */
    502          
    503          }
   \                     ??MX_I2C1_Init_0: (+1)
   \       0x3C   0xBD01             POP      {R0,PC}
    504          
    505          /**
    506            * @brief I2C3 Initialization Function
    507            * @param None
    508            * @retval None
    509            */

   \                                 In section .text, align 2, keep-with-next
    510          static void MX_I2C3_Init(void)
    511          {
   \                     MX_I2C3_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    512          
    513            /* USER CODE BEGIN I2C3_Init 0 */
    514          
    515            /* USER CODE END I2C3_Init 0 */
    516          
    517            /* USER CODE BEGIN I2C3_Init 1 */
    518          
    519            /* USER CODE END I2C3_Init 1 */
    520            hi2c3.Instance = I2C3;
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable14_17
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable14_18
   \        0xA   0x6001             STR      R1,[R0, #+0]
    521            hi2c3.Init.ClockSpeed = 400000;
   \        0xC   0x.... 0x....      LDR.W    R1,??DataTable14_19
   \       0x10   0x6041             STR      R1,[R0, #+4]
    522            hi2c3.Init.DutyCycle = I2C_DUTYCYCLE_2;
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x6081             STR      R1,[R0, #+8]
    523            hi2c3.Init.OwnAddress1 = 0;
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0x60C1             STR      R1,[R0, #+12]
    524            hi2c3.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
   \       0x1A   0xF44F 0x4180      MOV      R1,#+16384
   \       0x1E   0x6101             STR      R1,[R0, #+16]
    525            hi2c3.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x6141             STR      R1,[R0, #+20]
    526            hi2c3.Init.OwnAddress2 = 0;
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x6181             STR      R1,[R0, #+24]
    527            hi2c3.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x61C1             STR      R1,[R0, #+28]
    528            hi2c3.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x6201             STR      R1,[R0, #+32]
    529            if (HAL_I2C_Init(&hi2c3) != HAL_OK)
   \       0x30   0x.... 0x....      BL       HAL_I2C_Init
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD001             BEQ.N    ??MX_I2C3_Init_0
    530            {
    531              Error_Handler();
   \       0x38   0x.... 0x....      BL       Error_Handler
    532            }
    533            /* USER CODE BEGIN I2C3_Init 2 */
    534          
    535            /* USER CODE END I2C3_Init 2 */
    536          
    537          }
   \                     ??MX_I2C3_Init_0: (+1)
   \       0x3C   0xBD01             POP      {R0,PC}
    538          
    539          /**
    540            * @brief I2S3 Initialization Function
    541            * @param None
    542            * @retval None
    543            */

   \                                 In section .text, align 2, keep-with-next
    544          static void MX_I2S3_Init(void)
    545          {
   \                     MX_I2S3_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    546          
    547            /* USER CODE BEGIN I2S3_Init 0 */
    548          
    549            /* USER CODE END I2S3_Init 0 */
    550          
    551            /* USER CODE BEGIN I2S3_Init 1 */
    552          
    553            /* USER CODE END I2S3_Init 1 */
    554            hi2s3.Instance = SPI3;
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable14_20
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable14_21
   \        0xA   0x6001             STR      R1,[R0, #+0]
    555            hi2s3.Init.Mode = I2S_MODE_MASTER_TX;
   \        0xC   0xF44F 0x7100      MOV      R1,#+512
   \       0x10   0x6041             STR      R1,[R0, #+4]
    556            hi2s3.Init.Standard = I2S_STANDARD_PCM_SHORT;
   \       0x12   0x2130             MOVS     R1,#+48
   \       0x14   0x6081             STR      R1,[R0, #+8]
    557            hi2s3.Init.DataFormat = I2S_DATAFORMAT_16B_EXTENDED;
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0x60C1             STR      R1,[R0, #+12]
    558            hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_DISABLE;
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0x6101             STR      R1,[R0, #+16]
    559            hi2s3.Init.AudioFreq = I2S_AUDIOFREQ_8K;
   \       0x1E   0xF44F 0x51FA      MOV      R1,#+8000
   \       0x22   0x6141             STR      R1,[R0, #+20]
    560            hi2s3.Init.CPOL = I2S_CPOL_LOW;
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x6181             STR      R1,[R0, #+24]
    561            hi2s3.Init.ClockSource = I2S_CLOCK_PLL;
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x61C1             STR      R1,[R0, #+28]
    562            hi2s3.Init.FullDuplexMode = I2S_FULLDUPLEXMODE_ENABLE;
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0x6201             STR      R1,[R0, #+32]
    563            if (HAL_I2S_Init(&hi2s3) != HAL_OK)
   \       0x30   0x.... 0x....      BL       HAL_I2S_Init
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD001             BEQ.N    ??MX_I2S3_Init_0
    564            {
    565              Error_Handler();
   \       0x38   0x.... 0x....      BL       Error_Handler
    566            }
    567            /* USER CODE BEGIN I2S3_Init 2 */
    568          
    569            /* USER CODE END I2S3_Init 2 */
    570          
    571          }
   \                     ??MX_I2S3_Init_0: (+1)
   \       0x3C   0xBD01             POP      {R0,PC}
    572          
    573          /**
    574            * @brief IWDG Initialization Function
    575            * @param None
    576            * @retval None
    577            */

   \                                 In section .text, align 2, keep-with-next
    578          static void MX_IWDG_Init(void)
    579          {
   \                     MX_IWDG_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    580          
    581            /* USER CODE BEGIN IWDG_Init 0 */
    582          
    583          	//	32 KHz
    584          	//	1 / 32000 X 32 X 4000 = 4 sec
    585          	//	1 / 32000 X 64 X 4000 = 8 sec
    586          	//	1 / 32000 X 128 X 4000 = 16 sec
    587          	//	1 / 32000 X 256 X 4000 = 32 sec
    588          
    589            /* USER CODE END IWDG_Init 0 */
    590          
    591            /* USER CODE BEGIN IWDG_Init 1 */
    592          
    593            /* USER CODE END IWDG_Init 1 */
    594            hiwdg.Instance = IWDG;
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable14_22
   \        0xA   0x6001             STR      R1,[R0, #+0]
    595            hiwdg.Init.Prescaler = IWDG_PRESCALER_128;
   \        0xC   0x2105             MOVS     R1,#+5
   \        0xE   0x6041             STR      R1,[R0, #+4]
    596            hiwdg.Init.Reload = 4000;
   \       0x10   0xF44F 0x617A      MOV      R1,#+4000
   \       0x14   0x6081             STR      R1,[R0, #+8]
    597            if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
   \       0x16   0x.... 0x....      BL       HAL_IWDG_Init
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD001             BEQ.N    ??MX_IWDG_Init_0
    598            {
    599              Error_Handler();
   \       0x1E   0x.... 0x....      BL       Error_Handler
    600            }
    601            /* USER CODE BEGIN IWDG_Init 2 */
    602          
    603            /* USER CODE END IWDG_Init 2 */
    604          
    605          }
   \                     ??MX_IWDG_Init_0: (+1)
   \       0x22   0xBD01             POP      {R0,PC}
    606          
    607          /**
    608            * @brief SPI1 Initialization Function
    609            * @param None
    610            * @retval None
    611            */

   \                                 In section .text, align 2, keep-with-next
    612          static void MX_SPI1_Init(void)
    613          {
   \                     MX_SPI1_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    614          
    615            /* USER CODE BEGIN SPI1_Init 0 */
    616          
    617            /* USER CODE END SPI1_Init 0 */
    618          
    619            /* USER CODE BEGIN SPI1_Init 1 */
    620          
    621            /* USER CODE END SPI1_Init 1 */
    622            /* SPI1 parameter configuration*/
    623            hspi1.Instance = SPI1;
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable14_23
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable14_24
   \        0xA   0x6001             STR      R1,[R0, #+0]
    624            hspi1.Init.Mode = SPI_MODE_MASTER;
   \        0xC   0xF44F 0x7182      MOV      R1,#+260
   \       0x10   0x6041             STR      R1,[R0, #+4]
    625            hspi1.Init.Direction = SPI_DIRECTION_2LINES;
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x6081             STR      R1,[R0, #+8]
    626            hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0x60C1             STR      R1,[R0, #+12]
    627            hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0x6101             STR      R1,[R0, #+16]
    628            hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
   \       0x1E   0x2100             MOVS     R1,#+0
   \       0x20   0x6141             STR      R1,[R0, #+20]
    629            hspi1.Init.NSS = SPI_NSS_SOFT;
   \       0x22   0xF44F 0x7100      MOV      R1,#+512
   \       0x26   0x6181             STR      R1,[R0, #+24]
    630            hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
   \       0x28   0x2110             MOVS     R1,#+16
   \       0x2A   0x61C1             STR      R1,[R0, #+28]
    631            hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x6201             STR      R1,[R0, #+32]
    632            hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x6241             STR      R1,[R0, #+36]
    633            hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x6281             STR      R1,[R0, #+40]
    634            hspi1.Init.CRCPolynomial = 10;
   \       0x38   0x210A             MOVS     R1,#+10
   \       0x3A   0x62C1             STR      R1,[R0, #+44]
    635            if (HAL_SPI_Init(&hspi1) != HAL_OK)
   \       0x3C   0x.... 0x....      BL       HAL_SPI_Init
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD001             BEQ.N    ??MX_SPI1_Init_0
    636            {
    637              Error_Handler();
   \       0x44   0x.... 0x....      BL       Error_Handler
    638            }
    639            /* USER CODE BEGIN SPI1_Init 2 */
    640          
    641            /* USER CODE END SPI1_Init 2 */
    642          
    643          }
   \                     ??MX_SPI1_Init_0: (+1)
   \       0x48   0xBD01             POP      {R0,PC}
    644          
    645          /**
    646            * @brief SPI2 Initialization Function
    647            * @param None
    648            * @retval None
    649            */

   \                                 In section .text, align 2, keep-with-next
    650          static void MX_SPI2_Init(void)
    651          {
   \                     MX_SPI2_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    652          
    653            /* USER CODE BEGIN SPI2_Init 0 */
    654          
    655            /* USER CODE END SPI2_Init 0 */
    656          
    657            /* USER CODE BEGIN SPI2_Init 1 */
    658          
    659            /* USER CODE END SPI2_Init 1 */
    660            /* SPI2 parameter configuration*/
    661            hspi2.Instance = SPI2;
   \        0x2   0x.... 0x....      LDR.W    R0,??DataTable14_25
   \        0x6   0x.... 0x....      LDR.W    R1,??DataTable14_26
   \        0xA   0x6001             STR      R1,[R0, #+0]
    662            hspi2.Init.Mode = SPI_MODE_MASTER;
   \        0xC   0xF44F 0x7182      MOV      R1,#+260
   \       0x10   0x6041             STR      R1,[R0, #+4]
    663            hspi2.Init.Direction = SPI_DIRECTION_2LINES;
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x6081             STR      R1,[R0, #+8]
    664            hspi2.Init.DataSize = SPI_DATASIZE_16BIT;
   \       0x16   0xF44F 0x6100      MOV      R1,#+2048
   \       0x1A   0x60C1             STR      R1,[R0, #+12]
    665            hspi2.Init.CLKPolarity = SPI_POLARITY_HIGH;
   \       0x1C   0x2102             MOVS     R1,#+2
   \       0x1E   0x6101             STR      R1,[R0, #+16]
    666            hspi2.Init.CLKPhase = SPI_PHASE_2EDGE;
   \       0x20   0x2101             MOVS     R1,#+1
   \       0x22   0x6141             STR      R1,[R0, #+20]
    667            hspi2.Init.NSS = SPI_NSS_SOFT;
   \       0x24   0xF44F 0x7100      MOV      R1,#+512
   \       0x28   0x6181             STR      R1,[R0, #+24]
    668            hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_64;
   \       0x2A   0x2128             MOVS     R1,#+40
   \       0x2C   0x61C1             STR      R1,[R0, #+28]
    669            hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
   \       0x2E   0x2100             MOVS     R1,#+0
   \       0x30   0x6201             STR      R1,[R0, #+32]
    670            hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x6241             STR      R1,[R0, #+36]
    671            hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
   \       0x36   0x2100             MOVS     R1,#+0
   \       0x38   0x6281             STR      R1,[R0, #+40]
    672            hspi2.Init.CRCPolynomial = 10;
   \       0x3A   0x210A             MOVS     R1,#+10
   \       0x3C   0x62C1             STR      R1,[R0, #+44]
    673            if (HAL_SPI_Init(&hspi2) != HAL_OK)
   \       0x3E   0x.... 0x....      BL       HAL_SPI_Init
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD001             BEQ.N    ??MX_SPI2_Init_0
    674            {
    675              Error_Handler();
   \       0x46   0x.... 0x....      BL       Error_Handler
    676            }
    677            /* USER CODE BEGIN SPI2_Init 2 */
    678          
    679            /* USER CODE END SPI2_Init 2 */
    680          
    681          }
   \                     ??MX_SPI2_Init_0: (+1)
   \       0x4A   0xBD01             POP      {R0,PC}
    682          
    683          /**
    684            * @brief TIM3 Initialization Function
    685            * @param None
    686            * @retval None
    687            */

   \                                 In section .text, align 2, keep-with-next
    688          static void MX_TIM3_Init(void)
    689          {
   \                     MX_TIM3_Init: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0xB089             SUB      SP,SP,#+36
   \        0x4   0x2208             MOVS     R2,#+8
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x4668             MOV      R0,SP
   \        0xA   0x.... 0x....      BL       memset
   \        0xE   0x221C             MOVS     R2,#+28
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0xA802             ADD      R0,SP,#+8
   \       0x14   0x.... 0x....      BL       memset
    690          
    691            /* USER CODE BEGIN TIM3_Init 0 */
    692          
    693              //  72000000 / 18 / 2 = 2000000 ( 2MHz )
    694              //  72000000 / 3 / 2 = 12000000 ( 12MHz ) - MCLK ( MAX9860+ )
    695          
    696            /* USER CODE END TIM3_Init 0 */
    697          
    698            TIM_MasterConfigTypeDef sMasterConfig = {0};
    699            TIM_OC_InitTypeDef sConfigOC = {0};
    700          
    701            /* USER CODE BEGIN TIM3_Init 1 */
    702          
    703            /* USER CODE END TIM3_Init 1 */
    704            htim3.Instance = TIM3;
   \       0x18   0x....             LDR.N    R4,??DataTable14_3
   \       0x1A   0x....             LDR.N    R0,??DataTable14_27
   \       0x1C   0x6020             STR      R0,[R4, #+0]
    705            htim3.Init.Prescaler = 3-1;
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0x6060             STR      R0,[R4, #+4]
    706            htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x60A0             STR      R0,[R4, #+8]
    707            htim3.Init.Period = 2-1;
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0x60E0             STR      R0,[R4, #+12]
    708            htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x6120             STR      R0,[R4, #+16]
    709            htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x61A0             STR      R0,[R4, #+24]
    710            if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       HAL_TIM_PWM_Init
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD001             BEQ.N    ??MX_TIM3_Init_0
    711            {
    712              Error_Handler();
   \       0x3C   0x.... 0x....      BL       Error_Handler
    713            }
    714            sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
   \                     ??MX_TIM3_Init_0: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x9000             STR      R0,[SP, #+0]
    715            sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x9001             STR      R0,[SP, #+4]
    716            if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
   \       0x48   0x4669             MOV      R1,SP
   \       0x4A   0x0020             MOVS     R0,R4
   \       0x4C   0x.... 0x....      BL       HAL_TIMEx_MasterConfigSynchronization
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD001             BEQ.N    ??MX_TIM3_Init_1
    717            {
    718              Error_Handler();
   \       0x54   0x.... 0x....      BL       Error_Handler
    719            }
    720            sConfigOC.OCMode = TIM_OCMODE_PWM1;
   \                     ??MX_TIM3_Init_1: (+1)
   \       0x58   0x2060             MOVS     R0,#+96
   \       0x5A   0x9002             STR      R0,[SP, #+8]
    721            sConfigOC.Pulse = 1;
   \       0x5C   0x2001             MOVS     R0,#+1
   \       0x5E   0x9003             STR      R0,[SP, #+12]
    722            sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0x9004             STR      R0,[SP, #+16]
    723            sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x9006             STR      R0,[SP, #+24]
    724            if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
   \       0x68   0x2204             MOVS     R2,#+4
   \       0x6A   0xA902             ADD      R1,SP,#+8
   \       0x6C   0x0020             MOVS     R0,R4
   \       0x6E   0x.... 0x....      BL       HAL_TIM_PWM_ConfigChannel
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD001             BEQ.N    ??MX_TIM3_Init_2
    725            {
    726              Error_Handler();
   \       0x76   0x.... 0x....      BL       Error_Handler
    727            }
    728            /* USER CODE BEGIN TIM3_Init 2 */
    729          
    730            /* USER CODE END TIM3_Init 2 */
    731            HAL_TIM_MspPostInit(&htim3);
   \                     ??MX_TIM3_Init_2: (+1)
   \       0x7A   0x0020             MOVS     R0,R4
   \       0x7C   0x.... 0x....      BL       HAL_TIM_MspPostInit
    732          
    733          }
   \       0x80   0xB00A             ADD      SP,SP,#+40
   \       0x82   0xBD10             POP      {R4,PC}
    734          
    735          /**
    736            * @brief USART1 Initialization Function
    737            * @param None
    738            * @retval None
    739            */
    740          static void MX_USART1_UART_Init(void)
                             ^
Warning[Pe177]: function "MX_USART1_UART_Init" was declared but never
          referenced
    741          {
    742          
    743            /* USER CODE BEGIN USART1_Init 0 */
    744          
    745            /* USER CODE END USART1_Init 0 */
    746          
    747            /* USER CODE BEGIN USART1_Init 1 */
    748          
    749            /* USER CODE END USART1_Init 1 */
    750            huart1.Instance = USART1;
    751            huart1.Init.BaudRate = 115200;
    752            huart1.Init.WordLength = UART_WORDLENGTH_8B;
    753            huart1.Init.StopBits = UART_STOPBITS_1;
    754            huart1.Init.Parity = UART_PARITY_NONE;
    755            huart1.Init.Mode = UART_MODE_TX_RX;
    756            huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    757            huart1.Init.OverSampling = UART_OVERSAMPLING_16;
    758            if (HAL_UART_Init(&huart1) != HAL_OK)
    759            {
    760              Error_Handler();
    761            }
    762            /* USER CODE BEGIN USART1_Init 2 */
    763          
    764            /* USER CODE END USART1_Init 2 */
    765          
    766          }
    767          
    768          /**
    769            * @brief USART2 Initialization Function
    770            * @param None
    771            * @retval None
    772            */

   \                                 In section .text, align 2, keep-with-next
    773          static void MX_USART2_UART_Init(void)
    774          {
   \                     MX_USART2_UART_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    775          
    776            /* USER CODE BEGIN USART2_Init 0 */
    777          
    778            /* USER CODE END USART2_Init 0 */
    779          
    780            /* USER CODE BEGIN USART2_Init 1 */
    781          
    782            /* USER CODE END USART2_Init 1 */
    783            huart2.Instance = USART2;
   \        0x2   0x....             LDR.N    R0,??DataTable14_4
   \        0x4   0x....             LDR.N    R1,??DataTable14_28
   \        0x6   0x6001             STR      R1,[R0, #+0]
    784            huart2.Init.BaudRate = 115200;
   \        0x8   0xF45F 0x31E1      MOVS     R1,#+115200
   \        0xC   0x6041             STR      R1,[R0, #+4]
    785            huart2.Init.WordLength = UART_WORDLENGTH_8B;
   \        0xE   0x2100             MOVS     R1,#+0
   \       0x10   0x6081             STR      R1,[R0, #+8]
    786            huart2.Init.StopBits = UART_STOPBITS_1;
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x60C1             STR      R1,[R0, #+12]
    787            huart2.Init.Parity = UART_PARITY_NONE;
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0x6101             STR      R1,[R0, #+16]
    788            huart2.Init.Mode = UART_MODE_TX_RX;
   \       0x1A   0x210C             MOVS     R1,#+12
   \       0x1C   0x6141             STR      R1,[R0, #+20]
    789            huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
   \       0x1E   0x2100             MOVS     R1,#+0
   \       0x20   0x6181             STR      R1,[R0, #+24]
    790            huart2.Init.OverSampling = UART_OVERSAMPLING_16;
   \       0x22   0x2100             MOVS     R1,#+0
   \       0x24   0x61C1             STR      R1,[R0, #+28]
    791            if (HAL_UART_Init(&huart2) != HAL_OK)
   \       0x26   0x.... 0x....      BL       HAL_UART_Init
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD001             BEQ.N    ??MX_USART2_UART_Init_0
    792            {
    793              Error_Handler();
   \       0x2E   0x.... 0x....      BL       Error_Handler
    794            }
    795            /* USER CODE BEGIN USART2_Init 2 */
    796          
    797            /* USER CODE END USART2_Init 2 */
    798          
    799          }
   \                     ??MX_USART2_UART_Init_0: (+1)
   \       0x32   0xBD01             POP      {R0,PC}
    800          
    801          /**
    802            * Enable DMA controller clock
    803            */

   \                                 In section .text, align 2, keep-with-next
    804          static void MX_DMA_Init(void)
    805          {
   \                     MX_DMA_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    806          
    807            /* DMA controller clock enable */
    808            __HAL_RCC_DMA1_CLK_ENABLE();
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x9000             STR      R0,[SP, #+0]
   \        0x6   0x....             LDR.N    R0,??DataTable14_29
   \        0x8   0x6801             LDR      R1,[R0, #+0]
   \        0xA   0xF451 0x1100      ORRS     R1,R1,#0x200000
   \        0xE   0x6001             STR      R1,[R0, #+0]
   \       0x10   0x6801             LDR      R1,[R0, #+0]
   \       0x12   0xF411 0x1100      ANDS     R1,R1,#0x200000
   \       0x16   0x9100             STR      R1,[SP, #+0]
   \       0x18   0x9900             LDR      R1,[SP, #+0]
    809            __HAL_RCC_DMA2_CLK_ENABLE();
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0x9100             STR      R1,[SP, #+0]
   \       0x1E   0x6801             LDR      R1,[R0, #+0]
   \       0x20   0xF451 0x0180      ORRS     R1,R1,#0x400000
   \       0x24   0x6001             STR      R1,[R0, #+0]
   \       0x26   0x6800             LDR      R0,[R0, #+0]
   \       0x28   0xF410 0x0080      ANDS     R0,R0,#0x400000
   \       0x2C   0x9000             STR      R0,[SP, #+0]
   \       0x2E   0x9800             LDR      R0,[SP, #+0]
    810          
    811            /* DMA interrupt init */
    812            /* DMA1_Stream0_IRQn interrupt configuration */
    813            HAL_NVIC_SetPriority(DMA1_Stream0_IRQn, 0, 0);
   \       0x30   0x2200             MOVS     R2,#+0
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x200B             MOVS     R0,#+11
   \       0x36   0x.... 0x....      BL       HAL_NVIC_SetPriority
    814            HAL_NVIC_EnableIRQ(DMA1_Stream0_IRQn);
   \       0x3A   0x200B             MOVS     R0,#+11
   \       0x3C   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    815            /* DMA1_Stream5_IRQn interrupt configuration */
    816            HAL_NVIC_SetPriority(DMA1_Stream5_IRQn, 0, 0);
   \       0x40   0x2200             MOVS     R2,#+0
   \       0x42   0x2100             MOVS     R1,#+0
   \       0x44   0x2010             MOVS     R0,#+16
   \       0x46   0x.... 0x....      BL       HAL_NVIC_SetPriority
    817            HAL_NVIC_EnableIRQ(DMA1_Stream5_IRQn);
   \       0x4A   0x2010             MOVS     R0,#+16
   \       0x4C   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    818            /* DMA2_Stream0_IRQn interrupt configuration */
    819            HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);
   \       0x50   0x2200             MOVS     R2,#+0
   \       0x52   0x2100             MOVS     R1,#+0
   \       0x54   0x2038             MOVS     R0,#+56
   \       0x56   0x.... 0x....      BL       HAL_NVIC_SetPriority
    820            HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
   \       0x5A   0x2038             MOVS     R0,#+56
   \       0x5C   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    821            /* DMA2_Stream3_IRQn interrupt configuration */
    822            HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 0, 0);
   \       0x60   0x2200             MOVS     R2,#+0
   \       0x62   0x2100             MOVS     R1,#+0
   \       0x64   0x203B             MOVS     R0,#+59
   \       0x66   0x.... 0x....      BL       HAL_NVIC_SetPriority
    823            HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
   \       0x6A   0x203B             MOVS     R0,#+59
   \       0x6C   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    824          
    825          }
   \       0x70   0xBD01             POP      {R0,PC}
    826          
    827          /**
    828            * @brief GPIO Initialization Function
    829            * @param None
    830            * @retval None
    831            */

   \                                 In section .text, align 2, keep-with-next
    832          static void MX_GPIO_Init(void)
    833          {
   \                     MX_GPIO_Init: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0xB086             SUB      SP,SP,#+24
   \        0x6   0x2214             MOVS     R2,#+20
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0x.... 0x....      BL       memset
    834            GPIO_InitTypeDef GPIO_InitStruct = {0};
    835          
    836            /* GPIO Ports Clock Enable */
    837            __HAL_RCC_GPIOE_CLK_ENABLE();
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x9005             STR      R0,[SP, #+20]
   \       0x14   0x....             LDR.N    R0,??DataTable14_29
   \       0x16   0x6801             LDR      R1,[R0, #+0]
   \       0x18   0xF051 0x0110      ORRS     R1,R1,#0x10
   \       0x1C   0x6001             STR      R1,[R0, #+0]
   \       0x1E   0x6801             LDR      R1,[R0, #+0]
   \       0x20   0xF011 0x0110      ANDS     R1,R1,#0x10
   \       0x24   0x9105             STR      R1,[SP, #+20]
   \       0x26   0x9905             LDR      R1,[SP, #+20]
    838            __HAL_RCC_GPIOC_CLK_ENABLE();
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x9105             STR      R1,[SP, #+20]
   \       0x2C   0x6801             LDR      R1,[R0, #+0]
   \       0x2E   0xF051 0x0104      ORRS     R1,R1,#0x4
   \       0x32   0x6001             STR      R1,[R0, #+0]
   \       0x34   0x6801             LDR      R1,[R0, #+0]
   \       0x36   0xF011 0x0104      ANDS     R1,R1,#0x4
   \       0x3A   0x9105             STR      R1,[SP, #+20]
   \       0x3C   0x9905             LDR      R1,[SP, #+20]
    839            __HAL_RCC_GPIOH_CLK_ENABLE();
   \       0x3E   0x2100             MOVS     R1,#+0
   \       0x40   0x9105             STR      R1,[SP, #+20]
   \       0x42   0x6801             LDR      R1,[R0, #+0]
   \       0x44   0xF051 0x0180      ORRS     R1,R1,#0x80
   \       0x48   0x6001             STR      R1,[R0, #+0]
   \       0x4A   0x6801             LDR      R1,[R0, #+0]
   \       0x4C   0xF011 0x0180      ANDS     R1,R1,#0x80
   \       0x50   0x9105             STR      R1,[SP, #+20]
   \       0x52   0x9905             LDR      R1,[SP, #+20]
    840            __HAL_RCC_GPIOA_CLK_ENABLE();
   \       0x54   0x2100             MOVS     R1,#+0
   \       0x56   0x9105             STR      R1,[SP, #+20]
   \       0x58   0x6801             LDR      R1,[R0, #+0]
   \       0x5A   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x5E   0x6001             STR      R1,[R0, #+0]
   \       0x60   0x6801             LDR      R1,[R0, #+0]
   \       0x62   0xF011 0x0101      ANDS     R1,R1,#0x1
   \       0x66   0x9105             STR      R1,[SP, #+20]
   \       0x68   0x9905             LDR      R1,[SP, #+20]
    841            __HAL_RCC_GPIOB_CLK_ENABLE();
   \       0x6A   0x2100             MOVS     R1,#+0
   \       0x6C   0x9105             STR      R1,[SP, #+20]
   \       0x6E   0x6801             LDR      R1,[R0, #+0]
   \       0x70   0xF051 0x0102      ORRS     R1,R1,#0x2
   \       0x74   0x6001             STR      R1,[R0, #+0]
   \       0x76   0x6801             LDR      R1,[R0, #+0]
   \       0x78   0xF011 0x0102      ANDS     R1,R1,#0x2
   \       0x7C   0x9105             STR      R1,[SP, #+20]
   \       0x7E   0x9905             LDR      R1,[SP, #+20]
    842            __HAL_RCC_GPIOD_CLK_ENABLE();
   \       0x80   0x2100             MOVS     R1,#+0
   \       0x82   0x9105             STR      R1,[SP, #+20]
   \       0x84   0x6801             LDR      R1,[R0, #+0]
   \       0x86   0xF051 0x0108      ORRS     R1,R1,#0x8
   \       0x8A   0x6001             STR      R1,[R0, #+0]
   \       0x8C   0x6800             LDR      R0,[R0, #+0]
   \       0x8E   0xF010 0x0008      ANDS     R0,R0,#0x8
   \       0x92   0x9005             STR      R0,[SP, #+20]
   \       0x94   0x9805             LDR      R0,[SP, #+20]
    843          
    844            /*Configure GPIO pin Output Level */
    845            HAL_GPIO_WritePin(GPIOE, PWR_RF_Pin|PWR_AUDIO_Pin, GPIO_PIN_SET);
   \       0x96   0x....             LDR.N    R4,??DataTable14_30
   \       0x98   0x2201             MOVS     R2,#+1
   \       0x9A   0x210C             MOVS     R1,#+12
   \       0x9C   0x0020             MOVS     R0,R4
   \       0x9E   0x.... 0x....      BL       HAL_GPIO_WritePin
    846          
    847            /*Configure GPIO pin Output Level */
    848            HAL_GPIO_WritePin(GPIOE, SPK_ON_Pin|STANDBY_Pin|AUDIO_ON_Pin|LIGHT_ON_Pin
    849                                    |GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14, GPIO_PIN_RESET);
   \       0xA2   0x2200             MOVS     R2,#+0
   \       0xA4   0xF647 0x31A0      MOVW     R1,#+31648
   \       0xA8   0x0020             MOVS     R0,R4
   \       0xAA   0x.... 0x....      BL       HAL_GPIO_WritePin
    850          
    851            /*Configure GPIO pin Output Level */
    852            HAL_GPIO_WritePin(GPIOC, USB_ID_Pin|TRN_RST_Pin, GPIO_PIN_RESET);
   \       0xAE   0xF248 0x0520      MOVW     R5,#+32800
   \       0xB2   0x....             LDR.N    R6,??DataTable14
   \       0xB4   0x2200             MOVS     R2,#+0
   \       0xB6   0x0029             MOVS     R1,R5
   \       0xB8   0x0030             MOVS     R0,R6
   \       0xBA   0x.... 0x....      BL       HAL_GPIO_WritePin
    853          
    854            /*Configure GPIO pin Output Level */
    855            HAL_GPIO_WritePin(SPI_CSN_GPIO_Port, SPI_CSN_Pin, GPIO_PIN_SET);
   \       0xBE   0x....             LDR.N    R7,??DataTable14_31
   \       0xC0   0x2201             MOVS     R2,#+1
   \       0xC2   0x2110             MOVS     R1,#+16
   \       0xC4   0x0038             MOVS     R0,R7
   \       0xC6   0x.... 0x....      BL       HAL_GPIO_WritePin
    856          
    857            /*Configure GPIO pin Output Level */
    858            HAL_GPIO_WritePin(GPIOB, RX_EN_Pin|RF_TX_Pin|RF_RX_Pin|LED_ON_A_Pin
    859                                    |LED_ON_B_Pin|FLASH_ON_Pin, GPIO_PIN_RESET);
   \       0xCA   0xF246 0x1807      MOVW     R8,#+24839
   \       0xCE   0x.... 0x....      LDR.W    R9,??DataTable14_32
   \       0xD2   0x2200             MOVS     R2,#+0
   \       0xD4   0x4641             MOV      R1,R8
   \       0xD6   0x4648             MOV      R0,R9
   \       0xD8   0x.... 0x....      BL       HAL_GPIO_WritePin
    860          
    861            /*Configure GPIO pin Output Level */
    862            HAL_GPIO_WritePin(SS_GPIO_Port, SS_Pin, GPIO_PIN_SET);
   \       0xDC   0x2201             MOVS     R2,#+1
   \       0xDE   0xF44F 0x5180      MOV      R1,#+4096
   \       0xE2   0x4648             MOV      R0,R9
   \       0xE4   0x.... 0x....      BL       HAL_GPIO_WritePin
    863          
    864            /*Configure GPIO pin Output Level */
    865            HAL_GPIO_WritePin(ON_OFF_EN_GPIO_Port, ON_OFF_EN_Pin, GPIO_PIN_SET);
   \       0xE8   0x.... 0x....      LDR.W    R10,??DataTable14_8
   \       0xEC   0x2201             MOVS     R2,#+1
   \       0xEE   0xF44F 0x6180      MOV      R1,#+1024
   \       0xF2   0x4650             MOV      R0,R10
   \       0xF4   0x.... 0x....      BL       HAL_GPIO_WritePin
    866          
    867            /*Configure GPIO pin Output Level */
    868            HAL_GPIO_WritePin(LED_ST_GPIO_Port, LED_ST_Pin, GPIO_PIN_RESET);
   \       0xF8   0x2200             MOVS     R2,#+0
   \       0xFA   0xF44F 0x4100      MOV      R1,#+32768
   \       0xFE   0x4650             MOV      R0,R10
   \      0x100   0x.... 0x....      BL       HAL_GPIO_WritePin
    869          
    870            /*Configure GPIO pins : PWR_RF_Pin PWR_AUDIO_Pin SPK_ON_Pin STANDBY_Pin
    871                                     AUDIO_ON_Pin LIGHT_ON_Pin PE11 PE12
    872                                     PE13 PE14 */
    873            GPIO_InitStruct.Pin = PWR_RF_Pin|PWR_AUDIO_Pin|SPK_ON_Pin|STANDBY_Pin
    874                                    |AUDIO_ON_Pin|LIGHT_ON_Pin|GPIO_PIN_11|GPIO_PIN_12
    875                                    |GPIO_PIN_13|GPIO_PIN_14;
   \      0x104   0xF647 0x30AC      MOVW     R0,#+31660
   \      0x108   0x9000             STR      R0,[SP, #+0]
    876            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \      0x10A   0x2001             MOVS     R0,#+1
   \      0x10C   0x9001             STR      R0,[SP, #+4]
    877            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \      0x10E   0x2000             MOVS     R0,#+0
   \      0x110   0x9002             STR      R0,[SP, #+8]
    878            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   \      0x112   0x2000             MOVS     R0,#+0
   \      0x114   0x9003             STR      R0,[SP, #+12]
    879            HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   \      0x116   0x4669             MOV      R1,SP
   \      0x118   0x0020             MOVS     R0,R4
   \      0x11A   0x.... 0x....      BL       HAL_GPIO_Init
    880          
    881            /*Configure GPIO pins : GPIO1_Pin OVERRIDE_ON_Pin VDD_3_3V_RF_Pin */
    882            GPIO_InitStruct.Pin = GPIO1_Pin|OVERRIDE_ON_Pin|VDD_3_3V_RF_Pin;
   \      0x11E   0xF240 0x4041      MOVW     R0,#+1089
   \      0x122   0x9000             STR      R0,[SP, #+0]
    883            GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
   \      0x124   0x2000             MOVS     R0,#+0
   \      0x126   0x9001             STR      R0,[SP, #+4]
    884            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \      0x128   0x2000             MOVS     R0,#+0
   \      0x12A   0x9002             STR      R0,[SP, #+8]
    885            HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
   \      0x12C   0x4669             MOV      R1,SP
   \      0x12E   0x0020             MOVS     R0,R4
   \      0x130   0x.... 0x....      BL       HAL_GPIO_Init
    886          
    887            /*Configure GPIO pins : USB_ID_Pin TRN_RST_Pin */
    888            GPIO_InitStruct.Pin = USB_ID_Pin|TRN_RST_Pin;
   \      0x134   0x9500             STR      R5,[SP, #+0]
    889            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \      0x136   0x2001             MOVS     R0,#+1
   \      0x138   0x9001             STR      R0,[SP, #+4]
    890            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \      0x13A   0x2000             MOVS     R0,#+0
   \      0x13C   0x9002             STR      R0,[SP, #+8]
    891            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   \      0x13E   0x2000             MOVS     R0,#+0
   \      0x140   0x9003             STR      R0,[SP, #+12]
    892            HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   \      0x142   0x4669             MOV      R1,SP
   \      0x144   0x0030             MOVS     R0,R6
   \      0x146   0x.... 0x....      BL       HAL_GPIO_Init
    893          
    894            /*Configure GPIO pin : BAT_CHRG_Pin */
    895            GPIO_InitStruct.Pin = BAT_CHRG_Pin;
   \      0x14A   0x2001             MOVS     R0,#+1
   \      0x14C   0x9000             STR      R0,[SP, #+0]
    896            GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
   \      0x14E   0x2000             MOVS     R0,#+0
   \      0x150   0x9001             STR      R0,[SP, #+4]
    897            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \      0x152   0x2000             MOVS     R0,#+0
   \      0x154   0x9002             STR      R0,[SP, #+8]
    898            HAL_GPIO_Init(BAT_CHRG_GPIO_Port, &GPIO_InitStruct);
   \      0x156   0x4669             MOV      R1,SP
   \      0x158   0x0030             MOVS     R0,R6
   \      0x15A   0x.... 0x....      BL       HAL_GPIO_Init
    899          
    900            /*Configure GPIO pin : SPI_CSN_Pin */
    901            GPIO_InitStruct.Pin = SPI_CSN_Pin;
   \      0x15E   0x2010             MOVS     R0,#+16
   \      0x160   0x9000             STR      R0,[SP, #+0]
    902            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \      0x162   0x2001             MOVS     R0,#+1
   \      0x164   0x9001             STR      R0,[SP, #+4]
    903            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \      0x166   0x2000             MOVS     R0,#+0
   \      0x168   0x9002             STR      R0,[SP, #+8]
    904            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
   \      0x16A   0x2002             MOVS     R0,#+2
   \      0x16C   0x9003             STR      R0,[SP, #+12]
    905            HAL_GPIO_Init(SPI_CSN_GPIO_Port, &GPIO_InitStruct);
   \      0x16E   0x4669             MOV      R1,SP
   \      0x170   0x0038             MOVS     R0,R7
   \      0x172   0x.... 0x....      BL       HAL_GPIO_Init
    906          
    907            /*Configure GPIO pin : RF_INT_Pin */
    908            GPIO_InitStruct.Pin = RF_INT_Pin;
   \      0x176   0x2010             MOVS     R0,#+16
   \      0x178   0x9000             STR      R0,[SP, #+0]
    909            GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;
   \      0x17A   0x....             LDR.N    R0,??DataTable14_33
   \      0x17C   0x9001             STR      R0,[SP, #+4]
    910            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \      0x17E   0x2000             MOVS     R0,#+0
   \      0x180   0x9002             STR      R0,[SP, #+8]
    911            HAL_GPIO_Init(RF_INT_GPIO_Port, &GPIO_InitStruct);
   \      0x182   0x4669             MOV      R1,SP
   \      0x184   0x0030             MOVS     R0,R6
   \      0x186   0x.... 0x....      BL       HAL_GPIO_Init
    912          
    913            /*Configure GPIO pins : RX_EN_Pin RF_TX_Pin RF_RX_Pin LED_ON_A_Pin
    914                                     LED_ON_B_Pin FLASH_ON_Pin */
    915            GPIO_InitStruct.Pin = RX_EN_Pin|RF_TX_Pin|RF_RX_Pin|LED_ON_A_Pin
    916                                    |LED_ON_B_Pin|FLASH_ON_Pin;
   \      0x18A   0xF8CD 0x8000      STR      R8,[SP, #+0]
    917            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \      0x18E   0x2001             MOVS     R0,#+1
   \      0x190   0x9001             STR      R0,[SP, #+4]
    918            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \      0x192   0x2000             MOVS     R0,#+0
   \      0x194   0x9002             STR      R0,[SP, #+8]
    919            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   \      0x196   0x2000             MOVS     R0,#+0
   \      0x198   0x9003             STR      R0,[SP, #+12]
    920            HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
   \      0x19A   0x4669             MOV      R1,SP
   \      0x19C   0x4648             MOV      R0,R9
   \      0x19E   0x.... 0x....      BL       HAL_GPIO_Init
    921          
    922            /*Configure GPIO pin : SS_Pin */
    923            GPIO_InitStruct.Pin = SS_Pin;
   \      0x1A2   0xF44F 0x5080      MOV      R0,#+4096
   \      0x1A6   0x9000             STR      R0,[SP, #+0]
    924            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \      0x1A8   0x2001             MOVS     R0,#+1
   \      0x1AA   0x9001             STR      R0,[SP, #+4]
    925            GPIO_InitStruct.Pull = GPIO_PULLUP;
   \      0x1AC   0x2001             MOVS     R0,#+1
   \      0x1AE   0x9002             STR      R0,[SP, #+8]
    926            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
   \      0x1B0   0x2002             MOVS     R0,#+2
   \      0x1B2   0x9003             STR      R0,[SP, #+12]
    927            HAL_GPIO_Init(SS_GPIO_Port, &GPIO_InitStruct);
   \      0x1B4   0x4669             MOV      R1,SP
   \      0x1B6   0x4648             MOV      R0,R9
   \      0x1B8   0x.... 0x....      BL       HAL_GPIO_Init
    928          
    929            /*Configure GPIO pins : ON_OFF_KEY_Pin DOME1_Pin DOME2_Pin DOME3_Pin
    930                                     DOME4_Pin DOME5_Pin DOME6_Pin SOS_KEY_Pin
    931                                     PTT_KEY_Pin */
    932            GPIO_InitStruct.Pin = ON_OFF_KEY_Pin|DOME1_Pin|DOME2_Pin|DOME3_Pin
    933                                    |DOME4_Pin|DOME5_Pin|DOME6_Pin|SOS_KEY_Pin
    934                                    |PTT_KEY_Pin;
   \      0x1BC   0xF240 0x20FF      MOVW     R0,#+767
   \      0x1C0   0x9000             STR      R0,[SP, #+0]
    935            GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
   \      0x1C2   0x2000             MOVS     R0,#+0
   \      0x1C4   0x9001             STR      R0,[SP, #+4]
    936            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \      0x1C6   0x2000             MOVS     R0,#+0
   \      0x1C8   0x9002             STR      R0,[SP, #+8]
    937            HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   \      0x1CA   0x4669             MOV      R1,SP
   \      0x1CC   0x4650             MOV      R0,R10
   \      0x1CE   0x.... 0x....      BL       HAL_GPIO_Init
    938          
    939            /*Configure GPIO pins : ON_OFF_EN_Pin LED_ST_Pin */
    940            GPIO_InitStruct.Pin = ON_OFF_EN_Pin|LED_ST_Pin;
   \      0x1D2   0xF44F 0x4004      MOV      R0,#+33792
   \      0x1D6   0x9000             STR      R0,[SP, #+0]
    941            GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
   \      0x1D8   0x2001             MOVS     R0,#+1
   \      0x1DA   0x9001             STR      R0,[SP, #+4]
    942            GPIO_InitStruct.Pull = GPIO_NOPULL;
   \      0x1DC   0x2000             MOVS     R0,#+0
   \      0x1DE   0x9002             STR      R0,[SP, #+8]
    943            GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
   \      0x1E0   0x2000             MOVS     R0,#+0
   \      0x1E2   0x9003             STR      R0,[SP, #+12]
    944            HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   \      0x1E4   0x4669             MOV      R1,SP
   \      0x1E6   0x4650             MOV      R0,R10
   \      0x1E8   0x.... 0x....      BL       HAL_GPIO_Init
    945          
    946            /* EXTI interrupt init*/
    947            HAL_NVIC_SetPriority(EXTI4_IRQn, 0, 0);
   \      0x1EC   0x2200             MOVS     R2,#+0
   \      0x1EE   0x2100             MOVS     R1,#+0
   \      0x1F0   0x200A             MOVS     R0,#+10
   \      0x1F2   0x.... 0x....      BL       HAL_NVIC_SetPriority
    948            HAL_NVIC_EnableIRQ(EXTI4_IRQn);
   \      0x1F6   0x200A             MOVS     R0,#+10
   \      0x1F8   0x.... 0x....      BL       HAL_NVIC_EnableIRQ
    949          
    950          
    951          }
   \      0x1FC   0xB006             ADD      SP,SP,#+24
   \      0x1FE   0xE8BD 0x87F0      POP      {R4-R10,PC}
    952          
    953          /* USER CODE BEGIN 4 */
    954          
    955          /* USER CODE END 4 */
    956          
    957           /**
    958            * @brief  Period elapsed callback in non blocking mode
    959            * @note   This function is called  when TIM1 interrupt took place, inside
    960            * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
    961            * a global variable "uwTick" used as application time base.
    962            * @param  htim : TIM handle
    963            * @retval None
    964            */
    965          //void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
    966          //{
    967          //  /* USER CODE BEGIN Callback 0 */
    968          //
    969          //  /* USER CODE END Callback 0 */
    970          ////  if (htim->Instance == TIM1) {
    971          ////    HAL_IncTick();
    972          ////  }
    973          //  /* USER CODE BEGIN Callback 1 */
    974          //
    975          //  /* USER CODE END Callback 1 */
    976          //}
    977          
    978          /**
    979            * @brief  This function is executed in case of error occurrence.
    980            * @retval None
    981            */

   \                                 In section .text, align 2, keep-with-next
    982          void Error_Handler(void)
    983          {
    984            /* USER CODE BEGIN Error_Handler_Debug */
    985            /* User can add his own implementation to report the HAL error return state */
    986          
    987            /* USER CODE END Error_Handler_Debug */
    988          }
   \                     Error_Handler: (+1)
   \        0x0   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x4002'0800        DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x....'....        DC32     RF_NIRQ

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x....'....        DC32     hiwdg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0x....'....        DC32     htim3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \        0x0   0x....'....        DC32     huart2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \        0x0   0x....'....        DC32     __iar_Stdout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \        0x0   0x....'....        DC32     `main::nCallTimeCnt`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \        0x0   0x....'....        DC32     `main::nLedTick`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \        0x0   0x4002'0C00        DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \        0x0   0x4002'3840        DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \        0x0   0x4000'7000        DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \        0x0   0x....'....        DC32     hadc1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \        0x0   0x4001'2000        DC32     0x40012000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \        0x0   0x0F00'0001        DC32     0xf000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_14:
   \        0x0   0x....'....        DC32     hi2c1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_15:
   \        0x0   0x4000'5400        DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_16:
   \        0x0   0x0001'86A0        DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_17:
   \        0x0   0x....'....        DC32     hi2c3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_18:
   \        0x0   0x4000'5C00        DC32     0x40005c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_19:
   \        0x0   0x0006'1A80        DC32     0x61a80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_20:
   \        0x0   0x....'....        DC32     hi2s3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_21:
   \        0x0   0x4000'3C00        DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_22:
   \        0x0   0x4000'3000        DC32     0x40003000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_23:
   \        0x0   0x....'....        DC32     hspi1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_24:
   \        0x0   0x4001'3000        DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_25:
   \        0x0   0x....'....        DC32     hspi2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_26:
   \        0x0   0x4000'3800        DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_27:
   \        0x0   0x4000'0400        DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_28:
   \        0x0   0x4000'4400        DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_29:
   \        0x0   0x4002'3830        DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_30:
   \        0x0   0x4002'1000        DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_31:
   \        0x0   0x4002'0000        DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_32:
   \        0x0   0x4002'0400        DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_33:
   \        0x0   0x1031'0000        DC32     0x10310000
    989          
    990          #ifdef  USE_FULL_ASSERT
    991          /**
    992            * @brief  Reports the name of the source file and the source line number
    993            *         where the assert_param error has occurred.
    994            * @param  file: pointer to the source file name
    995            * @param  line: assert_param error line source number
    996            * @retval None
    997            */
    998          void assert_failed(uint8_t *file, uint32_t line)
    999          {
   1000            /* USER CODE BEGIN 6 */
   1001            /* User can add his own implementation to report the file name and line number,
   1002               tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
   1003            /* USER CODE END 6 */
   1004          }
   1005          #endif /* USE_FULL_ASSERT */
   1006          
   1007          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Error_Handler
       8   HAL_GPIO_EXTI_Callback
         8   -> HAL_GPIO_ReadPin
       0   LoopProcMain
      24   MX_ADC1_Init
        24   -> Error_Handler
        24   -> HAL_ADC_ConfigChannel
        24   -> HAL_ADC_Init
        24   -> memset
       8   MX_DMA_Init
         8   -> HAL_NVIC_EnableIRQ
         8   -> HAL_NVIC_SetPriority
      56   MX_GPIO_Init
        56   -> HAL_GPIO_Init
        56   -> HAL_GPIO_WritePin
        56   -> HAL_NVIC_EnableIRQ
        56   -> HAL_NVIC_SetPriority
        56   -> memset
       8   MX_I2C1_Init
         8   -> Error_Handler
         8   -> HAL_I2C_Init
       8   MX_I2C3_Init
         8   -> Error_Handler
         8   -> HAL_I2C_Init
       8   MX_I2S3_Init
         8   -> Error_Handler
         8   -> HAL_I2S_Init
       0   MX_IWDG_Disable
       8   MX_IWDG_Init
         8   -> Error_Handler
         8   -> HAL_IWDG_Init
       8   MX_SPI1_Init
         8   -> Error_Handler
         8   -> HAL_SPI_Init
       8   MX_SPI2_Init
         8   -> Error_Handler
         8   -> HAL_SPI_Init
      48   MX_TIM3_Init
        48   -> Error_Handler
        48   -> HAL_TIMEx_MasterConfigSynchronization
        48   -> HAL_TIM_MspPostInit
        48   -> HAL_TIM_PWM_ConfigChannel
        48   -> HAL_TIM_PWM_Init
        48   -> memset
       8   MX_USART2_UART_Init
         8   -> Error_Handler
         8   -> HAL_UART_Init
      96   SystemClock_Config
        96   -> Error_Handler
        96   -> HAL_RCCEx_PeriphCLKConfig
        96   -> HAL_RCC_ClockConfig
        96   -> HAL_RCC_OscConfig
        96   -> memset
      16   main
        16   -> HAL_GPIO_TogglePin
        16   -> HAL_GetTick
        16   -> HAL_Init
        16   -> HAL_TIMEx_PWMN_Start
        16   -> HAL_TIM_PWM_Start
        16   -> LoopProcKey
        16   -> MX_ADC1_Init
        16   -> MX_DMA_Init
        16   -> MX_GPIO_Init
        16   -> MX_I2C1_Init
        16   -> MX_I2C3_Init
        16   -> MX_I2S3_Init
        16   -> MX_IWDG_Init
        16   -> MX_SPI1_Init
        16   -> MX_SPI2_Init
        16   -> MX_TIM3_Init
        16   -> MX_USART2_UART_Init
        16   -> RFM_main
        16   -> SerialInit
        16   -> SystemClock_Config
        16   -> setbuf
        16   -> setvbuf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_16
       4  ??DataTable14_17
       4  ??DataTable14_18
       4  ??DataTable14_19
       4  ??DataTable14_2
       4  ??DataTable14_20
       4  ??DataTable14_21
       4  ??DataTable14_22
       4  ??DataTable14_23
       4  ??DataTable14_24
       4  ??DataTable14_25
       4  ??DataTable14_26
       4  ??DataTable14_27
       4  ??DataTable14_28
       4  ??DataTable14_29
       4  ??DataTable14_3
       4  ??DataTable14_30
       4  ??DataTable14_31
       4  ??DataTable14_32
       4  ??DataTable14_33
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
       2  Error_Handler
      42  HAL_GPIO_EXTI_Callback
      14  LoopProcMain
     116  MX_ADC1_Init
     114  MX_DMA_Init
     514  MX_GPIO_Init
      62  MX_I2C1_Init
      62  MX_I2C3_Init
      62  MX_I2S3_Init
       2  MX_IWDG_Disable
      36  MX_IWDG_Init
      74  MX_SPI1_Init
      76  MX_SPI2_Init
     132  MX_TIM3_Init
      52  MX_USART2_UART_Init
       1  RF_NIRQ
     208  SystemClock_Config
      72  hadc1
      96  hdma_i2s3_ext_rx
      96  hdma_spi1_rx
      96  hdma_spi1_tx
      96  hdma_spi3_tx
      84  hi2c1
      84  hi2c3
      72  hi2s3
      12  hiwdg
      88  hspi1
      88  hspi2
      64  htim1
      64  htim3
      64  huart1
      64  huart2
     188  main
       4  nCallTimeCnt
       4  nLedTick

 
 1'145 bytes in section .bss
     4 bytes in section .data
 1'892 bytes in section .text
 
 1'892 bytes of CODE memory
 1'149 bytes of DATA memory

Errors: none
Warnings: 19
