###############################################################################
#
#                                                         29/Sep/2022  16:58:06
# IAR ANSI C/C++ Compiler V9.20.3.326/W64 for ARM Functional Safety
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Src\system_stm32f4xx.c
#    Command line      =
#        -f
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\CMSIS\system_stm32f4xx.o.rsp
#        (C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Src\system_stm32f4xx.c -D
#        USE_HAL_DRIVER -D STM32F407xx -lC
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\CMSIS -o
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\CMSIS --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e
#        --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.0 EWARM FS 9.20.3\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/App\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Core/Inc\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Include\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/display\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Library\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.0 EWARM FS 9.20.3\arm\CMSIS\Core\Include\\")
#        --dependencies=n
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\CMSIS\system_stm32f4xx.o.d
#    Locale            =  C
#    List file         =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\CMSIS\system_stm32f4xx.lst
#    Object file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\CMSIS\system_stm32f4xx.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Src\system_stm32f4xx.c
      1          /**
      2            ******************************************************************************
      3            * @file    system_stm32f4xx.c
      4            * @author  MCD Application Team
      5            * @brief   CMSIS Cortex-M4 Device Peripheral Access Layer System Source File.
      6            *
      7            *   This file provides two functions and one global variable to be called from 
      8            *   user application:
      9            *      - SystemInit(): This function is called at startup just after reset and 
     10            *                      before branch to main program. This call is made inside
     11            *                      the "startup_stm32f4xx.s" file.
     12            *
     13            *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used
     14            *                                  by the user application to setup the SysTick 
     15            *                                  timer or configure other parameters.
     16            *                                     
     17            *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must
     18            *                                 be called whenever the core clock is changed
     19            *                                 during program execution.
     20            *
     21            *
     22            ******************************************************************************
     23            * @attention
     24            *
     25            * <h2><center>&copy; COPYRIGHT 2017 STMicroelectronics</center></h2>
     26            *
     27            * Redistribution and use in source and binary forms, with or without modification,
     28            * are permitted provided that the following conditions are met:
     29            *   1. Redistributions of source code must retain the above copyright notice,
     30            *      this list of conditions and the following disclaimer.
     31            *   2. Redistributions in binary form must reproduce the above copyright notice,
     32            *      this list of conditions and the following disclaimer in the documentation
     33            *      and/or other materials provided with the distribution.
     34            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     35            *      may be used to endorse or promote products derived from this software
     36            *      without specific prior written permission.
     37            *
     38            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     39            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     40            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     41            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     42            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     43            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     44            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     45            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     46            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     47            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     48            *
     49            ******************************************************************************
     50            */
     51          
     52          /** @addtogroup CMSIS
     53            * @{
     54            */
     55          
     56          /** @addtogroup stm32f4xx_system
     57            * @{
     58            */  
     59            
     60          /** @addtogroup STM32F4xx_System_Private_Includes
     61            * @{
     62            */
     63          
     64          
     65          #include "stm32f4xx.h"
     66          
     67          #if !defined  (HSE_VALUE) 
     68            #define HSE_VALUE    ((uint32_t)25000000) /*!< Default value of the External oscillator in Hz */
     69          #endif /* HSE_VALUE */
     70          
     71          #if !defined  (HSI_VALUE)
     72            #define HSI_VALUE    ((uint32_t)16000000) /*!< Value of the Internal oscillator in Hz*/
     73          #endif /* HSI_VALUE */
     74          
     75          /**
     76            * @}
     77            */
     78          
     79          /** @addtogroup STM32F4xx_System_Private_TypesDefinitions
     80            * @{
     81            */
     82          
     83          /**
     84            * @}
     85            */
     86          
     87          /** @addtogroup STM32F4xx_System_Private_Defines
     88            * @{
     89            */
     90          
     91          /************************* Miscellaneous Configuration ************************/
     92          /*!< Uncomment the following line if you need to use external SRAM or SDRAM as data memory  */
     93          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)\
     94           || defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
     95           || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx)
     96          /* #define DATA_IN_ExtSRAM */
     97          #endif /* STM32F40xxx || STM32F41xxx || STM32F42xxx || STM32F43xxx || STM32F469xx || STM32F479xx ||\
     98                    STM32F412Zx || STM32F412Vx */
     99           
    100          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
    101           || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
    102          /* #define DATA_IN_ExtSDRAM */
    103          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx ||\
    104                    STM32F479xx */
    105          
    106          /*!< Uncomment the following line if you need to relocate your vector Table in
    107               Internal SRAM. */
    108          /* #define VECT_TAB_SRAM */
    109          #define VECT_TAB_OFFSET  0x20000 /*!< Vector Table base offset field. 
    110                                             This value must be a multiple of 0x200. */
    111          /******************************************************************************/
    112          
    113          /**
    114            * @}
    115            */
    116          
    117          /** @addtogroup STM32F4xx_System_Private_Macros
    118            * @{
    119            */
    120          
    121          /**
    122            * @}
    123            */
    124          
    125          /** @addtogroup STM32F4xx_System_Private_Variables
    126            * @{
    127            */
    128            /* This variable is updated in three ways:
    129                1) by calling CMSIS function SystemCoreClockUpdate()
    130                2) by calling HAL API function HAL_RCC_GetHCLKFreq()
    131                3) each time HAL_RCC_ClockConfig() is called to configure the system clock frequency 
    132                   Note: If you use this function to configure the system clock; then there
    133                         is no need to call the 2 first functions listed above, since SystemCoreClock
    134                         variable is updated automatically.
    135            */

   \                                 In section .data, align 4
    136          uint32_t SystemCoreClock = 16000000;
   \                     SystemCoreClock:
   \        0x0   0x00F4'2400        DC32 16'000'000

   \                                 In section .rodata, align 4
    137          const uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
   \                     AHBPrescTable:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x00 0x00    

   \              0x01 0x02    

   \              0x03 0x04    

   \              0x06 0x07    

   \              0x08 0x09

   \                                 In section .rodata, align 4
    138          const uint8_t APBPrescTable[8]  = {0, 0, 0, 0, 1, 2, 3, 4};
   \                     APBPrescTable:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 1, 2, 3, 4

   \              0x00 0x00    

   \              0x01 0x02    

   \              0x03 0x04
    139          /**
    140            * @}
    141            */
    142          
    143          /** @addtogroup STM32F4xx_System_Private_FunctionPrototypes
    144            * @{
    145            */
    146          
    147          #if defined (DATA_IN_ExtSRAM) || defined (DATA_IN_ExtSDRAM)
    148            static void SystemInit_ExtMemCtl(void); 
    149          #endif /* DATA_IN_ExtSRAM || DATA_IN_ExtSDRAM */
    150          
    151          /**
    152            * @}
    153            */
    154          
    155          /** @addtogroup STM32F4xx_System_Private_Functions
    156            * @{
    157            */
    158          
    159          /**
    160            * @brief  Setup the microcontroller system
    161            *         Initialize the FPU setting, vector table location and External memory 
    162            *         configuration.
    163            * @param  None
    164            * @retval None
    165            */

   \                                 In section .text, align 2, keep-with-next
    166          void SystemInit(void)
    167          {
    168            /* FPU settings ------------------------------------------------------------*/
    169            #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    170              SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
   \                     SystemInit: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable1
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF451 0x0170      ORRS     R1,R1,#0xF00000
   \        0x8   0x6001             STR      R1,[R0, #+0]
    171            #endif
    172          
    173          #if defined (DATA_IN_ExtSRAM) || defined (DATA_IN_ExtSDRAM)
    174            SystemInit_ExtMemCtl(); 
    175          #endif /* DATA_IN_ExtSRAM || DATA_IN_ExtSDRAM */
    176          
    177            /* Configure the Vector Table location add offset address ------------------*/
    178          #ifdef VECT_TAB_SRAM
    179            SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
    180          #else
    181          
    182          //  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
    183          #if		defined(USE_BOOTLOADER)	//	Bootloader	memory Address : 0x08000000
    184           SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
    185          #else							//	Application	memory Address : 0x08020000
    186           SCB->VTOR = (FLASH_BASE | VECT_TAB_OFFSET);//VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
   \        0xA   0x....             LDR.N    R0,??DataTable1_1
   \        0xC   0x....             LDR.N    R1,??DataTable1_2
   \        0xE   0x6008             STR      R0,[R1, #+0]
    187          #endif
    188          
    189          #endif
    190          }
   \       0x10   0x4770             BX       LR
    191          
    192          /**
    193             * @brief  Update SystemCoreClock variable according to Clock Register Values.
    194            *         The SystemCoreClock variable contains the core clock (HCLK), it can
    195            *         be used by the user application to setup the SysTick timer or configure
    196            *         other parameters.
    197            *           
    198            * @note   Each time the core clock (HCLK) changes, this function must be called
    199            *         to update SystemCoreClock variable value. Otherwise, any configuration
    200            *         based on this variable will be incorrect.         
    201            *     
    202            * @note   - The system frequency computed by this function is not the real 
    203            *           frequency in the chip. It is calculated based on the predefined 
    204            *           constant and the selected clock source:
    205            *             
    206            *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)
    207            *                                              
    208            *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)
    209            *                          
    210            *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**) 
    211            *             or HSI_VALUE(*) multiplied/divided by the PLL factors.
    212            *         
    213            *         (*) HSI_VALUE is a constant defined in stm32f4xx_hal_conf.h file (default value
    214            *             16 MHz) but the real value may vary depending on the variations
    215            *             in voltage and temperature.   
    216            *    
    217            *         (**) HSE_VALUE is a constant defined in stm32f4xx_hal_conf.h file (its value
    218            *              depends on the application requirements), user has to ensure that HSE_VALUE
    219            *              is same as the real frequency of the crystal used. Otherwise, this function
    220            *              may have wrong result.
    221            *                
    222            *         - The result of this function could be not correct when using fractional
    223            *           value for HSE crystal.
    224            *     
    225            * @param  None
    226            * @retval None
    227            */

   \                                 In section .text, align 2, keep-with-next
    228          void SystemCoreClockUpdate(void)
    229          {
   \                     SystemCoreClockUpdate: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
    230            uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2302             MOVS     R3,#+2
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x2402             MOVS     R4,#+2
    231            
    232            /* Get SYSCLK source -------------------------------------------------------*/
    233            tmp = RCC->CFGR & RCC_CFGR_SWS;
   \        0xC   0x....             LDR.N    R6,??DataTable1_3
   \        0xE   0x6835             LDR      R5,[R6, #+0]
   \       0x10   0xF015 0x050C      ANDS     R5,R5,#0xC
    234          
    235            switch (tmp)
   \       0x14   0x002F             MOVS     R7,R5
   \       0x16   0x2F00             CMP      R7,#+0
   \       0x18   0xD004             BEQ.N    ??SystemCoreClockUpdate_0
   \       0x1A   0x2F04             CMP      R7,#+4
   \       0x1C   0xD006             BEQ.N    ??SystemCoreClockUpdate_1
   \       0x1E   0x2F08             CMP      R7,#+8
   \       0x20   0xD008             BEQ.N    ??SystemCoreClockUpdate_2
   \       0x22   0xE030             B.N      ??SystemCoreClockUpdate_3
    236            {
    237              case 0x00:  /* HSI used as system clock source */
    238                SystemCoreClock = HSI_VALUE;
   \                     ??SystemCoreClockUpdate_0: (+1)
   \       0x24   0x....             LDR.N    R1,??DataTable1_4
   \       0x26   0x....             LDR.N    R7,??DataTable1_5
   \       0x28   0x6039             STR      R1,[R7, #+0]
    239                break;
   \       0x2A   0xE02F             B.N      ??SystemCoreClockUpdate_4
    240              case 0x04:  /* HSE used as system clock source */
    241                SystemCoreClock = HSE_VALUE;
   \                     ??SystemCoreClockUpdate_1: (+1)
   \       0x2C   0x....             LDR.N    R1,??DataTable1_6
   \       0x2E   0x....             LDR.N    R7,??DataTable1_5
   \       0x30   0x6039             STR      R1,[R7, #+0]
    242                break;
   \       0x32   0xE02B             B.N      ??SystemCoreClockUpdate_4
    243              case 0x08:  /* PLL used as system clock source */
    244          
    245                /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
    246                   SYSCLK = PLL_VCO / PLL_P
    247                   */    
    248                pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
   \                     ??SystemCoreClockUpdate_2: (+1)
   \       0x34   0x....             LDR.N    R7,??DataTable1_7
   \       0x36   0x6839             LDR      R1,[R7, #+0]
   \       0x38   0xF3C1 0x5180      UBFX     R1,R1,#+22,#+1
   \       0x3C   0x0008             MOVS     R0,R1
    249                pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
   \       0x3E   0x6839             LDR      R1,[R7, #+0]
   \       0x40   0xF011 0x013F      ANDS     R1,R1,#0x3F
   \       0x44   0x000C             MOVS     R4,R1
    250                
    251                if (pllsource != 0)
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD009             BEQ.N    ??SystemCoreClockUpdate_5
    252                {
    253                  /* HSE used as PLL clock source */
    254                  pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
   \       0x4A   0x....             LDR.N    R1,??DataTable1_6
   \       0x4C   0xFBB1 0xFCF4      UDIV     R12,R1,R4
   \       0x50   0x6839             LDR      R1,[R7, #+0]
   \       0x52   0xF3C1 0x1188      UBFX     R1,R1,#+6,#+9
   \       0x56   0xFB01 0xFC0C      MUL      R12,R1,R12
   \       0x5A   0x4662             MOV      R2,R12
   \       0x5C   0xE008             B.N      ??SystemCoreClockUpdate_6
    255                }
    256                else
    257                {
    258                  /* HSI used as PLL clock source */
    259                  pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
   \                     ??SystemCoreClockUpdate_5: (+1)
   \       0x5E   0x....             LDR.N    R1,??DataTable1_4
   \       0x60   0xFBB1 0xFCF4      UDIV     R12,R1,R4
   \       0x64   0x6839             LDR      R1,[R7, #+0]
   \       0x66   0xF3C1 0x1188      UBFX     R1,R1,#+6,#+9
   \       0x6A   0xFB01 0xFC0C      MUL      R12,R1,R12
   \       0x6E   0x4662             MOV      R2,R12
    260                }
    261          
    262                pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
   \                     ??SystemCoreClockUpdate_6: (+1)
   \       0x70   0x6839             LDR      R1,[R7, #+0]
   \       0x72   0xF3C1 0x4101      UBFX     R1,R1,#+16,#+2
   \       0x76   0x1C49             ADDS     R1,R1,#+1
   \       0x78   0x0049             LSLS     R1,R1,#+1
   \       0x7A   0x000B             MOVS     R3,R1
    263                SystemCoreClock = pllvco/pllp;
   \       0x7C   0xFBB2 0xF1F3      UDIV     R1,R2,R3
   \       0x80   0x....             LDR.N    R7,??DataTable1_5
   \       0x82   0x6039             STR      R1,[R7, #+0]
    264                break;
   \       0x84   0xE002             B.N      ??SystemCoreClockUpdate_4
    265              default:
    266                SystemCoreClock = HSI_VALUE;
   \                     ??SystemCoreClockUpdate_3: (+1)
   \       0x86   0x....             LDR.N    R1,??DataTable1_4
   \       0x88   0x....             LDR.N    R7,??DataTable1_5
   \       0x8A   0x6039             STR      R1,[R7, #+0]
    267                break;
    268            }
    269            /* Compute HCLK frequency --------------------------------------------------*/
    270            /* Get HCLK prescaler */
    271            tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
   \                     ??SystemCoreClockUpdate_4: (+1)
   \       0x8C   0x....             LDR.N    R1,??DataTable1_8
   \       0x8E   0x6836             LDR      R6,[R6, #+0]
   \       0x90   0xF3C6 0x1603      UBFX     R6,R6,#+4,#+4
   \       0x94   0x5D89             LDRB     R1,[R1, R6]
    272            /* HCLK frequency */
    273            SystemCoreClock >>= tmp;
   \       0x96   0x....             LDR.N    R6,??DataTable1_5
   \       0x98   0x6837             LDR      R7,[R6, #+0]
   \       0x9A   0x40CF             LSRS     R7,R7,R1
   \       0x9C   0x6037             STR      R7,[R6, #+0]
    274          }
   \       0x9E   0xBCF0             POP      {R4-R7}
   \       0xA0   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0xE000'ED88        DC32     0xe000ed88

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x0802'0000        DC32     0x8020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \        0x0   0xE000'ED08        DC32     0xe000ed08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \        0x0   0x4002'3808        DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \        0x0   0x00F4'2400        DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \        0x0   0x01C9'C380        DC32     0x1c9c380

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_7:
   \        0x0   0x4002'3804        DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_8:
   \        0x0   0x....'....        DC32     AHBPrescTable
    275          
    276          #if defined (DATA_IN_ExtSRAM) && defined (DATA_IN_ExtSDRAM)
    277          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
    278           || defined(STM32F469xx) || defined(STM32F479xx)
    279          /**
    280            * @brief  Setup the external memory controller.
    281            *         Called in startup_stm32f4xx.s before jump to main.
    282            *         This function configures the external memories (SRAM/SDRAM)
    283            *         This SRAM/SDRAM will be used as program data memory (including heap and stack).
    284            * @param  None
    285            * @retval None
    286            */
    287          void SystemInit_ExtMemCtl(void)
    288          {
    289            __IO uint32_t tmp = 0x00;
    290          
    291            register uint32_t tmpreg = 0, timeout = 0xFFFF;
    292            register __IO uint32_t index;
    293          
    294            /* Enable GPIOC, GPIOD, GPIOE, GPIOF, GPIOG, GPIOH and GPIOI interface clock */
    295            RCC->AHB1ENR |= 0x000001F8;
    296          
    297            /* Delay after an RCC peripheral clock enabling */
    298            tmp = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);
    299            
    300            /* Connect PDx pins to FMC Alternate function */
    301            GPIOD->AFR[0]  = 0x00CCC0CC;
    302            GPIOD->AFR[1]  = 0xCCCCCCCC;
    303            /* Configure PDx pins in Alternate function mode */  
    304            GPIOD->MODER   = 0xAAAA0A8A;
    305            /* Configure PDx pins speed to 100 MHz */  
    306            GPIOD->OSPEEDR = 0xFFFF0FCF;
    307            /* Configure PDx pins Output type to push-pull */  
    308            GPIOD->OTYPER  = 0x00000000;
    309            /* No pull-up, pull-down for PDx pins */ 
    310            GPIOD->PUPDR   = 0x00000000;
    311          
    312            /* Connect PEx pins to FMC Alternate function */
    313            GPIOE->AFR[0]  = 0xC00CC0CC;
    314            GPIOE->AFR[1]  = 0xCCCCCCCC;
    315            /* Configure PEx pins in Alternate function mode */ 
    316            GPIOE->MODER   = 0xAAAA828A;
    317            /* Configure PEx pins speed to 100 MHz */ 
    318            GPIOE->OSPEEDR = 0xFFFFC3CF;
    319            /* Configure PEx pins Output type to push-pull */  
    320            GPIOE->OTYPER  = 0x00000000;
    321            /* No pull-up, pull-down for PEx pins */ 
    322            GPIOE->PUPDR   = 0x00000000;
    323            
    324            /* Connect PFx pins to FMC Alternate function */
    325            GPIOF->AFR[0]  = 0xCCCCCCCC;
    326            GPIOF->AFR[1]  = 0xCCCCCCCC;
    327            /* Configure PFx pins in Alternate function mode */   
    328            GPIOF->MODER   = 0xAA800AAA;
    329            /* Configure PFx pins speed to 50 MHz */ 
    330            GPIOF->OSPEEDR = 0xAA800AAA;
    331            /* Configure PFx pins Output type to push-pull */  
    332            GPIOF->OTYPER  = 0x00000000;
    333            /* No pull-up, pull-down for PFx pins */ 
    334            GPIOF->PUPDR   = 0x00000000;
    335          
    336            /* Connect PGx pins to FMC Alternate function */
    337            GPIOG->AFR[0]  = 0xCCCCCCCC;
    338            GPIOG->AFR[1]  = 0xCCCCCCCC;
    339            /* Configure PGx pins in Alternate function mode */ 
    340            GPIOG->MODER   = 0xAAAAAAAA;
    341            /* Configure PGx pins speed to 50 MHz */ 
    342            GPIOG->OSPEEDR = 0xAAAAAAAA;
    343            /* Configure PGx pins Output type to push-pull */  
    344            GPIOG->OTYPER  = 0x00000000;
    345            /* No pull-up, pull-down for PGx pins */ 
    346            GPIOG->PUPDR   = 0x00000000;
    347            
    348            /* Connect PHx pins to FMC Alternate function */
    349            GPIOH->AFR[0]  = 0x00C0CC00;
    350            GPIOH->AFR[1]  = 0xCCCCCCCC;
    351            /* Configure PHx pins in Alternate function mode */ 
    352            GPIOH->MODER   = 0xAAAA08A0;
    353            /* Configure PHx pins speed to 50 MHz */ 
    354            GPIOH->OSPEEDR = 0xAAAA08A0;
    355            /* Configure PHx pins Output type to push-pull */  
    356            GPIOH->OTYPER  = 0x00000000;
    357            /* No pull-up, pull-down for PHx pins */ 
    358            GPIOH->PUPDR   = 0x00000000;
    359            
    360            /* Connect PIx pins to FMC Alternate function */
    361            GPIOI->AFR[0]  = 0xCCCCCCCC;
    362            GPIOI->AFR[1]  = 0x00000CC0;
    363            /* Configure PIx pins in Alternate function mode */ 
    364            GPIOI->MODER   = 0x0028AAAA;
    365            /* Configure PIx pins speed to 50 MHz */ 
    366            GPIOI->OSPEEDR = 0x0028AAAA;
    367            /* Configure PIx pins Output type to push-pull */  
    368            GPIOI->OTYPER  = 0x00000000;
    369            /* No pull-up, pull-down for PIx pins */ 
    370            GPIOI->PUPDR   = 0x00000000;
    371            
    372          /*-- FMC Configuration -------------------------------------------------------*/
    373            /* Enable the FMC interface clock */
    374            RCC->AHB3ENR |= 0x00000001;
    375            /* Delay after an RCC peripheral clock enabling */
    376            tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
    377          
    378            FMC_Bank5_6->SDCR[0] = 0x000019E4;
    379            FMC_Bank5_6->SDTR[0] = 0x01115351;      
    380            
    381            /* SDRAM initialization sequence */
    382            /* Clock enable command */
    383            FMC_Bank5_6->SDCMR = 0x00000011; 
    384            tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    385            while((tmpreg != 0) && (timeout-- > 0))
    386            {
    387              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    388            }
    389          
    390            /* Delay */
    391            for (index = 0; index<1000; index++);
    392            
    393            /* PALL command */
    394            FMC_Bank5_6->SDCMR = 0x00000012;           
    395            timeout = 0xFFFF;
    396            while((tmpreg != 0) && (timeout-- > 0))
    397            {
    398              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    399            }
    400            
    401            /* Auto refresh command */
    402            FMC_Bank5_6->SDCMR = 0x00000073;
    403            timeout = 0xFFFF;
    404            while((tmpreg != 0) && (timeout-- > 0))
    405            {
    406              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    407            }
    408           
    409            /* MRD register program */
    410            FMC_Bank5_6->SDCMR = 0x00046014;
    411            timeout = 0xFFFF;
    412            while((tmpreg != 0) && (timeout-- > 0))
    413            {
    414              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    415            } 
    416            
    417            /* Set refresh count */
    418            tmpreg = FMC_Bank5_6->SDRTR;
    419            FMC_Bank5_6->SDRTR = (tmpreg | (0x0000027C<<1));
    420            
    421            /* Disable write protection */
    422            tmpreg = FMC_Bank5_6->SDCR[0]; 
    423            FMC_Bank5_6->SDCR[0] = (tmpreg & 0xFFFFFDFF);
    424          
    425          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)
    426            /* Configure and enable Bank1_SRAM2 */
    427            FMC_Bank1->BTCR[2]  = 0x00001011;
    428            FMC_Bank1->BTCR[3]  = 0x00000201;
    429            FMC_Bank1E->BWTR[2] = 0x0fffffff;
    430          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */ 
    431          #if defined(STM32F469xx) || defined(STM32F479xx)
    432            /* Configure and enable Bank1_SRAM2 */
    433            FMC_Bank1->BTCR[2]  = 0x00001091;
    434            FMC_Bank1->BTCR[3]  = 0x00110212;
    435            FMC_Bank1E->BWTR[2] = 0x0fffffff;
    436          #endif /* STM32F469xx || STM32F479xx */
    437          
    438            (void)(tmp); 
    439          }
    440          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
    441          #elif defined (DATA_IN_ExtSRAM) || defined (DATA_IN_ExtSDRAM)
    442          /**
    443            * @brief  Setup the external memory controller.
    444            *         Called in startup_stm32f4xx.s before jump to main.
    445            *         This function configures the external memories (SRAM/SDRAM)
    446            *         This SRAM/SDRAM will be used as program data memory (including heap and stack).
    447            * @param  None
    448            * @retval None
    449            */
    450          void SystemInit_ExtMemCtl(void)
    451          {
    452            __IO uint32_t tmp = 0x00;
    453          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
    454           || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
    455          #if defined (DATA_IN_ExtSDRAM)
    456            register uint32_t tmpreg = 0, timeout = 0xFFFF;
    457            register __IO uint32_t index;
    458          
    459          #if defined(STM32F446xx)
    460            /* Enable GPIOA, GPIOC, GPIOD, GPIOE, GPIOF, GPIOG interface
    461                clock */
    462            RCC->AHB1ENR |= 0x0000007D;
    463          #else
    464            /* Enable GPIOC, GPIOD, GPIOE, GPIOF, GPIOG, GPIOH and GPIOI interface 
    465                clock */
    466            RCC->AHB1ENR |= 0x000001F8;
    467          #endif /* STM32F446xx */  
    468            /* Delay after an RCC peripheral clock enabling */
    469            tmp = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOCEN);
    470            
    471          #if defined(STM32F446xx)
    472            /* Connect PAx pins to FMC Alternate function */
    473            GPIOA->AFR[0]  |= 0xC0000000;
    474            GPIOA->AFR[1]  |= 0x00000000;
    475            /* Configure PDx pins in Alternate function mode */
    476            GPIOA->MODER   |= 0x00008000;
    477            /* Configure PDx pins speed to 50 MHz */
    478            GPIOA->OSPEEDR |= 0x00008000;
    479            /* Configure PDx pins Output type to push-pull */
    480            GPIOA->OTYPER  |= 0x00000000;
    481            /* No pull-up, pull-down for PDx pins */
    482            GPIOA->PUPDR   |= 0x00000000;
    483          
    484            /* Connect PCx pins to FMC Alternate function */
    485            GPIOC->AFR[0]  |= 0x00CC0000;
    486            GPIOC->AFR[1]  |= 0x00000000;
    487            /* Configure PDx pins in Alternate function mode */
    488            GPIOC->MODER   |= 0x00000A00;
    489            /* Configure PDx pins speed to 50 MHz */
    490            GPIOC->OSPEEDR |= 0x00000A00;
    491            /* Configure PDx pins Output type to push-pull */
    492            GPIOC->OTYPER  |= 0x00000000;
    493            /* No pull-up, pull-down for PDx pins */
    494            GPIOC->PUPDR   |= 0x00000000;
    495          #endif /* STM32F446xx */
    496          
    497            /* Connect PDx pins to FMC Alternate function */
    498            GPIOD->AFR[0]  = 0x000000CC;
    499            GPIOD->AFR[1]  = 0xCC000CCC;
    500            /* Configure PDx pins in Alternate function mode */  
    501            GPIOD->MODER   = 0xA02A000A;
    502            /* Configure PDx pins speed to 50 MHz */  
    503            GPIOD->OSPEEDR = 0xA02A000A;
    504            /* Configure PDx pins Output type to push-pull */  
    505            GPIOD->OTYPER  = 0x00000000;
    506            /* No pull-up, pull-down for PDx pins */ 
    507            GPIOD->PUPDR   = 0x00000000;
    508          
    509            /* Connect PEx pins to FMC Alternate function */
    510            GPIOE->AFR[0]  = 0xC00000CC;
    511            GPIOE->AFR[1]  = 0xCCCCCCCC;
    512            /* Configure PEx pins in Alternate function mode */ 
    513            GPIOE->MODER   = 0xAAAA800A;
    514            /* Configure PEx pins speed to 50 MHz */ 
    515            GPIOE->OSPEEDR = 0xAAAA800A;
    516            /* Configure PEx pins Output type to push-pull */  
    517            GPIOE->OTYPER  = 0x00000000;
    518            /* No pull-up, pull-down for PEx pins */ 
    519            GPIOE->PUPDR   = 0x00000000;
    520          
    521            /* Connect PFx pins to FMC Alternate function */
    522            GPIOF->AFR[0]  = 0xCCCCCCCC;
    523            GPIOF->AFR[1]  = 0xCCCCCCCC;
    524            /* Configure PFx pins in Alternate function mode */   
    525            GPIOF->MODER   = 0xAA800AAA;
    526            /* Configure PFx pins speed to 50 MHz */ 
    527            GPIOF->OSPEEDR = 0xAA800AAA;
    528            /* Configure PFx pins Output type to push-pull */  
    529            GPIOF->OTYPER  = 0x00000000;
    530            /* No pull-up, pull-down for PFx pins */ 
    531            GPIOF->PUPDR   = 0x00000000;
    532          
    533            /* Connect PGx pins to FMC Alternate function */
    534            GPIOG->AFR[0]  = 0xCCCCCCCC;
    535            GPIOG->AFR[1]  = 0xCCCCCCCC;
    536            /* Configure PGx pins in Alternate function mode */ 
    537            GPIOG->MODER   = 0xAAAAAAAA;
    538            /* Configure PGx pins speed to 50 MHz */ 
    539            GPIOG->OSPEEDR = 0xAAAAAAAA;
    540            /* Configure PGx pins Output type to push-pull */  
    541            GPIOG->OTYPER  = 0x00000000;
    542            /* No pull-up, pull-down for PGx pins */ 
    543            GPIOG->PUPDR   = 0x00000000;
    544          
    545          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
    546           || defined(STM32F469xx) || defined(STM32F479xx)  
    547            /* Connect PHx pins to FMC Alternate function */
    548            GPIOH->AFR[0]  = 0x00C0CC00;
    549            GPIOH->AFR[1]  = 0xCCCCCCCC;
    550            /* Configure PHx pins in Alternate function mode */ 
    551            GPIOH->MODER   = 0xAAAA08A0;
    552            /* Configure PHx pins speed to 50 MHz */ 
    553            GPIOH->OSPEEDR = 0xAAAA08A0;
    554            /* Configure PHx pins Output type to push-pull */  
    555            GPIOH->OTYPER  = 0x00000000;
    556            /* No pull-up, pull-down for PHx pins */ 
    557            GPIOH->PUPDR   = 0x00000000;
    558            
    559            /* Connect PIx pins to FMC Alternate function */
    560            GPIOI->AFR[0]  = 0xCCCCCCCC;
    561            GPIOI->AFR[1]  = 0x00000CC0;
    562            /* Configure PIx pins in Alternate function mode */ 
    563            GPIOI->MODER   = 0x0028AAAA;
    564            /* Configure PIx pins speed to 50 MHz */ 
    565            GPIOI->OSPEEDR = 0x0028AAAA;
    566            /* Configure PIx pins Output type to push-pull */  
    567            GPIOI->OTYPER  = 0x00000000;
    568            /* No pull-up, pull-down for PIx pins */ 
    569            GPIOI->PUPDR   = 0x00000000;
    570          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
    571            
    572          /*-- FMC Configuration -------------------------------------------------------*/
    573            /* Enable the FMC interface clock */
    574            RCC->AHB3ENR |= 0x00000001;
    575            /* Delay after an RCC peripheral clock enabling */
    576            tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
    577          
    578            /* Configure and enable SDRAM bank1 */
    579          #if defined(STM32F446xx)
    580            FMC_Bank5_6->SDCR[0] = 0x00001954;
    581          #else  
    582            FMC_Bank5_6->SDCR[0] = 0x000019E4;
    583          #endif /* STM32F446xx */
    584            FMC_Bank5_6->SDTR[0] = 0x01115351;      
    585            
    586            /* SDRAM initialization sequence */
    587            /* Clock enable command */
    588            FMC_Bank5_6->SDCMR = 0x00000011; 
    589            tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    590            while((tmpreg != 0) && (timeout-- > 0))
    591            {
    592              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    593            }
    594          
    595            /* Delay */
    596            for (index = 0; index<1000; index++);
    597            
    598            /* PALL command */
    599            FMC_Bank5_6->SDCMR = 0x00000012;           
    600            timeout = 0xFFFF;
    601            while((tmpreg != 0) && (timeout-- > 0))
    602            {
    603              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    604            }
    605            
    606            /* Auto refresh command */
    607          #if defined(STM32F446xx)
    608            FMC_Bank5_6->SDCMR = 0x000000F3;
    609          #else  
    610            FMC_Bank5_6->SDCMR = 0x00000073;
    611          #endif /* STM32F446xx */
    612            timeout = 0xFFFF;
    613            while((tmpreg != 0) && (timeout-- > 0))
    614            {
    615              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    616            }
    617           
    618            /* MRD register program */
    619          #if defined(STM32F446xx)
    620            FMC_Bank5_6->SDCMR = 0x00044014;
    621          #else  
    622            FMC_Bank5_6->SDCMR = 0x00046014;
    623          #endif /* STM32F446xx */
    624            timeout = 0xFFFF;
    625            while((tmpreg != 0) && (timeout-- > 0))
    626            {
    627              tmpreg = FMC_Bank5_6->SDSR & 0x00000020; 
    628            } 
    629            
    630            /* Set refresh count */
    631            tmpreg = FMC_Bank5_6->SDRTR;
    632          #if defined(STM32F446xx)
    633            FMC_Bank5_6->SDRTR = (tmpreg | (0x0000050C<<1));
    634          #else    
    635            FMC_Bank5_6->SDRTR = (tmpreg | (0x0000027C<<1));
    636          #endif /* STM32F446xx */
    637            
    638            /* Disable write protection */
    639            tmpreg = FMC_Bank5_6->SDCR[0]; 
    640            FMC_Bank5_6->SDCR[0] = (tmpreg & 0xFFFFFDFF);
    641          #endif /* DATA_IN_ExtSDRAM */
    642          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F446xx || STM32F469xx || STM32F479xx */
    643          
    644          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)\
    645           || defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)\
    646           || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx)
    647          
    648          #if defined(DATA_IN_ExtSRAM)
    649          /*-- GPIOs Configuration -----------------------------------------------------*/
    650             /* Enable GPIOD, GPIOE, GPIOF and GPIOG interface clock */
    651            RCC->AHB1ENR   |= 0x00000078;
    652            /* Delay after an RCC peripheral clock enabling */
    653            tmp = READ_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIODEN);
    654            
    655            /* Connect PDx pins to FMC Alternate function */
    656            GPIOD->AFR[0]  = 0x00CCC0CC;
    657            GPIOD->AFR[1]  = 0xCCCCCCCC;
    658            /* Configure PDx pins in Alternate function mode */  
    659            GPIOD->MODER   = 0xAAAA0A8A;
    660            /* Configure PDx pins speed to 100 MHz */  
    661            GPIOD->OSPEEDR = 0xFFFF0FCF;
    662            /* Configure PDx pins Output type to push-pull */  
    663            GPIOD->OTYPER  = 0x00000000;
    664            /* No pull-up, pull-down for PDx pins */ 
    665            GPIOD->PUPDR   = 0x00000000;
    666          
    667            /* Connect PEx pins to FMC Alternate function */
    668            GPIOE->AFR[0]  = 0xC00CC0CC;
    669            GPIOE->AFR[1]  = 0xCCCCCCCC;
    670            /* Configure PEx pins in Alternate function mode */ 
    671            GPIOE->MODER   = 0xAAAA828A;
    672            /* Configure PEx pins speed to 100 MHz */ 
    673            GPIOE->OSPEEDR = 0xFFFFC3CF;
    674            /* Configure PEx pins Output type to push-pull */  
    675            GPIOE->OTYPER  = 0x00000000;
    676            /* No pull-up, pull-down for PEx pins */ 
    677            GPIOE->PUPDR   = 0x00000000;
    678          
    679            /* Connect PFx pins to FMC Alternate function */
    680            GPIOF->AFR[0]  = 0x00CCCCCC;
    681            GPIOF->AFR[1]  = 0xCCCC0000;
    682            /* Configure PFx pins in Alternate function mode */   
    683            GPIOF->MODER   = 0xAA000AAA;
    684            /* Configure PFx pins speed to 100 MHz */ 
    685            GPIOF->OSPEEDR = 0xFF000FFF;
    686            /* Configure PFx pins Output type to push-pull */  
    687            GPIOF->OTYPER  = 0x00000000;
    688            /* No pull-up, pull-down for PFx pins */ 
    689            GPIOF->PUPDR   = 0x00000000;
    690          
    691            /* Connect PGx pins to FMC Alternate function */
    692            GPIOG->AFR[0]  = 0x00CCCCCC;
    693            GPIOG->AFR[1]  = 0x000000C0;
    694            /* Configure PGx pins in Alternate function mode */ 
    695            GPIOG->MODER   = 0x00085AAA;
    696            /* Configure PGx pins speed to 100 MHz */ 
    697            GPIOG->OSPEEDR = 0x000CAFFF;
    698            /* Configure PGx pins Output type to push-pull */  
    699            GPIOG->OTYPER  = 0x00000000;
    700            /* No pull-up, pull-down for PGx pins */ 
    701            GPIOG->PUPDR   = 0x00000000;
    702            
    703          /*-- FMC/FSMC Configuration --------------------------------------------------*/
    704            /* Enable the FMC/FSMC interface clock */
    705            RCC->AHB3ENR         |= 0x00000001;
    706          
    707          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)
    708            /* Delay after an RCC peripheral clock enabling */
    709            tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
    710            /* Configure and enable Bank1_SRAM2 */
    711            FMC_Bank1->BTCR[2]  = 0x00001011;
    712            FMC_Bank1->BTCR[3]  = 0x00000201;
    713            FMC_Bank1E->BWTR[2] = 0x0fffffff;
    714          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */ 
    715          #if defined(STM32F469xx) || defined(STM32F479xx)
    716            /* Delay after an RCC peripheral clock enabling */
    717            tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
    718            /* Configure and enable Bank1_SRAM2 */
    719            FMC_Bank1->BTCR[2]  = 0x00001091;
    720            FMC_Bank1->BTCR[3]  = 0x00110212;
    721            FMC_Bank1E->BWTR[2] = 0x0fffffff;
    722          #endif /* STM32F469xx || STM32F479xx */
    723          #if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx)|| defined(STM32F417xx)\
    724             || defined(STM32F412Zx) || defined(STM32F412Vx)
    725            /* Delay after an RCC peripheral clock enabling */
    726            tmp = READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FSMCEN);
    727            /* Configure and enable Bank1_SRAM2 */
    728            FSMC_Bank1->BTCR[2]  = 0x00001011;
    729            FSMC_Bank1->BTCR[3]  = 0x00000201;
    730            FSMC_Bank1E->BWTR[2] = 0x0FFFFFFF;
    731          #endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F412Zx || STM32F412Vx */
    732          
    733          #endif /* DATA_IN_ExtSRAM */
    734          #endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx || STM32F427xx || STM32F437xx ||\
    735                    STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx || STM32F412Zx || STM32F412Vx  */ 
    736            (void)(tmp); 
    737          }
    738          #endif /* DATA_IN_ExtSRAM && DATA_IN_ExtSDRAM */
    739          /**
    740            * @}
    741            */
    742          
    743          /**
    744            * @}
    745            */
    746          
    747          /**
    748            * @}
    749            */
    750          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   SystemCoreClockUpdate
       0   SystemInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
      16  AHBPrescTable
       8  APBPrescTable
       4  SystemCoreClock
     162  SystemCoreClockUpdate
      18  SystemInit

 
   4 bytes in section .data
  24 bytes in section .rodata
 216 bytes in section .text
 
 216 bytes of CODE  memory
  24 bytes of CONST memory
   4 bytes of DATA  memory

Errors: none
Warnings: none
