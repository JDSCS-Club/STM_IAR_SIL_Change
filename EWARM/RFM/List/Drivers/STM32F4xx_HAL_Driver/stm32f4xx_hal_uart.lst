###############################################################################
#
#                                                         06/Oct/2022  13:55:45
# IAR ANSI C/C++ Compiler V9.20.3.326/W64 for ARM Functional Safety
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_uart.c
#    Command line      =
#        -f
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_uart.o.rsp
#        (C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_uart.c
#        -D USE_HAL_DRIVER -D STM32F407xx -lC
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver
#        -o
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0 EWARM FS
#        9.20.3\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/App\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Core/Inc\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Include\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/display\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Library\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.0 EWARM FS 9.20.3\arm\CMSIS\Core\Include\\")
#        --dependencies=n
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_uart.o.d
#    Locale            =  C
#    List file         =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_uart.lst
#    Object file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_uart.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_uart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_uart.c
      4            * @author  MCD Application Team
      5            * @brief   UART HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Universal Asynchronous Receiver Transmitter Peripheral (UART).
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *           + Peripheral Control functions
     11            *           + Peripheral State and Errors functions
     12            @verbatim
     13            ==============================================================================
     14                                  ##### How to use this driver #####
     15            ==============================================================================
     16            [..]
     17              The UART HAL driver can be used as follows:
     18          
     19              (#) Declare a UART_HandleTypeDef handle structure (eg. UART_HandleTypeDef huart).
     20              (#) Initialize the UART low level resources by implementing the HAL_UART_MspInit() API:
     21                  (##) Enable the USARTx interface clock.
     22                  (##) UART pins configuration:
     23                      (+++) Enable the clock for the UART GPIOs.
     24                      (+++) Configure these UART pins (TX as alternate function pull-up, RX as alternate function Input).
     25                  (##) NVIC configuration if you need to use interrupt process (HAL_UART_Transmit_IT()
     26                       and HAL_UART_Receive_IT() APIs):
     27                      (+++) Configure the USARTx interrupt priority.
     28                      (+++) Enable the NVIC USART IRQ handle.
     29                  (##) DMA Configuration if you need to use DMA process (HAL_UART_Transmit_DMA()
     30                       and HAL_UART_Receive_DMA() APIs):
     31                      (+++) Declare a DMA handle structure for the Tx/Rx stream.
     32                      (+++) Enable the DMAx interface clock.
     33                      (+++) Configure the declared DMA handle structure with the required
     34                            Tx/Rx parameters.
     35                      (+++) Configure the DMA Tx/Rx stream.
     36                      (+++) Associate the initialized DMA handle to the UART DMA Tx/Rx handle.
     37                      (+++) Configure the priority and enable the NVIC for the transfer complete
     38                            interrupt on the DMA Tx/Rx stream.
     39                      (+++) Configure the USARTx interrupt priority and enable the NVIC USART IRQ handle
     40                            (used for last byte sending completion detection in DMA non circular mode)
     41          
     42              (#) Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware
     43                  flow control and Mode(Receiver/Transmitter) in the huart Init structure.
     44          
     45              (#) For the UART asynchronous mode, initialize the UART registers by calling
     46                  the HAL_UART_Init() API.
     47          
     48              (#) For the UART Half duplex mode, initialize the UART registers by calling
     49                  the HAL_HalfDuplex_Init() API.
     50          
     51              (#) For the LIN mode, initialize the UART registers by calling the HAL_LIN_Init() API.
     52          
     53              (#) For the Multi-Processor mode, initialize the UART registers by calling
     54                  the HAL_MultiProcessor_Init() API.
     55          
     56               [..]
     57                 (@) The specific UART interrupts (Transmission complete interrupt,
     58                      RXNE interrupt and Error Interrupts) will be managed using the macros
     59                      __HAL_UART_ENABLE_IT() and __HAL_UART_DISABLE_IT() inside the transmit
     60                      and receive process.
     61          
     62               [..]
     63                 (@) These APIs (HAL_UART_Init() and HAL_HalfDuplex_Init()) configure also the
     64                      low level Hardware GPIO, CLOCK, CORTEX...etc) by calling the customized
     65                      HAL_UART_MspInit() API.
     66          
     67              ##### Callback registration #####
     68              ==================================
     69          
     70              [..]
     71              The compilation define USE_HAL_UART_REGISTER_CALLBACKS when set to 1
     72              allows the user to configure dynamically the driver callbacks.
     73          
     74              [..]
     75              Use Function @ref HAL_UART_RegisterCallback() to register a user callback.
     76              Function @ref HAL_UART_RegisterCallback() allows to register following callbacks:
     77              (+) TxHalfCpltCallback        : Tx Half Complete Callback.
     78              (+) TxCpltCallback            : Tx Complete Callback.
     79              (+) RxHalfCpltCallback        : Rx Half Complete Callback.
     80              (+) RxCpltCallback            : Rx Complete Callback.
     81              (+) ErrorCallback             : Error Callback.
     82              (+) AbortCpltCallback         : Abort Complete Callback.
     83              (+) AbortTransmitCpltCallback : Abort Transmit Complete Callback.
     84              (+) AbortReceiveCpltCallback  : Abort Receive Complete Callback.
     85              (+) MspInitCallback           : UART MspInit.
     86              (+) MspDeInitCallback         : UART MspDeInit.
     87              This function takes as parameters the HAL peripheral handle, the Callback ID
     88              and a pointer to the user callback function.
     89          
     90              [..]
     91              Use function @ref HAL_UART_UnRegisterCallback() to reset a callback to the default
     92              weak (surcharged) function.
     93              @ref HAL_UART_UnRegisterCallback() takes as parameters the HAL peripheral handle,
     94              and the Callback ID.
     95              This function allows to reset following callbacks:
     96              (+) TxHalfCpltCallback        : Tx Half Complete Callback.
     97              (+) TxCpltCallback            : Tx Complete Callback.
     98              (+) RxHalfCpltCallback        : Rx Half Complete Callback.
     99              (+) RxCpltCallback            : Rx Complete Callback.
    100              (+) ErrorCallback             : Error Callback.
    101              (+) AbortCpltCallback         : Abort Complete Callback.
    102              (+) AbortTransmitCpltCallback : Abort Transmit Complete Callback.
    103              (+) AbortReceiveCpltCallback  : Abort Receive Complete Callback.
    104              (+) MspInitCallback           : UART MspInit.
    105              (+) MspDeInitCallback         : UART MspDeInit.
    106          
    107              [..]
    108              By default, after the @ref HAL_UART_Init() and when the state is HAL_UART_STATE_RESET
    109              all callbacks are set to the corresponding weak (surcharged) functions:
    110              examples @ref HAL_UART_TxCpltCallback(), @ref HAL_UART_RxHalfCpltCallback().
    111              Exception done for MspInit and MspDeInit functions that are respectively
    112              reset to the legacy weak (surcharged) functions in the @ref HAL_UART_Init()
    113              and @ref HAL_UART_DeInit() only when these callbacks are null (not registered beforehand).
    114              If not, MspInit or MspDeInit are not null, the @ref HAL_UART_Init() and @ref HAL_UART_DeInit()
    115              keep and use the user MspInit/MspDeInit callbacks (registered beforehand).
    116          
    117              [..]
    118              Callbacks can be registered/unregistered in HAL_UART_STATE_READY state only.
    119              Exception done MspInit/MspDeInit that can be registered/unregistered
    120              in HAL_UART_STATE_READY or HAL_UART_STATE_RESET state, thus registered (user)
    121              MspInit/DeInit callbacks can be used during the Init/DeInit.
    122              In that case first register the MspInit/MspDeInit user callbacks
    123              using @ref HAL_UART_RegisterCallback() before calling @ref HAL_UART_DeInit()
    124              or @ref HAL_UART_Init() function.
    125          
    126              [..]
    127              When The compilation define USE_HAL_UART_REGISTER_CALLBACKS is set to 0 or
    128              not defined, the callback registration feature is not available
    129              and weak (surcharged) callbacks are used.
    130          
    131               [..]
    132                  Three operation modes are available within this driver :
    133          
    134               *** Polling mode IO operation ***
    135               =================================
    136               [..]
    137                 (+) Send an amount of data in blocking mode using HAL_UART_Transmit()
    138                 (+) Receive an amount of data in blocking mode using HAL_UART_Receive()
    139          
    140               *** Interrupt mode IO operation ***
    141               ===================================
    142               [..]
    143                 (+) Send an amount of data in non blocking mode using HAL_UART_Transmit_IT()
    144                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can
    145                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
    146                 (+) Receive an amount of data in non blocking mode using HAL_UART_Receive_IT()
    147                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can
    148                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
    149                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can
    150                      add his own code by customization of function pointer HAL_UART_ErrorCallback
    151          
    152               *** DMA mode IO operation ***
    153               ==============================
    154               [..]
    155                 (+) Send an amount of data in non blocking mode (DMA) using HAL_UART_Transmit_DMA()
    156                 (+) At transmission end of half transfer HAL_UART_TxHalfCpltCallback is executed and user can
    157                      add his own code by customization of function pointer HAL_UART_TxHalfCpltCallback
    158                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can
    159                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
    160                 (+) Receive an amount of data in non blocking mode (DMA) using HAL_UART_Receive_DMA()
    161                 (+) At reception end of half transfer HAL_UART_RxHalfCpltCallback is executed and user can
    162                      add his own code by customization of function pointer HAL_UART_RxHalfCpltCallback
    163                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can
    164                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
    165                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can
    166                      add his own code by customization of function pointer HAL_UART_ErrorCallback
    167                 (+) Pause the DMA Transfer using HAL_UART_DMAPause()
    168                 (+) Resume the DMA Transfer using HAL_UART_DMAResume()
    169                 (+) Stop the DMA Transfer using HAL_UART_DMAStop()
    170          
    171               *** UART HAL driver macros list ***
    172               =============================================
    173               [..]
    174                 Below the list of most used macros in UART HAL driver.
    175          
    176                (+) __HAL_UART_ENABLE: Enable the UART peripheral
    177                (+) __HAL_UART_DISABLE: Disable the UART peripheral
    178                (+) __HAL_UART_GET_FLAG : Check whether the specified UART flag is set or not
    179                (+) __HAL_UART_CLEAR_FLAG : Clear the specified UART pending flag
    180                (+) __HAL_UART_ENABLE_IT: Enable the specified UART interrupt
    181                (+) __HAL_UART_DISABLE_IT: Disable the specified UART interrupt
    182                (+) __HAL_UART_GET_IT_SOURCE: Check whether the specified UART interrupt has occurred or not
    183          
    184               [..]
    185                 (@) You can refer to the UART HAL driver header file for more useful macros
    186          
    187            @endverbatim
    188               [..]
    189                 (@) Additionnal remark: If the parity is enabled, then the MSB bit of the data written
    190                     in the data register is transmitted but is changed by the parity bit.
    191                     Depending on the frame length defined by the M bit (8-bits or 9-bits),
    192                     the possible UART frame formats are as listed in the following table:
    193              +-------------------------------------------------------------+
    194              |   M bit |  PCE bit  |            UART frame                 |
    195              |---------------------|---------------------------------------|
    196              |    0    |    0      |    | SB | 8 bit data | STB |          |
    197              |---------|-----------|---------------------------------------|
    198              |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    199              |---------|-----------|---------------------------------------|
    200              |    1    |    0      |    | SB | 9 bit data | STB |          |
    201              |---------|-----------|---------------------------------------|
    202              |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    203              +-------------------------------------------------------------+
    204            ******************************************************************************
    205            * @attention
    206            *
    207            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
    208            * All rights reserved.</center></h2>
    209            *
    210            * This software component is licensed by ST under BSD 3-Clause license,
    211            * the "License"; You may not use this file except in compliance with the
    212            * License. You may obtain a copy of the License at:
    213            *                        opensource.org/licenses/BSD-3-Clause
    214            *
    215            ******************************************************************************
    216            */
    217          
    218          /* Includes ------------------------------------------------------------------*/
    219          #include "stm32f4xx_hal.h"
    220          
    221          /** @addtogroup STM32F4xx_HAL_Driver
    222            * @{
    223            */
    224          
    225          /** @defgroup UART UART
    226            * @brief HAL UART module driver
    227            * @{
    228            */
    229          #ifdef HAL_UART_MODULE_ENABLED
    230          
    231          /* Private typedef -----------------------------------------------------------*/
    232          /* Private define ------------------------------------------------------------*/
    233          /** @addtogroup UART_Private_Constants
    234            * @{
    235            */
    236          /**
    237            * @}
    238            */
    239          /* Private macro -------------------------------------------------------------*/
    240          /* Private variables ---------------------------------------------------------*/
    241          /* Private function prototypes -----------------------------------------------*/
    242          /** @addtogroup UART_Private_Functions  UART Private Functions
    243            * @{
    244            */
    245          
    246          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    247          void UART_InitCallbacksToDefault(UART_HandleTypeDef *huart);
    248          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
    249          static void UART_EndTxTransfer(UART_HandleTypeDef *huart);
    250          static void UART_EndRxTransfer(UART_HandleTypeDef *huart);
    251          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    252          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    253          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    254          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    255          static void UART_DMAError(DMA_HandleTypeDef *hdma);
    256          static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma);
    257          static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma);
    258          static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma);
    259          static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma);
    260          static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma);
    261          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart);
    262          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart);
    263          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart);
    264          static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout);
    265          static void UART_SetConfig(UART_HandleTypeDef *huart);
    266          
    267          /**
    268            * @}
    269            */
    270          
    271          /* Exported functions ---------------------------------------------------------*/
    272          /** @defgroup UART_Exported_Functions UART Exported Functions
    273            * @{
    274            */
    275          
    276          /** @defgroup UART_Exported_Functions_Group1 Initialization and de-initialization functions
    277            *  @brief    Initialization and Configuration functions
    278            *
    279          @verbatim
    280           ===============================================================================
    281                      ##### Initialization and Configuration functions #####
    282           ===============================================================================
    283              [..]
    284              This subsection provides a set of functions allowing to initialize the USARTx or the UARTy
    285              in asynchronous mode.
    286                (+) For the asynchronous mode only these parameters can be configured:
    287                  (++) Baud Rate
    288                  (++) Word Length
    289                  (++) Stop Bit
    290                  (++) Parity: If the parity is enabled, then the MSB bit of the data written
    291                       in the data register is transmitted but is changed by the parity bit.
    292                       Depending on the frame length defined by the M bit (8-bits or 9-bits),
    293                       please refer to Reference manual for possible UART frame formats.
    294                  (++) Hardware flow control
    295                  (++) Receiver/transmitter modes
    296                  (++) Over Sampling Method
    297              [..]
    298              The HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init() and HAL_MultiProcessor_Init() APIs
    299              follow respectively the UART asynchronous, UART Half duplex, LIN and Multi-Processor configuration
    300              procedures (details for the procedures are available in reference manual
    301              (RM0430 for STM32F4X3xx MCUs and RM0402 for STM32F412xx MCUs
    302               RM0383 for STM32F411xC/E MCUs and RM0401 for STM32F410xx MCUs
    303               RM0090 for STM32F4X5xx/STM32F4X7xx/STM32F429xx/STM32F439xx MCUs
    304               RM0390 for STM32F446xx MCUs and RM0386 for STM32F469xx/STM32F479xx MCUs)).
    305          
    306          @endverbatim
    307            * @{
    308            */
    309          
    310          /**
    311            * @brief  Initializes the UART mode according to the specified parameters in
    312            *         the UART_InitTypeDef and create the associated handle.
    313            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
    314            *                the configuration information for the specified UART module.
    315            * @retval HAL status
    316            */

   \                                 In section .text, align 2, keep-with-next
    317          HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
    318          {
   \                     HAL_UART_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    319            /* Check the UART handle allocation */
    320            if (huart == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_UART_Init_0
    321            {
    322              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE033             B.N      ??HAL_UART_Init_1
    323            }
    324          
    325            /* Check the parameters */
    326            if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
   \                     ??HAL_UART_Init_0: (+1)
   \        0xC   0x69A0             LDR      R0,[R4, #+24]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD1FF             BNE.N    ??HAL_UART_Init_2
    327            {
    328              /* The hardware flow control is available only for USART1, USART2, USART3 and USART6.
    329                 Except for STM32F446xx devices, that is available for USART1, USART2, USART3, USART6, UART4 and UART5.
    330              */
    331              assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
    332              assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
    333            }
    334            else
    335            {
    336              assert_param(IS_UART_INSTANCE(huart->Instance));
    337            }
    338            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    339            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    340          
    341            if (huart->gState == HAL_UART_STATE_RESET)
   \                     ??HAL_UART_Init_3: (+1)
   \                     ??HAL_UART_Init_2: (+1)
   \       0x12   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD105             BNE.N    ??HAL_UART_Init_4
    342            {
    343              /* Allocate lock resource and initialize it */
    344              huart->Lock = HAL_UNLOCKED;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xF884 0x0038      STRB     R0,[R4, #+56]
    345          
    346          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    347              UART_InitCallbacksToDefault(huart);
    348          
    349              if (huart->MspInitCallback == NULL)
    350              {
    351                huart->MspInitCallback = HAL_UART_MspInit;
    352              }
    353          
    354              /* Init the low level hardware */
    355              huart->MspInitCallback(huart);
    356          #else
    357              /* Init the low level hardware : GPIO, CLOCK */
    358              HAL_UART_MspInit(huart);
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       HAL_UART_MspInit
    359          #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
    360            }
    361          
    362            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_Init_4: (+1)
   \       0x26   0x2024             MOVS     R0,#+36
   \       0x28   0xF884 0x0039      STRB     R0,[R4, #+57]
    363          
    364            /* Disable the peripheral */
    365            __HAL_UART_DISABLE(huart);
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x68C0             LDR      R0,[R0, #+12]
   \       0x30   0xF430 0x5000      BICS     R0,R0,#0x2000
   \       0x34   0x6821             LDR      R1,[R4, #+0]
   \       0x36   0x60C8             STR      R0,[R1, #+12]
    366          
    367            /* Set the UART Communication parameters */
    368            UART_SetConfig(huart);
   \       0x38   0x0020             MOVS     R0,R4
   \       0x3A   0x.... 0x....      BL       UART_SetConfig
    369          
    370            /* In asynchronous mode, the following bits must be kept cleared:
    371               - LINEN and CLKEN bits in the USART_CR2 register,
    372               - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
    373            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6900             LDR      R0,[R0, #+16]
   \       0x42   0xF430 0x4090      BICS     R0,R0,#0x4800
   \       0x46   0x6821             LDR      R1,[R4, #+0]
   \       0x48   0x6108             STR      R0,[R1, #+16]
    374            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x6940             LDR      R0,[R0, #+20]
   \       0x4E   0xF030 0x002A      BICS     R0,R0,#0x2A
   \       0x52   0x6821             LDR      R1,[R4, #+0]
   \       0x54   0x6148             STR      R0,[R1, #+20]
    375          
    376            /* Enable the peripheral */
    377            __HAL_UART_ENABLE(huart);
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x68C0             LDR      R0,[R0, #+12]
   \       0x5A   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \       0x5E   0x6821             LDR      R1,[R4, #+0]
   \       0x60   0x60C8             STR      R0,[R1, #+12]
    378          
    379            /* Initialize the UART state */
    380            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x63E0             STR      R0,[R4, #+60]
    381            huart->gState = HAL_UART_STATE_READY;
   \       0x66   0x2020             MOVS     R0,#+32
   \       0x68   0xF884 0x0039      STRB     R0,[R4, #+57]
    382            huart->RxState = HAL_UART_STATE_READY;
   \       0x6C   0x2020             MOVS     R0,#+32
   \       0x6E   0xF884 0x003A      STRB     R0,[R4, #+58]
    383          
    384            return HAL_OK;
   \       0x72   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_Init_1: (+1)
   \       0x74   0xBD10             POP      {R4,PC}
    385          }
    386          
    387          /**
    388            * @brief  Initializes the half-duplex mode according to the specified
    389            *         parameters in the UART_InitTypeDef and create the associated handle.
    390            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
    391            *                the configuration information for the specified UART module.
    392            * @retval HAL status
    393            */

   \                                 In section .text, align 2, keep-with-next
    394          HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
    395          {
   \                     HAL_HalfDuplex_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    396            /* Check the UART handle allocation */
    397            if (huart == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_HalfDuplex_Init_0
    398            {
    399              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE036             B.N      ??HAL_HalfDuplex_Init_1
    400            }
    401          
    402            /* Check the parameters */
    403            assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
    404            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    405            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    406          
    407            if (huart->gState == HAL_UART_STATE_RESET)
   \                     ??HAL_HalfDuplex_Init_0: (+1)
   \        0xC   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD105             BNE.N    ??HAL_HalfDuplex_Init_2
    408            {
    409              /* Allocate lock resource and initialize it */
    410              huart->Lock = HAL_UNLOCKED;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xF884 0x0038      STRB     R0,[R4, #+56]
    411          
    412          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    413              UART_InitCallbacksToDefault(huart);
    414          
    415              if (huart->MspInitCallback == NULL)
    416              {
    417                huart->MspInitCallback = HAL_UART_MspInit;
    418              }
    419          
    420              /* Init the low level hardware */
    421              huart->MspInitCallback(huart);
    422          #else
    423              /* Init the low level hardware : GPIO, CLOCK */
    424              HAL_UART_MspInit(huart);
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       HAL_UART_MspInit
    425          #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
    426            }
    427          
    428            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_HalfDuplex_Init_2: (+1)
   \       0x20   0x2024             MOVS     R0,#+36
   \       0x22   0xF884 0x0039      STRB     R0,[R4, #+57]
    429          
    430            /* Disable the peripheral */
    431            __HAL_UART_DISABLE(huart);
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x68C0             LDR      R0,[R0, #+12]
   \       0x2A   0xF430 0x5000      BICS     R0,R0,#0x2000
   \       0x2E   0x6821             LDR      R1,[R4, #+0]
   \       0x30   0x60C8             STR      R0,[R1, #+12]
    432          
    433            /* Set the UART Communication parameters */
    434            UART_SetConfig(huart);
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       UART_SetConfig
    435          
    436            /* In half-duplex mode, the following bits must be kept cleared:
    437               - LINEN and CLKEN bits in the USART_CR2 register,
    438               - SCEN and IREN bits in the USART_CR3 register.*/
    439            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x6900             LDR      R0,[R0, #+16]
   \       0x3C   0xF430 0x4090      BICS     R0,R0,#0x4800
   \       0x40   0x6821             LDR      R1,[R4, #+0]
   \       0x42   0x6108             STR      R0,[R1, #+16]
    440            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x6940             LDR      R0,[R0, #+20]
   \       0x48   0xF030 0x0022      BICS     R0,R0,#0x22
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x6148             STR      R0,[R1, #+20]
    441          
    442            /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    443            SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x6940             LDR      R0,[R0, #+20]
   \       0x54   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0x58   0x6821             LDR      R1,[R4, #+0]
   \       0x5A   0x6148             STR      R0,[R1, #+20]
    444          
    445            /* Enable the peripheral */
    446            __HAL_UART_ENABLE(huart);
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x68C0             LDR      R0,[R0, #+12]
   \       0x60   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \       0x64   0x6821             LDR      R1,[R4, #+0]
   \       0x66   0x60C8             STR      R0,[R1, #+12]
    447          
    448            /* Initialize the UART state*/
    449            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0x63E0             STR      R0,[R4, #+60]
    450            huart->gState = HAL_UART_STATE_READY;
   \       0x6C   0x2020             MOVS     R0,#+32
   \       0x6E   0xF884 0x0039      STRB     R0,[R4, #+57]
    451            huart->RxState = HAL_UART_STATE_READY;
   \       0x72   0x2020             MOVS     R0,#+32
   \       0x74   0xF884 0x003A      STRB     R0,[R4, #+58]
    452          
    453            return HAL_OK;
   \       0x78   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_Init_1: (+1)
   \       0x7A   0xBD10             POP      {R4,PC}
    454          }
    455          
    456          /**
    457            * @brief  Initializes the LIN mode according to the specified
    458            *         parameters in the UART_InitTypeDef and create the associated handle.
    459            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
    460            *                the configuration information for the specified UART module.
    461            * @param  BreakDetectLength Specifies the LIN break detection length.
    462            *         This parameter can be one of the following values:
    463            *            @arg UART_LINBREAKDETECTLENGTH_10B: 10-bit break detection
    464            *            @arg UART_LINBREAKDETECTLENGTH_11B: 11-bit break detection
    465            * @retval HAL status
    466            */

   \                                 In section .text, align 2, keep-with-next
    467          HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
    468          {
   \                     HAL_LIN_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    469            /* Check the UART handle allocation */
    470            if (huart == NULL)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??HAL_LIN_Init_0
    471            {
    472              return HAL_ERROR;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE041             B.N      ??HAL_LIN_Init_1
    473            }
    474          
    475            /* Check the LIN UART instance */
    476            assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
    477          
    478            /* Check the Break detection length parameter */
    479            assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
    480            assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
    481            assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
    482          
    483            if (huart->gState == HAL_UART_STATE_RESET)
   \                     ??HAL_LIN_Init_0: (+1)
   \        0xE   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD105             BNE.N    ??HAL_LIN_Init_2
    484            {
    485              /* Allocate lock resource and initialize it */
    486              huart->Lock = HAL_UNLOCKED;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xF884 0x0038      STRB     R0,[R4, #+56]
    487          
    488          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    489              UART_InitCallbacksToDefault(huart);
    490          
    491              if (huart->MspInitCallback == NULL)
    492              {
    493                huart->MspInitCallback = HAL_UART_MspInit;
    494              }
    495          
    496              /* Init the low level hardware */
    497              huart->MspInitCallback(huart);
    498          #else
    499              /* Init the low level hardware : GPIO, CLOCK */
    500              HAL_UART_MspInit(huart);
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       HAL_UART_MspInit
    501          #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
    502            }
    503          
    504            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_LIN_Init_2: (+1)
   \       0x22   0x2024             MOVS     R0,#+36
   \       0x24   0xF884 0x0039      STRB     R0,[R4, #+57]
    505          
    506            /* Disable the peripheral */
    507            __HAL_UART_DISABLE(huart);
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x68C0             LDR      R0,[R0, #+12]
   \       0x2C   0xF430 0x5000      BICS     R0,R0,#0x2000
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x60C8             STR      R0,[R1, #+12]
    508          
    509            /* Set the UART Communication parameters */
    510            UART_SetConfig(huart);
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       UART_SetConfig
    511          
    512            /* In LIN mode, the following bits must be kept cleared:
    513               - CLKEN bits in the USART_CR2 register,
    514               - SCEN, HDSEL and IREN bits in the USART_CR3 register.*/
    515            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_CLKEN));
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x6900             LDR      R0,[R0, #+16]
   \       0x3E   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x42   0x6821             LDR      R1,[R4, #+0]
   \       0x44   0x6108             STR      R0,[R1, #+16]
    516            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x6940             LDR      R0,[R0, #+20]
   \       0x4A   0xF030 0x002A      BICS     R0,R0,#0x2A
   \       0x4E   0x6821             LDR      R1,[R4, #+0]
   \       0x50   0x6148             STR      R0,[R1, #+20]
    517          
    518            /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    519            SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x6900             LDR      R0,[R0, #+16]
   \       0x56   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \       0x5A   0x6821             LDR      R1,[R4, #+0]
   \       0x5C   0x6108             STR      R0,[R1, #+16]
    520          
    521            /* Set the USART LIN Break detection length. */
    522            CLEAR_BIT(huart->Instance->CR2, USART_CR2_LBDL);
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6900             LDR      R0,[R0, #+16]
   \       0x62   0xF030 0x0020      BICS     R0,R0,#0x20
   \       0x66   0x6821             LDR      R1,[R4, #+0]
   \       0x68   0x6108             STR      R0,[R1, #+16]
    523            SET_BIT(huart->Instance->CR2, BreakDetectLength);
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x6900             LDR      R0,[R0, #+16]
   \       0x6E   0x4328             ORRS     R0,R5,R0
   \       0x70   0x6821             LDR      R1,[R4, #+0]
   \       0x72   0x6108             STR      R0,[R1, #+16]
    524          
    525            /* Enable the peripheral */
    526            __HAL_UART_ENABLE(huart);
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x68C0             LDR      R0,[R0, #+12]
   \       0x78   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \       0x7C   0x6821             LDR      R1,[R4, #+0]
   \       0x7E   0x60C8             STR      R0,[R1, #+12]
    527          
    528            /* Initialize the UART state*/
    529            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0x63E0             STR      R0,[R4, #+60]
    530            huart->gState = HAL_UART_STATE_READY;
   \       0x84   0x2020             MOVS     R0,#+32
   \       0x86   0xF884 0x0039      STRB     R0,[R4, #+57]
    531            huart->RxState = HAL_UART_STATE_READY;
   \       0x8A   0x2020             MOVS     R0,#+32
   \       0x8C   0xF884 0x003A      STRB     R0,[R4, #+58]
    532          
    533            return HAL_OK;
   \       0x90   0x2000             MOVS     R0,#+0
   \                     ??HAL_LIN_Init_1: (+1)
   \       0x92   0xBD32             POP      {R1,R4,R5,PC}
    534          }
    535          
    536          /**
    537            * @brief  Initializes the Multi-Processor mode according to the specified
    538            *         parameters in the UART_InitTypeDef and create the associated handle.
    539            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
    540            *                the configuration information for the specified UART module.
    541            * @param  Address USART address
    542            * @param  WakeUpMethod specifies the USART wake-up method.
    543            *         This parameter can be one of the following values:
    544            *            @arg UART_WAKEUPMETHOD_IDLELINE: Wake-up by an idle line detection
    545            *            @arg UART_WAKEUPMETHOD_ADDRESSMARK: Wake-up by an address mark
    546            * @retval HAL status
    547            */

   \                                 In section .text, align 2, keep-with-next
    548          HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
    549          {
   \                     HAL_MultiProcessor_Init: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
    550            /* Check the UART handle allocation */
    551            if (huart == NULL)
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD101             BNE.N    ??HAL_MultiProcessor_Init_0
    552            {
    553              return HAL_ERROR;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE048             B.N      ??HAL_MultiProcessor_Init_1
    554            }
    555          
    556            /* Check the parameters */
    557            assert_param(IS_UART_INSTANCE(huart->Instance));
    558          
    559            /* Check the Address & wake up method parameters */
    560            assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
    561            assert_param(IS_UART_ADDRESS(Address));
    562            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    563            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    564          
    565            if (huart->gState == HAL_UART_STATE_RESET)
   \                     ??HAL_MultiProcessor_Init_0: (+1)
   \       0x10   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD105             BNE.N    ??HAL_MultiProcessor_Init_2
    566            {
    567              /* Allocate lock resource and initialize it */
    568              huart->Lock = HAL_UNLOCKED;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xF884 0x0038      STRB     R0,[R4, #+56]
    569          
    570          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    571              UART_InitCallbacksToDefault(huart);
    572          
    573              if (huart->MspInitCallback == NULL)
    574              {
    575                huart->MspInitCallback = HAL_UART_MspInit;
    576              }
    577          
    578              /* Init the low level hardware */
    579              huart->MspInitCallback(huart);
    580          #else
    581              /* Init the low level hardware : GPIO, CLOCK */
    582              HAL_UART_MspInit(huart);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       HAL_UART_MspInit
    583          #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
    584            }
    585          
    586            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_MultiProcessor_Init_2: (+1)
   \       0x24   0x2024             MOVS     R0,#+36
   \       0x26   0xF884 0x0039      STRB     R0,[R4, #+57]
    587          
    588            /* Disable the peripheral */
    589            __HAL_UART_DISABLE(huart);
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x68C0             LDR      R0,[R0, #+12]
   \       0x2E   0xF430 0x5000      BICS     R0,R0,#0x2000
   \       0x32   0x6821             LDR      R1,[R4, #+0]
   \       0x34   0x60C8             STR      R0,[R1, #+12]
    590          
    591            /* Set the UART Communication parameters */
    592            UART_SetConfig(huart);
   \       0x36   0x0020             MOVS     R0,R4
   \       0x38   0x.... 0x....      BL       UART_SetConfig
    593          
    594            /* In Multi-Processor mode, the following bits must be kept cleared:
    595               - LINEN and CLKEN bits in the USART_CR2 register,
    596               - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
    597            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x6900             LDR      R0,[R0, #+16]
   \       0x40   0xF430 0x4090      BICS     R0,R0,#0x4800
   \       0x44   0x6821             LDR      R1,[R4, #+0]
   \       0x46   0x6108             STR      R0,[R1, #+16]
    598            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x6940             LDR      R0,[R0, #+20]
   \       0x4C   0xF030 0x002A      BICS     R0,R0,#0x2A
   \       0x50   0x6821             LDR      R1,[R4, #+0]
   \       0x52   0x6148             STR      R0,[R1, #+20]
    599          
    600            /* Set the USART address node */
    601            CLEAR_BIT(huart->Instance->CR2, USART_CR2_ADD);
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x6900             LDR      R0,[R0, #+16]
   \       0x58   0x0900             LSRS     R0,R0,#+4
   \       0x5A   0x0100             LSLS     R0,R0,#+4
   \       0x5C   0x6821             LDR      R1,[R4, #+0]
   \       0x5E   0x6108             STR      R0,[R1, #+16]
    602            SET_BIT(huart->Instance->CR2, Address);
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x6901             LDR      R1,[R0, #+16]
   \       0x64   0x0028             MOVS     R0,R5
   \       0x66   0xB2C0             UXTB     R0,R0
   \       0x68   0x4301             ORRS     R1,R0,R1
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x6101             STR      R1,[R0, #+16]
    603          
    604            /* Set the wake up method by setting the WAKE bit in the CR1 register */
    605            CLEAR_BIT(huart->Instance->CR1, USART_CR1_WAKE);
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x68C0             LDR      R0,[R0, #+12]
   \       0x72   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x76   0x6821             LDR      R1,[R4, #+0]
   \       0x78   0x60C8             STR      R0,[R1, #+12]
    606            SET_BIT(huart->Instance->CR1, WakeUpMethod);
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x68C0             LDR      R0,[R0, #+12]
   \       0x7E   0x4330             ORRS     R0,R6,R0
   \       0x80   0x6821             LDR      R1,[R4, #+0]
   \       0x82   0x60C8             STR      R0,[R1, #+12]
    607          
    608            /* Enable the peripheral */
    609            __HAL_UART_ENABLE(huart);
   \       0x84   0x6820             LDR      R0,[R4, #+0]
   \       0x86   0x68C0             LDR      R0,[R0, #+12]
   \       0x88   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \       0x8C   0x6821             LDR      R1,[R4, #+0]
   \       0x8E   0x60C8             STR      R0,[R1, #+12]
    610          
    611            /* Initialize the UART state */
    612            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0x63E0             STR      R0,[R4, #+60]
    613            huart->gState = HAL_UART_STATE_READY;
   \       0x94   0x2020             MOVS     R0,#+32
   \       0x96   0xF884 0x0039      STRB     R0,[R4, #+57]
    614            huart->RxState = HAL_UART_STATE_READY;
   \       0x9A   0x2020             MOVS     R0,#+32
   \       0x9C   0xF884 0x003A      STRB     R0,[R4, #+58]
    615          
    616            return HAL_OK;
   \       0xA0   0x2000             MOVS     R0,#+0
   \                     ??HAL_MultiProcessor_Init_1: (+1)
   \       0xA2   0xBD70             POP      {R4-R6,PC}
    617          }
    618          
    619          /**
    620            * @brief  DeInitializes the UART peripheral.
    621            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
    622            *                the configuration information for the specified UART module.
    623            * @retval HAL status
    624            */

   \                                 In section .text, align 2, keep-with-next
    625          HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
    626          {
   \                     HAL_UART_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    627            /* Check the UART handle allocation */
    628            if (huart == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_UART_DeInit_0
    629            {
    630              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE017             B.N      ??HAL_UART_DeInit_1
    631            }
    632          
    633            /* Check the parameters */
    634            assert_param(IS_UART_INSTANCE(huart->Instance));
    635          
    636            huart->gState = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_DeInit_0: (+1)
   \        0xC   0x2024             MOVS     R0,#+36
   \        0xE   0xF884 0x0039      STRB     R0,[R4, #+57]
    637          
    638            /* Disable the Peripheral */
    639            __HAL_UART_DISABLE(huart);
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x68C0             LDR      R0,[R0, #+12]
   \       0x16   0xF430 0x5000      BICS     R0,R0,#0x2000
   \       0x1A   0x6821             LDR      R1,[R4, #+0]
   \       0x1C   0x60C8             STR      R0,[R1, #+12]
    640          
    641          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    642            if (huart->MspDeInitCallback == NULL)
    643            {
    644              huart->MspDeInitCallback = HAL_UART_MspDeInit;
    645            }
    646            /* DeInit the low level hardware */
    647            huart->MspDeInitCallback(huart);
    648          #else
    649            /* DeInit the low level hardware */
    650            HAL_UART_MspDeInit(huart);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       HAL_UART_MspDeInit
    651          #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
    652          
    653            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x63E0             STR      R0,[R4, #+60]
    654            huart->gState = HAL_UART_STATE_RESET;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xF884 0x0039      STRB     R0,[R4, #+57]
    655            huart->RxState = HAL_UART_STATE_RESET;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xF884 0x003A      STRB     R0,[R4, #+58]
    656          
    657            /* Process Unlock */
    658            __HAL_UNLOCK(huart);
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF884 0x0038      STRB     R0,[R4, #+56]
    659          
    660            return HAL_OK;
   \       0x3A   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DeInit_1: (+1)
   \       0x3C   0xBD10             POP      {R4,PC}
    661          }
    662          
    663          /**
    664            * @brief  UART MSP Init.
    665            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
    666            *                the configuration information for the specified UART module.
    667            * @retval None
    668            */

   \                                 In section .text, align 2
    669          __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
    670          {
    671            /* Prevent unused argument(s) compilation warning */
    672            UNUSED(huart);
    673            /* NOTE: This function should not be modified, when the callback is needed,
    674                     the HAL_UART_MspInit could be implemented in the user file
    675             */
    676          }
   \                     HAL_UART_MspInit: (+1)
   \        0x0   0x4770             BX       LR
    677          
    678          /**
    679            * @brief  UART MSP DeInit.
    680            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
    681            *                the configuration information for the specified UART module.
    682            * @retval None
    683            */

   \                                 In section .text, align 2
    684          __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
    685          {
    686            /* Prevent unused argument(s) compilation warning */
    687            UNUSED(huart);
    688            /* NOTE: This function should not be modified, when the callback is needed,
    689                     the HAL_UART_MspDeInit could be implemented in the user file
    690             */
    691          }
   \                     HAL_UART_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
    692          
    693          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    694          /**
    695            * @brief  Register a User UART Callback
    696            *         To be used instead of the weak predefined callback
    697            * @param  huart uart handle
    698            * @param  CallbackID ID of the callback to be registered
    699            *         This parameter can be one of the following values:
    700            *           @arg @ref HAL_UART_TX_HALFCOMPLETE_CB_ID Tx Half Complete Callback ID
    701            *           @arg @ref HAL_UART_TX_COMPLETE_CB_ID Tx Complete Callback ID
    702            *           @arg @ref HAL_UART_RX_HALFCOMPLETE_CB_ID Rx Half Complete Callback ID
    703            *           @arg @ref HAL_UART_RX_COMPLETE_CB_ID Rx Complete Callback ID
    704            *           @arg @ref HAL_UART_ERROR_CB_ID Error Callback ID
    705            *           @arg @ref HAL_UART_ABORT_COMPLETE_CB_ID Abort Complete Callback ID
    706            *           @arg @ref HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID Abort Transmit Complete Callback ID
    707            *           @arg @ref HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID Abort Receive Complete Callback ID
    708            *           @arg @ref HAL_UART_MSPINIT_CB_ID MspInit Callback ID
    709            *           @arg @ref HAL_UART_MSPDEINIT_CB_ID MspDeInit Callback ID
    710            * @param  pCallback pointer to the Callback function
    711            * @retval HAL status
    712            */
    713          HAL_StatusTypeDef HAL_UART_RegisterCallback(UART_HandleTypeDef *huart, HAL_UART_CallbackIDTypeDef CallbackID, pUART_CallbackTypeDef pCallback)
    714          {
    715            HAL_StatusTypeDef status = HAL_OK;
    716          
    717            if (pCallback == NULL)
    718            {
    719              /* Update the error code */
    720              huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
    721          
    722              return HAL_ERROR;
    723            }
    724            /* Process locked */
    725            __HAL_LOCK(huart);
    726          
    727            if (huart->gState == HAL_UART_STATE_READY)
    728            {
    729              switch (CallbackID)
    730              {
    731                case HAL_UART_TX_HALFCOMPLETE_CB_ID :
    732                  huart->TxHalfCpltCallback = pCallback;
    733                  break;
    734          
    735                case HAL_UART_TX_COMPLETE_CB_ID :
    736                  huart->TxCpltCallback = pCallback;
    737                  break;
    738          
    739                case HAL_UART_RX_HALFCOMPLETE_CB_ID :
    740                  huart->RxHalfCpltCallback = pCallback;
    741                  break;
    742          
    743                case HAL_UART_RX_COMPLETE_CB_ID :
    744                  huart->RxCpltCallback = pCallback;
    745                  break;
    746          
    747                case HAL_UART_ERROR_CB_ID :
    748                  huart->ErrorCallback = pCallback;
    749                  break;
    750          
    751                case HAL_UART_ABORT_COMPLETE_CB_ID :
    752                  huart->AbortCpltCallback = pCallback;
    753                  break;
    754          
    755                case HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID :
    756                  huart->AbortTransmitCpltCallback = pCallback;
    757                  break;
    758          
    759                case HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID :
    760                  huart->AbortReceiveCpltCallback = pCallback;
    761                  break;
    762          
    763                case HAL_UART_MSPINIT_CB_ID :
    764                  huart->MspInitCallback = pCallback;
    765                  break;
    766          
    767                case HAL_UART_MSPDEINIT_CB_ID :
    768                  huart->MspDeInitCallback = pCallback;
    769                  break;
    770          
    771                default :
    772                  /* Update the error code */
    773                  huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
    774          
    775                  /* Return error status */
    776                  status =  HAL_ERROR;
    777                  break;
    778              }
    779            }
    780            else if (huart->gState == HAL_UART_STATE_RESET)
    781            {
    782              switch (CallbackID)
    783              {
    784                case HAL_UART_MSPINIT_CB_ID :
    785                  huart->MspInitCallback = pCallback;
    786                  break;
    787          
    788                case HAL_UART_MSPDEINIT_CB_ID :
    789                  huart->MspDeInitCallback = pCallback;
    790                  break;
    791          
    792                default :
    793                  /* Update the error code */
    794                  huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
    795          
    796                  /* Return error status */
    797                  status =  HAL_ERROR;
    798                  break;
    799              }
    800            }
    801            else
    802            {
    803              /* Update the error code */
    804              huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
    805          
    806              /* Return error status */
    807              status =  HAL_ERROR;
    808            }
    809          
    810            /* Release Lock */
    811            __HAL_UNLOCK(huart);
    812          
    813            return status;
    814          }
    815          
    816          /**
    817            * @brief  Unregister an UART Callback
    818            *         UART callaback is redirected to the weak predefined callback
    819            * @param  huart uart handle
    820            * @param  CallbackID ID of the callback to be unregistered
    821            *         This parameter can be one of the following values:
    822            *           @arg @ref HAL_UART_TX_HALFCOMPLETE_CB_ID Tx Half Complete Callback ID
    823            *           @arg @ref HAL_UART_TX_COMPLETE_CB_ID Tx Complete Callback ID
    824            *           @arg @ref HAL_UART_RX_HALFCOMPLETE_CB_ID Rx Half Complete Callback ID
    825            *           @arg @ref HAL_UART_RX_COMPLETE_CB_ID Rx Complete Callback ID
    826            *           @arg @ref HAL_UART_ERROR_CB_ID Error Callback ID
    827            *           @arg @ref HAL_UART_ABORT_COMPLETE_CB_ID Abort Complete Callback ID
    828            *           @arg @ref HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID Abort Transmit Complete Callback ID
    829            *           @arg @ref HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID Abort Receive Complete Callback ID
    830            *           @arg @ref HAL_UART_MSPINIT_CB_ID MspInit Callback ID
    831            *           @arg @ref HAL_UART_MSPDEINIT_CB_ID MspDeInit Callback ID
    832            * @retval HAL status
    833            */
    834          HAL_StatusTypeDef HAL_UART_UnRegisterCallback(UART_HandleTypeDef *huart, HAL_UART_CallbackIDTypeDef CallbackID)
    835          {
    836            HAL_StatusTypeDef status = HAL_OK;
    837          
    838            /* Process locked */
    839            __HAL_LOCK(huart);
    840          
    841            if (HAL_UART_STATE_READY == huart->gState)
    842            {
    843              switch (CallbackID)
    844              {
    845                case HAL_UART_TX_HALFCOMPLETE_CB_ID :
    846                  huart->TxHalfCpltCallback = HAL_UART_TxHalfCpltCallback;               /* Legacy weak  TxHalfCpltCallback       */
    847                  break;
    848          
    849                case HAL_UART_TX_COMPLETE_CB_ID :
    850                  huart->TxCpltCallback = HAL_UART_TxCpltCallback;                       /* Legacy weak TxCpltCallback            */
    851                  break;
    852          
    853                case HAL_UART_RX_HALFCOMPLETE_CB_ID :
    854                  huart->RxHalfCpltCallback = HAL_UART_RxHalfCpltCallback;               /* Legacy weak RxHalfCpltCallback        */
    855                  break;
    856          
    857                case HAL_UART_RX_COMPLETE_CB_ID :
    858                  huart->RxCpltCallback = HAL_UART_RxCpltCallback;                       /* Legacy weak RxCpltCallback            */
    859                  break;
    860          
    861                case HAL_UART_ERROR_CB_ID :
    862                  huart->ErrorCallback = HAL_UART_ErrorCallback;                         /* Legacy weak ErrorCallback             */
    863                  break;
    864          
    865                case HAL_UART_ABORT_COMPLETE_CB_ID :
    866                  huart->AbortCpltCallback = HAL_UART_AbortCpltCallback;                 /* Legacy weak AbortCpltCallback         */
    867                  break;
    868          
    869                case HAL_UART_ABORT_TRANSMIT_COMPLETE_CB_ID :
    870                  huart->AbortTransmitCpltCallback = HAL_UART_AbortTransmitCpltCallback; /* Legacy weak AbortTransmitCpltCallback */
    871                  break;
    872          
    873                case HAL_UART_ABORT_RECEIVE_COMPLETE_CB_ID :
    874                  huart->AbortReceiveCpltCallback = HAL_UART_AbortReceiveCpltCallback;   /* Legacy weak AbortReceiveCpltCallback  */
    875                  break;
    876          
    877                case HAL_UART_MSPINIT_CB_ID :
    878                  huart->MspInitCallback = HAL_UART_MspInit;                             /* Legacy weak MspInitCallback           */
    879                  break;
    880          
    881                case HAL_UART_MSPDEINIT_CB_ID :
    882                  huart->MspDeInitCallback = HAL_UART_MspDeInit;                         /* Legacy weak MspDeInitCallback         */
    883                  break;
    884          
    885                default :
    886                  /* Update the error code */
    887                  huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
    888          
    889                  /* Return error status */
    890                  status =  HAL_ERROR;
    891                  break;
    892              }
    893            }
    894            else if (HAL_UART_STATE_RESET == huart->gState)
    895            {
    896              switch (CallbackID)
    897              {
    898                case HAL_UART_MSPINIT_CB_ID :
    899                  huart->MspInitCallback = HAL_UART_MspInit;
    900                  break;
    901          
    902                case HAL_UART_MSPDEINIT_CB_ID :
    903                  huart->MspDeInitCallback = HAL_UART_MspDeInit;
    904                  break;
    905          
    906                default :
    907                  /* Update the error code */
    908                  huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
    909          
    910                  /* Return error status */
    911                  status =  HAL_ERROR;
    912                  break;
    913              }
    914            }
    915            else
    916            {
    917              /* Update the error code */
    918              huart->ErrorCode |= HAL_UART_ERROR_INVALID_CALLBACK;
    919          
    920              /* Return error status */
    921              status =  HAL_ERROR;
    922            }
    923          
    924            /* Release Lock */
    925            __HAL_UNLOCK(huart);
    926          
    927            return status;
    928          }
    929          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
    930          
    931          /**
    932            * @}
    933            */
    934          
    935          /** @defgroup UART_Exported_Functions_Group2 IO operation functions
    936            *  @brief UART Transmit and Receive functions
    937            *
    938          @verbatim
    939           ===============================================================================
    940                                ##### IO operation functions #####
    941           ===============================================================================
    942              This subsection provides a set of functions allowing to manage the UART asynchronous
    943              and Half duplex data transfers.
    944          
    945              (#) There are two modes of transfer:
    946                 (+) Blocking mode: The communication is performed in polling mode.
    947                     The HAL status of all data processing is returned by the same function
    948                     after finishing transfer.
    949                 (+) Non-Blocking mode: The communication is performed using Interrupts
    950                     or DMA, these API's return the HAL status.
    951                     The end of the data processing will be indicated through the
    952                     dedicated UART IRQ when using Interrupt mode or the DMA IRQ when
    953                     using DMA mode.
    954                     The HAL_UART_TxCpltCallback(), HAL_UART_RxCpltCallback() user callbacks
    955                     will be executed respectively at the end of the transmit or receive process
    956                     The HAL_UART_ErrorCallback()user callback will be executed when a communication error is detected.
    957          
    958              (#) Blocking mode API's are :
    959                  (+) HAL_UART_Transmit()
    960                  (+) HAL_UART_Receive()
    961          
    962              (#) Non-Blocking mode API's with Interrupt are :
    963                  (+) HAL_UART_Transmit_IT()
    964                  (+) HAL_UART_Receive_IT()
    965                  (+) HAL_UART_IRQHandler()
    966          
    967              (#) Non-Blocking mode API's with DMA are :
    968                  (+) HAL_UART_Transmit_DMA()
    969                  (+) HAL_UART_Receive_DMA()
    970                  (+) HAL_UART_DMAPause()
    971                  (+) HAL_UART_DMAResume()
    972                  (+) HAL_UART_DMAStop()
    973          
    974              (#) A set of Transfer Complete Callbacks are provided in Non_Blocking mode:
    975                  (+) HAL_UART_TxHalfCpltCallback()
    976                  (+) HAL_UART_TxCpltCallback()
    977                  (+) HAL_UART_RxHalfCpltCallback()
    978                  (+) HAL_UART_RxCpltCallback()
    979                  (+) HAL_UART_ErrorCallback()
    980          
    981              (#) Non-Blocking mode transfers could be aborted using Abort API's :
    982                  (+) HAL_UART_Abort()
    983                  (+) HAL_UART_AbortTransmit()
    984                  (+) HAL_UART_AbortReceive()
    985                  (+) HAL_UART_Abort_IT()
    986                  (+) HAL_UART_AbortTransmit_IT()
    987                  (+) HAL_UART_AbortReceive_IT()
    988          
    989              (#) For Abort services based on interrupts (HAL_UART_Abortxxx_IT), a set of Abort Complete Callbacks are provided:
    990                  (+) HAL_UART_AbortCpltCallback()
    991                  (+) HAL_UART_AbortTransmitCpltCallback()
    992                  (+) HAL_UART_AbortReceiveCpltCallback()
    993          
    994              (#) In Non-Blocking mode transfers, possible errors are split into 2 categories.
    995                  Errors are handled as follows :
    996                 (+) Error is considered as Recoverable and non blocking : Transfer could go till end, but error severity is
    997                     to be evaluated by user : this concerns Frame Error, Parity Error or Noise Error in Interrupt mode reception .
    998                     Received character is then retrieved and stored in Rx buffer, Error code is set to allow user to identify error type,
    999                     and HAL_UART_ErrorCallback() user callback is executed. Transfer is kept ongoing on UART side.
   1000                     If user wants to abort it, Abort services should be called by user.
   1001                 (+) Error is considered as Blocking : Transfer could not be completed properly and is aborted.
   1002                     This concerns Overrun Error In Interrupt mode reception and all errors in DMA mode.
   1003                     Error code is set to allow user to identify error type, and HAL_UART_ErrorCallback() user callback is executed.
   1004          
   1005              -@- In the Half duplex communication, it is forbidden to run the transmit
   1006                  and receive process in parallel, the UART state HAL_UART_STATE_BUSY_TX_RX can't be useful.
   1007          
   1008          @endverbatim
   1009            * @{
   1010            */
   1011          
   1012          /**
   1013            * @brief  Sends an amount of data in blocking mode.
   1014            * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1015            *         the sent data is handled as a set of u16. In this case, Size must indicate the number
   1016            *         of u16 provided through pData.
   1017            * @param  huart Pointer to a UART_HandleTypeDef structure that contains
   1018            *               the configuration information for the specified UART module.
   1019            * @param  pData Pointer to data buffer (u8 or u16 data elements).
   1020            * @param  Size  Amount of data elements (u8 or u16) to be sent
   1021            * @param  Timeout Timeout duration
   1022            * @retval HAL status
   1023            */

   \                                 In section .text, align 2, keep-with-next
   1024          HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1025          {
   \                     HAL_UART_Transmit: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1026            uint16_t *tmp;
   1027            uint32_t tickstart = 0U;
   \        0xC   0xF05F 0x0A00      MOVS     R10,#+0
   1028          
   1029            /* Check that a Tx process is not already ongoing */
   1030            if (huart->gState == HAL_UART_STATE_READY)
   \       0x10   0xF895 0x0039      LDRB     R0,[R5, #+57]
   \       0x14   0x2820             CMP      R0,#+32
   \       0x16   0xD160             BNE.N    ??HAL_UART_Transmit_0
   1031            {
   1032              if ((pData == NULL) || (Size == 0U))
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD003             BEQ.N    ??HAL_UART_Transmit_1
   \       0x1C   0x0030             MOVS     R0,R6
   \       0x1E   0xB280             UXTH     R0,R0
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD101             BNE.N    ??HAL_UART_Transmit_2
   1033              {
   1034                return  HAL_ERROR;
   \                     ??HAL_UART_Transmit_1: (+1)
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xE059             B.N      ??HAL_UART_Transmit_3
   1035              }
   1036          
   1037              /* Process Locked */
   1038              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_2: (+1)
   \       0x28   0xF895 0x0038      LDRB     R0,[R5, #+56]
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD101             BNE.N    ??HAL_UART_Transmit_4
   \       0x30   0x2002             MOVS     R0,#+2
   \       0x32   0xE053             B.N      ??HAL_UART_Transmit_3
   \                     ??HAL_UART_Transmit_4: (+1)
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xF885 0x0038      STRB     R0,[R5, #+56]
   1039          
   1040              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x63E8             STR      R0,[R5, #+60]
   1041              huart->gState = HAL_UART_STATE_BUSY_TX;
   \       0x3E   0x2021             MOVS     R0,#+33
   \       0x40   0xF885 0x0039      STRB     R0,[R5, #+57]
   1042          
   1043              /* Init tickstart for timeout managment */
   1044              tickstart = HAL_GetTick();
   \       0x44   0x.... 0x....      BL       HAL_GetTick
   \       0x48   0x4681             MOV      R9,R0
   1045          
   1046              huart->TxXferSize = Size;
   \       0x4A   0x84AE             STRH     R6,[R5, #+36]
   1047              huart->TxXferCount = Size;
   \       0x4C   0x84EE             STRH     R6,[R5, #+38]
   1048          
   1049              /* Process Unlocked */
   1050              __HAL_UNLOCK(huart);
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xF885 0x0038      STRB     R0,[R5, #+56]
   1051          
   1052              while (huart->TxXferCount > 0U)
   \                     ??HAL_UART_Transmit_5: (+1)
   \       0x54   0x8CE8             LDRH     R0,[R5, #+38]
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD02F             BEQ.N    ??HAL_UART_Transmit_6
   1053              {
   1054                huart->TxXferCount--;
   \       0x5A   0x8CE8             LDRH     R0,[R5, #+38]
   \       0x5C   0x1E40             SUBS     R0,R0,#+1
   \       0x5E   0x84E8             STRH     R0,[R5, #+38]
   1055                if (huart->Init.WordLength == UART_WORDLENGTH_9B)
   \       0x60   0x68A8             LDR      R0,[R5, #+8]
   \       0x62   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x66   0xD118             BNE.N    ??HAL_UART_Transmit_7
   1056                {
   1057                  if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
   \       0x68   0x9700             STR      R7,[SP, #+0]
   \       0x6A   0x464B             MOV      R3,R9
   \       0x6C   0x2200             MOVS     R2,#+0
   \       0x6E   0x2180             MOVS     R1,#+128
   \       0x70   0x0028             MOVS     R0,R5
   \       0x72   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD001             BEQ.N    ??HAL_UART_Transmit_8
   1058                  {
   1059                    return HAL_TIMEOUT;
   \       0x7A   0x2003             MOVS     R0,#+3
   \       0x7C   0xE02E             B.N      ??HAL_UART_Transmit_3
   1060                  }
   1061                  tmp = (uint16_t *) pData;
   \                     ??HAL_UART_Transmit_8: (+1)
   \       0x7E   0x46A0             MOV      R8,R4
   1062                  huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
   \       0x80   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \       0x84   0x05C0             LSLS     R0,R0,#+23
   \       0x86   0x0DC0             LSRS     R0,R0,#+23
   \       0x88   0x6829             LDR      R1,[R5, #+0]
   \       0x8A   0x6048             STR      R0,[R1, #+4]
   1063                  if (huart->Init.Parity == UART_PARITY_NONE)
   \       0x8C   0x6928             LDR      R0,[R5, #+16]
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD101             BNE.N    ??HAL_UART_Transmit_9
   1064                  {
   1065                    pData += 2U;
   \       0x92   0x1CA4             ADDS     R4,R4,#+2
   \       0x94   0xE7DE             B.N      ??HAL_UART_Transmit_5
   1066                  }
   1067                  else
   1068                  {
   1069                    pData += 1U;
   \                     ??HAL_UART_Transmit_9: (+1)
   \       0x96   0x1C64             ADDS     R4,R4,#+1
   \       0x98   0xE7DC             B.N      ??HAL_UART_Transmit_5
   1070                  }
   1071                }
   1072                else
   1073                {
   1074                  if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
   \                     ??HAL_UART_Transmit_7: (+1)
   \       0x9A   0x9700             STR      R7,[SP, #+0]
   \       0x9C   0x464B             MOV      R3,R9
   \       0x9E   0x2200             MOVS     R2,#+0
   \       0xA0   0x2180             MOVS     R1,#+128
   \       0xA2   0x0028             MOVS     R0,R5
   \       0xA4   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD001             BEQ.N    ??HAL_UART_Transmit_10
   1075                  {
   1076                    return HAL_TIMEOUT;
   \       0xAC   0x2003             MOVS     R0,#+3
   \       0xAE   0xE015             B.N      ??HAL_UART_Transmit_3
   1077                  }
   1078                  huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
   \                     ??HAL_UART_Transmit_10: (+1)
   \       0xB0   0x7820             LDRB     R0,[R4, #+0]
   \       0xB2   0x6829             LDR      R1,[R5, #+0]
   \       0xB4   0x6048             STR      R0,[R1, #+4]
   \       0xB6   0x1C64             ADDS     R4,R4,#+1
   \       0xB8   0xE7CC             B.N      ??HAL_UART_Transmit_5
   1079                }
   1080              }
   1081          
   1082              if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
   \                     ??HAL_UART_Transmit_6: (+1)
   \       0xBA   0x9700             STR      R7,[SP, #+0]
   \       0xBC   0x464B             MOV      R3,R9
   \       0xBE   0x2200             MOVS     R2,#+0
   \       0xC0   0x2140             MOVS     R1,#+64
   \       0xC2   0x0028             MOVS     R0,R5
   \       0xC4   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xD001             BEQ.N    ??HAL_UART_Transmit_11
   1083              {
   1084                return HAL_TIMEOUT;
   \       0xCC   0x2003             MOVS     R0,#+3
   \       0xCE   0xE005             B.N      ??HAL_UART_Transmit_3
   1085              }
   1086          
   1087              /* At end of Tx process, restore huart->gState to Ready */
   1088              huart->gState = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Transmit_11: (+1)
   \       0xD0   0x2020             MOVS     R0,#+32
   \       0xD2   0xF885 0x0039      STRB     R0,[R5, #+57]
   1089          
   1090              return HAL_OK;
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0xE000             B.N      ??HAL_UART_Transmit_3
   1091            }
   1092            else
   1093            {
   1094              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_0: (+1)
   \       0xDA   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_3: (+1)
   \       0xDC   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   1095            }
   1096          }
   1097          
   1098          /**
   1099            * @brief  Receives an amount of data in blocking mode.
   1100            * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1101            *         the received data is handled as a set of u16. In this case, Size must indicate the number
   1102            *         of u16 available through pData.
   1103            * @param  huart Pointer to a UART_HandleTypeDef structure that contains
   1104            *               the configuration information for the specified UART module.
   1105            * @param  pData Pointer to data buffer (u8 or u16 data elements).
   1106            * @param  Size  Amount of data elements (u8 or u16) to be received.
   1107            * @param  Timeout Timeout duration
   1108            * @retval HAL status
   1109            */

   \                                 In section .text, align 2, keep-with-next
   1110          HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1111          {
   \                     HAL_UART_Receive: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1112            uint16_t *tmp;
   1113            uint32_t tickstart = 0U;
   \        0xC   0xF05F 0x0A00      MOVS     R10,#+0
   1114          
   1115            /* Check that a Rx process is not already ongoing */
   1116            if (huart->RxState == HAL_UART_STATE_READY)
   \       0x10   0xF895 0x003A      LDRB     R0,[R5, #+58]
   \       0x14   0x2820             CMP      R0,#+32
   \       0x16   0xD165             BNE.N    ??HAL_UART_Receive_0
   1117            {
   1118              if ((pData == NULL) || (Size == 0U))
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD003             BEQ.N    ??HAL_UART_Receive_1
   \       0x1C   0x0030             MOVS     R0,R6
   \       0x1E   0xB280             UXTH     R0,R0
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD101             BNE.N    ??HAL_UART_Receive_2
   1119              {
   1120                return  HAL_ERROR;
   \                     ??HAL_UART_Receive_1: (+1)
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xE05E             B.N      ??HAL_UART_Receive_3
   1121              }
   1122          
   1123              /* Process Locked */
   1124              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_2: (+1)
   \       0x28   0xF895 0x0038      LDRB     R0,[R5, #+56]
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD101             BNE.N    ??HAL_UART_Receive_4
   \       0x30   0x2002             MOVS     R0,#+2
   \       0x32   0xE058             B.N      ??HAL_UART_Receive_3
   \                     ??HAL_UART_Receive_4: (+1)
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xF885 0x0038      STRB     R0,[R5, #+56]
   1125          
   1126              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x63E8             STR      R0,[R5, #+60]
   1127              huart->RxState = HAL_UART_STATE_BUSY_RX;
   \       0x3E   0x2022             MOVS     R0,#+34
   \       0x40   0xF885 0x003A      STRB     R0,[R5, #+58]
   1128          
   1129              /* Init tickstart for timeout managment */
   1130              tickstart = HAL_GetTick();
   \       0x44   0x.... 0x....      BL       HAL_GetTick
   \       0x48   0x4681             MOV      R9,R0
   1131          
   1132              huart->RxXferSize = Size;
   \       0x4A   0x85AE             STRH     R6,[R5, #+44]
   1133              huart->RxXferCount = Size;
   \       0x4C   0x85EE             STRH     R6,[R5, #+46]
   1134          
   1135              /* Process Unlocked */
   1136              __HAL_UNLOCK(huart);
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xF885 0x0038      STRB     R0,[R5, #+56]
   1137          
   1138              /* Check the remain data to be received */
   1139              while (huart->RxXferCount > 0U)
   \                     ??HAL_UART_Receive_5: (+1)
   \       0x54   0x8DE8             LDRH     R0,[R5, #+46]
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD03F             BEQ.N    ??HAL_UART_Receive_6
   1140              {
   1141                huart->RxXferCount--;
   \       0x5A   0x8DE8             LDRH     R0,[R5, #+46]
   \       0x5C   0x1E40             SUBS     R0,R0,#+1
   \       0x5E   0x85E8             STRH     R0,[R5, #+46]
   1142                if (huart->Init.WordLength == UART_WORDLENGTH_9B)
   \       0x60   0x68A8             LDR      R0,[R5, #+8]
   \       0x62   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x66   0xD11E             BNE.N    ??HAL_UART_Receive_7
   1143                {
   1144                  if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
   \       0x68   0x9700             STR      R7,[SP, #+0]
   \       0x6A   0x464B             MOV      R3,R9
   \       0x6C   0x2200             MOVS     R2,#+0
   \       0x6E   0x2120             MOVS     R1,#+32
   \       0x70   0x0028             MOVS     R0,R5
   \       0x72   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD001             BEQ.N    ??HAL_UART_Receive_8
   1145                  {
   1146                    return HAL_TIMEOUT;
   \       0x7A   0x2003             MOVS     R0,#+3
   \       0x7C   0xE033             B.N      ??HAL_UART_Receive_3
   1147                  }
   1148                  tmp = (uint16_t *) pData;
   \                     ??HAL_UART_Receive_8: (+1)
   \       0x7E   0x46A0             MOV      R8,R4
   1149                  if (huart->Init.Parity == UART_PARITY_NONE)
   \       0x80   0x6928             LDR      R0,[R5, #+16]
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD107             BNE.N    ??HAL_UART_Receive_9
   1150                  {
   1151                    *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
   \       0x86   0x6828             LDR      R0,[R5, #+0]
   \       0x88   0x6840             LDR      R0,[R0, #+4]
   \       0x8A   0x05C0             LSLS     R0,R0,#+23
   \       0x8C   0x0DC0             LSRS     R0,R0,#+23
   \       0x8E   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   1152                    pData += 2U;
   \       0x92   0x1CA4             ADDS     R4,R4,#+2
   \       0x94   0xE7DE             B.N      ??HAL_UART_Receive_5
   1153                  }
   1154                  else
   1155                  {
   1156                    *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
   \                     ??HAL_UART_Receive_9: (+1)
   \       0x96   0x6828             LDR      R0,[R5, #+0]
   \       0x98   0x6840             LDR      R0,[R0, #+4]
   \       0x9A   0xF000 0x00FF      AND      R0,R0,#0xFF
   \       0x9E   0xF8A8 0x0000      STRH     R0,[R8, #+0]
   1157                    pData += 1U;
   \       0xA2   0x1C64             ADDS     R4,R4,#+1
   \       0xA4   0xE7D6             B.N      ??HAL_UART_Receive_5
   1158                  }
   1159          
   1160                }
   1161                else
   1162                {
   1163                  if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
   \                     ??HAL_UART_Receive_7: (+1)
   \       0xA6   0x9700             STR      R7,[SP, #+0]
   \       0xA8   0x464B             MOV      R3,R9
   \       0xAA   0x2200             MOVS     R2,#+0
   \       0xAC   0x2120             MOVS     R1,#+32
   \       0xAE   0x0028             MOVS     R0,R5
   \       0xB0   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD001             BEQ.N    ??HAL_UART_Receive_10
   1164                  {
   1165                    return HAL_TIMEOUT;
   \       0xB8   0x2003             MOVS     R0,#+3
   \       0xBA   0xE014             B.N      ??HAL_UART_Receive_3
   1166                  }
   1167                  if (huart->Init.Parity == UART_PARITY_NONE)
   \                     ??HAL_UART_Receive_10: (+1)
   \       0xBC   0x6928             LDR      R0,[R5, #+16]
   \       0xBE   0x2800             CMP      R0,#+0
   \       0xC0   0xD104             BNE.N    ??HAL_UART_Receive_11
   1168                  {
   1169                    *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
   \       0xC2   0x6828             LDR      R0,[R5, #+0]
   \       0xC4   0x6840             LDR      R0,[R0, #+4]
   \       0xC6   0x7020             STRB     R0,[R4, #+0]
   \       0xC8   0x1C64             ADDS     R4,R4,#+1
   \       0xCA   0xE7C3             B.N      ??HAL_UART_Receive_5
   1170                  }
   1171                  else
   1172                  {
   1173                    *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
   \                     ??HAL_UART_Receive_11: (+1)
   \       0xCC   0x6828             LDR      R0,[R5, #+0]
   \       0xCE   0x6840             LDR      R0,[R0, #+4]
   \       0xD0   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \       0xD4   0x7020             STRB     R0,[R4, #+0]
   \       0xD6   0x1C64             ADDS     R4,R4,#+1
   \       0xD8   0xE7BC             B.N      ??HAL_UART_Receive_5
   1174                  }
   1175          
   1176                }
   1177              }
   1178          
   1179              /* At end of Rx process, restore huart->RxState to Ready */
   1180              huart->RxState = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Receive_6: (+1)
   \       0xDA   0x2020             MOVS     R0,#+32
   \       0xDC   0xF885 0x003A      STRB     R0,[R5, #+58]
   1181          
   1182              return HAL_OK;
   \       0xE0   0x2000             MOVS     R0,#+0
   \       0xE2   0xE000             B.N      ??HAL_UART_Receive_3
   1183            }
   1184            else
   1185            {
   1186              return HAL_BUSY;
   \                     ??HAL_UART_Receive_0: (+1)
   \       0xE4   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_3: (+1)
   \       0xE6   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   1187            }
   1188          }
   1189          
   1190          /**
   1191            * @brief  Sends an amount of data in non blocking mode.
   1192            * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1193            *         the sent data is handled as a set of u16. In this case, Size must indicate the number
   1194            *         of u16 provided through pData.
   1195            * @param  huart Pointer to a UART_HandleTypeDef structure that contains
   1196            *               the configuration information for the specified UART module.
   1197            * @param  pData Pointer to data buffer (u8 or u16 data elements).
   1198            * @param  Size  Amount of data elements (u8 or u16) to be sent
   1199            * @retval HAL status
   1200            */

   \                                 In section .text, align 2, keep-with-next
   1201          HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
   1202          {
   \                     HAL_UART_Transmit_IT: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0003             MOVS     R3,R0
   1203            /* Check that a Tx process is not already ongoing */
   1204            if (huart->gState == HAL_UART_STATE_READY)
   \        0x4   0xF893 0x0039      LDRB     R0,[R3, #+57]
   \        0x8   0x2820             CMP      R0,#+32
   \        0xA   0xD123             BNE.N    ??HAL_UART_Transmit_IT_0
   1205            {
   1206              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD003             BEQ.N    ??HAL_UART_Transmit_IT_1
   \       0x10   0x0010             MOVS     R0,R2
   \       0x12   0xB280             UXTH     R0,R0
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??HAL_UART_Transmit_IT_2
   1207              {
   1208                return HAL_ERROR;
   \                     ??HAL_UART_Transmit_IT_1: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE01C             B.N      ??HAL_UART_Transmit_IT_3
   1209              }
   1210          
   1211              /* Process Locked */
   1212              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_IT_2: (+1)
   \       0x1C   0xF893 0x0038      LDRB     R0,[R3, #+56]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD101             BNE.N    ??HAL_UART_Transmit_IT_4
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0xE016             B.N      ??HAL_UART_Transmit_IT_3
   \                     ??HAL_UART_Transmit_IT_4: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xF883 0x0038      STRB     R0,[R3, #+56]
   1213          
   1214              huart->pTxBuffPtr = pData;
   \       0x2E   0x6219             STR      R1,[R3, #+32]
   1215              huart->TxXferSize = Size;
   \       0x30   0x849A             STRH     R2,[R3, #+36]
   1216              huart->TxXferCount = Size;
   \       0x32   0x84DA             STRH     R2,[R3, #+38]
   1217          
   1218              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x63D8             STR      R0,[R3, #+60]
   1219              huart->gState = HAL_UART_STATE_BUSY_TX;
   \       0x38   0x2021             MOVS     R0,#+33
   \       0x3A   0xF883 0x0039      STRB     R0,[R3, #+57]
   1220          
   1221              /* Process Unlocked */
   1222              __HAL_UNLOCK(huart);
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xF883 0x0038      STRB     R0,[R3, #+56]
   1223          
   1224              /* Enable the UART Transmit data register empty Interrupt */
   1225              __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
   \       0x44   0x6818             LDR      R0,[R3, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0xF050 0x0080      ORRS     R0,R0,#0x80
   \       0x4C   0x681C             LDR      R4,[R3, #+0]
   \       0x4E   0x60E0             STR      R0,[R4, #+12]
   1226          
   1227              return HAL_OK;
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xE000             B.N      ??HAL_UART_Transmit_IT_3
   1228            }
   1229            else
   1230            {
   1231              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_IT_0: (+1)
   \       0x54   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_IT_3: (+1)
   \       0x56   0xBC10             POP      {R4}
   \       0x58   0x4770             BX       LR
   1232            }
   1233          }
   1234          
   1235          /**
   1236            * @brief  Receives an amount of data in non blocking mode.
   1237            * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1238            *         the received data is handled as a set of u16. In this case, Size must indicate the number
   1239            *         of u16 available through pData.
   1240            * @param  huart Pointer to a UART_HandleTypeDef structure that contains
   1241            *               the configuration information for the specified UART module.
   1242            * @param  pData Pointer to data buffer (u8 or u16 data elements).
   1243            * @param  Size  Amount of data elements (u8 or u16) to be received.
   1244            * @retval HAL status
   1245            */

   \                                 In section .text, align 2, keep-with-next
   1246          HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
   1247          {
   \                     HAL_UART_Receive_IT: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0003             MOVS     R3,R0
   1248            /* Check that a Rx process is not already ongoing */
   1249            if (huart->RxState == HAL_UART_STATE_READY)
   \        0x4   0xF893 0x003A      LDRB     R0,[R3, #+58]
   \        0x8   0x2820             CMP      R0,#+32
   \        0xA   0xD12F             BNE.N    ??HAL_UART_Receive_IT_0
   1250            {
   1251              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD003             BEQ.N    ??HAL_UART_Receive_IT_1
   \       0x10   0x0010             MOVS     R0,R2
   \       0x12   0xB280             UXTH     R0,R0
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??HAL_UART_Receive_IT_2
   1252              {
   1253                return HAL_ERROR;
   \                     ??HAL_UART_Receive_IT_1: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE028             B.N      ??HAL_UART_Receive_IT_3
   1254              }
   1255          
   1256              /* Process Locked */
   1257              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_IT_2: (+1)
   \       0x1C   0xF893 0x0038      LDRB     R0,[R3, #+56]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD101             BNE.N    ??HAL_UART_Receive_IT_4
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0xE022             B.N      ??HAL_UART_Receive_IT_3
   \                     ??HAL_UART_Receive_IT_4: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xF883 0x0038      STRB     R0,[R3, #+56]
   1258          
   1259              huart->pRxBuffPtr = pData;
   \       0x2E   0x6299             STR      R1,[R3, #+40]
   1260              huart->RxXferSize = Size;
   \       0x30   0x859A             STRH     R2,[R3, #+44]
   1261              huart->RxXferCount = Size;
   \       0x32   0x85DA             STRH     R2,[R3, #+46]
   1262          
   1263              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x63D8             STR      R0,[R3, #+60]
   1264              huart->RxState = HAL_UART_STATE_BUSY_RX;
   \       0x38   0x2022             MOVS     R0,#+34
   \       0x3A   0xF883 0x003A      STRB     R0,[R3, #+58]
   1265          
   1266              /* Process Unlocked */
   1267              __HAL_UNLOCK(huart);
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xF883 0x0038      STRB     R0,[R3, #+56]
   1268          
   1269              /* Enable the UART Parity Error Interrupt */
   1270              __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
   \       0x44   0x6818             LDR      R0,[R3, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x4C   0x681C             LDR      R4,[R3, #+0]
   \       0x4E   0x60E0             STR      R0,[R4, #+12]
   1271          
   1272              /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   1273              __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
   \       0x50   0x6818             LDR      R0,[R3, #+0]
   \       0x52   0x6940             LDR      R0,[R0, #+20]
   \       0x54   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x58   0x681C             LDR      R4,[R3, #+0]
   \       0x5A   0x6160             STR      R0,[R4, #+20]
   1274          
   1275              /* Enable the UART Data Register not empty Interrupt */
   1276              __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
   \       0x5C   0x6818             LDR      R0,[R3, #+0]
   \       0x5E   0x68C0             LDR      R0,[R0, #+12]
   \       0x60   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x64   0x681C             LDR      R4,[R3, #+0]
   \       0x66   0x60E0             STR      R0,[R4, #+12]
   1277          
   1278              return HAL_OK;
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xE000             B.N      ??HAL_UART_Receive_IT_3
   1279            }
   1280            else
   1281            {
   1282              return HAL_BUSY;
   \                     ??HAL_UART_Receive_IT_0: (+1)
   \       0x6C   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_IT_3: (+1)
   \       0x6E   0xBC10             POP      {R4}
   \       0x70   0x4770             BX       LR
   1283            }
   1284          }
   1285          
   1286          /**
   1287            * @brief  Sends an amount of data in DMA mode.
   1288            * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1289            *         the sent data is handled as a set of u16. In this case, Size must indicate the number
   1290            *         of u16 provided through pData.
   1291            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   1292            *                the configuration information for the specified UART module.
   1293            * @param  pData Pointer to data buffer (u8 or u16 data elements).
   1294            * @param  Size  Amount of data elements (u8 or u16) to be sent
   1295            * @retval HAL status
   1296            */

   \                                 In section .text, align 2, keep-with-next
   1297          HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
   1298          {
   \                     HAL_UART_Transmit_DMA: (+1)
   \        0x0   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0015             MOVS     R5,R2
   1299            uint32_t *tmp;
   1300          
   1301            /* Check that a Tx process is not already ongoing */
   1302            if (huart->gState == HAL_UART_STATE_READY)
   \        0x6   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \        0xA   0x2820             CMP      R0,#+32
   \        0xC   0xD141             BNE.N    ??HAL_UART_Transmit_DMA_0
   1303            {
   1304              if ((pData == NULL) || (Size == 0U))
   \        0xE   0x9801             LDR      R0,[SP, #+4]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD003             BEQ.N    ??HAL_UART_Transmit_DMA_1
   \       0x14   0x0028             MOVS     R0,R5
   \       0x16   0xB280             UXTH     R0,R0
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_2
   1305              {
   1306                return HAL_ERROR;
   \                     ??HAL_UART_Transmit_DMA_1: (+1)
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE039             B.N      ??HAL_UART_Transmit_DMA_3
   1307              }
   1308          
   1309              /* Process Locked */
   1310              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_DMA_2: (+1)
   \       0x20   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_4
   \       0x28   0x2002             MOVS     R0,#+2
   \       0x2A   0xE033             B.N      ??HAL_UART_Transmit_DMA_3
   \                     ??HAL_UART_Transmit_DMA_4: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xF884 0x0038      STRB     R0,[R4, #+56]
   1311          
   1312              huart->pTxBuffPtr = pData;
   \       0x32   0x9801             LDR      R0,[SP, #+4]
   \       0x34   0x6220             STR      R0,[R4, #+32]
   1313              huart->TxXferSize = Size;
   \       0x36   0x84A5             STRH     R5,[R4, #+36]
   1314              huart->TxXferCount = Size;
   \       0x38   0x84E5             STRH     R5,[R4, #+38]
   1315          
   1316              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x63E0             STR      R0,[R4, #+60]
   1317              huart->gState = HAL_UART_STATE_BUSY_TX;
   \       0x3E   0x2021             MOVS     R0,#+33
   \       0x40   0xF884 0x0039      STRB     R0,[R4, #+57]
   1318          
   1319              /* Set the UART DMA transfer complete callback */
   1320              huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
   \       0x44   0x.... 0x....      ADR.W    R0,UART_DMATransmitCplt
   \       0x48   0x6B21             LDR      R1,[R4, #+48]
   \       0x4A   0x63C8             STR      R0,[R1, #+60]
   1321          
   1322              /* Set the UART DMA Half transfer complete callback */
   1323              huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
   \       0x4C   0x.... 0x....      ADR.W    R0,UART_DMATxHalfCplt
   \       0x50   0x6B21             LDR      R1,[R4, #+48]
   \       0x52   0x6408             STR      R0,[R1, #+64]
   1324          
   1325              /* Set the DMA error callback */
   1326              huart->hdmatx->XferErrorCallback = UART_DMAError;
   \       0x54   0x.... 0x....      ADR.W    R0,UART_DMAError
   \       0x58   0x6B21             LDR      R1,[R4, #+48]
   \       0x5A   0x64C8             STR      R0,[R1, #+76]
   1327          
   1328              /* Set the DMA abort callback */
   1329              huart->hdmatx->XferAbortCallback = NULL;
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x6B21             LDR      R1,[R4, #+48]
   \       0x60   0x6508             STR      R0,[R1, #+80]
   1330          
   1331              /* Enable the UART transmit DMA stream */
   1332              tmp = (uint32_t *)&pData;
   \       0x62   0xAE01             ADD      R6,SP,#+4
   1333              HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t *)tmp, (uint32_t)&huart->Instance->DR, Size);
   \       0x64   0x002B             MOVS     R3,R5
   \       0x66   0xB29B             UXTH     R3,R3
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x1D02             ADDS     R2,R0,#+4
   \       0x6C   0x6831             LDR      R1,[R6, #+0]
   \       0x6E   0x6B20             LDR      R0,[R4, #+48]
   \       0x70   0x.... 0x....      BL       HAL_DMA_Start_IT
   1334          
   1335              /* Clear the TC flag in the SR register by writing 0 to it */
   1336              __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
   \       0x74   0xF07F 0x0040      MVNS     R0,#+64
   \       0x78   0x6821             LDR      R1,[R4, #+0]
   \       0x7A   0x6008             STR      R0,[R1, #+0]
   1337          
   1338              /* Process Unlocked */
   1339              __HAL_UNLOCK(huart);
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0xF884 0x0038      STRB     R0,[R4, #+56]
   1340          
   1341              /* Enable the DMA transfer for transmit request by setting the DMAT bit
   1342                 in the UART CR3 register */
   1343              SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \       0x82   0x6820             LDR      R0,[R4, #+0]
   \       0x84   0x6940             LDR      R0,[R0, #+20]
   \       0x86   0xF050 0x0080      ORRS     R0,R0,#0x80
   \       0x8A   0x6821             LDR      R1,[R4, #+0]
   \       0x8C   0x6148             STR      R0,[R1, #+20]
   1344          
   1345              return HAL_OK;
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0xE000             B.N      ??HAL_UART_Transmit_DMA_3
   1346            }
   1347            else
   1348            {
   1349              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_DMA_0: (+1)
   \       0x92   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_DMA_3: (+1)
   \       0x94   0xBD76             POP      {R1,R2,R4-R6,PC}
   1350            }
   1351          }
   1352          
   1353          /**
   1354            * @brief  Receives an amount of data in DMA mode.
   1355            * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-M0 = 01),
   1356            *         the received data is handled as a set of u16. In this case, Size must indicate the number
   1357            *         of u16 available through pData.
   1358            * @param  huart Pointer to a UART_HandleTypeDef structure that contains
   1359            *               the configuration information for the specified UART module.
   1360            * @param  pData Pointer to data buffer (u8 or u16 data elements).
   1361            * @param  Size  Amount of data elements (u8 or u16) to be received.
   1362            * @note   When the UART parity is enabled (PCE = 1) the received data contains the parity bit.
   1363            * @retval HAL status
   1364            */

   \                                 In section .text, align 2, keep-with-next
   1365          HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
   1366          {
   \                     HAL_UART_Receive_DMA: (+1)
   \        0x0   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0015             MOVS     R5,R2
   1367            uint32_t *tmp;
   1368          
   1369            /* Check that a Rx process is not already ongoing */
   1370            if (huart->RxState == HAL_UART_STATE_READY)
   \        0x6   0xF894 0x003A      LDRB     R0,[R4, #+58]
   \        0xA   0x2820             CMP      R0,#+32
   \        0xC   0xD151             BNE.N    ??HAL_UART_Receive_DMA_0
   1371            {
   1372              if ((pData == NULL) || (Size == 0U))
   \        0xE   0x9801             LDR      R0,[SP, #+4]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD003             BEQ.N    ??HAL_UART_Receive_DMA_1
   \       0x14   0x0028             MOVS     R0,R5
   \       0x16   0xB280             UXTH     R0,R0
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD101             BNE.N    ??HAL_UART_Receive_DMA_2
   1373              {
   1374                return HAL_ERROR;
   \                     ??HAL_UART_Receive_DMA_1: (+1)
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE049             B.N      ??HAL_UART_Receive_DMA_3
   1375              }
   1376          
   1377              /* Process Locked */
   1378              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_DMA_2: (+1)
   \       0x20   0xF894 0x0038      LDRB     R0,[R4, #+56]
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xD101             BNE.N    ??HAL_UART_Receive_DMA_4
   \       0x28   0x2002             MOVS     R0,#+2
   \       0x2A   0xE043             B.N      ??HAL_UART_Receive_DMA_3
   \                     ??HAL_UART_Receive_DMA_4: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xF884 0x0038      STRB     R0,[R4, #+56]
   1379          
   1380              huart->pRxBuffPtr = pData;
   \       0x32   0x9801             LDR      R0,[SP, #+4]
   \       0x34   0x62A0             STR      R0,[R4, #+40]
   1381              huart->RxXferSize = Size;
   \       0x36   0x85A5             STRH     R5,[R4, #+44]
   1382          
   1383              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x63E0             STR      R0,[R4, #+60]
   1384              huart->RxState = HAL_UART_STATE_BUSY_RX;
   \       0x3C   0x2022             MOVS     R0,#+34
   \       0x3E   0xF884 0x003A      STRB     R0,[R4, #+58]
   1385          
   1386              /* Set the UART DMA transfer complete callback */
   1387              huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
   \       0x42   0x.... 0x....      ADR.W    R0,UART_DMAReceiveCplt
   \       0x46   0x6B61             LDR      R1,[R4, #+52]
   \       0x48   0x63C8             STR      R0,[R1, #+60]
   1388          
   1389              /* Set the UART DMA Half transfer complete callback */
   1390              huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
   \       0x4A   0x.... 0x....      ADR.W    R0,UART_DMARxHalfCplt
   \       0x4E   0x6B61             LDR      R1,[R4, #+52]
   \       0x50   0x6408             STR      R0,[R1, #+64]
   1391          
   1392              /* Set the DMA error callback */
   1393              huart->hdmarx->XferErrorCallback = UART_DMAError;
   \       0x52   0x.... 0x....      ADR.W    R0,UART_DMAError
   \       0x56   0x6B61             LDR      R1,[R4, #+52]
   \       0x58   0x64C8             STR      R0,[R1, #+76]
   1394          
   1395              /* Set the DMA abort callback */
   1396              huart->hdmarx->XferAbortCallback = NULL;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x6B61             LDR      R1,[R4, #+52]
   \       0x5E   0x6508             STR      R0,[R1, #+80]
   1397          
   1398              /* Enable the DMA stream */
   1399              tmp = (uint32_t *)&pData;
   \       0x60   0xAE01             ADD      R6,SP,#+4
   1400              HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t *)tmp, Size);
   \       0x62   0x002B             MOVS     R3,R5
   \       0x64   0xB29B             UXTH     R3,R3
   \       0x66   0x6832             LDR      R2,[R6, #+0]
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x1D01             ADDS     R1,R0,#+4
   \       0x6C   0x6B60             LDR      R0,[R4, #+52]
   \       0x6E   0x.... 0x....      BL       HAL_DMA_Start_IT
   1401          
   1402              /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
   1403              __HAL_UART_CLEAR_OREFLAG(huart);
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0x9000             STR      R0,[SP, #+0]
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x6800             LDR      R0,[R0, #+0]
   \       0x7A   0x9000             STR      R0,[SP, #+0]
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x6840             LDR      R0,[R0, #+4]
   \       0x80   0x9000             STR      R0,[SP, #+0]
   \       0x82   0x9800             LDR      R0,[SP, #+0]
   1404          
   1405              /* Process Unlocked */
   1406              __HAL_UNLOCK(huart);
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0xF884 0x0038      STRB     R0,[R4, #+56]
   1407          
   1408              /* Enable the UART Parity Error Interrupt */
   1409              SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \       0x8A   0x6820             LDR      R0,[R4, #+0]
   \       0x8C   0x68C0             LDR      R0,[R0, #+12]
   \       0x8E   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x92   0x6821             LDR      R1,[R4, #+0]
   \       0x94   0x60C8             STR      R0,[R1, #+12]
   1410          
   1411              /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   1412              SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \       0x96   0x6820             LDR      R0,[R4, #+0]
   \       0x98   0x6940             LDR      R0,[R0, #+20]
   \       0x9A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x9E   0x6821             LDR      R1,[R4, #+0]
   \       0xA0   0x6148             STR      R0,[R1, #+20]
   1413          
   1414              /* Enable the DMA transfer for the receiver request by setting the DMAR bit
   1415              in the UART CR3 register */
   1416              SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \       0xA2   0x6820             LDR      R0,[R4, #+0]
   \       0xA4   0x6940             LDR      R0,[R0, #+20]
   \       0xA6   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0xAA   0x6821             LDR      R1,[R4, #+0]
   \       0xAC   0x6148             STR      R0,[R1, #+20]
   1417          
   1418              return HAL_OK;
   \       0xAE   0x2000             MOVS     R0,#+0
   \       0xB0   0xE000             B.N      ??HAL_UART_Receive_DMA_3
   1419            }
   1420            else
   1421            {
   1422              return HAL_BUSY;
   \                     ??HAL_UART_Receive_DMA_0: (+1)
   \       0xB2   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_DMA_3: (+1)
   \       0xB4   0xBD76             POP      {R1,R2,R4-R6,PC}
   1423            }
   1424          }
   1425          
   1426          /**
   1427            * @brief Pauses the DMA Transfer.
   1428            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   1429            *                the configuration information for the specified UART module.
   1430            * @retval HAL status
   1431            */

   \                                 In section .text, align 2, keep-with-next
   1432          HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
   1433          {
   \                     HAL_UART_DMAPause: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   1434            uint32_t dmarequest = 0x00U;
   \        0x2   0x2100             MOVS     R1,#+0
   1435          
   1436            /* Process Locked */
   1437            __HAL_LOCK(huart);
   \        0x4   0xF892 0x0038      LDRB     R0,[R2, #+56]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE.N    ??HAL_UART_DMAPause_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE034             B.N      ??HAL_UART_DMAPause_1
   \                     ??HAL_UART_DMAPause_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xF882 0x0038      STRB     R0,[R2, #+56]
   1438          
   1439            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
   \       0x16   0x6810             LDR      R0,[R2, #+0]
   \       0x18   0x6940             LDR      R0,[R0, #+20]
   \       0x1A   0x09C0             LSRS     R0,R0,#+7
   \       0x1C   0xF010 0x0001      ANDS     R0,R0,#0x1
   1440            if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
   \       0x20   0xF892 0x3039      LDRB     R3,[R2, #+57]
   \       0x24   0x2B21             CMP      R3,#+33
   \       0x26   0xD107             BNE.N    ??HAL_UART_DMAPause_2
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD005             BEQ.N    ??HAL_UART_DMAPause_2
   1441            {
   1442              /* Disable the UART DMA Tx request */
   1443              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \       0x2C   0x6811             LDR      R1,[R2, #+0]
   \       0x2E   0x6949             LDR      R1,[R1, #+20]
   \       0x30   0xF031 0x0180      BICS     R1,R1,#0x80
   \       0x34   0x6813             LDR      R3,[R2, #+0]
   \       0x36   0x6159             STR      R1,[R3, #+20]
   1444            }
   1445          
   1446            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_DMAPause_2: (+1)
   \       0x38   0x6811             LDR      R1,[R2, #+0]
   \       0x3A   0x6949             LDR      R1,[R1, #+20]
   \       0x3C   0x0989             LSRS     R1,R1,#+6
   \       0x3E   0xF011 0x0101      ANDS     R1,R1,#0x1
   1447            if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
   \       0x42   0xF892 0x303A      LDRB     R3,[R2, #+58]
   \       0x46   0x2B22             CMP      R3,#+34
   \       0x48   0xD113             BNE.N    ??HAL_UART_DMAPause_3
   \       0x4A   0x2900             CMP      R1,#+0
   \       0x4C   0xD011             BEQ.N    ??HAL_UART_DMAPause_3
   1448            {
   1449              /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   1450              CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \       0x4E   0x6810             LDR      R0,[R2, #+0]
   \       0x50   0x68C0             LDR      R0,[R0, #+12]
   \       0x52   0xF430 0x7080      BICS     R0,R0,#0x100
   \       0x56   0x6813             LDR      R3,[R2, #+0]
   \       0x58   0x60D8             STR      R0,[R3, #+12]
   1451              CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \       0x5A   0x6810             LDR      R0,[R2, #+0]
   \       0x5C   0x6940             LDR      R0,[R0, #+20]
   \       0x5E   0x0840             LSRS     R0,R0,#+1
   \       0x60   0x0040             LSLS     R0,R0,#+1
   \       0x62   0x6813             LDR      R3,[R2, #+0]
   \       0x64   0x6158             STR      R0,[R3, #+20]
   1452          
   1453              /* Disable the UART DMA Rx request */
   1454              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \       0x66   0x6810             LDR      R0,[R2, #+0]
   \       0x68   0x6940             LDR      R0,[R0, #+20]
   \       0x6A   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x6E   0x6813             LDR      R3,[R2, #+0]
   \       0x70   0x6158             STR      R0,[R3, #+20]
   1455            }
   1456          
   1457            /* Process Unlocked */
   1458            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAPause_3: (+1)
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0xF882 0x0038      STRB     R0,[R2, #+56]
   1459          
   1460            return HAL_OK;
   \       0x78   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DMAPause_1: (+1)
   \       0x7A   0x4770             BX       LR
   1461          }
   1462          
   1463          /**
   1464            * @brief Resumes the DMA Transfer.
   1465            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   1466            *                the configuration information for the specified UART module.
   1467            * @retval HAL status
   1468            */

   \                                 In section .text, align 2, keep-with-next
   1469          HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
   1470          {
   \                     HAL_UART_DMAResume: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x0001             MOVS     R1,R0
   1471            /* Process Locked */
   1472            __HAL_LOCK(huart);
   \        0x4   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE.N    ??HAL_UART_DMAResume_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE02F             B.N      ??HAL_UART_DMAResume_1
   \                     ??HAL_UART_DMAResume_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xF881 0x0038      STRB     R0,[R1, #+56]
   1473          
   1474            if (huart->gState == HAL_UART_STATE_BUSY_TX)
   \       0x16   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \       0x1A   0x2821             CMP      R0,#+33
   \       0x1C   0xD105             BNE.N    ??HAL_UART_DMAResume_2
   1475            {
   1476              /* Enable the UART DMA Tx request */
   1477              SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \       0x1E   0x6808             LDR      R0,[R1, #+0]
   \       0x20   0x6940             LDR      R0,[R0, #+20]
   \       0x22   0xF050 0x0080      ORRS     R0,R0,#0x80
   \       0x26   0x680A             LDR      R2,[R1, #+0]
   \       0x28   0x6150             STR      R0,[R2, #+20]
   1478            }
   1479          
   1480            if (huart->RxState == HAL_UART_STATE_BUSY_RX)
   \                     ??HAL_UART_DMAResume_2: (+1)
   \       0x2A   0xF891 0x003A      LDRB     R0,[R1, #+58]
   \       0x2E   0x2822             CMP      R0,#+34
   \       0x30   0xD11A             BNE.N    ??HAL_UART_DMAResume_3
   1481            {
   1482              /* Clear the Overrun flag before resuming the Rx transfer*/
   1483              __HAL_UART_CLEAR_OREFLAG(huart);
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x9000             STR      R0,[SP, #+0]
   \       0x36   0x6808             LDR      R0,[R1, #+0]
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0x9000             STR      R0,[SP, #+0]
   \       0x3C   0x6808             LDR      R0,[R1, #+0]
   \       0x3E   0x6840             LDR      R0,[R0, #+4]
   \       0x40   0x9000             STR      R0,[SP, #+0]
   \       0x42   0x9800             LDR      R0,[SP, #+0]
   1484          
   1485              /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
   1486              SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \       0x44   0x6808             LDR      R0,[R1, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x4C   0x680A             LDR      R2,[R1, #+0]
   \       0x4E   0x60D0             STR      R0,[R2, #+12]
   1487              SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \       0x50   0x6808             LDR      R0,[R1, #+0]
   \       0x52   0x6940             LDR      R0,[R0, #+20]
   \       0x54   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x58   0x680A             LDR      R2,[R1, #+0]
   \       0x5A   0x6150             STR      R0,[R2, #+20]
   1488          
   1489              /* Enable the UART DMA Rx request */
   1490              SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \       0x5C   0x6808             LDR      R0,[R1, #+0]
   \       0x5E   0x6940             LDR      R0,[R0, #+20]
   \       0x60   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x64   0x680A             LDR      R2,[R1, #+0]
   \       0x66   0x6150             STR      R0,[R2, #+20]
   1491            }
   1492          
   1493            /* Process Unlocked */
   1494            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAResume_3: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xF881 0x0038      STRB     R0,[R1, #+56]
   1495          
   1496            return HAL_OK;
   \       0x6E   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DMAResume_1: (+1)
   \       0x70   0xB001             ADD      SP,SP,#+4
   \       0x72   0x4770             BX       LR
   1497          }
   1498          
   1499          /**
   1500            * @brief Stops the DMA Transfer.
   1501            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   1502            *                the configuration information for the specified UART module.
   1503            * @retval HAL status
   1504            */

   \                                 In section .text, align 2, keep-with-next
   1505          HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
   1506          {
   \                     HAL_UART_DMAStop: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0006             MOVS     R6,R0
   1507            uint32_t dmarequest = 0x00U;
   \        0x4   0x2000             MOVS     R0,#+0
   1508            /* The Lock is not implemented on this API to allow the user application
   1509               to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
   1510               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1511               and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
   1512               */
   1513          
   1514            /* Stop UART DMA Tx request if ongoing */
   1515            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
   \        0x6   0x6831             LDR      R1,[R6, #+0]
   \        0x8   0x694C             LDR      R4,[R1, #+20]
   \        0xA   0x09E4             LSRS     R4,R4,#+7
   \        0xC   0xF014 0x0401      ANDS     R4,R4,#0x1
   1516            if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
   \       0x10   0xF896 0x1039      LDRB     R1,[R6, #+57]
   \       0x14   0x2921             CMP      R1,#+33
   \       0x16   0xD110             BNE.N    ??HAL_UART_DMAStop_0
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD00E             BEQ.N    ??HAL_UART_DMAStop_0
   1517            {
   1518              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \       0x1C   0x6830             LDR      R0,[R6, #+0]
   \       0x1E   0x6940             LDR      R0,[R0, #+20]
   \       0x20   0xF030 0x0080      BICS     R0,R0,#0x80
   \       0x24   0x6831             LDR      R1,[R6, #+0]
   \       0x26   0x6148             STR      R0,[R1, #+20]
   1519          
   1520              /* Abort the UART DMA Tx stream */
   1521              if (huart->hdmatx != NULL)
   \       0x28   0x6B30             LDR      R0,[R6, #+48]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD002             BEQ.N    ??HAL_UART_DMAStop_1
   1522              {
   1523                HAL_DMA_Abort(huart->hdmatx);
   \       0x2E   0x6B30             LDR      R0,[R6, #+48]
   \       0x30   0x.... 0x....      BL       HAL_DMA_Abort
   1524              }
   1525              UART_EndTxTransfer(huart);
   \                     ??HAL_UART_DMAStop_1: (+1)
   \       0x34   0x0030             MOVS     R0,R6
   \       0x36   0x.... 0x....      BL       UART_EndTxTransfer
   1526            }
   1527          
   1528            /* Stop UART DMA Rx request if ongoing */
   1529            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_DMAStop_0: (+1)
   \       0x3A   0x6830             LDR      R0,[R6, #+0]
   \       0x3C   0x6945             LDR      R5,[R0, #+20]
   \       0x3E   0x09AD             LSRS     R5,R5,#+6
   \       0x40   0xF015 0x0501      ANDS     R5,R5,#0x1
   1530            if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
   \       0x44   0xF896 0x003A      LDRB     R0,[R6, #+58]
   \       0x48   0x2822             CMP      R0,#+34
   \       0x4A   0xD110             BNE.N    ??HAL_UART_DMAStop_2
   \       0x4C   0x2D00             CMP      R5,#+0
   \       0x4E   0xD00E             BEQ.N    ??HAL_UART_DMAStop_2
   1531            {
   1532              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \       0x50   0x6830             LDR      R0,[R6, #+0]
   \       0x52   0x6940             LDR      R0,[R0, #+20]
   \       0x54   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x58   0x6831             LDR      R1,[R6, #+0]
   \       0x5A   0x6148             STR      R0,[R1, #+20]
   1533          
   1534              /* Abort the UART DMA Rx stream */
   1535              if (huart->hdmarx != NULL)
   \       0x5C   0x6B70             LDR      R0,[R6, #+52]
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD002             BEQ.N    ??HAL_UART_DMAStop_3
   1536              {
   1537                HAL_DMA_Abort(huart->hdmarx);
   \       0x62   0x6B70             LDR      R0,[R6, #+52]
   \       0x64   0x.... 0x....      BL       HAL_DMA_Abort
   1538              }
   1539              UART_EndRxTransfer(huart);
   \                     ??HAL_UART_DMAStop_3: (+1)
   \       0x68   0x0030             MOVS     R0,R6
   \       0x6A   0x.... 0x....      BL       UART_EndRxTransfer
   1540            }
   1541          
   1542            return HAL_OK;
   \                     ??HAL_UART_DMAStop_2: (+1)
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xBD70             POP      {R4-R6,PC}
   1543          }
   1544          
   1545          /**
   1546            * @brief  Abort ongoing transfers (blocking mode).
   1547            * @param  huart UART handle.
   1548            * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode.
   1549            *         This procedure performs following operations :
   1550            *           - Disable UART Interrupts (Tx and Rx)
   1551            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1552            *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
   1553            *           - Set handle State to READY
   1554            * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
   1555            * @retval HAL status
   1556          */

   \                                 In section .text, align 2, keep-with-next
   1557          HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
   1558          {
   \                     HAL_UART_Abort: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1559            /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   1560            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C0             LDR      R0,[R0, #+12]
   \        0x8   0xF430 0x70F0      BICS     R0,R0,#0x1E0
   \        0xC   0x6821             LDR      R1,[R4, #+0]
   \        0xE   0x60C8             STR      R0,[R1, #+12]
   1561            CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6940             LDR      R0,[R0, #+20]
   \       0x14   0x0840             LSRS     R0,R0,#+1
   \       0x16   0x0040             LSLS     R0,R0,#+1
   \       0x18   0x6821             LDR      R1,[R4, #+0]
   \       0x1A   0x6148             STR      R0,[R1, #+20]
   1562          
   1563            /* Disable the UART DMA Tx request if enabled */
   1564            if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x6940             LDR      R0,[R0, #+20]
   \       0x20   0x0600             LSLS     R0,R0,#+24
   \       0x22   0xD519             BPL.N    ??HAL_UART_Abort_0
   1565            {
   1566              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x6940             LDR      R0,[R0, #+20]
   \       0x28   0xF030 0x0080      BICS     R0,R0,#0x80
   \       0x2C   0x6821             LDR      R1,[R4, #+0]
   \       0x2E   0x6148             STR      R0,[R1, #+20]
   1567          
   1568              /* Abort the UART DMA Tx stream: use blocking DMA Abort API (no callback) */
   1569              if (huart->hdmatx != NULL)
   \       0x30   0x6B20             LDR      R0,[R4, #+48]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD010             BEQ.N    ??HAL_UART_Abort_0
   1570              {
   1571                /* Set the UART DMA Abort callback to Null.
   1572                   No call back execution at end of DMA abort procedure */
   1573                huart->hdmatx->XferAbortCallback = NULL;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x6B21             LDR      R1,[R4, #+48]
   \       0x3A   0x6508             STR      R0,[R1, #+80]
   1574          
   1575                if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
   \       0x3C   0x6B20             LDR      R0,[R4, #+48]
   \       0x3E   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD008             BEQ.N    ??HAL_UART_Abort_0
   1576                {
   1577                  if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
   \       0x46   0x6B20             LDR      R0,[R4, #+48]
   \       0x48   0x.... 0x....      BL       HAL_DMA_GetError
   \       0x4C   0x2820             CMP      R0,#+32
   \       0x4E   0xD103             BNE.N    ??HAL_UART_Abort_0
   1578                  {
   1579                    /* Set error code to DMA */
   1580                    huart->ErrorCode = HAL_UART_ERROR_DMA;
   \       0x50   0x2010             MOVS     R0,#+16
   \       0x52   0x63E0             STR      R0,[R4, #+60]
   1581          
   1582                    return HAL_TIMEOUT;
   \       0x54   0x2003             MOVS     R0,#+3
   \       0x56   0xE02A             B.N      ??HAL_UART_Abort_1
   1583                  }
   1584                }
   1585              }
   1586            }
   1587          
   1588            /* Disable the UART DMA Rx request if enabled */
   1589            if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \                     ??HAL_UART_Abort_0: (+1)
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x6940             LDR      R0,[R0, #+20]
   \       0x5C   0x0640             LSLS     R0,R0,#+25
   \       0x5E   0xD519             BPL.N    ??HAL_UART_Abort_2
   1590            {
   1591              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x6940             LDR      R0,[R0, #+20]
   \       0x64   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x68   0x6821             LDR      R1,[R4, #+0]
   \       0x6A   0x6148             STR      R0,[R1, #+20]
   1592          
   1593              /* Abort the UART DMA Rx stream: use blocking DMA Abort API (no callback) */
   1594              if (huart->hdmarx != NULL)
   \       0x6C   0x6B60             LDR      R0,[R4, #+52]
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD010             BEQ.N    ??HAL_UART_Abort_2
   1595              {
   1596                /* Set the UART DMA Abort callback to Null.
   1597                   No call back execution at end of DMA abort procedure */
   1598                huart->hdmarx->XferAbortCallback = NULL;
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0x6B61             LDR      R1,[R4, #+52]
   \       0x76   0x6508             STR      R0,[R1, #+80]
   1599          
   1600                if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
   \       0x78   0x6B60             LDR      R0,[R4, #+52]
   \       0x7A   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x7E   0x2800             CMP      R0,#+0
   \       0x80   0xD008             BEQ.N    ??HAL_UART_Abort_2
   1601                {
   1602                  if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
   \       0x82   0x6B60             LDR      R0,[R4, #+52]
   \       0x84   0x.... 0x....      BL       HAL_DMA_GetError
   \       0x88   0x2820             CMP      R0,#+32
   \       0x8A   0xD103             BNE.N    ??HAL_UART_Abort_2
   1603                  {
   1604                    /* Set error code to DMA */
   1605                    huart->ErrorCode = HAL_UART_ERROR_DMA;
   \       0x8C   0x2010             MOVS     R0,#+16
   \       0x8E   0x63E0             STR      R0,[R4, #+60]
   1606          
   1607                    return HAL_TIMEOUT;
   \       0x90   0x2003             MOVS     R0,#+3
   \       0x92   0xE00C             B.N      ??HAL_UART_Abort_1
   1608                  }
   1609                }
   1610              }
   1611            }
   1612          
   1613            /* Reset Tx and Rx transfer counters */
   1614            huart->TxXferCount = 0x00U;
   \                     ??HAL_UART_Abort_2: (+1)
   \       0x94   0x2000             MOVS     R0,#+0
   \       0x96   0x84E0             STRH     R0,[R4, #+38]
   1615            huart->RxXferCount = 0x00U;
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0x85E0             STRH     R0,[R4, #+46]
   1616          
   1617            /* Reset ErrorCode */
   1618            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x9C   0x2000             MOVS     R0,#+0
   \       0x9E   0x63E0             STR      R0,[R4, #+60]
   1619          
   1620            /* Restore huart->RxState and huart->gState to Ready */
   1621            huart->RxState = HAL_UART_STATE_READY;
   \       0xA0   0x2020             MOVS     R0,#+32
   \       0xA2   0xF884 0x003A      STRB     R0,[R4, #+58]
   1622            huart->gState = HAL_UART_STATE_READY;
   \       0xA6   0x2020             MOVS     R0,#+32
   \       0xA8   0xF884 0x0039      STRB     R0,[R4, #+57]
   1623          
   1624            return HAL_OK;
   \       0xAC   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_Abort_1: (+1)
   \       0xAE   0xBD10             POP      {R4,PC}
   1625          }
   1626          
   1627          /**
   1628            * @brief  Abort ongoing Transmit transfer (blocking mode).
   1629            * @param  huart UART handle.
   1630            * @note   This procedure could be used for aborting any ongoing Tx transfer started in Interrupt or DMA mode.
   1631            *         This procedure performs following operations :
   1632            *           - Disable UART Interrupts (Tx)
   1633            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1634            *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
   1635            *           - Set handle State to READY
   1636            * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
   1637            * @retval HAL status
   1638          */

   \                                 In section .text, align 2, keep-with-next
   1639          HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
   1640          {
   \                     HAL_UART_AbortTransmit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1641            /* Disable TXEIE and TCIE interrupts */
   1642            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C0             LDR      R0,[R0, #+12]
   \        0x8   0xF030 0x00C0      BICS     R0,R0,#0xC0
   \        0xC   0x6821             LDR      R1,[R4, #+0]
   \        0xE   0x60C8             STR      R0,[R1, #+12]
   1643          
   1644            /* Disable the UART DMA Tx request if enabled */
   1645            if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6940             LDR      R0,[R0, #+20]
   \       0x14   0x0600             LSLS     R0,R0,#+24
   \       0x16   0xD519             BPL.N    ??HAL_UART_AbortTransmit_0
   1646            {
   1647              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x6940             LDR      R0,[R0, #+20]
   \       0x1C   0xF030 0x0080      BICS     R0,R0,#0x80
   \       0x20   0x6821             LDR      R1,[R4, #+0]
   \       0x22   0x6148             STR      R0,[R1, #+20]
   1648          
   1649              /* Abort the UART DMA Tx stream : use blocking DMA Abort API (no callback) */
   1650              if (huart->hdmatx != NULL)
   \       0x24   0x6B20             LDR      R0,[R4, #+48]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD010             BEQ.N    ??HAL_UART_AbortTransmit_0
   1651              {
   1652                /* Set the UART DMA Abort callback to Null.
   1653                   No call back execution at end of DMA abort procedure */
   1654                huart->hdmatx->XferAbortCallback = NULL;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x6B21             LDR      R1,[R4, #+48]
   \       0x2E   0x6508             STR      R0,[R1, #+80]
   1655          
   1656                if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
   \       0x30   0x6B20             LDR      R0,[R4, #+48]
   \       0x32   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD008             BEQ.N    ??HAL_UART_AbortTransmit_0
   1657                {
   1658                  if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
   \       0x3A   0x6B20             LDR      R0,[R4, #+48]
   \       0x3C   0x.... 0x....      BL       HAL_DMA_GetError
   \       0x40   0x2820             CMP      R0,#+32
   \       0x42   0xD103             BNE.N    ??HAL_UART_AbortTransmit_0
   1659                  {
   1660                    /* Set error code to DMA */
   1661                    huart->ErrorCode = HAL_UART_ERROR_DMA;
   \       0x44   0x2010             MOVS     R0,#+16
   \       0x46   0x63E0             STR      R0,[R4, #+60]
   1662          
   1663                    return HAL_TIMEOUT;
   \       0x48   0x2003             MOVS     R0,#+3
   \       0x4A   0xE005             B.N      ??HAL_UART_AbortTransmit_1
   1664                  }
   1665                }
   1666              }
   1667            }
   1668          
   1669            /* Reset Tx transfer counter */
   1670            huart->TxXferCount = 0x00U;
   \                     ??HAL_UART_AbortTransmit_0: (+1)
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x84E0             STRH     R0,[R4, #+38]
   1671          
   1672            /* Restore huart->gState to Ready */
   1673            huart->gState = HAL_UART_STATE_READY;
   \       0x50   0x2020             MOVS     R0,#+32
   \       0x52   0xF884 0x0039      STRB     R0,[R4, #+57]
   1674          
   1675            return HAL_OK;
   \       0x56   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_AbortTransmit_1: (+1)
   \       0x58   0xBD10             POP      {R4,PC}
   1676          }
   1677          
   1678          /**
   1679            * @brief  Abort ongoing Receive transfer (blocking mode).
   1680            * @param  huart UART handle.
   1681            * @note   This procedure could be used for aborting any ongoing Rx transfer started in Interrupt or DMA mode.
   1682            *         This procedure performs following operations :
   1683            *           - Disable UART Interrupts (Rx)
   1684            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1685            *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
   1686            *           - Set handle State to READY
   1687            * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
   1688            * @retval HAL status
   1689          */

   \                                 In section .text, align 2, keep-with-next
   1690          HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
   1691          {
   \                     HAL_UART_AbortReceive: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1692            /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   1693            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C0             LDR      R0,[R0, #+12]
   \        0x8   0xF430 0x7090      BICS     R0,R0,#0x120
   \        0xC   0x6821             LDR      R1,[R4, #+0]
   \        0xE   0x60C8             STR      R0,[R1, #+12]
   1694            CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6940             LDR      R0,[R0, #+20]
   \       0x14   0x0840             LSRS     R0,R0,#+1
   \       0x16   0x0040             LSLS     R0,R0,#+1
   \       0x18   0x6821             LDR      R1,[R4, #+0]
   \       0x1A   0x6148             STR      R0,[R1, #+20]
   1695          
   1696            /* Disable the UART DMA Rx request if enabled */
   1697            if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x6940             LDR      R0,[R0, #+20]
   \       0x20   0x0640             LSLS     R0,R0,#+25
   \       0x22   0xD519             BPL.N    ??HAL_UART_AbortReceive_0
   1698            {
   1699              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x6940             LDR      R0,[R0, #+20]
   \       0x28   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x2C   0x6821             LDR      R1,[R4, #+0]
   \       0x2E   0x6148             STR      R0,[R1, #+20]
   1700          
   1701              /* Abort the UART DMA Rx stream : use blocking DMA Abort API (no callback) */
   1702              if (huart->hdmarx != NULL)
   \       0x30   0x6B60             LDR      R0,[R4, #+52]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD010             BEQ.N    ??HAL_UART_AbortReceive_0
   1703              {
   1704                /* Set the UART DMA Abort callback to Null.
   1705                   No call back execution at end of DMA abort procedure */
   1706                huart->hdmarx->XferAbortCallback = NULL;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x6B61             LDR      R1,[R4, #+52]
   \       0x3A   0x6508             STR      R0,[R1, #+80]
   1707          
   1708                if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
   \       0x3C   0x6B60             LDR      R0,[R4, #+52]
   \       0x3E   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD008             BEQ.N    ??HAL_UART_AbortReceive_0
   1709                {
   1710                  if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
   \       0x46   0x6B60             LDR      R0,[R4, #+52]
   \       0x48   0x.... 0x....      BL       HAL_DMA_GetError
   \       0x4C   0x2820             CMP      R0,#+32
   \       0x4E   0xD103             BNE.N    ??HAL_UART_AbortReceive_0
   1711                  {
   1712                    /* Set error code to DMA */
   1713                    huart->ErrorCode = HAL_UART_ERROR_DMA;
   \       0x50   0x2010             MOVS     R0,#+16
   \       0x52   0x63E0             STR      R0,[R4, #+60]
   1714          
   1715                    return HAL_TIMEOUT;
   \       0x54   0x2003             MOVS     R0,#+3
   \       0x56   0xE005             B.N      ??HAL_UART_AbortReceive_1
   1716                  }
   1717                }
   1718              }
   1719            }
   1720          
   1721            /* Reset Rx transfer counter */
   1722            huart->RxXferCount = 0x00U;
   \                     ??HAL_UART_AbortReceive_0: (+1)
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x85E0             STRH     R0,[R4, #+46]
   1723          
   1724            /* Restore huart->RxState to Ready */
   1725            huart->RxState = HAL_UART_STATE_READY;
   \       0x5C   0x2020             MOVS     R0,#+32
   \       0x5E   0xF884 0x003A      STRB     R0,[R4, #+58]
   1726          
   1727            return HAL_OK;
   \       0x62   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_AbortReceive_1: (+1)
   \       0x64   0xBD10             POP      {R4,PC}
   1728          }
   1729          
   1730          /**
   1731            * @brief  Abort ongoing transfers (Interrupt mode).
   1732            * @param  huart UART handle.
   1733            * @note   This procedure could be used for aborting any ongoing transfer started in Interrupt or DMA mode.
   1734            *         This procedure performs following operations :
   1735            *           - Disable UART Interrupts (Tx and Rx)
   1736            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1737            *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
   1738            *           - Set handle State to READY
   1739            *           - At abort completion, call user abort complete callback
   1740            * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
   1741            *         considered as completed only when user abort complete callback is executed (not when exiting function).
   1742            * @retval HAL status
   1743          */

   \                                 In section .text, align 2, keep-with-next
   1744          HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
   1745          {
   \                     HAL_UART_Abort_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1746            uint32_t AbortCplt = 0x01U;
   \        0x4   0x2501             MOVS     R5,#+1
   1747          
   1748            /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   1749            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x68C0             LDR      R0,[R0, #+12]
   \        0xA   0xF430 0x70F0      BICS     R0,R0,#0x1E0
   \        0xE   0x6821             LDR      R1,[R4, #+0]
   \       0x10   0x60C8             STR      R0,[R1, #+12]
   1750            CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x6940             LDR      R0,[R0, #+20]
   \       0x16   0x0840             LSRS     R0,R0,#+1
   \       0x18   0x0040             LSLS     R0,R0,#+1
   \       0x1A   0x6821             LDR      R1,[R4, #+0]
   \       0x1C   0x6148             STR      R0,[R1, #+20]
   1751          
   1752            /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
   1753               before any call to DMA Abort functions */
   1754            /* DMA Tx Handle is valid */
   1755            if (huart->hdmatx != NULL)
   \       0x1E   0x6B20             LDR      R0,[R4, #+48]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD00B             BEQ.N    ??HAL_UART_Abort_IT_0
   1756            {
   1757              /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
   1758                 Otherwise, set it to NULL */
   1759              if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x6940             LDR      R0,[R0, #+20]
   \       0x28   0x0600             LSLS     R0,R0,#+24
   \       0x2A   0xD504             BPL.N    ??HAL_UART_Abort_IT_1
   1760              {
   1761                huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
   \       0x2C   0x.... 0x....      ADR.W    R0,UART_DMATxAbortCallback
   \       0x30   0x6B21             LDR      R1,[R4, #+48]
   \       0x32   0x6508             STR      R0,[R1, #+80]
   \       0x34   0xE002             B.N      ??HAL_UART_Abort_IT_0
   1762              }
   1763              else
   1764              {
   1765                huart->hdmatx->XferAbortCallback = NULL;
   \                     ??HAL_UART_Abort_IT_1: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x6B21             LDR      R1,[R4, #+48]
   \       0x3A   0x6508             STR      R0,[R1, #+80]
   1766              }
   1767            }
   1768            /* DMA Rx Handle is valid */
   1769            if (huart->hdmarx != NULL)
   \                     ??HAL_UART_Abort_IT_0: (+1)
   \       0x3C   0x6B60             LDR      R0,[R4, #+52]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD00B             BEQ.N    ??HAL_UART_Abort_IT_2
   1770            {
   1771              /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
   1772                 Otherwise, set it to NULL */
   1773              if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x6940             LDR      R0,[R0, #+20]
   \       0x46   0x0640             LSLS     R0,R0,#+25
   \       0x48   0xD504             BPL.N    ??HAL_UART_Abort_IT_3
   1774              {
   1775                huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
   \       0x4A   0x.... 0x....      ADR.W    R0,UART_DMARxAbortCallback
   \       0x4E   0x6B61             LDR      R1,[R4, #+52]
   \       0x50   0x6508             STR      R0,[R1, #+80]
   \       0x52   0xE002             B.N      ??HAL_UART_Abort_IT_2
   1776              }
   1777              else
   1778              {
   1779                huart->hdmarx->XferAbortCallback = NULL;
   \                     ??HAL_UART_Abort_IT_3: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x6B61             LDR      R1,[R4, #+52]
   \       0x58   0x6508             STR      R0,[R1, #+80]
   1780              }
   1781            }
   1782          
   1783            /* Disable the UART DMA Tx request if enabled */
   1784            if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
   \                     ??HAL_UART_Abort_IT_2: (+1)
   \       0x5A   0x6820             LDR      R0,[R4, #+0]
   \       0x5C   0x6940             LDR      R0,[R0, #+20]
   \       0x5E   0x0600             LSLS     R0,R0,#+24
   \       0x60   0xD513             BPL.N    ??HAL_UART_Abort_IT_4
   1785            {
   1786              /* Disable DMA Tx at UART level */
   1787              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x6940             LDR      R0,[R0, #+20]
   \       0x66   0xF030 0x0080      BICS     R0,R0,#0x80
   \       0x6A   0x6821             LDR      R1,[R4, #+0]
   \       0x6C   0x6148             STR      R0,[R1, #+20]
   1788          
   1789              /* Abort the UART DMA Tx stream : use non blocking DMA Abort API (callback) */
   1790              if (huart->hdmatx != NULL)
   \       0x6E   0x6B20             LDR      R0,[R4, #+48]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD00A             BEQ.N    ??HAL_UART_Abort_IT_4
   1791              {
   1792                /* UART Tx DMA Abort callback has already been initialised :
   1793                   will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
   1794          
   1795                /* Abort DMA TX */
   1796                if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
   \       0x74   0x6B20             LDR      R0,[R4, #+48]
   \       0x76   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD003             BEQ.N    ??HAL_UART_Abort_IT_5
   1797                {
   1798                  huart->hdmatx->XferAbortCallback = NULL;
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0x6B21             LDR      R1,[R4, #+48]
   \       0x82   0x6508             STR      R0,[R1, #+80]
   \       0x84   0xE001             B.N      ??HAL_UART_Abort_IT_4
   1799                }
   1800                else
   1801                {
   1802                  AbortCplt = 0x00U;
   \                     ??HAL_UART_Abort_IT_5: (+1)
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0x0005             MOVS     R5,R0
   1803                }
   1804              }
   1805            }
   1806          
   1807            /* Disable the UART DMA Rx request if enabled */
   1808            if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \                     ??HAL_UART_Abort_IT_4: (+1)
   \       0x8A   0x6820             LDR      R0,[R4, #+0]
   \       0x8C   0x6940             LDR      R0,[R0, #+20]
   \       0x8E   0x0640             LSLS     R0,R0,#+25
   \       0x90   0xD515             BPL.N    ??HAL_UART_Abort_IT_6
   1809            {
   1810              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x6940             LDR      R0,[R0, #+20]
   \       0x96   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x9A   0x6821             LDR      R1,[R4, #+0]
   \       0x9C   0x6148             STR      R0,[R1, #+20]
   1811          
   1812              /* Abort the UART DMA Rx stream : use non blocking DMA Abort API (callback) */
   1813              if (huart->hdmarx != NULL)
   \       0x9E   0x6B60             LDR      R0,[R4, #+52]
   \       0xA0   0x2800             CMP      R0,#+0
   \       0xA2   0xD00C             BEQ.N    ??HAL_UART_Abort_IT_6
   1814              {
   1815                /* UART Rx DMA Abort callback has already been initialised :
   1816                   will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
   1817          
   1818                /* Abort DMA RX */
   1819                if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
   \       0xA4   0x6B60             LDR      R0,[R4, #+52]
   \       0xA6   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD005             BEQ.N    ??HAL_UART_Abort_IT_7
   1820                {
   1821                  huart->hdmarx->XferAbortCallback = NULL;
   \       0xAE   0x2000             MOVS     R0,#+0
   \       0xB0   0x6B61             LDR      R1,[R4, #+52]
   \       0xB2   0x6508             STR      R0,[R1, #+80]
   1822                  AbortCplt = 0x01U;
   \       0xB4   0x2001             MOVS     R0,#+1
   \       0xB6   0x0005             MOVS     R5,R0
   \       0xB8   0xE001             B.N      ??HAL_UART_Abort_IT_6
   1823                }
   1824                else
   1825                {
   1826                  AbortCplt = 0x00U;
   \                     ??HAL_UART_Abort_IT_7: (+1)
   \       0xBA   0x2000             MOVS     R0,#+0
   \       0xBC   0x0005             MOVS     R5,R0
   1827                }
   1828              }
   1829            }
   1830          
   1831            /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
   1832            if (AbortCplt == 0x01U)
   \                     ??HAL_UART_Abort_IT_6: (+1)
   \       0xBE   0x2D01             CMP      R5,#+1
   \       0xC0   0xD10E             BNE.N    ??HAL_UART_Abort_IT_8
   1833            {
   1834              /* Reset Tx and Rx transfer counters */
   1835              huart->TxXferCount = 0x00U;
   \       0xC2   0x2000             MOVS     R0,#+0
   \       0xC4   0x84E0             STRH     R0,[R4, #+38]
   1836              huart->RxXferCount = 0x00U;
   \       0xC6   0x2000             MOVS     R0,#+0
   \       0xC8   0x85E0             STRH     R0,[R4, #+46]
   1837          
   1838              /* Reset ErrorCode */
   1839              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0xCA   0x2000             MOVS     R0,#+0
   \       0xCC   0x63E0             STR      R0,[R4, #+60]
   1840          
   1841              /* Restore huart->gState and huart->RxState to Ready */
   1842              huart->gState  = HAL_UART_STATE_READY;
   \       0xCE   0x2020             MOVS     R0,#+32
   \       0xD0   0xF884 0x0039      STRB     R0,[R4, #+57]
   1843              huart->RxState = HAL_UART_STATE_READY;
   \       0xD4   0x2020             MOVS     R0,#+32
   \       0xD6   0xF884 0x003A      STRB     R0,[R4, #+58]
   1844          
   1845              /* As no DMA to be aborted, call directly user Abort complete callback */
   1846          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   1847              /* Call registered Abort complete callback */
   1848              huart->AbortCpltCallback(huart);
   1849          #else
   1850              /* Call legacy weak Abort complete callback */
   1851              HAL_UART_AbortCpltCallback(huart);
   \       0xDA   0x0020             MOVS     R0,R4
   \       0xDC   0x.... 0x....      BL       HAL_UART_AbortCpltCallback
   1852          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   1853            }
   1854          
   1855            return HAL_OK;
   \                     ??HAL_UART_Abort_IT_8: (+1)
   \       0xE0   0x2000             MOVS     R0,#+0
   \       0xE2   0xBD32             POP      {R1,R4,R5,PC}
   1856          }
   1857          
   1858          /**
   1859            * @brief  Abort ongoing Transmit transfer (Interrupt mode).
   1860            * @param  huart UART handle.
   1861            * @note   This procedure could be used for aborting any ongoing Tx transfer started in Interrupt or DMA mode.
   1862            *         This procedure performs following operations :
   1863            *           - Disable UART Interrupts (Tx)
   1864            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1865            *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
   1866            *           - Set handle State to READY
   1867            *           - At abort completion, call user abort complete callback
   1868            * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
   1869            *         considered as completed only when user abort complete callback is executed (not when exiting function).
   1870            * @retval HAL status
   1871          */

   \                                 In section .text, align 2, keep-with-next
   1872          HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
   1873          {
   \                     HAL_UART_AbortTransmit_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1874            /* Disable TXEIE and TCIE interrupts */
   1875            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C0             LDR      R0,[R0, #+12]
   \        0x8   0xF030 0x00C0      BICS     R0,R0,#0xC0
   \        0xC   0x6821             LDR      R1,[R4, #+0]
   \        0xE   0x60C8             STR      R0,[R1, #+12]
   1876          
   1877            /* Disable the UART DMA Tx request if enabled */
   1878            if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6940             LDR      R0,[R0, #+20]
   \       0x14   0x0600             LSLS     R0,R0,#+24
   \       0x16   0xD51F             BPL.N    ??HAL_UART_AbortTransmit_IT_0
   1879            {
   1880              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x6940             LDR      R0,[R0, #+20]
   \       0x1C   0xF030 0x0080      BICS     R0,R0,#0x80
   \       0x20   0x6821             LDR      R1,[R4, #+0]
   \       0x22   0x6148             STR      R0,[R1, #+20]
   1881          
   1882              /* Abort the UART DMA Tx stream : use blocking DMA Abort API (no callback) */
   1883              if (huart->hdmatx != NULL)
   \       0x24   0x6B20             LDR      R0,[R4, #+48]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD00D             BEQ.N    ??HAL_UART_AbortTransmit_IT_1
   1884              {
   1885                /* Set the UART DMA Abort callback :
   1886                   will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
   1887                huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
   \       0x2A   0x.... 0x....      ADR.W    R0,UART_DMATxOnlyAbortCallback
   \       0x2E   0x6B21             LDR      R1,[R4, #+48]
   \       0x30   0x6508             STR      R0,[R1, #+80]
   1888          
   1889                /* Abort DMA TX */
   1890                if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
   \       0x32   0x6B20             LDR      R0,[R4, #+48]
   \       0x34   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD015             BEQ.N    ??HAL_UART_AbortTransmit_IT_2
   1891                {
   1892                  /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
   1893                  huart->hdmatx->XferAbortCallback(huart->hdmatx);
   \       0x3C   0x6B20             LDR      R0,[R4, #+48]
   \       0x3E   0x6B21             LDR      R1,[R4, #+48]
   \       0x40   0x6D09             LDR      R1,[R1, #+80]
   \       0x42   0x4788             BLX      R1
   \       0x44   0xE010             B.N      ??HAL_UART_AbortTransmit_IT_2
   1894                }
   1895              }
   1896              else
   1897              {
   1898                /* Reset Tx transfer counter */
   1899                huart->TxXferCount = 0x00U;
   \                     ??HAL_UART_AbortTransmit_IT_1: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x84E0             STRH     R0,[R4, #+38]
   1900          
   1901                /* Restore huart->gState to Ready */
   1902                huart->gState = HAL_UART_STATE_READY;
   \       0x4A   0x2020             MOVS     R0,#+32
   \       0x4C   0xF884 0x0039      STRB     R0,[R4, #+57]
   1903          
   1904                /* As no DMA to be aborted, call directly user Abort complete callback */
   1905          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   1906                /* Call registered Abort Transmit Complete Callback */
   1907                huart->AbortTransmitCpltCallback(huart);
   1908          #else
   1909                /* Call legacy weak Abort Transmit Complete Callback */
   1910                HAL_UART_AbortTransmitCpltCallback(huart);
   \       0x50   0x0020             MOVS     R0,R4
   \       0x52   0x.... 0x....      BL       HAL_UART_AbortTransmitCpltCallback
   \       0x56   0xE007             B.N      ??HAL_UART_AbortTransmit_IT_2
   1911          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   1912              }
   1913            }
   1914            else
   1915            {
   1916              /* Reset Tx transfer counter */
   1917              huart->TxXferCount = 0x00U;
   \                     ??HAL_UART_AbortTransmit_IT_0: (+1)
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x84E0             STRH     R0,[R4, #+38]
   1918          
   1919              /* Restore huart->gState to Ready */
   1920              huart->gState = HAL_UART_STATE_READY;
   \       0x5C   0x2020             MOVS     R0,#+32
   \       0x5E   0xF884 0x0039      STRB     R0,[R4, #+57]
   1921          
   1922              /* As no DMA to be aborted, call directly user Abort complete callback */
   1923          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   1924              /* Call registered Abort Transmit Complete Callback */
   1925              huart->AbortTransmitCpltCallback(huart);
   1926          #else
   1927              /* Call legacy weak Abort Transmit Complete Callback */
   1928              HAL_UART_AbortTransmitCpltCallback(huart);
   \       0x62   0x0020             MOVS     R0,R4
   \       0x64   0x.... 0x....      BL       HAL_UART_AbortTransmitCpltCallback
   1929          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   1930            }
   1931          
   1932            return HAL_OK;
   \                     ??HAL_UART_AbortTransmit_IT_2: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xBD10             POP      {R4,PC}
   1933          }
   1934          
   1935          /**
   1936            * @brief  Abort ongoing Receive transfer (Interrupt mode).
   1937            * @param  huart UART handle.
   1938            * @note   This procedure could be used for aborting any ongoing Rx transfer started in Interrupt or DMA mode.
   1939            *         This procedure performs following operations :
   1940            *           - Disable UART Interrupts (Rx)
   1941            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1942            *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
   1943            *           - Set handle State to READY
   1944            *           - At abort completion, call user abort complete callback
   1945            * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
   1946            *         considered as completed only when user abort complete callback is executed (not when exiting function).
   1947            * @retval HAL status
   1948          */

   \                                 In section .text, align 2, keep-with-next
   1949          HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
   1950          {
   \                     HAL_UART_AbortReceive_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1951            /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   1952            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C0             LDR      R0,[R0, #+12]
   \        0x8   0xF430 0x7090      BICS     R0,R0,#0x120
   \        0xC   0x6821             LDR      R1,[R4, #+0]
   \        0xE   0x60C8             STR      R0,[R1, #+12]
   1953            CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6940             LDR      R0,[R0, #+20]
   \       0x14   0x0840             LSRS     R0,R0,#+1
   \       0x16   0x0040             LSLS     R0,R0,#+1
   \       0x18   0x6821             LDR      R1,[R4, #+0]
   \       0x1A   0x6148             STR      R0,[R1, #+20]
   1954          
   1955            /* Disable the UART DMA Rx request if enabled */
   1956            if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x6940             LDR      R0,[R0, #+20]
   \       0x20   0x0640             LSLS     R0,R0,#+25
   \       0x22   0xD51F             BPL.N    ??HAL_UART_AbortReceive_IT_0
   1957            {
   1958              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x6940             LDR      R0,[R0, #+20]
   \       0x28   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x2C   0x6821             LDR      R1,[R4, #+0]
   \       0x2E   0x6148             STR      R0,[R1, #+20]
   1959          
   1960              /* Abort the UART DMA Rx stream : use blocking DMA Abort API (no callback) */
   1961              if (huart->hdmarx != NULL)
   \       0x30   0x6B60             LDR      R0,[R4, #+52]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD00D             BEQ.N    ??HAL_UART_AbortReceive_IT_1
   1962              {
   1963                /* Set the UART DMA Abort callback :
   1964                   will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
   1965                huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
   \       0x36   0x.... 0x....      ADR.W    R0,UART_DMARxOnlyAbortCallback
   \       0x3A   0x6B61             LDR      R1,[R4, #+52]
   \       0x3C   0x6508             STR      R0,[R1, #+80]
   1966          
   1967                /* Abort DMA RX */
   1968                if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
   \       0x3E   0x6B60             LDR      R0,[R4, #+52]
   \       0x40   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD015             BEQ.N    ??HAL_UART_AbortReceive_IT_2
   1969                {
   1970                  /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
   1971                  huart->hdmarx->XferAbortCallback(huart->hdmarx);
   \       0x48   0x6B60             LDR      R0,[R4, #+52]
   \       0x4A   0x6B61             LDR      R1,[R4, #+52]
   \       0x4C   0x6D09             LDR      R1,[R1, #+80]
   \       0x4E   0x4788             BLX      R1
   \       0x50   0xE010             B.N      ??HAL_UART_AbortReceive_IT_2
   1972                }
   1973              }
   1974              else
   1975              {
   1976                /* Reset Rx transfer counter */
   1977                huart->RxXferCount = 0x00U;
   \                     ??HAL_UART_AbortReceive_IT_1: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x85E0             STRH     R0,[R4, #+46]
   1978          
   1979                /* Restore huart->RxState to Ready */
   1980                huart->RxState = HAL_UART_STATE_READY;
   \       0x56   0x2020             MOVS     R0,#+32
   \       0x58   0xF884 0x003A      STRB     R0,[R4, #+58]
   1981          
   1982                /* As no DMA to be aborted, call directly user Abort complete callback */
   1983          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   1984                /* Call registered Abort Receive Complete Callback */
   1985                huart->AbortReceiveCpltCallback(huart);
   1986          #else
   1987                /* Call legacy weak Abort Receive Complete Callback */
   1988                HAL_UART_AbortReceiveCpltCallback(huart);
   \       0x5C   0x0020             MOVS     R0,R4
   \       0x5E   0x.... 0x....      BL       HAL_UART_AbortReceiveCpltCallback
   \       0x62   0xE007             B.N      ??HAL_UART_AbortReceive_IT_2
   1989          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   1990              }
   1991            }
   1992            else
   1993            {
   1994              /* Reset Rx transfer counter */
   1995              huart->RxXferCount = 0x00U;
   \                     ??HAL_UART_AbortReceive_IT_0: (+1)
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x85E0             STRH     R0,[R4, #+46]
   1996          
   1997              /* Restore huart->RxState to Ready */
   1998              huart->RxState = HAL_UART_STATE_READY;
   \       0x68   0x2020             MOVS     R0,#+32
   \       0x6A   0xF884 0x003A      STRB     R0,[R4, #+58]
   1999          
   2000              /* As no DMA to be aborted, call directly user Abort complete callback */
   2001          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2002              /* Call registered Abort Receive Complete Callback */
   2003              huart->AbortReceiveCpltCallback(huart);
   2004          #else
   2005              /* Call legacy weak Abort Receive Complete Callback */
   2006              HAL_UART_AbortReceiveCpltCallback(huart);
   \       0x6E   0x0020             MOVS     R0,R4
   \       0x70   0x.... 0x....      BL       HAL_UART_AbortReceiveCpltCallback
   2007          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2008            }
   2009          
   2010            return HAL_OK;
   \                     ??HAL_UART_AbortReceive_IT_2: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xBD10             POP      {R4,PC}
   2011          }
   2012          
   2013          /**
   2014            * @brief  This function handles UART interrupt request.
   2015            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   2016            *                the configuration information for the specified UART module.
   2017            * @retval None
   2018            */

   \                                 In section .text, align 2, keep-with-next
   2019          void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
   2020          {
   \                     HAL_UART_IRQHandler: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0006             MOVS     R6,R0
   2021            uint32_t isrflags   = READ_REG(huart->Instance->SR);
   \        0x6   0x6830             LDR      R0,[R6, #+0]
   \        0x8   0x6807             LDR      R7,[R0, #+0]
   2022            uint32_t cr1its     = READ_REG(huart->Instance->CR1);
   \        0xA   0x6830             LDR      R0,[R6, #+0]
   \        0xC   0xF8D0 0x800C      LDR      R8,[R0, #+12]
   2023            uint32_t cr3its     = READ_REG(huart->Instance->CR3);
   \       0x10   0x6830             LDR      R0,[R6, #+0]
   \       0x12   0xF8D0 0x9014      LDR      R9,[R0, #+20]
   2024            uint32_t errorflags = 0x00U;
   \       0x16   0x2000             MOVS     R0,#+0
   2025            uint32_t dmarequest = 0x00U;
   \       0x18   0x2500             MOVS     R5,#+0
   2026          
   2027            /* If no error occurs */
   2028            errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
   \       0x1A   0xF017 0x040F      ANDS     R4,R7,#0xF
   2029            if (errorflags == RESET)
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD108             BNE.N    ??HAL_UART_IRQHandler_0
   2030            {
   2031              /* UART in mode Receiver -------------------------------------------------*/
   2032              if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
   \       0x22   0x06B8             LSLS     R0,R7,#+26
   \       0x24   0xD506             BPL.N    ??HAL_UART_IRQHandler_0
   \       0x26   0xEA5F 0x6088      LSLS     R0,R8,#+26
   \       0x2A   0xD503             BPL.N    ??HAL_UART_IRQHandler_0
   2033              {
   2034                UART_Receive_IT(huart);
   \       0x2C   0x0030             MOVS     R0,R6
   \       0x2E   0x.... 0x....      BL       UART_Receive_IT
   2035                return;
   \       0x32   0xE08B             B.N      ??HAL_UART_IRQHandler_1
   2036              }
   2037            }
   2038          
   2039            /* If some errors occur */
   2040            if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
   \                     ??HAL_UART_IRQHandler_0: (+1)
   \       0x34   0x2C00             CMP      R4,#+0
   \       0x36   0xD077             BEQ.N    ??HAL_UART_IRQHandler_2
   \       0x38   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \       0x3C   0xD402             BMI.N    ??HAL_UART_IRQHandler_3
   \       0x3E   0xF418 0x7F90      TST      R8,#0x120
   \       0x42   0xD071             BEQ.N    ??HAL_UART_IRQHandler_2
   2041            {
   2042              /* UART parity error interrupt occurred ----------------------------------*/
   2043              if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
   \                     ??HAL_UART_IRQHandler_3: (+1)
   \       0x44   0xF017 0x0001      ANDS     R0,R7,#0x1
   \       0x48   0xB2C0             UXTB     R0,R0
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD006             BEQ.N    ??HAL_UART_IRQHandler_4
   \       0x4E   0xEA5F 0x50C8      LSLS     R0,R8,#+23
   \       0x52   0xD503             BPL.N    ??HAL_UART_IRQHandler_4
   2044              {
   2045                huart->ErrorCode |= HAL_UART_ERROR_PE;
   \       0x54   0x6BF0             LDR      R0,[R6, #+60]
   \       0x56   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x5A   0x63F0             STR      R0,[R6, #+60]
   2046              }
   2047          
   2048              /* UART noise error interrupt occurred -----------------------------------*/
   2049              if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
   \                     ??HAL_UART_IRQHandler_4: (+1)
   \       0x5C   0x0778             LSLS     R0,R7,#+29
   \       0x5E   0xD508             BPL.N    ??HAL_UART_IRQHandler_5
   \       0x60   0xF019 0x0001      ANDS     R0,R9,#0x1
   \       0x64   0xB2C0             UXTB     R0,R0
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD003             BEQ.N    ??HAL_UART_IRQHandler_5
   2050              {
   2051                huart->ErrorCode |= HAL_UART_ERROR_NE;
   \       0x6A   0x6BF0             LDR      R0,[R6, #+60]
   \       0x6C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x70   0x63F0             STR      R0,[R6, #+60]
   2052              }
   2053          
   2054              /* UART frame error interrupt occurred -----------------------------------*/
   2055              if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
   \                     ??HAL_UART_IRQHandler_5: (+1)
   \       0x72   0x07B8             LSLS     R0,R7,#+30
   \       0x74   0xD508             BPL.N    ??HAL_UART_IRQHandler_6
   \       0x76   0xF019 0x0001      ANDS     R0,R9,#0x1
   \       0x7A   0xB2C0             UXTB     R0,R0
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD003             BEQ.N    ??HAL_UART_IRQHandler_6
   2056              {
   2057                huart->ErrorCode |= HAL_UART_ERROR_FE;
   \       0x80   0x6BF0             LDR      R0,[R6, #+60]
   \       0x82   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x86   0x63F0             STR      R0,[R6, #+60]
   2058              }
   2059          
   2060              /* UART Over-Run interrupt occurred --------------------------------------*/
   2061              if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
   \                     ??HAL_UART_IRQHandler_6: (+1)
   \       0x88   0x0738             LSLS     R0,R7,#+28
   \       0x8A   0xD50B             BPL.N    ??HAL_UART_IRQHandler_7
   \       0x8C   0xEA5F 0x6088      LSLS     R0,R8,#+26
   \       0x90   0xD404             BMI.N    ??HAL_UART_IRQHandler_8
   \       0x92   0xF019 0x0001      ANDS     R0,R9,#0x1
   \       0x96   0xB2C0             UXTB     R0,R0
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD003             BEQ.N    ??HAL_UART_IRQHandler_7
   2062              {
   2063                huart->ErrorCode |= HAL_UART_ERROR_ORE;
   \                     ??HAL_UART_IRQHandler_8: (+1)
   \       0x9C   0x6BF0             LDR      R0,[R6, #+60]
   \       0x9E   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0xA2   0x63F0             STR      R0,[R6, #+60]
   2064              }
   2065          
   2066              /* Call UART Error Call back function if need be --------------------------*/
   2067              if (huart->ErrorCode != HAL_UART_ERROR_NONE)
   \                     ??HAL_UART_IRQHandler_7: (+1)
   \       0xA4   0x6BF0             LDR      R0,[R6, #+60]
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD03D             BEQ.N    ??HAL_UART_IRQHandler_9
   2068              {
   2069                /* UART in mode Receiver -----------------------------------------------*/
   2070                if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
   \       0xAA   0x06B8             LSLS     R0,R7,#+26
   \       0xAC   0xD505             BPL.N    ??HAL_UART_IRQHandler_10
   \       0xAE   0xEA5F 0x6088      LSLS     R0,R8,#+26
   \       0xB2   0xD502             BPL.N    ??HAL_UART_IRQHandler_10
   2071                {
   2072                  UART_Receive_IT(huart);
   \       0xB4   0x0030             MOVS     R0,R6
   \       0xB6   0x.... 0x....      BL       UART_Receive_IT
   2073                }
   2074          
   2075                /* If Overrun error occurs, or if any error occurs in DMA mode reception,
   2076                   consider error as blocking */
   2077                dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??HAL_UART_IRQHandler_10: (+1)
   \       0xBA   0x6830             LDR      R0,[R6, #+0]
   \       0xBC   0x6940             LDR      R0,[R0, #+20]
   \       0xBE   0x0980             LSRS     R0,R0,#+6
   \       0xC0   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0xC4   0x0005             MOVS     R5,R0
   2078                if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
   \       0xC6   0x6BF0             LDR      R0,[R6, #+60]
   \       0xC8   0x0700             LSLS     R0,R0,#+28
   \       0xCA   0xD401             BMI.N    ??HAL_UART_IRQHandler_11
   \       0xCC   0x2D00             CMP      R5,#+0
   \       0xCE   0xD025             BEQ.N    ??HAL_UART_IRQHandler_12
   2079                {
   2080                  /* Blocking error : transfer is aborted
   2081                     Set the UART state ready to be able to start again the process,
   2082                     Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
   2083                  UART_EndRxTransfer(huart);
   \                     ??HAL_UART_IRQHandler_11: (+1)
   \       0xD0   0x0030             MOVS     R0,R6
   \       0xD2   0x.... 0x....      BL       UART_EndRxTransfer
   2084          
   2085                  /* Disable the UART DMA Rx request if enabled */
   2086                  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
   \       0xD6   0x6830             LDR      R0,[R6, #+0]
   \       0xD8   0x6940             LDR      R0,[R0, #+20]
   \       0xDA   0x0640             LSLS     R0,R0,#+25
   \       0xDC   0xD51A             BPL.N    ??HAL_UART_IRQHandler_13
   2087                  {
   2088                    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \       0xDE   0x6830             LDR      R0,[R6, #+0]
   \       0xE0   0x6940             LDR      R0,[R0, #+20]
   \       0xE2   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0xE6   0x6831             LDR      R1,[R6, #+0]
   \       0xE8   0x6148             STR      R0,[R1, #+20]
   2089          
   2090                    /* Abort the UART DMA Rx stream */
   2091                    if (huart->hdmarx != NULL)
   \       0xEA   0x6B70             LDR      R0,[R6, #+52]
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD00D             BEQ.N    ??HAL_UART_IRQHandler_14
   2092                    {
   2093                      /* Set the UART DMA Abort callback :
   2094                         will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
   2095                      huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
   \       0xF0   0x.... 0x....      ADR.W    R0,UART_DMAAbortOnError
   \       0xF4   0x6B71             LDR      R1,[R6, #+52]
   \       0xF6   0x6508             STR      R0,[R1, #+80]
   2096                      if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
   \       0xF8   0x6B70             LDR      R0,[R6, #+52]
   \       0xFA   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xD011             BEQ.N    ??HAL_UART_IRQHandler_9
   2097                      {
   2098                        /* Call Directly XferAbortCallback function in case of error */
   2099                        huart->hdmarx->XferAbortCallback(huart->hdmarx);
   \      0x102   0x6B70             LDR      R0,[R6, #+52]
   \      0x104   0x6B71             LDR      R1,[R6, #+52]
   \      0x106   0x6D09             LDR      R1,[R1, #+80]
   \      0x108   0x4788             BLX      R1
   \      0x10A   0xE00C             B.N      ??HAL_UART_IRQHandler_9
   2100                      }
   2101                    }
   2102                    else
   2103                    {
   2104                      /* Call user error callback */
   2105          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2106                      /*Call registered error callback*/
   2107                      huart->ErrorCallback(huart);
   2108          #else
   2109                      /*Call legacy weak error callback*/
   2110                      HAL_UART_ErrorCallback(huart);
   \                     ??HAL_UART_IRQHandler_14: (+1)
   \      0x10C   0x0030             MOVS     R0,R6
   \      0x10E   0x.... 0x....      BL       HAL_UART_ErrorCallback
   \      0x112   0xE008             B.N      ??HAL_UART_IRQHandler_9
   2111          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2112                    }
   2113                  }
   2114                  else
   2115                  {
   2116                    /* Call user error callback */
   2117          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2118                    /*Call registered error callback*/
   2119                    huart->ErrorCallback(huart);
   2120          #else
   2121                    /*Call legacy weak error callback*/
   2122                    HAL_UART_ErrorCallback(huart);
   \                     ??HAL_UART_IRQHandler_13: (+1)
   \      0x114   0x0030             MOVS     R0,R6
   \      0x116   0x.... 0x....      BL       HAL_UART_ErrorCallback
   \      0x11A   0xE004             B.N      ??HAL_UART_IRQHandler_9
   2123          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2124                  }
   2125                }
   2126                else
   2127                {
   2128                  /* Non Blocking error : transfer could go on.
   2129                     Error is notified to user through user error callback */
   2130          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2131                  /*Call registered error callback*/
   2132                  huart->ErrorCallback(huart);
   2133          #else
   2134                  /*Call legacy weak error callback*/
   2135                  HAL_UART_ErrorCallback(huart);
   \                     ??HAL_UART_IRQHandler_12: (+1)
   \      0x11C   0x0030             MOVS     R0,R6
   \      0x11E   0x.... 0x....      BL       HAL_UART_ErrorCallback
   2136          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2137          
   2138                  huart->ErrorCode = HAL_UART_ERROR_NONE;
   \      0x122   0x2000             MOVS     R0,#+0
   \      0x124   0x63F0             STR      R0,[R6, #+60]
   2139                }
   2140              }
   2141              return;
   \                     ??HAL_UART_IRQHandler_9: (+1)
   \      0x126   0xE011             B.N      ??HAL_UART_IRQHandler_1
   2142            } /* End if some error occurs */
   2143          
   2144            /* UART in mode Transmitter ------------------------------------------------*/
   2145            if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
   \                     ??HAL_UART_IRQHandler_2: (+1)
   \      0x128   0x0638             LSLS     R0,R7,#+24
   \      0x12A   0xD506             BPL.N    ??HAL_UART_IRQHandler_15
   \      0x12C   0xEA5F 0x6008      LSLS     R0,R8,#+24
   \      0x130   0xD503             BPL.N    ??HAL_UART_IRQHandler_15
   2146            {
   2147              UART_Transmit_IT(huart);
   \      0x132   0x0030             MOVS     R0,R6
   \      0x134   0x.... 0x....      BL       UART_Transmit_IT
   2148              return;
   \      0x138   0xE008             B.N      ??HAL_UART_IRQHandler_1
   2149            }
   2150          
   2151            /* UART in mode Transmitter end --------------------------------------------*/
   2152            if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
   \                     ??HAL_UART_IRQHandler_15: (+1)
   \      0x13A   0x0678             LSLS     R0,R7,#+25
   \      0x13C   0xD506             BPL.N    ??HAL_UART_IRQHandler_16
   \      0x13E   0xEA5F 0x6048      LSLS     R0,R8,#+25
   \      0x142   0xD503             BPL.N    ??HAL_UART_IRQHandler_16
   2153            {
   2154              UART_EndTransmit_IT(huart);
   \      0x144   0x0030             MOVS     R0,R6
   \      0x146   0x.... 0x....      BL       UART_EndTransmit_IT
   2155              return;
   \      0x14A   0xE7FF             B.N      ??HAL_UART_IRQHandler_1
   2156            }
   2157          }
   \                     ??HAL_UART_IRQHandler_16: (+1)
   \                     ??HAL_UART_IRQHandler_1: (+1)
   \      0x14C   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}
   2158          
   2159          /**
   2160            * @brief  Tx Transfer completed callbacks.
   2161            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   2162            *                the configuration information for the specified UART module.
   2163            * @retval None
   2164            */

   \                                 In section .text, align 2
   2165          __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
   2166          {
   2167            /* Prevent unused argument(s) compilation warning */
   2168            UNUSED(huart);
   2169            /* NOTE: This function should not be modified, when the callback is needed,
   2170                     the HAL_UART_TxCpltCallback could be implemented in the user file
   2171             */
   2172          }
   \                     HAL_UART_TxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2173          
   2174          /**
   2175            * @brief  Tx Half Transfer completed callbacks.
   2176            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   2177            *                the configuration information for the specified UART module.
   2178            * @retval None
   2179            */

   \                                 In section .text, align 2
   2180          __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
   2181          {
   2182            /* Prevent unused argument(s) compilation warning */
   2183            UNUSED(huart);
   2184            /* NOTE: This function should not be modified, when the callback is needed,
   2185                     the HAL_UART_TxHalfCpltCallback could be implemented in the user file
   2186             */
   2187          }
   \                     HAL_UART_TxHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2188          
   2189          /**
   2190            * @brief  Rx Transfer completed callbacks.
   2191            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   2192            *                the configuration information for the specified UART module.
   2193            * @retval None
   2194            */

   \                                 In section .text, align 2
   2195          __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
   2196          {
   2197            /* Prevent unused argument(s) compilation warning */
   2198            UNUSED(huart);
   2199            /* NOTE: This function should not be modified, when the callback is needed,
   2200                     the HAL_UART_RxCpltCallback could be implemented in the user file
   2201             */
   2202          }
   \                     HAL_UART_RxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2203          
   2204          /**
   2205            * @brief  Rx Half Transfer completed callbacks.
   2206            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   2207            *                the configuration information for the specified UART module.
   2208            * @retval None
   2209            */

   \                                 In section .text, align 2
   2210          __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
   2211          {
   2212            /* Prevent unused argument(s) compilation warning */
   2213            UNUSED(huart);
   2214            /* NOTE: This function should not be modified, when the callback is needed,
   2215                     the HAL_UART_RxHalfCpltCallback could be implemented in the user file
   2216             */
   2217          }
   \                     HAL_UART_RxHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2218          
   2219          /**
   2220            * @brief  UART error callbacks.
   2221            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   2222            *                the configuration information for the specified UART module.
   2223            * @retval None
   2224            */

   \                                 In section .text, align 2
   2225          __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
   2226          {
   2227            /* Prevent unused argument(s) compilation warning */
   2228            UNUSED(huart);
   2229            /* NOTE: This function should not be modified, when the callback is needed,
   2230                     the HAL_UART_ErrorCallback could be implemented in the user file
   2231             */
   2232          }
   \                     HAL_UART_ErrorCallback: (+1)
   \        0x0   0x4770             BX       LR
   2233          
   2234          /**
   2235            * @brief  UART Abort Complete callback.
   2236            * @param  huart UART handle.
   2237            * @retval None
   2238            */

   \                                 In section .text, align 2
   2239          __weak void HAL_UART_AbortCpltCallback(UART_HandleTypeDef *huart)
   2240          {
   2241            /* Prevent unused argument(s) compilation warning */
   2242            UNUSED(huart);
   2243          
   2244            /* NOTE : This function should not be modified, when the callback is needed,
   2245                      the HAL_UART_AbortCpltCallback can be implemented in the user file.
   2246             */
   2247          }
   \                     HAL_UART_AbortCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2248          
   2249          /**
   2250            * @brief  UART Abort Complete callback.
   2251            * @param  huart UART handle.
   2252            * @retval None
   2253            */

   \                                 In section .text, align 2
   2254          __weak void HAL_UART_AbortTransmitCpltCallback(UART_HandleTypeDef *huart)
   2255          {
   2256            /* Prevent unused argument(s) compilation warning */
   2257            UNUSED(huart);
   2258          
   2259            /* NOTE : This function should not be modified, when the callback is needed,
   2260                      the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
   2261             */
   2262          }
   \                     HAL_UART_AbortTransmitCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2263          
   2264          /**
   2265            * @brief  UART Abort Receive Complete callback.
   2266            * @param  huart UART handle.
   2267            * @retval None
   2268            */

   \                                 In section .text, align 2
   2269          __weak void HAL_UART_AbortReceiveCpltCallback(UART_HandleTypeDef *huart)
   2270          {
   2271            /* Prevent unused argument(s) compilation warning */
   2272            UNUSED(huart);
   2273          
   2274            /* NOTE : This function should not be modified, when the callback is needed,
   2275                      the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
   2276             */
   2277          }
   \                     HAL_UART_AbortReceiveCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2278          
   2279          /**
   2280            * @}
   2281            */
   2282          
   2283          /** @defgroup UART_Exported_Functions_Group3 Peripheral Control functions
   2284            *  @brief   UART control functions
   2285            *
   2286          @verbatim
   2287            ==============================================================================
   2288                                ##### Peripheral Control functions #####
   2289            ==============================================================================
   2290            [..]
   2291              This subsection provides a set of functions allowing to control the UART:
   2292              (+) HAL_LIN_SendBreak() API can be helpful to transmit the break character.
   2293              (+) HAL_MultiProcessor_EnterMuteMode() API can be helpful to enter the UART in mute mode.
   2294              (+) HAL_MultiProcessor_ExitMuteMode() API can be helpful to exit the UART mute mode by software.
   2295              (+) HAL_HalfDuplex_EnableTransmitter() API to enable the UART transmitter and disables the UART receiver in Half Duplex mode
   2296              (+) HAL_HalfDuplex_EnableReceiver() API to enable the UART receiver and disables the UART transmitter in Half Duplex mode
   2297          
   2298          @endverbatim
   2299            * @{
   2300            */
   2301          
   2302          /**
   2303            * @brief  Transmits break characters.
   2304            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   2305            *                the configuration information for the specified UART module.
   2306            * @retval HAL status
   2307            */

   \                                 In section .text, align 2, keep-with-next
   2308          HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
   2309          {
   \                     HAL_LIN_SendBreak: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   2310            /* Check the parameters */
   2311            assert_param(IS_UART_INSTANCE(huart->Instance));
   2312          
   2313            /* Process Locked */
   2314            __HAL_LOCK(huart);
   \        0x2   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD101             BNE.N    ??HAL_LIN_SendBreak_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xE012             B.N      ??HAL_LIN_SendBreak_1
   \                     ??HAL_LIN_SendBreak_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF881 0x0038      STRB     R0,[R1, #+56]
   2315          
   2316            huart->gState = HAL_UART_STATE_BUSY;
   \       0x14   0x2024             MOVS     R0,#+36
   \       0x16   0xF881 0x0039      STRB     R0,[R1, #+57]
   2317          
   2318            /* Send break characters */
   2319            SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
   \       0x1A   0x6808             LDR      R0,[R1, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x22   0x680A             LDR      R2,[R1, #+0]
   \       0x24   0x60D0             STR      R0,[R2, #+12]
   2320          
   2321            huart->gState = HAL_UART_STATE_READY;
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0xF881 0x0039      STRB     R0,[R1, #+57]
   2322          
   2323            /* Process Unlocked */
   2324            __HAL_UNLOCK(huart);
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xF881 0x0038      STRB     R0,[R1, #+56]
   2325          
   2326            return HAL_OK;
   \       0x32   0x2000             MOVS     R0,#+0
   \                     ??HAL_LIN_SendBreak_1: (+1)
   \       0x34   0x4770             BX       LR
   2327          }
   2328          
   2329          /**
   2330            * @brief  Enters the UART in mute mode.
   2331            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   2332            *                the configuration information for the specified UART module.
   2333            * @retval HAL status
   2334            */

   \                                 In section .text, align 2, keep-with-next
   2335          HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
   2336          {
   \                     HAL_MultiProcessor_EnterMuteMode: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   2337            /* Check the parameters */
   2338            assert_param(IS_UART_INSTANCE(huart->Instance));
   2339          
   2340            /* Process Locked */
   2341            __HAL_LOCK(huart);
   \        0x2   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD101             BNE.N    ??HAL_MultiProcessor_EnterMuteMode_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xE012             B.N      ??HAL_MultiProcessor_EnterMuteMode_1
   \                     ??HAL_MultiProcessor_EnterMuteMode_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF881 0x0038      STRB     R0,[R1, #+56]
   2342          
   2343            huart->gState = HAL_UART_STATE_BUSY;
   \       0x14   0x2024             MOVS     R0,#+36
   \       0x16   0xF881 0x0039      STRB     R0,[R1, #+57]
   2344          
   2345            /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
   2346            SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
   \       0x1A   0x6808             LDR      R0,[R1, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x22   0x680A             LDR      R2,[R1, #+0]
   \       0x24   0x60D0             STR      R0,[R2, #+12]
   2347          
   2348            huart->gState = HAL_UART_STATE_READY;
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0xF881 0x0039      STRB     R0,[R1, #+57]
   2349          
   2350            /* Process Unlocked */
   2351            __HAL_UNLOCK(huart);
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xF881 0x0038      STRB     R0,[R1, #+56]
   2352          
   2353            return HAL_OK;
   \       0x32   0x2000             MOVS     R0,#+0
   \                     ??HAL_MultiProcessor_EnterMuteMode_1: (+1)
   \       0x34   0x4770             BX       LR
   2354          }
   2355          
   2356          /**
   2357            * @brief  Exits the UART mute mode: wake up software.
   2358            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   2359            *                the configuration information for the specified UART module.
   2360            * @retval HAL status
   2361            */

   \                                 In section .text, align 2, keep-with-next
   2362          HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
   2363          {
   \                     HAL_MultiProcessor_ExitMuteMode: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   2364            /* Check the parameters */
   2365            assert_param(IS_UART_INSTANCE(huart->Instance));
   2366          
   2367            /* Process Locked */
   2368            __HAL_LOCK(huart);
   \        0x2   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD101             BNE.N    ??HAL_MultiProcessor_ExitMuteMode_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xE012             B.N      ??HAL_MultiProcessor_ExitMuteMode_1
   \                     ??HAL_MultiProcessor_ExitMuteMode_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF881 0x0038      STRB     R0,[R1, #+56]
   2369          
   2370            huart->gState = HAL_UART_STATE_BUSY;
   \       0x14   0x2024             MOVS     R0,#+36
   \       0x16   0xF881 0x0039      STRB     R0,[R1, #+57]
   2371          
   2372            /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
   2373            CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
   \       0x1A   0x6808             LDR      R0,[R1, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x22   0x680A             LDR      R2,[R1, #+0]
   \       0x24   0x60D0             STR      R0,[R2, #+12]
   2374          
   2375            huart->gState = HAL_UART_STATE_READY;
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0xF881 0x0039      STRB     R0,[R1, #+57]
   2376          
   2377            /* Process Unlocked */
   2378            __HAL_UNLOCK(huart);
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xF881 0x0038      STRB     R0,[R1, #+56]
   2379          
   2380            return HAL_OK;
   \       0x32   0x2000             MOVS     R0,#+0
   \                     ??HAL_MultiProcessor_ExitMuteMode_1: (+1)
   \       0x34   0x4770             BX       LR
   2381          }
   2382          
   2383          /**
   2384            * @brief  Enables the UART transmitter and disables the UART receiver.
   2385            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   2386            *                the configuration information for the specified UART module.
   2387            * @retval HAL status
   2388            */

   \                                 In section .text, align 2, keep-with-next
   2389          HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
   2390          {
   \                     HAL_HalfDuplex_EnableTransmitter: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   2391            uint32_t tmpreg = 0x00U;
   \        0x2   0x2200             MOVS     R2,#+0
   2392          
   2393            /* Process Locked */
   2394            __HAL_LOCK(huart);
   \        0x4   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE.N    ??HAL_HalfDuplex_EnableTransmitter_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE014             B.N      ??HAL_HalfDuplex_EnableTransmitter_1
   \                     ??HAL_HalfDuplex_EnableTransmitter_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xF881 0x0038      STRB     R0,[R1, #+56]
   2395          
   2396            huart->gState = HAL_UART_STATE_BUSY;
   \       0x16   0x2024             MOVS     R0,#+36
   \       0x18   0xF881 0x0039      STRB     R0,[R1, #+57]
   2397          
   2398            /*-------------------------- USART CR1 Configuration -----------------------*/
   2399            tmpreg = huart->Instance->CR1;
   \       0x1C   0x6808             LDR      R0,[R1, #+0]
   \       0x1E   0x68C3             LDR      R3,[R0, #+12]
   2400          
   2401            /* Clear TE and RE bits */
   2402            tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
   \       0x20   0xF033 0x030C      BICS     R3,R3,#0xC
   2403          
   2404            /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
   2405            tmpreg |= (uint32_t)USART_CR1_TE;
   \       0x24   0xF053 0x0308      ORRS     R3,R3,#0x8
   2406          
   2407            /* Write to USART CR1 */
   2408            WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
   \       0x28   0x6808             LDR      R0,[R1, #+0]
   \       0x2A   0x60C3             STR      R3,[R0, #+12]
   2409          
   2410            huart->gState = HAL_UART_STATE_READY;
   \       0x2C   0x2020             MOVS     R0,#+32
   \       0x2E   0xF881 0x0039      STRB     R0,[R1, #+57]
   2411          
   2412            /* Process Unlocked */
   2413            __HAL_UNLOCK(huart);
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xF881 0x0038      STRB     R0,[R1, #+56]
   2414          
   2415            return HAL_OK;
   \       0x38   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_EnableTransmitter_1: (+1)
   \       0x3A   0x4770             BX       LR
   2416          }
   2417          
   2418          /**
   2419            * @brief  Enables the UART receiver and disables the UART transmitter.
   2420            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   2421            *                the configuration information for the specified UART module.
   2422            * @retval HAL status
   2423            */

   \                                 In section .text, align 2, keep-with-next
   2424          HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
   2425          {
   \                     HAL_HalfDuplex_EnableReceiver: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   2426            uint32_t tmpreg = 0x00U;
   \        0x2   0x2200             MOVS     R2,#+0
   2427          
   2428            /* Process Locked */
   2429            __HAL_LOCK(huart);
   \        0x4   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE.N    ??HAL_HalfDuplex_EnableReceiver_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE014             B.N      ??HAL_HalfDuplex_EnableReceiver_1
   \                     ??HAL_HalfDuplex_EnableReceiver_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xF881 0x0038      STRB     R0,[R1, #+56]
   2430          
   2431            huart->gState = HAL_UART_STATE_BUSY;
   \       0x16   0x2024             MOVS     R0,#+36
   \       0x18   0xF881 0x0039      STRB     R0,[R1, #+57]
   2432          
   2433            /*-------------------------- USART CR1 Configuration -----------------------*/
   2434            tmpreg = huart->Instance->CR1;
   \       0x1C   0x6808             LDR      R0,[R1, #+0]
   \       0x1E   0x68C3             LDR      R3,[R0, #+12]
   2435          
   2436            /* Clear TE and RE bits */
   2437            tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
   \       0x20   0xF033 0x030C      BICS     R3,R3,#0xC
   2438          
   2439            /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
   2440            tmpreg |= (uint32_t)USART_CR1_RE;
   \       0x24   0xF053 0x0304      ORRS     R3,R3,#0x4
   2441          
   2442            /* Write to USART CR1 */
   2443            WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
   \       0x28   0x6808             LDR      R0,[R1, #+0]
   \       0x2A   0x60C3             STR      R3,[R0, #+12]
   2444          
   2445            huart->gState = HAL_UART_STATE_READY;
   \       0x2C   0x2020             MOVS     R0,#+32
   \       0x2E   0xF881 0x0039      STRB     R0,[R1, #+57]
   2446          
   2447            /* Process Unlocked */
   2448            __HAL_UNLOCK(huart);
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xF881 0x0038      STRB     R0,[R1, #+56]
   2449          
   2450            return HAL_OK;
   \       0x38   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_EnableReceiver_1: (+1)
   \       0x3A   0x4770             BX       LR
   2451          }
   2452          
   2453          /**
   2454            * @}
   2455            */
   2456          
   2457          /** @defgroup UART_Exported_Functions_Group4 Peripheral State and Errors functions
   2458            *  @brief   UART State and Errors functions
   2459            *
   2460          @verbatim
   2461            ==============================================================================
   2462                           ##### Peripheral State and Errors functions #####
   2463            ==============================================================================
   2464           [..]
   2465             This subsection provides a set of functions allowing to return the State of
   2466             UART communication process, return Peripheral Errors occurred during communication
   2467             process
   2468             (+) HAL_UART_GetState() API can be helpful to check in run-time the state of the UART peripheral.
   2469             (+) HAL_UART_GetError() check in run-time errors that could be occurred during communication.
   2470          
   2471          @endverbatim
   2472            * @{
   2473            */
   2474          
   2475          /**
   2476            * @brief  Returns the UART state.
   2477            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   2478            *                the configuration information for the specified UART module.
   2479            * @retval HAL state
   2480            */

   \                                 In section .text, align 2, keep-with-next
   2481          HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
   2482          {
   \                     HAL_UART_GetState: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0001             MOVS     R1,R0
   2483            uint32_t temp1 = 0x00U, temp2 = 0x00U;
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2300             MOVS     R3,#+0
   2484            temp1 = huart->gState;
   \        0x8   0xF891 0x0039      LDRB     R0,[R1, #+57]
   2485            temp2 = huart->RxState;
   \        0xC   0xF891 0x403A      LDRB     R4,[R1, #+58]
   2486          
   2487            return (HAL_UART_StateTypeDef)(temp1 | temp2);
   \       0x10   0x4320             ORRS     R0,R4,R0
   \       0x12   0xB2C0             UXTB     R0,R0
   \       0x14   0xBC10             POP      {R4}
   \       0x16   0x4770             BX       LR
   2488          }
   2489          
   2490          /**
   2491            * @brief  Return the UART error code
   2492            * @param  huart Pointer to a UART_HandleTypeDef structure that contains
   2493            *               the configuration information for the specified UART.
   2494            * @retval UART Error Code
   2495            */

   \                                 In section .text, align 2, keep-with-next
   2496          uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
   2497          {
   2498            return huart->ErrorCode;
   \                     HAL_UART_GetError: (+1)
   \        0x0   0x6BC0             LDR      R0,[R0, #+60]
   \        0x2   0x4770             BX       LR
   2499          }
   2500          
   2501          /**
   2502            * @}
   2503            */
   2504          
   2505          /**
   2506            * @}
   2507            */
   2508          
   2509          /** @defgroup UART_Private_Functions UART Private Functions
   2510            * @{
   2511            */
   2512          
   2513          /**
   2514            * @brief  Initialize the callbacks to their default values.
   2515            * @param  huart UART handle.
   2516            * @retval none
   2517            */
   2518          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2519          void UART_InitCallbacksToDefault(UART_HandleTypeDef *huart)
   2520          {
   2521            /* Init the UART Callback settings */
   2522            huart->TxHalfCpltCallback        = HAL_UART_TxHalfCpltCallback;        /* Legacy weak TxHalfCpltCallback        */
   2523            huart->TxCpltCallback            = HAL_UART_TxCpltCallback;            /* Legacy weak TxCpltCallback            */
   2524            huart->RxHalfCpltCallback        = HAL_UART_RxHalfCpltCallback;        /* Legacy weak RxHalfCpltCallback        */
   2525            huart->RxCpltCallback            = HAL_UART_RxCpltCallback;            /* Legacy weak RxCpltCallback            */
   2526            huart->ErrorCallback             = HAL_UART_ErrorCallback;             /* Legacy weak ErrorCallback             */
   2527            huart->AbortCpltCallback         = HAL_UART_AbortCpltCallback;         /* Legacy weak AbortCpltCallback         */
   2528            huart->AbortTransmitCpltCallback = HAL_UART_AbortTransmitCpltCallback; /* Legacy weak AbortTransmitCpltCallback */
   2529            huart->AbortReceiveCpltCallback  = HAL_UART_AbortReceiveCpltCallback;  /* Legacy weak AbortReceiveCpltCallback  */
   2530          
   2531          }
   2532          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2533          
   2534          /**
   2535            * @brief  DMA UART transmit process complete callback.
   2536            * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
   2537            *               the configuration information for the specified DMA module.
   2538            * @retval None
   2539            */

   \                                 In section .text, align 4, keep-with-next
   2540          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
   2541          {
   \                     UART_DMATransmitCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2542            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2543            /* DMA Normal mode*/
   2544            if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0x05C0             LSLS     R0,R0,#+23
   \        0xC   0xD40E             BMI.N    ??UART_DMATransmitCplt_0
   2545            {
   2546              huart->TxXferCount = 0x00U;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x84E8             STRH     R0,[R5, #+38]
   2547          
   2548              /* Disable the DMA transfer for transmit request by setting the DMAT bit
   2549                 in the UART CR3 register */
   2550              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \       0x12   0x6828             LDR      R0,[R5, #+0]
   \       0x14   0x6940             LDR      R0,[R0, #+20]
   \       0x16   0xF030 0x0080      BICS     R0,R0,#0x80
   \       0x1A   0x6829             LDR      R1,[R5, #+0]
   \       0x1C   0x6148             STR      R0,[R1, #+20]
   2551          
   2552              /* Enable the UART Transmit Complete Interrupt */
   2553              SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
   \       0x1E   0x6828             LDR      R0,[R5, #+0]
   \       0x20   0x68C0             LDR      R0,[R0, #+12]
   \       0x22   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x26   0x6829             LDR      R1,[R5, #+0]
   \       0x28   0x60C8             STR      R0,[R1, #+12]
   \       0x2A   0xE002             B.N      ??UART_DMATransmitCplt_1
   2554          
   2555            }
   2556            /* DMA Circular mode */
   2557            else
   2558            {
   2559          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2560              /*Call registered Tx complete callback*/
   2561              huart->TxCpltCallback(huart);
   2562          #else
   2563              /*Call legacy weak Tx complete callback*/
   2564              HAL_UART_TxCpltCallback(huart);
   \                     ??UART_DMATransmitCplt_0: (+1)
   \       0x2C   0x0028             MOVS     R0,R5
   \       0x2E   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   2565          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2566            }
   2567          }
   \                     ??UART_DMATransmitCplt_1: (+1)
   \       0x32   0xBD31             POP      {R0,R4,R5,PC}
   2568          
   2569          /**
   2570            * @brief DMA UART transmit process half complete callback
   2571            * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
   2572            *               the configuration information for the specified DMA module.
   2573            * @retval None
   2574            */

   \                                 In section .text, align 4, keep-with-next
   2575          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
   2576          {
   \                     UART_DMATxHalfCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2577            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2578          
   2579          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2580            /*Call registered Tx complete callback*/
   2581            huart->TxHalfCpltCallback(huart);
   2582          #else
   2583            /*Call legacy weak Tx complete callback*/
   2584            HAL_UART_TxHalfCpltCallback(huart);
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x.... 0x....      BL       HAL_UART_TxHalfCpltCallback
   2585          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2586          }
   \        0xC   0xBD31             POP      {R0,R4,R5,PC}
   2587          
   2588          /**
   2589            * @brief  DMA UART receive process complete callback.
   2590            * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
   2591            *               the configuration information for the specified DMA module.
   2592            * @retval None
   2593            */

   \                                 In section .text, align 4, keep-with-next
   2594          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
   2595          {
   \                     UART_DMAReceiveCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2596            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2597            /* DMA Normal mode*/
   2598            if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0x05C0             LSLS     R0,R0,#+23
   \        0xC   0xD416             BMI.N    ??UART_DMAReceiveCplt_0
   2599            {
   2600              huart->RxXferCount = 0U;
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x85E8             STRH     R0,[R5, #+46]
   2601          
   2602              /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   2603              CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
   \       0x12   0x6828             LDR      R0,[R5, #+0]
   \       0x14   0x68C0             LDR      R0,[R0, #+12]
   \       0x16   0xF430 0x7080      BICS     R0,R0,#0x100
   \       0x1A   0x6829             LDR      R1,[R5, #+0]
   \       0x1C   0x60C8             STR      R0,[R1, #+12]
   2604              CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \       0x1E   0x6828             LDR      R0,[R5, #+0]
   \       0x20   0x6940             LDR      R0,[R0, #+20]
   \       0x22   0x0840             LSRS     R0,R0,#+1
   \       0x24   0x0040             LSLS     R0,R0,#+1
   \       0x26   0x6829             LDR      R1,[R5, #+0]
   \       0x28   0x6148             STR      R0,[R1, #+20]
   2605          
   2606              /* Disable the DMA transfer for the receiver request by setting the DMAR bit
   2607                 in the UART CR3 register */
   2608              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \       0x2A   0x6828             LDR      R0,[R5, #+0]
   \       0x2C   0x6940             LDR      R0,[R0, #+20]
   \       0x2E   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x32   0x6829             LDR      R1,[R5, #+0]
   \       0x34   0x6148             STR      R0,[R1, #+20]
   2609          
   2610              /* At end of Rx process, restore huart->RxState to Ready */
   2611              huart->RxState = HAL_UART_STATE_READY;
   \       0x36   0x2020             MOVS     R0,#+32
   \       0x38   0xF885 0x003A      STRB     R0,[R5, #+58]
   2612            }
   2613          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2614            /*Call registered Rx complete callback*/
   2615            huart->RxCpltCallback(huart);
   2616          #else
   2617            /*Call legacy weak Rx complete callback*/
   2618            HAL_UART_RxCpltCallback(huart);
   \                     ??UART_DMAReceiveCplt_0: (+1)
   \       0x3C   0x0028             MOVS     R0,R5
   \       0x3E   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   2619          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2620          }
   \       0x42   0xBD31             POP      {R0,R4,R5,PC}
   2621          
   2622          /**
   2623            * @brief DMA UART receive process half complete callback
   2624            * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
   2625            *               the configuration information for the specified DMA module.
   2626            * @retval None
   2627            */

   \                                 In section .text, align 4, keep-with-next
   2628          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   2629          {
   \                     UART_DMARxHalfCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2630            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2631          
   2632          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2633            /*Call registered Rx Half complete callback*/
   2634            huart->RxHalfCpltCallback(huart);
   2635          #else
   2636            /*Call legacy weak Rx Half complete callback*/
   2637            HAL_UART_RxHalfCpltCallback(huart);
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x.... 0x....      BL       HAL_UART_RxHalfCpltCallback
   2638          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2639          }
   \        0xC   0xBD31             POP      {R0,R4,R5,PC}
   2640          
   2641          /**
   2642            * @brief  DMA UART communication error callback.
   2643            * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
   2644            *               the configuration information for the specified DMA module.
   2645            * @retval None
   2646            */

   \                                 In section .text, align 4, keep-with-next
   2647          static void UART_DMAError(DMA_HandleTypeDef *hdma)
   2648          {
   \                     UART_DMAError: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0006             MOVS     R6,R0
   2649            uint32_t dmarequest = 0x00U;
   \        0x4   0x2000             MOVS     R0,#+0
   2650            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x6   0x6BB7             LDR      R7,[R6, #+56]
   2651          
   2652            /* Stop UART DMA Tx request if ongoing */
   2653            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
   \        0x8   0x6839             LDR      R1,[R7, #+0]
   \        0xA   0x694C             LDR      R4,[R1, #+20]
   \        0xC   0x09E4             LSRS     R4,R4,#+7
   \        0xE   0xF014 0x0401      ANDS     R4,R4,#0x1
   2654            if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
   \       0x12   0xF897 0x1039      LDRB     R1,[R7, #+57]
   \       0x16   0x2921             CMP      R1,#+33
   \       0x18   0xD106             BNE.N    ??UART_DMAError_0
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xD004             BEQ.N    ??UART_DMAError_0
   2655            {
   2656              huart->TxXferCount = 0x00U;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x84F8             STRH     R0,[R7, #+38]
   2657              UART_EndTxTransfer(huart);
   \       0x22   0x0038             MOVS     R0,R7
   \       0x24   0x.... 0x....      BL       UART_EndTxTransfer
   2658            }
   2659          
   2660            /* Stop UART DMA Rx request if ongoing */
   2661            dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
   \                     ??UART_DMAError_0: (+1)
   \       0x28   0x6838             LDR      R0,[R7, #+0]
   \       0x2A   0x6945             LDR      R5,[R0, #+20]
   \       0x2C   0x09AD             LSRS     R5,R5,#+6
   \       0x2E   0xF015 0x0501      ANDS     R5,R5,#0x1
   2662            if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
   \       0x32   0xF897 0x003A      LDRB     R0,[R7, #+58]
   \       0x36   0x2822             CMP      R0,#+34
   \       0x38   0xD106             BNE.N    ??UART_DMAError_1
   \       0x3A   0x2D00             CMP      R5,#+0
   \       0x3C   0xD004             BEQ.N    ??UART_DMAError_1
   2663            {
   2664              huart->RxXferCount = 0x00U;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x85F8             STRH     R0,[R7, #+46]
   2665              UART_EndRxTransfer(huart);
   \       0x42   0x0038             MOVS     R0,R7
   \       0x44   0x.... 0x....      BL       UART_EndRxTransfer
   2666            }
   2667          
   2668            huart->ErrorCode |= HAL_UART_ERROR_DMA;
   \                     ??UART_DMAError_1: (+1)
   \       0x48   0x6BF8             LDR      R0,[R7, #+60]
   \       0x4A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x4E   0x63F8             STR      R0,[R7, #+60]
   2669          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2670            /*Call registered error callback*/
   2671            huart->ErrorCallback(huart);
   2672          #else
   2673            /*Call legacy weak error callback*/
   2674            HAL_UART_ErrorCallback(huart);
   \       0x50   0x0038             MOVS     R0,R7
   \       0x52   0x.... 0x....      BL       HAL_UART_ErrorCallback
   2675          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2676          }
   \       0x56   0xBDF1             POP      {R0,R4-R7,PC}
   2677          
   2678          /**
   2679            * @brief  This function handles UART Communication Timeout.
   2680            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   2681            *                the configuration information for the specified UART module.
   2682            * @param  Flag specifies the UART flag to check.
   2683            * @param  Status The new Flag status (SET or RESET).
   2684            * @param  Tickstart Tick start value
   2685            * @param  Timeout Timeout duration
   2686            * @retval HAL status
   2687            */

   \                                 In section .text, align 2, keep-with-next
   2688          static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
   2689          {
   \                     UART_WaitOnFlagUntilTimeout: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0x9C06             LDR      R4,[SP, #+24]
   2690            /* Wait until flag is set */
   2691            while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
   \                     ??UART_WaitOnFlagUntilTimeout_0: (+1)
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x4030             ANDS     R0,R6,R0
   \       0x14   0x42B0             CMP      R0,R6
   \       0x16   0xD101             BNE.N    ??UART_WaitOnFlagUntilTimeout_1
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE000             B.N      ??UART_WaitOnFlagUntilTimeout_2
   \                     ??UART_WaitOnFlagUntilTimeout_1: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \                     ??UART_WaitOnFlagUntilTimeout_2: (+1)
   \       0x1E   0x4641             MOV      R1,R8
   \       0x20   0xB2C9             UXTB     R1,R1
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD120             BNE.N    ??UART_WaitOnFlagUntilTimeout_3
   2692            {
   2693              /* Check for the Timeout */
   2694              if (Timeout != HAL_MAX_DELAY)
   \       0x26   0xF114 0x0F01      CMN      R4,#+1
   \       0x2A   0xD0F0             BEQ.N    ??UART_WaitOnFlagUntilTimeout_0
   2695              {
   2696                if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
   \       0x2C   0x2C00             CMP      R4,#+0
   \       0x2E   0xD004             BEQ.N    ??UART_WaitOnFlagUntilTimeout_4
   \       0x30   0x.... 0x....      BL       HAL_GetTick
   \       0x34   0x1BC0             SUBS     R0,R0,R7
   \       0x36   0x4284             CMP      R4,R0
   \       0x38   0xD2E9             BCS.N    ??UART_WaitOnFlagUntilTimeout_0
   2697                {
   2698                  /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   2699                  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
   \                     ??UART_WaitOnFlagUntilTimeout_4: (+1)
   \       0x3A   0x6828             LDR      R0,[R5, #+0]
   \       0x3C   0x68C0             LDR      R0,[R0, #+12]
   \       0x3E   0xF430 0x70D0      BICS     R0,R0,#0x1A0
   \       0x42   0x6829             LDR      R1,[R5, #+0]
   \       0x44   0x60C8             STR      R0,[R1, #+12]
   2700                  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \       0x46   0x6828             LDR      R0,[R5, #+0]
   \       0x48   0x6940             LDR      R0,[R0, #+20]
   \       0x4A   0x0840             LSRS     R0,R0,#+1
   \       0x4C   0x0040             LSLS     R0,R0,#+1
   \       0x4E   0x6829             LDR      R1,[R5, #+0]
   \       0x50   0x6148             STR      R0,[R1, #+20]
   2701          
   2702                  huart->gState  = HAL_UART_STATE_READY;
   \       0x52   0x2020             MOVS     R0,#+32
   \       0x54   0xF885 0x0039      STRB     R0,[R5, #+57]
   2703                  huart->RxState = HAL_UART_STATE_READY;
   \       0x58   0x2020             MOVS     R0,#+32
   \       0x5A   0xF885 0x003A      STRB     R0,[R5, #+58]
   2704          
   2705                  /* Process Unlocked */
   2706                  __HAL_UNLOCK(huart);
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xF885 0x0038      STRB     R0,[R5, #+56]
   2707          
   2708                  return HAL_TIMEOUT;
   \       0x64   0x2003             MOVS     R0,#+3
   \       0x66   0xE000             B.N      ??UART_WaitOnFlagUntilTimeout_5
   2709                }
   2710              }
   2711            }
   2712            return HAL_OK;
   \                     ??UART_WaitOnFlagUntilTimeout_3: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \                     ??UART_WaitOnFlagUntilTimeout_5: (+1)
   \       0x6A   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2713          }
   2714          
   2715          /**
   2716            * @brief  End ongoing Tx transfer on UART peripheral (following error detection or Transmit completion).
   2717            * @param  huart UART handle.
   2718            * @retval None
   2719            */

   \                                 In section .text, align 2, keep-with-next
   2720          static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
   2721          {
   2722            /* Disable TXEIE and TCIE interrupts */
   2723            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
   \                     UART_EndTxTransfer: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x68C9             LDR      R1,[R1, #+12]
   \        0x4   0xF031 0x01C0      BICS     R1,R1,#0xC0
   \        0x8   0x6802             LDR      R2,[R0, #+0]
   \        0xA   0x60D1             STR      R1,[R2, #+12]
   2724          
   2725            /* At end of Tx process, restore huart->gState to Ready */
   2726            huart->gState = HAL_UART_STATE_READY;
   \        0xC   0x2120             MOVS     R1,#+32
   \        0xE   0xF880 0x1039      STRB     R1,[R0, #+57]
   2727          }
   \       0x12   0x4770             BX       LR
   2728          
   2729          /**
   2730            * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
   2731            * @param  huart UART handle.
   2732            * @retval None
   2733            */

   \                                 In section .text, align 2, keep-with-next
   2734          static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
   2735          {
   2736            /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
   2737            CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
   \                     UART_EndRxTransfer: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x68C9             LDR      R1,[R1, #+12]
   \        0x4   0xF431 0x7190      BICS     R1,R1,#0x120
   \        0x8   0x6802             LDR      R2,[R0, #+0]
   \        0xA   0x60D1             STR      R1,[R2, #+12]
   2738            CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
   \        0xC   0x6801             LDR      R1,[R0, #+0]
   \        0xE   0x6949             LDR      R1,[R1, #+20]
   \       0x10   0x0849             LSRS     R1,R1,#+1
   \       0x12   0x0049             LSLS     R1,R1,#+1
   \       0x14   0x6802             LDR      R2,[R0, #+0]
   \       0x16   0x6151             STR      R1,[R2, #+20]
   2739          
   2740            /* At end of Rx process, restore huart->RxState to Ready */
   2741            huart->RxState = HAL_UART_STATE_READY;
   \       0x18   0x2120             MOVS     R1,#+32
   \       0x1A   0xF880 0x103A      STRB     R1,[R0, #+58]
   2742          }
   \       0x1E   0x4770             BX       LR
   2743          
   2744          /**
   2745            * @brief  DMA UART communication abort callback, when initiated by HAL services on Error
   2746            *         (To be called at end of DMA Abort procedure following error occurrence).
   2747            * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
   2748            *               the configuration information for the specified DMA module.
   2749            * @retval None
   2750            */

   \                                 In section .text, align 4, keep-with-next
   2751          static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
   2752          {
   \                     UART_DMAAbortOnError: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2753            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2754            huart->RxXferCount = 0x00U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x85E8             STRH     R0,[R5, #+46]
   2755            huart->TxXferCount = 0x00U;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x84E8             STRH     R0,[R5, #+38]
   2756          
   2757          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2758            /*Call registered error callback*/
   2759            huart->ErrorCallback(huart);
   2760          #else
   2761            /*Call legacy weak error callback*/
   2762            HAL_UART_ErrorCallback(huart);
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0x.... 0x....      BL       HAL_UART_ErrorCallback
   2763          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2764          }
   \       0x14   0xBD31             POP      {R0,R4,R5,PC}
   2765          
   2766          /**
   2767            * @brief  DMA UART Tx communication abort callback, when initiated by user
   2768            *         (To be called at end of DMA Tx Abort procedure following user abort request).
   2769            * @note   When this callback is executed, User Abort complete call back is called only if no
   2770            *         Abort still ongoing for Rx DMA Handle.
   2771            * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
   2772            *               the configuration information for the specified DMA module.
   2773            * @retval None
   2774            */

   \                                 In section .text, align 4, keep-with-next
   2775          static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
   2776          {
   \                     UART_DMATxAbortCallback: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2777            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2778          
   2779            huart->hdmatx->XferAbortCallback = NULL;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x6B29             LDR      R1,[R5, #+48]
   \        0xA   0x6508             STR      R0,[R1, #+80]
   2780          
   2781            /* Check if an Abort process is still ongoing */
   2782            if (huart->hdmarx != NULL)
   \        0xC   0x6B68             LDR      R0,[R5, #+52]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD003             BEQ.N    ??UART_DMATxAbortCallback_0
   2783            {
   2784              if (huart->hdmarx->XferAbortCallback != NULL)
   \       0x12   0x6B68             LDR      R0,[R5, #+52]
   \       0x14   0x6D00             LDR      R0,[R0, #+80]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD10E             BNE.N    ??UART_DMATxAbortCallback_1
   2785              {
   2786                return;
   2787              }
   2788            }
   2789          
   2790            /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
   2791            huart->TxXferCount = 0x00U;
   \                     ??UART_DMATxAbortCallback_0: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x84E8             STRH     R0,[R5, #+38]
   2792            huart->RxXferCount = 0x00U;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x85E8             STRH     R0,[R5, #+46]
   2793          
   2794            /* Reset ErrorCode */
   2795            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x63E8             STR      R0,[R5, #+60]
   2796          
   2797            /* Restore huart->gState and huart->RxState to Ready */
   2798            huart->gState  = HAL_UART_STATE_READY;
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0xF885 0x0039      STRB     R0,[R5, #+57]
   2799            huart->RxState = HAL_UART_STATE_READY;
   \       0x2C   0x2020             MOVS     R0,#+32
   \       0x2E   0xF885 0x003A      STRB     R0,[R5, #+58]
   2800          
   2801            /* Call user Abort complete callback */
   2802          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2803            /* Call registered Abort complete callback */
   2804            huart->AbortCpltCallback(huart);
   2805          #else
   2806            /* Call legacy weak Abort complete callback */
   2807            HAL_UART_AbortCpltCallback(huart);
   \       0x32   0x0028             MOVS     R0,R5
   \       0x34   0x.... 0x....      BL       HAL_UART_AbortCpltCallback
   2808          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2809          }
   \                     ??UART_DMATxAbortCallback_1: (+1)
   \       0x38   0xBD31             POP      {R0,R4,R5,PC}
   2810          
   2811          /**
   2812            * @brief  DMA UART Rx communication abort callback, when initiated by user
   2813            *         (To be called at end of DMA Rx Abort procedure following user abort request).
   2814            * @note   When this callback is executed, User Abort complete call back is called only if no
   2815            *         Abort still ongoing for Tx DMA Handle.
   2816            * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
   2817            *               the configuration information for the specified DMA module.
   2818            * @retval None
   2819            */

   \                                 In section .text, align 4, keep-with-next
   2820          static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
   2821          {
   \                     UART_DMARxAbortCallback: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2822            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2823          
   2824            huart->hdmarx->XferAbortCallback = NULL;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x6B69             LDR      R1,[R5, #+52]
   \        0xA   0x6508             STR      R0,[R1, #+80]
   2825          
   2826            /* Check if an Abort process is still ongoing */
   2827            if (huart->hdmatx != NULL)
   \        0xC   0x6B28             LDR      R0,[R5, #+48]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD003             BEQ.N    ??UART_DMARxAbortCallback_0
   2828            {
   2829              if (huart->hdmatx->XferAbortCallback != NULL)
   \       0x12   0x6B28             LDR      R0,[R5, #+48]
   \       0x14   0x6D00             LDR      R0,[R0, #+80]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD10E             BNE.N    ??UART_DMARxAbortCallback_1
   2830              {
   2831                return;
   2832              }
   2833            }
   2834          
   2835            /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
   2836            huart->TxXferCount = 0x00U;
   \                     ??UART_DMARxAbortCallback_0: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x84E8             STRH     R0,[R5, #+38]
   2837            huart->RxXferCount = 0x00U;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x85E8             STRH     R0,[R5, #+46]
   2838          
   2839            /* Reset ErrorCode */
   2840            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x63E8             STR      R0,[R5, #+60]
   2841          
   2842            /* Restore huart->gState and huart->RxState to Ready */
   2843            huart->gState  = HAL_UART_STATE_READY;
   \       0x26   0x2020             MOVS     R0,#+32
   \       0x28   0xF885 0x0039      STRB     R0,[R5, #+57]
   2844            huart->RxState = HAL_UART_STATE_READY;
   \       0x2C   0x2020             MOVS     R0,#+32
   \       0x2E   0xF885 0x003A      STRB     R0,[R5, #+58]
   2845          
   2846            /* Call user Abort complete callback */
   2847          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2848            /* Call registered Abort complete callback */
   2849            huart->AbortCpltCallback(huart);
   2850          #else
   2851            /* Call legacy weak Abort complete callback */
   2852            HAL_UART_AbortCpltCallback(huart);
   \       0x32   0x0028             MOVS     R0,R5
   \       0x34   0x.... 0x....      BL       HAL_UART_AbortCpltCallback
   2853          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2854          }
   \                     ??UART_DMARxAbortCallback_1: (+1)
   \       0x38   0xBD31             POP      {R0,R4,R5,PC}
   2855          
   2856          /**
   2857            * @brief  DMA UART Tx communication abort callback, when initiated by user by a call to
   2858            *         HAL_UART_AbortTransmit_IT API (Abort only Tx transfer)
   2859            *         (This callback is executed at end of DMA Tx Abort procedure following user abort request,
   2860            *         and leads to user Tx Abort Complete callback execution).
   2861            * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
   2862            *               the configuration information for the specified DMA module.
   2863            * @retval None
   2864            */

   \                                 In section .text, align 4, keep-with-next
   2865          static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
   2866          {
   \                     UART_DMATxOnlyAbortCallback: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2867            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2868          
   2869            huart->TxXferCount = 0x00U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x84E8             STRH     R0,[R5, #+38]
   2870          
   2871            /* Restore huart->gState to Ready */
   2872            huart->gState = HAL_UART_STATE_READY;
   \        0xA   0x2020             MOVS     R0,#+32
   \        0xC   0xF885 0x0039      STRB     R0,[R5, #+57]
   2873          
   2874            /* Call user Abort complete callback */
   2875          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2876            /* Call registered Abort Transmit Complete Callback */
   2877            huart->AbortTransmitCpltCallback(huart);
   2878          #else
   2879            /* Call legacy weak Abort Transmit Complete Callback */
   2880            HAL_UART_AbortTransmitCpltCallback(huart);
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0x.... 0x....      BL       HAL_UART_AbortTransmitCpltCallback
   2881          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2882          }
   \       0x16   0xBD31             POP      {R0,R4,R5,PC}
   2883          
   2884          /**
   2885            * @brief  DMA UART Rx communication abort callback, when initiated by user by a call to
   2886            *         HAL_UART_AbortReceive_IT API (Abort only Rx transfer)
   2887            *         (This callback is executed at end of DMA Rx Abort procedure following user abort request,
   2888            *         and leads to user Rx Abort Complete callback execution).
   2889            * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
   2890            *               the configuration information for the specified DMA module.
   2891            * @retval None
   2892            */

   \                                 In section .text, align 4, keep-with-next
   2893          static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
   2894          {
   \                     UART_DMARxOnlyAbortCallback: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2895            UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2896          
   2897            huart->RxXferCount = 0x00U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x85E8             STRH     R0,[R5, #+46]
   2898          
   2899            /* Restore huart->RxState to Ready */
   2900            huart->RxState = HAL_UART_STATE_READY;
   \        0xA   0x2020             MOVS     R0,#+32
   \        0xC   0xF885 0x003A      STRB     R0,[R5, #+58]
   2901          
   2902            /* Call user Abort complete callback */
   2903          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2904            /* Call registered Abort Receive Complete Callback */
   2905            huart->AbortReceiveCpltCallback(huart);
   2906          #else
   2907            /* Call legacy weak Abort Receive Complete Callback */
   2908            HAL_UART_AbortReceiveCpltCallback(huart);
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0x.... 0x....      BL       HAL_UART_AbortReceiveCpltCallback
   2909          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2910          }
   \       0x16   0xBD31             POP      {R0,R4,R5,PC}
   2911          
   2912          /**
   2913            * @brief  Sends an amount of data in non blocking mode.
   2914            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   2915            *                the configuration information for the specified UART module.
   2916            * @retval HAL status
   2917            */

   \                                 In section .text, align 2, keep-with-next
   2918          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
   2919          {
   \                     UART_Transmit_IT: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   2920            uint16_t *tmp;
   2921          
   2922            /* Check that a Tx process is ongoing */
   2923            if (huart->gState == HAL_UART_STATE_BUSY_TX)
   \        0x2   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \        0x6   0x2821             CMP      R0,#+33
   \        0x8   0xD12F             BNE.N    ??UART_Transmit_IT_0
   2924            {
   2925              if (huart->Init.WordLength == UART_WORDLENGTH_9B)
   \        0xA   0x6888             LDR      R0,[R1, #+8]
   \        0xC   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x10   0xD111             BNE.N    ??UART_Transmit_IT_1
   2926              {
   2927                tmp = (uint16_t *) huart->pTxBuffPtr;
   \       0x12   0x6A08             LDR      R0,[R1, #+32]
   \       0x14   0x0002             MOVS     R2,R0
   2928                huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
   \       0x16   0x8810             LDRH     R0,[R2, #+0]
   \       0x18   0x05C0             LSLS     R0,R0,#+23
   \       0x1A   0x0DC0             LSRS     R0,R0,#+23
   \       0x1C   0x680B             LDR      R3,[R1, #+0]
   \       0x1E   0x6058             STR      R0,[R3, #+4]
   2929                if (huart->Init.Parity == UART_PARITY_NONE)
   \       0x20   0x6908             LDR      R0,[R1, #+16]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD103             BNE.N    ??UART_Transmit_IT_2
   2930                {
   2931                  huart->pTxBuffPtr += 2U;
   \       0x26   0x6A08             LDR      R0,[R1, #+32]
   \       0x28   0x1C80             ADDS     R0,R0,#+2
   \       0x2A   0x6208             STR      R0,[R1, #+32]
   \       0x2C   0xE009             B.N      ??UART_Transmit_IT_3
   2932                }
   2933                else
   2934                {
   2935                  huart->pTxBuffPtr += 1U;
   \                     ??UART_Transmit_IT_2: (+1)
   \       0x2E   0x6A08             LDR      R0,[R1, #+32]
   \       0x30   0x1C40             ADDS     R0,R0,#+1
   \       0x32   0x6208             STR      R0,[R1, #+32]
   \       0x34   0xE005             B.N      ??UART_Transmit_IT_3
   2936                }
   2937              }
   2938              else
   2939              {
   2940                huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
   \                     ??UART_Transmit_IT_1: (+1)
   \       0x36   0x6A08             LDR      R0,[R1, #+32]
   \       0x38   0x1C43             ADDS     R3,R0,#+1
   \       0x3A   0x620B             STR      R3,[R1, #+32]
   \       0x3C   0x7800             LDRB     R0,[R0, #+0]
   \       0x3E   0x680B             LDR      R3,[R1, #+0]
   \       0x40   0x6058             STR      R0,[R3, #+4]
   2941              }
   2942          
   2943              if (--huart->TxXferCount == 0U)
   \                     ??UART_Transmit_IT_3: (+1)
   \       0x42   0x8CC8             LDRH     R0,[R1, #+38]
   \       0x44   0x1E40             SUBS     R0,R0,#+1
   \       0x46   0x84C8             STRH     R0,[R1, #+38]
   \       0x48   0xB280             UXTH     R0,R0
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD10B             BNE.N    ??UART_Transmit_IT_4
   2944              {
   2945                /* Disable the UART Transmit Complete Interrupt */
   2946                __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \       0x4E   0x6808             LDR      R0,[R1, #+0]
   \       0x50   0x68C0             LDR      R0,[R0, #+12]
   \       0x52   0xF030 0x0080      BICS     R0,R0,#0x80
   \       0x56   0x680B             LDR      R3,[R1, #+0]
   \       0x58   0x60D8             STR      R0,[R3, #+12]
   2947          
   2948                /* Enable the UART Transmit Complete Interrupt */
   2949                __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
   \       0x5A   0x6808             LDR      R0,[R1, #+0]
   \       0x5C   0x68C0             LDR      R0,[R0, #+12]
   \       0x5E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x62   0x680B             LDR      R3,[R1, #+0]
   \       0x64   0x60D8             STR      R0,[R3, #+12]
   2950              }
   2951              return HAL_OK;
   \                     ??UART_Transmit_IT_4: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xE000             B.N      ??UART_Transmit_IT_5
   2952            }
   2953            else
   2954            {
   2955              return HAL_BUSY;
   \                     ??UART_Transmit_IT_0: (+1)
   \       0x6A   0x2002             MOVS     R0,#+2
   \                     ??UART_Transmit_IT_5: (+1)
   \       0x6C   0x4770             BX       LR
   2956            }
   2957          }
   2958          
   2959          /**
   2960            * @brief  Wraps up transmission in non blocking mode.
   2961            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   2962            *                the configuration information for the specified UART module.
   2963            * @retval HAL status
   2964            */

   \                                 In section .text, align 2, keep-with-next
   2965          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
   2966          {
   \                     UART_EndTransmit_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2967            /* Disable the UART Transmit Complete Interrupt */
   2968            __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C0             LDR      R0,[R0, #+12]
   \        0x8   0xF030 0x0040      BICS     R0,R0,#0x40
   \        0xC   0x6821             LDR      R1,[R4, #+0]
   \        0xE   0x60C8             STR      R0,[R1, #+12]
   2969          
   2970            /* Tx process is ended, restore huart->gState to Ready */
   2971            huart->gState = HAL_UART_STATE_READY;
   \       0x10   0x2020             MOVS     R0,#+32
   \       0x12   0xF884 0x0039      STRB     R0,[R4, #+57]
   2972          
   2973          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   2974            /*Call registered Tx complete callback*/
   2975            huart->TxCpltCallback(huart);
   2976          #else
   2977            /*Call legacy weak Tx complete callback*/
   2978            HAL_UART_TxCpltCallback(huart);
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   2979          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   2980          
   2981            return HAL_OK;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xBD10             POP      {R4,PC}
   2982          }
   2983          
   2984          /**
   2985            * @brief  Receives an amount of data in non blocking mode
   2986            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   2987            *                the configuration information for the specified UART module.
   2988            * @retval HAL status
   2989            */

   \                                 In section .text, align 2, keep-with-next
   2990          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
   2991          {
   \                     UART_Receive_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2992            uint16_t *tmp;
   2993          
   2994            /* Check that a Rx process is ongoing */
   2995            if (huart->RxState == HAL_UART_STATE_BUSY_RX)
   \        0x4   0xF894 0x003A      LDRB     R0,[R4, #+58]
   \        0x8   0x2822             CMP      R0,#+34
   \        0xA   0xD14E             BNE.N    ??UART_Receive_IT_0
   2996            {
   2997              if (huart->Init.WordLength == UART_WORDLENGTH_9B)
   \        0xC   0x68A0             LDR      R0,[R4, #+8]
   \        0xE   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x12   0xD116             BNE.N    ??UART_Receive_IT_1
   2998              {
   2999                tmp = (uint16_t *) huart->pRxBuffPtr;
   \       0x14   0x6AA0             LDR      R0,[R4, #+40]
   \       0x16   0x0005             MOVS     R5,R0
   3000                if (huart->Init.Parity == UART_PARITY_NONE)
   \       0x18   0x6920             LDR      R0,[R4, #+16]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD108             BNE.N    ??UART_Receive_IT_2
   3001                {
   3002                  *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6840             LDR      R0,[R0, #+4]
   \       0x22   0x05C0             LSLS     R0,R0,#+23
   \       0x24   0x0DC0             LSRS     R0,R0,#+23
   \       0x26   0x8028             STRH     R0,[R5, #+0]
   3003                  huart->pRxBuffPtr += 2U;
   \       0x28   0x6AA0             LDR      R0,[R4, #+40]
   \       0x2A   0x1C80             ADDS     R0,R0,#+2
   \       0x2C   0x62A0             STR      R0,[R4, #+40]
   \       0x2E   0xE01A             B.N      ??UART_Receive_IT_3
   3004                }
   3005                else
   3006                {
   3007                  *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
   \                     ??UART_Receive_IT_2: (+1)
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6840             LDR      R0,[R0, #+4]
   \       0x34   0xF000 0x00FF      AND      R0,R0,#0xFF
   \       0x38   0x8028             STRH     R0,[R5, #+0]
   3008                  huart->pRxBuffPtr += 1U;
   \       0x3A   0x6AA0             LDR      R0,[R4, #+40]
   \       0x3C   0x1C40             ADDS     R0,R0,#+1
   \       0x3E   0x62A0             STR      R0,[R4, #+40]
   \       0x40   0xE011             B.N      ??UART_Receive_IT_3
   3009                }
   3010              }
   3011              else
   3012              {
   3013                if (huart->Init.Parity == UART_PARITY_NONE)
   \                     ??UART_Receive_IT_1: (+1)
   \       0x42   0x6920             LDR      R0,[R4, #+16]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD106             BNE.N    ??UART_Receive_IT_4
   3014                {
   3015                  *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
   \       0x48   0x6AA0             LDR      R0,[R4, #+40]
   \       0x4A   0x1C41             ADDS     R1,R0,#+1
   \       0x4C   0x62A1             STR      R1,[R4, #+40]
   \       0x4E   0x6821             LDR      R1,[R4, #+0]
   \       0x50   0x6849             LDR      R1,[R1, #+4]
   \       0x52   0x7001             STRB     R1,[R0, #+0]
   \       0x54   0xE007             B.N      ??UART_Receive_IT_3
   3016                }
   3017                else
   3018                {
   3019                  *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
   \                     ??UART_Receive_IT_4: (+1)
   \       0x56   0x6AA0             LDR      R0,[R4, #+40]
   \       0x58   0x1C41             ADDS     R1,R0,#+1
   \       0x5A   0x62A1             STR      R1,[R4, #+40]
   \       0x5C   0x6821             LDR      R1,[R4, #+0]
   \       0x5E   0x6849             LDR      R1,[R1, #+4]
   \       0x60   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \       0x64   0x7001             STRB     R1,[R0, #+0]
   3020                }
   3021              }
   3022          
   3023              if (--huart->RxXferCount == 0U)
   \                     ??UART_Receive_IT_3: (+1)
   \       0x66   0x8DE0             LDRH     R0,[R4, #+46]
   \       0x68   0x1E40             SUBS     R0,R0,#+1
   \       0x6A   0x85E0             STRH     R0,[R4, #+46]
   \       0x6C   0xB280             UXTH     R0,R0
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD119             BNE.N    ??UART_Receive_IT_5
   3024              {
   3025                /* Disable the UART Data Register not empty Interrupt */
   3026                __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x68C0             LDR      R0,[R0, #+12]
   \       0x76   0xF030 0x0020      BICS     R0,R0,#0x20
   \       0x7A   0x6821             LDR      R1,[R4, #+0]
   \       0x7C   0x60C8             STR      R0,[R1, #+12]
   3027          
   3028                /* Disable the UART Parity Error Interrupt */
   3029                __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \       0x7E   0x6820             LDR      R0,[R4, #+0]
   \       0x80   0x68C0             LDR      R0,[R0, #+12]
   \       0x82   0xF430 0x7080      BICS     R0,R0,#0x100
   \       0x86   0x6821             LDR      R1,[R4, #+0]
   \       0x88   0x60C8             STR      R0,[R1, #+12]
   3030          
   3031                /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   3032                __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \       0x8A   0x6820             LDR      R0,[R4, #+0]
   \       0x8C   0x6940             LDR      R0,[R0, #+20]
   \       0x8E   0x0840             LSRS     R0,R0,#+1
   \       0x90   0x0040             LSLS     R0,R0,#+1
   \       0x92   0x6821             LDR      R1,[R4, #+0]
   \       0x94   0x6148             STR      R0,[R1, #+20]
   3033          
   3034                /* Rx process is completed, restore huart->RxState to Ready */
   3035                huart->RxState = HAL_UART_STATE_READY;
   \       0x96   0x2020             MOVS     R0,#+32
   \       0x98   0xF884 0x003A      STRB     R0,[R4, #+58]
   3036          
   3037          #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
   3038                /*Call registered Rx complete callback*/
   3039                huart->RxCpltCallback(huart);
   3040          #else
   3041                /*Call legacy weak Rx complete callback*/
   3042                HAL_UART_RxCpltCallback(huart);
   \       0x9C   0x0020             MOVS     R0,R4
   \       0x9E   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   3043          #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
   3044          
   3045                return HAL_OK;
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0xE002             B.N      ??UART_Receive_IT_6
   3046              }
   3047              return HAL_OK;
   \                     ??UART_Receive_IT_5: (+1)
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0xE000             B.N      ??UART_Receive_IT_6
   3048            }
   3049            else
   3050            {
   3051              return HAL_BUSY;
   \                     ??UART_Receive_IT_0: (+1)
   \       0xAA   0x2002             MOVS     R0,#+2
   \                     ??UART_Receive_IT_6: (+1)
   \       0xAC   0xBD32             POP      {R1,R4,R5,PC}
   3052            }
   3053          }
   3054          
   3055          /**
   3056            * @brief  Configures the UART peripheral.
   3057            * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
   3058            *                the configuration information for the specified UART module.
   3059            * @retval None
   3060            */

   \                                 In section .text, align 2, keep-with-next
   3061          static void UART_SetConfig(UART_HandleTypeDef *huart)
   3062          {
   \                     UART_SetConfig: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0xB084             SUB      SP,SP,#+16
   \        0x6   0x4682             MOV      R10,R0
   3063            uint32_t tmpreg;
   3064            uint32_t pclk;
   3065          
   3066            /* Check the parameters */
   3067            assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
   3068            assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
   3069            assert_param(IS_UART_PARITY(huart->Init.Parity));
   3070            assert_param(IS_UART_MODE(huart->Init.Mode));
   3071          
   3072            /*-------------------------- USART CR2 Configuration -----------------------*/
   3073            /* Configure the UART Stop Bits: Set STOP[13:12] bits
   3074               according to huart->Init.StopBits value */
   3075            MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
   \        0x8   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \        0xC   0x6901             LDR      R1,[R0, #+16]
   \        0xE   0xF431 0x5140      BICS     R1,R1,#0x3000
   \       0x12   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \       0x16   0x4301             ORRS     R1,R0,R1
   \       0x18   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x1C   0x6101             STR      R1,[R0, #+16]
   3076          
   3077            /*-------------------------- USART CR1 Configuration -----------------------*/
   3078            /* Configure the UART Word Length, Parity and mode:
   3079               Set the M bits according to huart->Init.WordLength value
   3080               Set PCE and PS bits according to huart->Init.Parity value
   3081               Set TE and RE bits according to huart->Init.Mode value
   3082               Set OVER8 bit according to huart->Init.OverSampling value */
   3083          
   3084            tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
   \       0x1E   0xF8DA 0xB008      LDR      R11,[R10, #+8]
   \       0x22   0xF8DA 0x0010      LDR      R0,[R10, #+16]
   \       0x26   0xEA50 0x0B0B      ORRS     R11,R0,R11
   \       0x2A   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \       0x2E   0xEA50 0x0B0B      ORRS     R11,R0,R11
   \       0x32   0xF8DA 0x001C      LDR      R0,[R10, #+28]
   \       0x36   0xEA50 0x0B0B      ORRS     R11,R0,R11
   3085            MODIFY_REG(huart->Instance->CR1,
   3086                       (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
   3087                       tmpreg);
   \       0x3A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x3E   0x68C1             LDR      R1,[R0, #+12]
   \       0x40   0x.... 0x....      LDR.W    R0,??DataTable1
   \       0x44   0x4001             ANDS     R1,R0,R1
   \       0x46   0xEA5B 0x0101      ORRS     R1,R11,R1
   \       0x4A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x4E   0x60C1             STR      R1,[R0, #+12]
   3088          
   3089            /*-------------------------- USART CR3 Configuration -----------------------*/
   3090            /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
   3091            MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
   \       0x50   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x54   0x6941             LDR      R1,[R0, #+20]
   \       0x56   0xF431 0x7140      BICS     R1,R1,#0x300
   \       0x5A   0xF8DA 0x0018      LDR      R0,[R10, #+24]
   \       0x5E   0x4301             ORRS     R1,R0,R1
   \       0x60   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x64   0x6141             STR      R1,[R0, #+20]
   3092          
   3093            /* Check the Over Sampling */
   3094            if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
   \       0x66   0xF8DA 0x001C      LDR      R0,[R10, #+28]
   \       0x6A   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x6E   0xF040 0x815F      BNE.W    ??UART_SetConfig_0
   3095            {
   3096              /*-------------------------- USART BRR Configuration ---------------------*/
   3097          #if defined(USART6) && defined(UART9) && defined(UART10)
   3098              if ((huart->Instance == USART1) || (huart->Instance == USART6) || (huart->Instance == UART9) || (huart->Instance == UART10))
   3099              {
   3100                pclk = HAL_RCC_GetPCLK2Freq();
   3101                huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
   3102              }
   3103          #elif defined(USART6)
   3104              if ((huart->Instance == USART1) || (huart->Instance == USART6))
   \       0x72   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x76   0x.... 0x....      LDR.W    R1,??DataTable1_1
   \       0x7A   0x4288             CMP      R0,R1
   \       0x7C   0xD006             BEQ.N    ??UART_SetConfig_1
   \       0x7E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x82   0x.... 0x....      LDR.W    R1,??DataTable1_2
   \       0x86   0x4288             CMP      R0,R1
   \       0x88   0xF040 0x80A9      BNE.W    ??UART_SetConfig_2
   3105              {
   3106                pclk = HAL_RCC_GetPCLK2Freq();
   \                     ??UART_SetConfig_1: (+1)
   \       0x8C   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \       0x90   0x0004             MOVS     R4,R0
   3107                huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
   \       0x92   0xF07F 0x0563      MVNS     R5,#+99
   \       0x96   0x2602             MOVS     R6,#+2
   \       0x98   0x2700             MOVS     R7,#+0
   \       0x9A   0xF05F 0x0819      MOVS     R8,#+25
   \       0x9E   0xF05F 0x0900      MOVS     R9,#+0
   \       0xA2   0x0022             MOVS     R2,R4
   \       0xA4   0x2300             MOVS     R3,#+0
   \       0xA6   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \       0xAA   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \       0xAE   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \       0xB2   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \       0xB6   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0xBA   0x2100             MOVS     R1,#+0
   \       0xBC   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \       0xC0   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \       0xC4   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \       0xC8   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \       0xCC   0x.... 0x....      BL       __aeabi_uldivmod
   \       0xD0   0x2164             MOVS     R1,#+100
   \       0xD2   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0xD6   0x9003             STR      R0,[SP, #+12]
   \       0xD8   0x0022             MOVS     R2,R4
   \       0xDA   0x2300             MOVS     R3,#+0
   \       0xDC   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \       0xE0   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \       0xE4   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \       0xE8   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \       0xEC   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \       0xF0   0x2100             MOVS     R1,#+0
   \       0xF2   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \       0xF6   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \       0xFA   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \       0xFE   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \      0x102   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x106   0x9002             STR      R0,[SP, #+8]
   \      0x108   0x0022             MOVS     R2,R4
   \      0x10A   0x2300             MOVS     R3,#+0
   \      0x10C   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x110   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x114   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x118   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x11C   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x120   0x2100             MOVS     R1,#+0
   \      0x122   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x126   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x12A   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x12E   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \      0x132   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x136   0x2164             MOVS     R1,#+100
   \      0x138   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \      0x13C   0x9802             LDR      R0,[SP, #+8]
   \      0x13E   0xFB05 0x0101      MLA      R1,R5,R1,R0
   \      0x142   0x00C8             LSLS     R0,R1,#+3
   \      0x144   0x3032             ADDS     R0,R0,#+50
   \      0x146   0x2164             MOVS     R1,#+100
   \      0x148   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \      0x14C   0x0040             LSLS     R0,R0,#+1
   \      0x14E   0xF410 0x70F8      ANDS     R0,R0,#0x1F0
   \      0x152   0x9903             LDR      R1,[SP, #+12]
   \      0x154   0xEB10 0x1001      ADDS     R0,R0,R1, LSL #+4
   \      0x158   0x9002             STR      R0,[SP, #+8]
   \      0x15A   0x0022             MOVS     R2,R4
   \      0x15C   0x2300             MOVS     R3,#+0
   \      0x15E   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x162   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x166   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x16A   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x16E   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x172   0x2100             MOVS     R1,#+0
   \      0x174   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x178   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x17C   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x180   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \      0x184   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x188   0x9000             STR      R0,[SP, #+0]
   \      0x18A   0x0022             MOVS     R2,R4
   \      0x18C   0x2300             MOVS     R3,#+0
   \      0x18E   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x192   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x196   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x19A   0x4680             MOV      R8,R0
   \      0x19C   0x4689             MOV      R9,R1
   \      0x19E   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x1A2   0x2100             MOVS     R1,#+0
   \      0x1A4   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x1A8   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x1AC   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x1B0   0x4640             MOV      R0,R8
   \      0x1B2   0x4649             MOV      R1,R9
   \      0x1B4   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x1B8   0x2164             MOVS     R1,#+100
   \      0x1BA   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \      0x1BE   0x9800             LDR      R0,[SP, #+0]
   \      0x1C0   0xFB05 0x0501      MLA      R5,R5,R1,R0
   \      0x1C4   0x00E8             LSLS     R0,R5,#+3
   \      0x1C6   0x3032             ADDS     R0,R0,#+50
   \      0x1C8   0x2164             MOVS     R1,#+100
   \      0x1CA   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \      0x1CE   0xF011 0x0107      ANDS     R1,R1,#0x7
   \      0x1D2   0x9802             LDR      R0,[SP, #+8]
   \      0x1D4   0x1809             ADDS     R1,R1,R0
   \      0x1D6   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x1DA   0x6081             STR      R1,[R0, #+8]
   \      0x1DC   0xE202             B.N      ??UART_SetConfig_3
   3108              }
   3109          #else
   3110              if (huart->Instance == USART1)
   3111              {
   3112                pclk = HAL_RCC_GetPCLK2Freq();
   3113                huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
   3114              }
   3115          #endif /* USART6 */
   3116              else
   3117              {
   3118                pclk = HAL_RCC_GetPCLK1Freq();
   \                     ??UART_SetConfig_2: (+1)
   \      0x1DE   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \      0x1E2   0x0004             MOVS     R4,R0
   3119                huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
   \      0x1E4   0xF07F 0x0563      MVNS     R5,#+99
   \      0x1E8   0x2602             MOVS     R6,#+2
   \      0x1EA   0x2700             MOVS     R7,#+0
   \      0x1EC   0xF05F 0x0819      MOVS     R8,#+25
   \      0x1F0   0xF05F 0x0900      MOVS     R9,#+0
   \      0x1F4   0x0022             MOVS     R2,R4
   \      0x1F6   0x2300             MOVS     R3,#+0
   \      0x1F8   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x1FC   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x200   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x204   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x208   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x20C   0x2100             MOVS     R1,#+0
   \      0x20E   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x212   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x216   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x21A   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \      0x21E   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x222   0x2164             MOVS     R1,#+100
   \      0x224   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \      0x228   0x9003             STR      R0,[SP, #+12]
   \      0x22A   0x0022             MOVS     R2,R4
   \      0x22C   0x2300             MOVS     R3,#+0
   \      0x22E   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x232   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x236   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x23A   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x23E   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x242   0x2100             MOVS     R1,#+0
   \      0x244   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x248   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x24C   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x250   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \      0x254   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x258   0x9002             STR      R0,[SP, #+8]
   \      0x25A   0x0022             MOVS     R2,R4
   \      0x25C   0x2300             MOVS     R3,#+0
   \      0x25E   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x262   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x266   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x26A   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x26E   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x272   0x2100             MOVS     R1,#+0
   \      0x274   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x278   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x27C   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x280   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \      0x284   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x288   0x2164             MOVS     R1,#+100
   \      0x28A   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \      0x28E   0x9802             LDR      R0,[SP, #+8]
   \      0x290   0xFB05 0x0101      MLA      R1,R5,R1,R0
   \      0x294   0x00C8             LSLS     R0,R1,#+3
   \      0x296   0x3032             ADDS     R0,R0,#+50
   \      0x298   0x2164             MOVS     R1,#+100
   \      0x29A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \      0x29E   0x0040             LSLS     R0,R0,#+1
   \      0x2A0   0xF410 0x70F8      ANDS     R0,R0,#0x1F0
   \      0x2A4   0x9903             LDR      R1,[SP, #+12]
   \      0x2A6   0xEB10 0x1001      ADDS     R0,R0,R1, LSL #+4
   \      0x2AA   0x9002             STR      R0,[SP, #+8]
   \      0x2AC   0x0022             MOVS     R2,R4
   \      0x2AE   0x2300             MOVS     R3,#+0
   \      0x2B0   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x2B4   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x2B8   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x2BC   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x2C0   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x2C4   0x2100             MOVS     R1,#+0
   \      0x2C6   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x2CA   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x2CE   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x2D2   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \      0x2D6   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x2DA   0x9000             STR      R0,[SP, #+0]
   \      0x2DC   0x0022             MOVS     R2,R4
   \      0x2DE   0x2300             MOVS     R3,#+0
   \      0x2E0   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x2E4   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x2E8   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x2EC   0x4680             MOV      R8,R0
   \      0x2EE   0x4689             MOV      R9,R1
   \      0x2F0   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x2F4   0x2100             MOVS     R1,#+0
   \      0x2F6   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x2FA   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x2FE   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x302   0x4640             MOV      R0,R8
   \      0x304   0x4649             MOV      R1,R9
   \      0x306   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x30A   0x2164             MOVS     R1,#+100
   \      0x30C   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \      0x310   0x9800             LDR      R0,[SP, #+0]
   \      0x312   0xFB05 0x0501      MLA      R5,R5,R1,R0
   \      0x316   0x00E8             LSLS     R0,R5,#+3
   \      0x318   0x3032             ADDS     R0,R0,#+50
   \      0x31A   0x2164             MOVS     R1,#+100
   \      0x31C   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \      0x320   0xF011 0x0107      ANDS     R1,R1,#0x7
   \      0x324   0x9802             LDR      R0,[SP, #+8]
   \      0x326   0x1809             ADDS     R1,R1,R0
   \      0x328   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x32C   0x6081             STR      R1,[R0, #+8]
   \      0x32E   0xE159             B.N      ??UART_SetConfig_3
   3120              }
   3121            }
   3122            else
   3123            {
   3124              /*-------------------------- USART BRR Configuration ---------------------*/
   3125          #if defined(USART6) && defined(UART9) && defined(UART10)
   3126              if ((huart->Instance == USART1) || (huart->Instance == USART6) || (huart->Instance == UART9) || (huart->Instance == UART10))
   3127              {
   3128                pclk = HAL_RCC_GetPCLK2Freq();
   3129                huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
   3130              }
   3131          #elif defined(USART6)
   3132              if ((huart->Instance == USART1) || (huart->Instance == USART6))
   \                     ??UART_SetConfig_0: (+1)
   \      0x330   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x334   0x....             LDR.N    R1,??DataTable1_1
   \      0x336   0x4288             CMP      R0,R1
   \      0x338   0xD005             BEQ.N    ??UART_SetConfig_4
   \      0x33A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x33E   0x....             LDR.N    R1,??DataTable1_2
   \      0x340   0x4288             CMP      R0,R1
   \      0x342   0xF040 0x80A8      BNE.W    ??UART_SetConfig_5
   3133              {
   3134                pclk = HAL_RCC_GetPCLK2Freq();
   \                     ??UART_SetConfig_4: (+1)
   \      0x346   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \      0x34A   0x0004             MOVS     R4,R0
   3135                huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
   \      0x34C   0x2604             MOVS     R6,#+4
   \      0x34E   0x2700             MOVS     R7,#+0
   \      0x350   0xF07F 0x0563      MVNS     R5,#+99
   \      0x354   0xF05F 0x0819      MOVS     R8,#+25
   \      0x358   0xF05F 0x0900      MOVS     R9,#+0
   \      0x35C   0x0022             MOVS     R2,R4
   \      0x35E   0x2300             MOVS     R3,#+0
   \      0x360   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x364   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x368   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x36C   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x370   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x374   0x2100             MOVS     R1,#+0
   \      0x376   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x37A   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x37E   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x382   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \      0x386   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x38A   0x2164             MOVS     R1,#+100
   \      0x38C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \      0x390   0x9003             STR      R0,[SP, #+12]
   \      0x392   0x0022             MOVS     R2,R4
   \      0x394   0x2300             MOVS     R3,#+0
   \      0x396   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x39A   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x39E   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x3A2   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x3A6   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x3AA   0x2100             MOVS     R1,#+0
   \      0x3AC   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x3B0   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x3B4   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x3B8   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \      0x3BC   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x3C0   0x9002             STR      R0,[SP, #+8]
   \      0x3C2   0x0022             MOVS     R2,R4
   \      0x3C4   0x2300             MOVS     R3,#+0
   \      0x3C6   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x3CA   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x3CE   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x3D2   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x3D6   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x3DA   0x2100             MOVS     R1,#+0
   \      0x3DC   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x3E0   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x3E4   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x3E8   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \      0x3EC   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x3F0   0x2164             MOVS     R1,#+100
   \      0x3F2   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \      0x3F6   0x9802             LDR      R0,[SP, #+8]
   \      0x3F8   0xFB05 0x0101      MLA      R1,R5,R1,R0
   \      0x3FC   0x0108             LSLS     R0,R1,#+4
   \      0x3FE   0x3032             ADDS     R0,R0,#+50
   \      0x400   0x2164             MOVS     R1,#+100
   \      0x402   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \      0x406   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \      0x40A   0x9903             LDR      R1,[SP, #+12]
   \      0x40C   0xEB10 0x1001      ADDS     R0,R0,R1, LSL #+4
   \      0x410   0x9002             STR      R0,[SP, #+8]
   \      0x412   0x0022             MOVS     R2,R4
   \      0x414   0x2300             MOVS     R3,#+0
   \      0x416   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x41A   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x41E   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x422   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x426   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x42A   0x2100             MOVS     R1,#+0
   \      0x42C   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x430   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x434   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x438   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \      0x43C   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x440   0x9000             STR      R0,[SP, #+0]
   \      0x442   0x0022             MOVS     R2,R4
   \      0x444   0x2300             MOVS     R3,#+0
   \      0x446   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x44A   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x44E   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x452   0x4680             MOV      R8,R0
   \      0x454   0x4689             MOV      R9,R1
   \      0x456   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x45A   0x2100             MOVS     R1,#+0
   \      0x45C   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x460   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x464   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x468   0x4640             MOV      R0,R8
   \      0x46A   0x4649             MOV      R1,R9
   \      0x46C   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x470   0x2164             MOVS     R1,#+100
   \      0x472   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \      0x476   0x9800             LDR      R0,[SP, #+0]
   \      0x478   0xFB05 0x0501      MLA      R5,R5,R1,R0
   \      0x47C   0x0128             LSLS     R0,R5,#+4
   \      0x47E   0x3032             ADDS     R0,R0,#+50
   \      0x480   0x2164             MOVS     R1,#+100
   \      0x482   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \      0x486   0xF011 0x010F      ANDS     R1,R1,#0xF
   \      0x48A   0x9802             LDR      R0,[SP, #+8]
   \      0x48C   0x1809             ADDS     R1,R1,R0
   \      0x48E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x492   0x6081             STR      R1,[R0, #+8]
   \      0x494   0xE0A6             B.N      ??UART_SetConfig_3
   3136              }
   3137          #else
   3138              if (huart->Instance == USART1)
   3139              {
   3140                pclk = HAL_RCC_GetPCLK2Freq();
   3141                huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
   3142              }
   3143          #endif /* USART6 */
   3144              else
   3145              {
   3146                pclk = HAL_RCC_GetPCLK1Freq();
   \                     ??UART_SetConfig_5: (+1)
   \      0x496   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \      0x49A   0x0004             MOVS     R4,R0
   3147                huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
   \      0x49C   0x2604             MOVS     R6,#+4
   \      0x49E   0x2700             MOVS     R7,#+0
   \      0x4A0   0xF07F 0x0563      MVNS     R5,#+99
   \      0x4A4   0xF05F 0x0819      MOVS     R8,#+25
   \      0x4A8   0xF05F 0x0900      MOVS     R9,#+0
   \      0x4AC   0x0022             MOVS     R2,R4
   \      0x4AE   0x2300             MOVS     R3,#+0
   \      0x4B0   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x4B4   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x4B8   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x4BC   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x4C0   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x4C4   0x2100             MOVS     R1,#+0
   \      0x4C6   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x4CA   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x4CE   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x4D2   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \      0x4D6   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x4DA   0x2164             MOVS     R1,#+100
   \      0x4DC   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \      0x4E0   0x9003             STR      R0,[SP, #+12]
   \      0x4E2   0x0022             MOVS     R2,R4
   \      0x4E4   0x2300             MOVS     R3,#+0
   \      0x4E6   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x4EA   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x4EE   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x4F2   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x4F6   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x4FA   0x2100             MOVS     R1,#+0
   \      0x4FC   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x500   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x504   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x508   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \      0x50C   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x510   0x9002             STR      R0,[SP, #+8]
   \      0x512   0x0022             MOVS     R2,R4
   \      0x514   0x2300             MOVS     R3,#+0
   \      0x516   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x51A   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x51E   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x522   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x526   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x52A   0x2100             MOVS     R1,#+0
   \      0x52C   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x530   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x534   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x538   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \      0x53C   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x540   0x2164             MOVS     R1,#+100
   \      0x542   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \      0x546   0x9802             LDR      R0,[SP, #+8]
   \      0x548   0xFB05 0x0101      MLA      R1,R5,R1,R0
   \      0x54C   0x0108             LSLS     R0,R1,#+4
   \      0x54E   0x3032             ADDS     R0,R0,#+50
   \      0x550   0x2164             MOVS     R1,#+100
   \      0x552   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \      0x556   0xF010 0x00F0      ANDS     R0,R0,#0xF0
   \      0x55A   0x9903             LDR      R1,[SP, #+12]
   \      0x55C   0xEB10 0x1001      ADDS     R0,R0,R1, LSL #+4
   \      0x560   0x9002             STR      R0,[SP, #+8]
   \      0x562   0x0022             MOVS     R2,R4
   \      0x564   0x2300             MOVS     R3,#+0
   \      0x566   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x56A   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x56E   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x572   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \      0x576   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x57A   0x2100             MOVS     R1,#+0
   \      0x57C   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x580   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x584   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x588   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \      0x58C   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x590   0x9000             STR      R0,[SP, #+0]
   \      0x592   0x0022             MOVS     R2,R4
   \      0x594   0x2300             MOVS     R3,#+0
   \      0x596   0xFBA8 0x0102      UMULL    R0,R1,R8,R2
   \      0x59A   0xFB08 0x1103      MLA      R1,R8,R3,R1
   \      0x59E   0xFB09 0x1102      MLA      R1,R9,R2,R1
   \      0x5A2   0x4680             MOV      R8,R0
   \      0x5A4   0x4689             MOV      R9,R1
   \      0x5A6   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \      0x5AA   0x2100             MOVS     R1,#+0
   \      0x5AC   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \      0x5B0   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \      0x5B4   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \      0x5B8   0x4640             MOV      R0,R8
   \      0x5BA   0x4649             MOV      R1,R9
   \      0x5BC   0x.... 0x....      BL       __aeabi_uldivmod
   \      0x5C0   0x2164             MOVS     R1,#+100
   \      0x5C2   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \      0x5C6   0x9800             LDR      R0,[SP, #+0]
   \      0x5C8   0xFB05 0x0501      MLA      R5,R5,R1,R0
   \      0x5CC   0x0128             LSLS     R0,R5,#+4
   \      0x5CE   0x3032             ADDS     R0,R0,#+50
   \      0x5D0   0x2164             MOVS     R1,#+100
   \      0x5D2   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \      0x5D6   0xF011 0x010F      ANDS     R1,R1,#0xF
   \      0x5DA   0x9802             LDR      R0,[SP, #+8]
   \      0x5DC   0x1809             ADDS     R1,R1,R0
   \      0x5DE   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \      0x5E2   0x6081             STR      R1,[R0, #+8]
   3148              }
   3149            }
   3150          }
   \                     ??UART_SetConfig_3: (+1)
   \      0x5E4   0xB005             ADD      SP,SP,#+20
   \      0x5E6   0xE8BD 0x8FF0      POP      {R4-R11,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0xFFFF'69F3        DC32     0xffff69f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x4001'1000        DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \        0x0   0x4001'1400        DC32     0x40011400
   3151          
   3152          /**
   3153            * @}
   3154            */
   3155          
   3156          #endif /* HAL_UART_MODULE_ENABLED */
   3157          /**
   3158            * @}
   3159            */
   3160          
   3161          /**
   3162            * @}
   3163            */
   3164          
   3165          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_HalfDuplex_EnableReceiver
       0   HAL_HalfDuplex_EnableTransmitter
       8   HAL_HalfDuplex_Init
         8   -> HAL_UART_MspInit
         8   -> UART_SetConfig
      16   HAL_LIN_Init
        16   -> HAL_UART_MspInit
        16   -> UART_SetConfig
       0   HAL_LIN_SendBreak
       0   HAL_MultiProcessor_EnterMuteMode
       0   HAL_MultiProcessor_ExitMuteMode
      16   HAL_MultiProcessor_Init
        16   -> HAL_UART_MspInit
        16   -> UART_SetConfig
       8   HAL_UART_Abort
         8   -> HAL_DMA_Abort
         8   -> HAL_DMA_GetError
       0   HAL_UART_AbortCpltCallback
       8   HAL_UART_AbortReceive
         8   -> HAL_DMA_Abort
         8   -> HAL_DMA_GetError
       0   HAL_UART_AbortReceiveCpltCallback
       8   HAL_UART_AbortReceive_IT
         8   -- Indirect call
         8   -> HAL_DMA_Abort_IT
         8   -> HAL_UART_AbortReceiveCpltCallback
       8   HAL_UART_AbortTransmit
         8   -> HAL_DMA_Abort
         8   -> HAL_DMA_GetError
       0   HAL_UART_AbortTransmitCpltCallback
       8   HAL_UART_AbortTransmit_IT
         8   -- Indirect call
         8   -> HAL_DMA_Abort_IT
         8   -> HAL_UART_AbortTransmitCpltCallback
      16   HAL_UART_Abort_IT
        16   -> HAL_DMA_Abort_IT
        16   -> HAL_UART_AbortCpltCallback
       0   HAL_UART_DMAPause
       4   HAL_UART_DMAResume
      16   HAL_UART_DMAStop
        16   -> HAL_DMA_Abort
        16   -> UART_EndRxTransfer
        16   -> UART_EndTxTransfer
       8   HAL_UART_DeInit
         8   -> HAL_UART_MspDeInit
       0   HAL_UART_ErrorCallback
       0   HAL_UART_GetError
       4   HAL_UART_GetState
      32   HAL_UART_IRQHandler
        32   -- Indirect call
        32   -> HAL_DMA_Abort_IT
        32   -> HAL_UART_ErrorCallback
        32   -> UART_EndRxTransfer
        32   -> UART_EndTransmit_IT
        32   -> UART_Receive_IT
        32   -> UART_Transmit_IT
       8   HAL_UART_Init
         8   -> HAL_UART_MspInit
         8   -> UART_SetConfig
       0   HAL_UART_MspDeInit
       0   HAL_UART_MspInit
      40   HAL_UART_Receive
        40   -> HAL_GetTick
        40   -> UART_WaitOnFlagUntilTimeout
      24   HAL_UART_Receive_DMA
        24   -> HAL_DMA_Start_IT
       4   HAL_UART_Receive_IT
       0   HAL_UART_RxCpltCallback
       0   HAL_UART_RxHalfCpltCallback
      40   HAL_UART_Transmit
        40   -> HAL_GetTick
        40   -> UART_WaitOnFlagUntilTimeout
      24   HAL_UART_Transmit_DMA
        24   -> HAL_DMA_Start_IT
       4   HAL_UART_Transmit_IT
       0   HAL_UART_TxCpltCallback
       0   HAL_UART_TxHalfCpltCallback
      16   UART_DMAAbortOnError
        16   -> HAL_UART_ErrorCallback
      24   UART_DMAError
        24   -> HAL_UART_ErrorCallback
        24   -> UART_EndRxTransfer
        24   -> UART_EndTxTransfer
      16   UART_DMAReceiveCplt
        16   -> HAL_UART_RxCpltCallback
      16   UART_DMARxAbortCallback
        16   -> HAL_UART_AbortCpltCallback
      16   UART_DMARxHalfCplt
        16   -> HAL_UART_RxHalfCpltCallback
      16   UART_DMARxOnlyAbortCallback
        16   -> HAL_UART_AbortReceiveCpltCallback
      16   UART_DMATransmitCplt
        16   -> HAL_UART_TxCpltCallback
      16   UART_DMATxAbortCallback
        16   -> HAL_UART_AbortCpltCallback
      16   UART_DMATxHalfCplt
        16   -> HAL_UART_TxHalfCpltCallback
      16   UART_DMATxOnlyAbortCallback
        16   -> HAL_UART_AbortTransmitCpltCallback
       0   UART_EndRxTransfer
       8   UART_EndTransmit_IT
         8   -> HAL_UART_TxCpltCallback
       0   UART_EndTxTransfer
      16   UART_Receive_IT
        16   -> HAL_UART_RxCpltCallback
      56   UART_SetConfig
        56   -> HAL_RCC_GetPCLK1Freq
        56   -> HAL_RCC_GetPCLK2Freq
        56 __aeabi_uldivmod
       0   UART_Transmit_IT
      24   UART_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
      60  HAL_HalfDuplex_EnableReceiver
      60  HAL_HalfDuplex_EnableTransmitter
     124  HAL_HalfDuplex_Init
     148  HAL_LIN_Init
      54  HAL_LIN_SendBreak
      54  HAL_MultiProcessor_EnterMuteMode
      54  HAL_MultiProcessor_ExitMuteMode
     164  HAL_MultiProcessor_Init
     176  HAL_UART_Abort
       2  HAL_UART_AbortCpltCallback
     102  HAL_UART_AbortReceive
       2  HAL_UART_AbortReceiveCpltCallback
     120  HAL_UART_AbortReceive_IT
      90  HAL_UART_AbortTransmit
       2  HAL_UART_AbortTransmitCpltCallback
     108  HAL_UART_AbortTransmit_IT
     228  HAL_UART_Abort_IT
     124  HAL_UART_DMAPause
     116  HAL_UART_DMAResume
     114  HAL_UART_DMAStop
      62  HAL_UART_DeInit
       2  HAL_UART_ErrorCallback
       4  HAL_UART_GetError
      24  HAL_UART_GetState
     336  HAL_UART_IRQHandler
     118  HAL_UART_Init
       2  HAL_UART_MspDeInit
       2  HAL_UART_MspInit
     234  HAL_UART_Receive
     182  HAL_UART_Receive_DMA
     114  HAL_UART_Receive_IT
       2  HAL_UART_RxCpltCallback
       2  HAL_UART_RxHalfCpltCallback
     224  HAL_UART_Transmit
     150  HAL_UART_Transmit_DMA
      90  HAL_UART_Transmit_IT
       2  HAL_UART_TxCpltCallback
       2  HAL_UART_TxHalfCpltCallback
      22  UART_DMAAbortOnError
      88  UART_DMAError
      68  UART_DMAReceiveCplt
      58  UART_DMARxAbortCallback
      14  UART_DMARxHalfCplt
      24  UART_DMARxOnlyAbortCallback
      52  UART_DMATransmitCplt
      58  UART_DMATxAbortCallback
      14  UART_DMATxHalfCplt
      24  UART_DMATxOnlyAbortCallback
      32  UART_EndRxTransfer
      32  UART_EndTransmit_IT
      20  UART_EndTxTransfer
     174  UART_Receive_IT
   1'514  UART_SetConfig
     110  UART_Transmit_IT
     110  UART_WaitOnFlagUntilTimeout

 
 5'880 bytes in section .text
 
 5'860 bytes of CODE memory (+ 20 bytes shared)

Errors: none
Warnings: none
