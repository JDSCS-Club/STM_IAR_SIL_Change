###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         27/Sep/2022  19:40:26
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_ll_usb.c
#    Command line      =
#        -f
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_ll_usb.o.rsp
#        (C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_ll_usb.c
#        -D USE_HAL_DRIVER -D STM32F407xx -lC
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver
#        -o
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/App\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Core/Inc\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Include\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/display\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Library\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_ll_usb.o.d
#    Locale            =  C
#    List file         =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_ll_usb.lst
#    Object file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_ll_usb.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_ll_usb.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_ll_usb.c
      4            * @author  MCD Application Team
      5            * @brief   USB Low Layer HAL module driver.
      6            *
      7            *          This file provides firmware functions to manage the following
      8            *          functionalities of the USB Peripheral Controller:
      9            *           + Initialization/de-initialization functions
     10            *           + I/O operation functions
     11            *           + Peripheral Control functions
     12            *           + Peripheral State functions
     13            *
     14            @verbatim
     15            ==============================================================================
     16                              ##### How to use this driver #####
     17            ==============================================================================
     18              [..]
     19                (#) Fill parameters of Init structure in USB_OTG_CfgTypeDef structure.
     20          
     21                (#) Call USB_CoreInit() API to initialize the USB Core peripheral.
     22          
     23                (#) The upper HAL HCD/PCD driver will call the right routines for its internal processes.
     24          
     25            @endverbatim
     26            ******************************************************************************
     27            * @attention
     28            *
     29            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
     30            * All rights reserved.</center></h2>
     31            *
     32            * This software component is licensed by ST under BSD 3-Clause license,
     33            * the "License"; You may not use this file except in compliance with the
     34            * License. You may obtain a copy of the License at:
     35            *                        opensource.org/licenses/BSD-3-Clause
     36            *
     37            ******************************************************************************
     38            */
     39          
     40          /* Includes ------------------------------------------------------------------*/
     41          #include "stm32f4xx_hal.h"
     42          
     43          /** @addtogroup STM32F4xx_LL_USB_DRIVER
     44            * @{
     45            */
     46          
     47          #if defined (HAL_PCD_MODULE_ENABLED) || defined (HAL_HCD_MODULE_ENABLED)
     48          #if defined (USB_OTG_FS) || defined (USB_OTG_HS)
     49          /* Private typedef -----------------------------------------------------------*/
     50          /* Private define ------------------------------------------------------------*/
     51          /* Private macro -------------------------------------------------------------*/
     52          /* Private variables ---------------------------------------------------------*/
     53          /* Private function prototypes -----------------------------------------------*/
     54          /* Private functions ---------------------------------------------------------*/
     55          #if defined (USB_OTG_FS) || defined (USB_OTG_HS)
     56          static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx);
     57          
     58          /* Exported functions --------------------------------------------------------*/
     59          /** @defgroup USB_LL_Exported_Functions USB Low Layer Exported Functions
     60            * @{
     61            */
     62          
     63          /** @defgroup USB_LL_Exported_Functions_Group1 Initialization/de-initialization functions
     64            *  @brief    Initialization and Configuration functions
     65            *
     66          @verbatim
     67           ===============================================================================
     68                                ##### Initialization/de-initialization functions #####
     69           ===============================================================================
     70          
     71          @endverbatim
     72            * @{
     73            */
     74          
     75          /**
     76            * @brief  Initializes the USB Core
     77            * @param  USBx USB Instance
     78            * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
     79            *         the configuration information for the specified USBx peripheral.
     80            * @retval HAL status
     81            */

   \                                 In section .text, align 2, keep-with-next
     82          HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
     83          {
   \                     USB_CoreInit: (+1)
   \        0x0   0xB40E             PUSH     {R1-R3}
   \        0x2   0xB518             PUSH     {R3,R4,LR}
   \        0x4   0x0004             MOVS     R4,R0
     84            HAL_StatusTypeDef ret;
     85          
     86            if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   \        0x6   0x9808             LDR      R0,[SP, #+32]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD117             BNE.N    ??USB_CoreInit_0
     87            {
     88              USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   \        0xC   0x6BA0             LDR      R0,[R4, #+56]
   \        0xE   0xF430 0x3080      BICS     R0,R0,#0x10000
   \       0x12   0x63A0             STR      R0,[R4, #+56]
     89          
     90              /* Init The ULPI Interface */
     91              USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
   \       0x14   0x68E1             LDR      R1,[R4, #+12]
   \       0x16   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x1A   0x4001             ANDS     R1,R0,R1
   \       0x1C   0x60E1             STR      R1,[R4, #+12]
     92          
     93              /* Select vbus source */
     94              USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
   \       0x1E   0x68E0             LDR      R0,[R4, #+12]
   \       0x20   0xF430 0x1040      BICS     R0,R0,#0x300000
   \       0x24   0x60E0             STR      R0,[R4, #+12]
     95              if (cfg.use_external_vbus == 1U)
   \       0x26   0x980F             LDR      R0,[SP, #+60]
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD103             BNE.N    ??USB_CoreInit_1
     96              {
     97                USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
   \       0x2C   0x68E0             LDR      R0,[R4, #+12]
   \       0x2E   0xF450 0x1080      ORRS     R0,R0,#0x100000
   \       0x32   0x60E0             STR      R0,[R4, #+12]
     98              }
     99              /* Reset after a PHY select  */
    100              ret = USB_CoreReset(USBx);
   \                     ??USB_CoreInit_1: (+1)
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       USB_CoreReset
   \       0x3A   0xE012             B.N      ??USB_CoreInit_2
    101            }
    102            else /* FS interface (embedded Phy) */
    103            {
    104              /* Select FS Embedded PHY */
    105              USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
   \                     ??USB_CoreInit_0: (+1)
   \       0x3C   0x68E0             LDR      R0,[R4, #+12]
   \       0x3E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x42   0x60E0             STR      R0,[R4, #+12]
    106          
    107              /* Reset after a PHY select */
    108              ret = USB_CoreReset(USBx);
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x.... 0x....      BL       USB_CoreReset
    109          
    110              if (cfg.battery_charging_enable == 0U)
   \       0x4A   0x990C             LDR      R1,[SP, #+48]
   \       0x4C   0x2900             CMP      R1,#+0
   \       0x4E   0xD104             BNE.N    ??USB_CoreInit_3
    111              {
    112                /* Activate the USB Transceiver */
    113                USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
   \       0x50   0x6BA1             LDR      R1,[R4, #+56]
   \       0x52   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \       0x56   0x63A1             STR      R1,[R4, #+56]
   \       0x58   0xE003             B.N      ??USB_CoreInit_2
    114              }
    115              else
    116              {
    117                /* Deactivate the USB Transceiver */
    118                USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   \                     ??USB_CoreInit_3: (+1)
   \       0x5A   0x6BA1             LDR      R1,[R4, #+56]
   \       0x5C   0xF431 0x3180      BICS     R1,R1,#0x10000
   \       0x60   0x63A1             STR      R1,[R4, #+56]
    119              }
    120            }
    121          
    122            if (cfg.dma_enable == 1U)
   \                     ??USB_CoreInit_2: (+1)
   \       0x62   0x9906             LDR      R1,[SP, #+24]
   \       0x64   0x2901             CMP      R1,#+1
   \       0x66   0xD107             BNE.N    ??USB_CoreInit_4
    123            {
    124              USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
   \       0x68   0x68A1             LDR      R1,[R4, #+8]
   \       0x6A   0xF051 0x0106      ORRS     R1,R1,#0x6
   \       0x6E   0x60A1             STR      R1,[R4, #+8]
    125              USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
   \       0x70   0x68A1             LDR      R1,[R4, #+8]
   \       0x72   0xF051 0x0120      ORRS     R1,R1,#0x20
   \       0x76   0x60A1             STR      R1,[R4, #+8]
    126            }
    127          
    128            return ret;
   \                     ??USB_CoreInit_4: (+1)
   \       0x78   0xB2C0             UXTB     R0,R0
   \       0x7A   0xBC12             POP      {R1,R4}
   \       0x7C   0xF85D 0xFB10      LDR      PC,[SP], #+16
    129          }
    130          
    131          
    132          /**
    133            * @brief  Set the USB turnaround time
    134            * @param  USBx USB Instance
    135            * @param  hclk: AHB clock frequency
    136            * @retval USB turnaround time In PHY Clocks number
    137            */

   \                                 In section .text, align 2, keep-with-next
    138          HAL_StatusTypeDef USB_SetTurnaroundTime(USB_OTG_GlobalTypeDef *USBx,
    139                                                  uint32_t hclk, uint8_t speed)
    140          {
   \                     USB_SetTurnaroundTime: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x0003             MOVS     R3,R0
    141            uint32_t UsbTrd;
    142          
    143            /* The USBTRD is configured according to the tables below, depending on AHB frequency
    144            used by application. In the low AHB frequency range it is used to stretch enough the USB response
    145            time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access
    146            latency to the Data FIFO */
    147            if (speed == USBD_FS_SPEED)
   \        0x4   0x0010             MOVS     R0,R2
   \        0x6   0xB2C0             UXTB     R0,R0
   \        0x8   0x2802             CMP      R0,#+2
   \        0xA   0xD15B             BNE.N    ??USB_SetTurnaroundTime_0
    148            {
    149              if ((hclk >= 14200000U) && (hclk < 15000000U))
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable6_1
   \       0x10   0x4281             CMP      R1,R0
   \       0x12   0xD305             BCC.N    ??USB_SetTurnaroundTime_1
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \       0x18   0x4281             CMP      R1,R0
   \       0x1A   0xD201             BCS.N    ??USB_SetTurnaroundTime_1
    150              {
    151                /* hclk Clock Range between 14.2-15 MHz */
    152                UsbTrd = 0xFU;
   \       0x1C   0x240F             MOVS     R4,#+15
   \       0x1E   0xE058             B.N      ??USB_SetTurnaroundTime_2
    153              }
    154              else if ((hclk >= 15000000U) && (hclk < 16000000U))
   \                     ??USB_SetTurnaroundTime_1: (+1)
   \       0x20   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \       0x24   0x4281             CMP      R1,R0
   \       0x26   0xD305             BCC.N    ??USB_SetTurnaroundTime_3
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \       0x2C   0x4281             CMP      R1,R0
   \       0x2E   0xD201             BCS.N    ??USB_SetTurnaroundTime_3
    155              {
    156                /* hclk Clock Range between 15-16 MHz */
    157                UsbTrd = 0xEU;
   \       0x30   0x240E             MOVS     R4,#+14
   \       0x32   0xE04E             B.N      ??USB_SetTurnaroundTime_2
    158              }
    159              else if ((hclk >= 16000000U) && (hclk < 17200000U))
   \                     ??USB_SetTurnaroundTime_3: (+1)
   \       0x34   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \       0x38   0x4281             CMP      R1,R0
   \       0x3A   0xD305             BCC.N    ??USB_SetTurnaroundTime_4
   \       0x3C   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \       0x40   0x4281             CMP      R1,R0
   \       0x42   0xD201             BCS.N    ??USB_SetTurnaroundTime_4
    160              {
    161                /* hclk Clock Range between 16-17.2 MHz */
    162                UsbTrd = 0xDU;
   \       0x44   0x240D             MOVS     R4,#+13
   \       0x46   0xE044             B.N      ??USB_SetTurnaroundTime_2
    163              }
    164              else if ((hclk >= 17200000U) && (hclk < 18500000U))
   \                     ??USB_SetTurnaroundTime_4: (+1)
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \       0x4C   0x4281             CMP      R1,R0
   \       0x4E   0xD305             BCC.N    ??USB_SetTurnaroundTime_5
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \       0x54   0x4281             CMP      R1,R0
   \       0x56   0xD201             BCS.N    ??USB_SetTurnaroundTime_5
    165              {
    166                /* hclk Clock Range between 17.2-18.5 MHz */
    167                UsbTrd = 0xCU;
   \       0x58   0x240C             MOVS     R4,#+12
   \       0x5A   0xE03A             B.N      ??USB_SetTurnaroundTime_2
    168              }
    169              else if ((hclk >= 18500000U) && (hclk < 20000000U))
   \                     ??USB_SetTurnaroundTime_5: (+1)
   \       0x5C   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \       0x60   0x4281             CMP      R1,R0
   \       0x62   0xD305             BCC.N    ??USB_SetTurnaroundTime_6
   \       0x64   0x.... 0x....      LDR.W    R0,??DataTable6_6
   \       0x68   0x4281             CMP      R1,R0
   \       0x6A   0xD201             BCS.N    ??USB_SetTurnaroundTime_6
    170              {
    171                /* hclk Clock Range between 18.5-20 MHz */
    172                UsbTrd = 0xBU;
   \       0x6C   0x240B             MOVS     R4,#+11
   \       0x6E   0xE030             B.N      ??USB_SetTurnaroundTime_2
    173              }
    174              else if ((hclk >= 20000000U) && (hclk < 21800000U))
   \                     ??USB_SetTurnaroundTime_6: (+1)
   \       0x70   0x.... 0x....      LDR.W    R0,??DataTable6_6
   \       0x74   0x4281             CMP      R1,R0
   \       0x76   0xD305             BCC.N    ??USB_SetTurnaroundTime_7
   \       0x78   0x.... 0x....      LDR.W    R0,??DataTable6_7
   \       0x7C   0x4281             CMP      R1,R0
   \       0x7E   0xD201             BCS.N    ??USB_SetTurnaroundTime_7
    175              {
    176                /* hclk Clock Range between 20-21.8 MHz */
    177                UsbTrd = 0xAU;
   \       0x80   0x240A             MOVS     R4,#+10
   \       0x82   0xE026             B.N      ??USB_SetTurnaroundTime_2
    178              }
    179              else if ((hclk >= 21800000U) && (hclk < 24000000U))
   \                     ??USB_SetTurnaroundTime_7: (+1)
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable6_7
   \       0x88   0x4281             CMP      R1,R0
   \       0x8A   0xD305             BCC.N    ??USB_SetTurnaroundTime_8
   \       0x8C   0x.... 0x....      LDR.W    R0,??DataTable6_8
   \       0x90   0x4281             CMP      R1,R0
   \       0x92   0xD201             BCS.N    ??USB_SetTurnaroundTime_8
    180              {
    181                /* hclk Clock Range between 21.8-24 MHz */
    182                UsbTrd = 0x9U;
   \       0x94   0x2409             MOVS     R4,#+9
   \       0x96   0xE01C             B.N      ??USB_SetTurnaroundTime_2
    183              }
    184              else if ((hclk >= 24000000U) && (hclk < 27700000U))
   \                     ??USB_SetTurnaroundTime_8: (+1)
   \       0x98   0x.... 0x....      LDR.W    R0,??DataTable6_8
   \       0x9C   0x4281             CMP      R1,R0
   \       0x9E   0xD305             BCC.N    ??USB_SetTurnaroundTime_9
   \       0xA0   0x.... 0x....      LDR.W    R0,??DataTable6_9
   \       0xA4   0x4281             CMP      R1,R0
   \       0xA6   0xD201             BCS.N    ??USB_SetTurnaroundTime_9
    185              {
    186                /* hclk Clock Range between 24-27.7 MHz */
    187                UsbTrd = 0x8U;
   \       0xA8   0x2408             MOVS     R4,#+8
   \       0xAA   0xE012             B.N      ??USB_SetTurnaroundTime_2
    188              }
    189              else if ((hclk >= 27700000U) && (hclk < 32000000U))
   \                     ??USB_SetTurnaroundTime_9: (+1)
   \       0xAC   0x.... 0x....      LDR.W    R0,??DataTable6_9
   \       0xB0   0x4281             CMP      R1,R0
   \       0xB2   0xD305             BCC.N    ??USB_SetTurnaroundTime_10
   \       0xB4   0x.... 0x....      LDR.W    R0,??DataTable6_10
   \       0xB8   0x4281             CMP      R1,R0
   \       0xBA   0xD201             BCS.N    ??USB_SetTurnaroundTime_10
    190              {
    191                /* hclk Clock Range between 27.7-32 MHz */
    192                UsbTrd = 0x7U;
   \       0xBC   0x2407             MOVS     R4,#+7
   \       0xBE   0xE008             B.N      ??USB_SetTurnaroundTime_2
    193              }
    194              else /* if(hclk >= 32000000) */
    195              {
    196                /* hclk Clock Range between 32-200 MHz */
    197                UsbTrd = 0x6U;
   \                     ??USB_SetTurnaroundTime_10: (+1)
   \       0xC0   0x2406             MOVS     R4,#+6
   \       0xC2   0xE006             B.N      ??USB_SetTurnaroundTime_2
    198              }
    199            }
    200            else if (speed == USBD_HS_SPEED)
   \                     ??USB_SetTurnaroundTime_0: (+1)
   \       0xC4   0x0010             MOVS     R0,R2
   \       0xC6   0xB2C0             UXTB     R0,R0
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xD101             BNE.N    ??USB_SetTurnaroundTime_11
    201            {
    202              UsbTrd = USBD_HS_TRDT_VALUE;
   \       0xCC   0x2409             MOVS     R4,#+9
   \       0xCE   0xE000             B.N      ??USB_SetTurnaroundTime_2
    203            }
    204            else
    205            {
    206              UsbTrd = USBD_DEFAULT_TRDT_VALUE;
   \                     ??USB_SetTurnaroundTime_11: (+1)
   \       0xD0   0x2409             MOVS     R4,#+9
    207            }
    208          
    209            USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
   \                     ??USB_SetTurnaroundTime_2: (+1)
   \       0xD2   0x68D8             LDR      R0,[R3, #+12]
   \       0xD4   0xF430 0x5070      BICS     R0,R0,#0x3C00
   \       0xD8   0x60D8             STR      R0,[R3, #+12]
    210            USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
   \       0xDA   0x68D8             LDR      R0,[R3, #+12]
   \       0xDC   0x02A5             LSLS     R5,R4,#+10
   \       0xDE   0xF415 0x5570      ANDS     R5,R5,#0x3C00
   \       0xE2   0x4328             ORRS     R0,R5,R0
   \       0xE4   0x60D8             STR      R0,[R3, #+12]
    211          
    212            return HAL_OK;
   \       0xE6   0x2000             MOVS     R0,#+0
   \       0xE8   0xBC30             POP      {R4,R5}
   \       0xEA   0x4770             BX       LR
    213          }
    214          
    215          /**
    216            * @brief  USB_EnableGlobalInt
    217            *         Enables the controller's Global Int in the AHB Config reg
    218            * @param  USBx  Selected device
    219            * @retval HAL status
    220            */

   \                                 In section .text, align 2, keep-with-next
    221          HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
    222          {
   \                     USB_EnableGlobalInt: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    223            USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
   \        0x2   0x6888             LDR      R0,[R1, #+8]
   \        0x4   0xF050 0x0001      ORRS     R0,R0,#0x1
   \        0x8   0x6088             STR      R0,[R1, #+8]
    224            return HAL_OK;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR
    225          }
    226          
    227          /**
    228            * @brief  USB_DisableGlobalInt
    229            *         Disable the controller's Global Int in the AHB Config reg
    230            * @param  USBx  Selected device
    231            * @retval HAL status
    232            */

   \                                 In section .text, align 2, keep-with-next
    233          HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
    234          {
   \                     USB_DisableGlobalInt: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    235            USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
   \        0x2   0x6888             LDR      R0,[R1, #+8]
   \        0x4   0x0840             LSRS     R0,R0,#+1
   \        0x6   0x0040             LSLS     R0,R0,#+1
   \        0x8   0x6088             STR      R0,[R1, #+8]
    236            return HAL_OK;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR
    237          }
    238          
    239          /**
    240            * @brief  USB_SetCurrentMode Set functional mode
    241            * @param  USBx  Selected device
    242            * @param  mode  current core mode
    243            *          This parameter can be one of these values:
    244            *            @arg USB_DEVICE_MODE Peripheral mode
    245            *            @arg USB_HOST_MODE Host mode
    246            * @retval HAL status
    247            */

   \                                 In section .text, align 2, keep-with-next
    248          HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)
    249          {
   \                     USB_SetCurrentMode: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    250            USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
   \        0x6   0x68E0             LDR      R0,[R4, #+12]
   \        0x8   0xF030 0x40C0      BICS     R0,R0,#0x60000000
   \        0xC   0x60E0             STR      R0,[R4, #+12]
    251          
    252            if (mode == USB_HOST_MODE)
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD104             BNE.N    ??USB_SetCurrentMode_0
    253            {
    254              USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
   \       0x16   0x68E0             LDR      R0,[R4, #+12]
   \       0x18   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \       0x1C   0x60E0             STR      R0,[R4, #+12]
   \       0x1E   0xE00A             B.N      ??USB_SetCurrentMode_1
    255            }
    256            else if (mode == USB_DEVICE_MODE)
   \                     ??USB_SetCurrentMode_0: (+1)
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD104             BNE.N    ??USB_SetCurrentMode_2
    257            {
    258              USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
   \       0x28   0x68E0             LDR      R0,[R4, #+12]
   \       0x2A   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \       0x2E   0x60E0             STR      R0,[R4, #+12]
   \       0x30   0xE001             B.N      ??USB_SetCurrentMode_1
    259            }
    260            else
    261            {
    262              return HAL_ERROR;
   \                     ??USB_SetCurrentMode_2: (+1)
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0xE003             B.N      ??USB_SetCurrentMode_3
    263            }
    264            HAL_Delay(50U);
   \                     ??USB_SetCurrentMode_1: (+1)
   \       0x36   0x2032             MOVS     R0,#+50
   \       0x38   0x.... 0x....      BL       HAL_Delay
    265          
    266            return HAL_OK;
   \       0x3C   0x2000             MOVS     R0,#+0
   \                     ??USB_SetCurrentMode_3: (+1)
   \       0x3E   0xBD32             POP      {R1,R4,R5,PC}
    267          }
    268          
    269          /**
    270            * @brief  USB_DevInit Initializes the USB_OTG controller registers
    271            *         for device mode
    272            * @param  USBx  Selected device
    273            * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
    274            *         the configuration information for the specified USBx peripheral.
    275            * @retval HAL status
    276            */

   \                                 In section .text, align 2, keep-with-next
    277          HAL_StatusTypeDef USB_DevInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
    278          {
   \                     USB_DevInit: (+1)
   \        0x0   0xB40E             PUSH     {R1-R3}
   \        0x2   0xB5F0             PUSH     {R4-R7,LR}
   \        0x4   0x0004             MOVS     R4,R0
    279            HAL_StatusTypeDef ret = HAL_OK;
   \        0x6   0x2500             MOVS     R5,#+0
    280            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x8   0x0026             MOVS     R6,R4
    281            uint32_t i;
    282          
    283            for (i = 0U; i < 15U; i++)
   \        0xA   0x2700             MOVS     R7,#+0
   \                     ??USB_DevInit_0: (+1)
   \        0xC   0x2F0F             CMP      R7,#+15
   \        0xE   0xD206             BCS.N    ??USB_DevInit_1
    284            {
    285              USBx->DIEPTXF[i] = 0U;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xEB04 0x0187      ADD      R1,R4,R7, LSL #+2
   \       0x16   0xF8C1 0x0104      STR      R0,[R1, #+260]
    286            }
   \       0x1A   0x1C7F             ADDS     R7,R7,#+1
   \       0x1C   0xE7F6             B.N      ??USB_DevInit_0
    287          
    288          #if defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
    289            /* VBUS Sensing setup */
    290            if (cfg.vbus_sensing_enable == 0U)
    291            {
    292              USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
    293          
    294              /* Deactivate VBUS Sensing B */
    295              USBx->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
    296          
    297              /* B-peripheral session valid override enable */
    298              USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOEN;
    299              USBx->GOTGCTL |= USB_OTG_GOTGCTL_BVALOVAL;
    300            }
    301            else
    302            {
    303              /* Enable HW VBUS sensing */
    304              USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
    305            }
    306          #else
    307            /* VBUS Sensing setup */
    308            if (cfg.vbus_sensing_enable == 0U)
   \                     ??USB_DevInit_1: (+1)
   \       0x1E   0x980F             LDR      R0,[SP, #+60]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD114             BNE.N    ??USB_DevInit_2
    309            {
    310              /*
    311               * Disable HW VBUS sensing. VBUS is internally considered to be always
    312               * at VBUS-Valid level (5V).
    313               */
    314              USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
   \       0x24   0xF516 0x6000      ADDS     R0,R6,#+2048
   \       0x28   0x6840             LDR      R0,[R0, #+4]
   \       0x2A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x2E   0xF516 0x6100      ADDS     R1,R6,#+2048
   \       0x32   0x6048             STR      R0,[R1, #+4]
    315              USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
   \       0x34   0x6BA0             LDR      R0,[R4, #+56]
   \       0x36   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \       0x3A   0x63A0             STR      R0,[R4, #+56]
    316              USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSBSEN;
   \       0x3C   0x6BA0             LDR      R0,[R4, #+56]
   \       0x3E   0xF430 0x2000      BICS     R0,R0,#0x80000
   \       0x42   0x63A0             STR      R0,[R4, #+56]
    317              USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSASEN;
   \       0x44   0x6BA0             LDR      R0,[R4, #+56]
   \       0x46   0xF430 0x2080      BICS     R0,R0,#0x40000
   \       0x4A   0x63A0             STR      R0,[R4, #+56]
   \       0x4C   0xE007             B.N      ??USB_DevInit_3
    318            }
    319            else
    320            {
    321              /* Enable HW VBUS sensing */
    322              USBx->GCCFG &= ~USB_OTG_GCCFG_NOVBUSSENS;
   \                     ??USB_DevInit_2: (+1)
   \       0x4E   0x6BA0             LDR      R0,[R4, #+56]
   \       0x50   0xF430 0x1000      BICS     R0,R0,#0x200000
   \       0x54   0x63A0             STR      R0,[R4, #+56]
    323              USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
   \       0x56   0x6BA0             LDR      R0,[R4, #+56]
   \       0x58   0xF450 0x2000      ORRS     R0,R0,#0x80000
   \       0x5C   0x63A0             STR      R0,[R4, #+56]
    324            }
    325          #endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */
    326          
    327            /* Restart the Phy Clock */
    328            USBx_PCGCCTL = 0U;
   \                     ??USB_DevInit_3: (+1)
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xF516 0x6160      ADDS     R1,R6,#+3584
   \       0x64   0x6008             STR      R0,[R1, #+0]
    329          
    330            /* Device mode configuration */
    331            USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
   \       0x66   0xF516 0x6000      ADDS     R0,R6,#+2048
   \       0x6A   0x6800             LDR      R0,[R0, #+0]
   \       0x6C   0xF516 0x6100      ADDS     R1,R6,#+2048
   \       0x70   0x6008             STR      R0,[R1, #+0]
    332          
    333            if (cfg.phy_itface == USB_OTG_ULPI_PHY)
   \       0x72   0x980A             LDR      R0,[SP, #+40]
   \       0x74   0x2801             CMP      R0,#+1
   \       0x76   0xD10C             BNE.N    ??USB_DevInit_4
    334            {
    335              if (cfg.speed == USBD_HS_SPEED)
   \       0x78   0x9807             LDR      R0,[SP, #+28]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD104             BNE.N    ??USB_DevInit_5
    336              {
    337                /* Set Core speed to High speed mode */
    338                (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);
   \       0x7E   0x2100             MOVS     R1,#+0
   \       0x80   0x0020             MOVS     R0,R4
   \       0x82   0x.... 0x....      BL       USB_SetDevSpeed
   \       0x86   0xE008             B.N      ??USB_DevInit_6
    339              }
    340              else
    341              {
    342                /* Set Core speed to Full speed mode */
    343                (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);
   \                     ??USB_DevInit_5: (+1)
   \       0x88   0x2101             MOVS     R1,#+1
   \       0x8A   0x0020             MOVS     R0,R4
   \       0x8C   0x.... 0x....      BL       USB_SetDevSpeed
   \       0x90   0xE003             B.N      ??USB_DevInit_6
    344              }
    345            }
    346            else
    347            {
    348              /* Set Core speed to Full speed mode */
    349              (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
   \                     ??USB_DevInit_4: (+1)
   \       0x92   0x2103             MOVS     R1,#+3
   \       0x94   0x0020             MOVS     R0,R4
   \       0x96   0x.... 0x....      BL       USB_SetDevSpeed
    350            }
    351          
    352            /* Flush the FIFOs */
    353            if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
   \                     ??USB_DevInit_6: (+1)
   \       0x9A   0x2110             MOVS     R1,#+16
   \       0x9C   0x0020             MOVS     R0,R4
   \       0x9E   0x.... 0x....      BL       USB_FlushTxFifo
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD001             BEQ.N    ??USB_DevInit_7
    354            {
    355              ret = HAL_ERROR;
   \       0xA6   0x2001             MOVS     R0,#+1
   \       0xA8   0x0005             MOVS     R5,R0
    356            }
    357          
    358            if (USB_FlushRxFifo(USBx) != HAL_OK)
   \                     ??USB_DevInit_7: (+1)
   \       0xAA   0x0020             MOVS     R0,R4
   \       0xAC   0x.... 0x....      BL       USB_FlushRxFifo
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD001             BEQ.N    ??USB_DevInit_8
    359            {
    360              ret = HAL_ERROR;
   \       0xB4   0x2001             MOVS     R0,#+1
   \       0xB6   0x0005             MOVS     R5,R0
    361            }
    362          
    363            /* Clear all pending Device Interrupts */
    364            USBx_DEVICE->DIEPMSK = 0U;
   \                     ??USB_DevInit_8: (+1)
   \       0xB8   0x2000             MOVS     R0,#+0
   \       0xBA   0xF516 0x6100      ADDS     R1,R6,#+2048
   \       0xBE   0x6108             STR      R0,[R1, #+16]
    365            USBx_DEVICE->DOEPMSK = 0U;
   \       0xC0   0x2000             MOVS     R0,#+0
   \       0xC2   0xF516 0x6100      ADDS     R1,R6,#+2048
   \       0xC6   0x6148             STR      R0,[R1, #+20]
    366            USBx_DEVICE->DAINTMSK = 0U;
   \       0xC8   0x2000             MOVS     R0,#+0
   \       0xCA   0xF516 0x6100      ADDS     R1,R6,#+2048
   \       0xCE   0x61C8             STR      R0,[R1, #+28]
    367          
    368            for (i = 0U; i < cfg.dev_endpoints; i++)
   \       0xD0   0x2000             MOVS     R0,#+0
   \                     ??USB_DevInit_9: (+1)
   \       0xD2   0x9905             LDR      R1,[SP, #+20]
   \       0xD4   0x4288             CMP      R0,R1
   \       0xD6   0xD22D             BCS.N    ??USB_DevInit_10
    369            {
    370              if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
   \       0xD8   0xEB16 0x1140      ADDS     R1,R6,R0, LSL #+5
   \       0xDC   0xF511 0x6110      ADDS     R1,R1,#+2304
   \       0xE0   0x6809             LDR      R1,[R1, #+0]
   \       0xE2   0x2900             CMP      R1,#+0
   \       0xE4   0xD511             BPL.N    ??USB_DevInit_11
    371              {
    372                if (i == 0U)
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0xD107             BNE.N    ??USB_DevInit_12
    373                {
    374                  USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
   \       0xEA   0xF05F 0x6100      MOVS     R1,#+134217728
   \       0xEE   0xEB16 0x1240      ADDS     R2,R6,R0, LSL #+5
   \       0xF2   0xF512 0x6210      ADDS     R2,R2,#+2304
   \       0xF6   0x6011             STR      R1,[R2, #+0]
   \       0xF8   0xE00D             B.N      ??USB_DevInit_13
    375                }
    376                else
    377                {
    378                  USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
   \                     ??USB_DevInit_12: (+1)
   \       0xFA   0xF05F 0x4190      MOVS     R1,#+1207959552
   \       0xFE   0xEB16 0x1240      ADDS     R2,R6,R0, LSL #+5
   \      0x102   0xF512 0x6210      ADDS     R2,R2,#+2304
   \      0x106   0x6011             STR      R1,[R2, #+0]
   \      0x108   0xE005             B.N      ??USB_DevInit_13
    379                }
    380              }
    381              else
    382              {
    383                USBx_INEP(i)->DIEPCTL = 0U;
   \                     ??USB_DevInit_11: (+1)
   \      0x10A   0x2100             MOVS     R1,#+0
   \      0x10C   0xEB16 0x1240      ADDS     R2,R6,R0, LSL #+5
   \      0x110   0xF512 0x6210      ADDS     R2,R2,#+2304
   \      0x114   0x6011             STR      R1,[R2, #+0]
    384              }
    385          
    386              USBx_INEP(i)->DIEPTSIZ = 0U;
   \                     ??USB_DevInit_13: (+1)
   \      0x116   0xEB16 0x1140      ADDS     R1,R6,R0, LSL #+5
   \      0x11A   0xF511 0x6110      ADDS     R1,R1,#+2304
   \      0x11E   0x2200             MOVS     R2,#+0
   \      0x120   0x610A             STR      R2,[R1, #+16]
    387              USBx_INEP(i)->DIEPINT  = 0xFB7FU;
   \      0x122   0xEB16 0x1140      ADDS     R1,R6,R0, LSL #+5
   \      0x126   0xF511 0x6110      ADDS     R1,R1,#+2304
   \      0x12A   0xF64F 0x327F      MOVW     R2,#+64383
   \      0x12E   0x608A             STR      R2,[R1, #+8]
    388            }
   \      0x130   0x1C40             ADDS     R0,R0,#+1
   \      0x132   0xE7CE             B.N      ??USB_DevInit_9
    389          
    390            for (i = 0U; i < cfg.dev_endpoints; i++)
   \                     ??USB_DevInit_10: (+1)
   \      0x134   0x2100             MOVS     R1,#+0
   \                     ??USB_DevInit_14: (+1)
   \      0x136   0x9805             LDR      R0,[SP, #+20]
   \      0x138   0x4281             CMP      R1,R0
   \      0x13A   0xD22D             BCS.N    ??USB_DevInit_15
    391            {
    392              if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
   \      0x13C   0xEB16 0x1041      ADDS     R0,R6,R1, LSL #+5
   \      0x140   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x144   0x6800             LDR      R0,[R0, #+0]
   \      0x146   0x2800             CMP      R0,#+0
   \      0x148   0xD511             BPL.N    ??USB_DevInit_16
    393              {
    394                if (i == 0U)
   \      0x14A   0x2900             CMP      R1,#+0
   \      0x14C   0xD107             BNE.N    ??USB_DevInit_17
    395                {
    396                  USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
   \      0x14E   0xF05F 0x6000      MOVS     R0,#+134217728
   \      0x152   0xEB16 0x1241      ADDS     R2,R6,R1, LSL #+5
   \      0x156   0xF512 0x6230      ADDS     R2,R2,#+2816
   \      0x15A   0x6010             STR      R0,[R2, #+0]
   \      0x15C   0xE00D             B.N      ??USB_DevInit_18
    397                }
    398                else
    399                {
    400                  USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
   \                     ??USB_DevInit_17: (+1)
   \      0x15E   0xF05F 0x4090      MOVS     R0,#+1207959552
   \      0x162   0xEB16 0x1241      ADDS     R2,R6,R1, LSL #+5
   \      0x166   0xF512 0x6230      ADDS     R2,R2,#+2816
   \      0x16A   0x6010             STR      R0,[R2, #+0]
   \      0x16C   0xE005             B.N      ??USB_DevInit_18
    401                }
    402              }
    403              else
    404              {
    405                USBx_OUTEP(i)->DOEPCTL = 0U;
   \                     ??USB_DevInit_16: (+1)
   \      0x16E   0x2000             MOVS     R0,#+0
   \      0x170   0xEB16 0x1241      ADDS     R2,R6,R1, LSL #+5
   \      0x174   0xF512 0x6230      ADDS     R2,R2,#+2816
   \      0x178   0x6010             STR      R0,[R2, #+0]
    406              }
    407          
    408              USBx_OUTEP(i)->DOEPTSIZ = 0U;
   \                     ??USB_DevInit_18: (+1)
   \      0x17A   0xEB16 0x1041      ADDS     R0,R6,R1, LSL #+5
   \      0x17E   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x182   0x2200             MOVS     R2,#+0
   \      0x184   0x6102             STR      R2,[R0, #+16]
    409              USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
   \      0x186   0xEB16 0x1041      ADDS     R0,R6,R1, LSL #+5
   \      0x18A   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x18E   0xF64F 0x327F      MOVW     R2,#+64383
   \      0x192   0x6082             STR      R2,[R0, #+8]
    410            }
   \      0x194   0x1C49             ADDS     R1,R1,#+1
   \      0x196   0xE7CE             B.N      ??USB_DevInit_14
    411          
    412            USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
   \                     ??USB_DevInit_15: (+1)
   \      0x198   0xF516 0x6000      ADDS     R0,R6,#+2048
   \      0x19C   0x6900             LDR      R0,[R0, #+16]
   \      0x19E   0xF430 0x7080      BICS     R0,R0,#0x100
   \      0x1A2   0xF516 0x6200      ADDS     R2,R6,#+2048
   \      0x1A6   0x6110             STR      R0,[R2, #+16]
    413          
    414            /* Disable all interrupts. */
    415            USBx->GINTMSK = 0U;
   \      0x1A8   0x2000             MOVS     R0,#+0
   \      0x1AA   0x61A0             STR      R0,[R4, #+24]
    416          
    417            /* Clear any pending interrupts */
    418            USBx->GINTSTS = 0xBFFFFFFFU;
   \      0x1AC   0xF07F 0x4080      MVNS     R0,#+1073741824
   \      0x1B0   0x6160             STR      R0,[R4, #+20]
    419          
    420            /* Enable the common interrupts */
    421            if (cfg.dma_enable == 0U)
   \      0x1B2   0x9808             LDR      R0,[SP, #+32]
   \      0x1B4   0x2800             CMP      R0,#+0
   \      0x1B6   0xD103             BNE.N    ??USB_DevInit_19
    422            {
    423              USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
   \      0x1B8   0x69A0             LDR      R0,[R4, #+24]
   \      0x1BA   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x1BE   0x61A0             STR      R0,[R4, #+24]
    424            }
    425          
    426            /* Enable interrupts matching to the Device mode ONLY */
    427            USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
    428                             USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |
    429                             USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM |
    430                             USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM;
   \                     ??USB_DevInit_19: (+1)
   \      0x1C0   0x69A2             LDR      R2,[R4, #+24]
   \      0x1C2   0x.... 0x....      LDR.W    R0,??DataTable8
   \      0x1C6   0x4302             ORRS     R2,R0,R2
   \      0x1C8   0x61A2             STR      R2,[R4, #+24]
    431          
    432            if (cfg.Sof_enable != 0U)
   \      0x1CA   0x980B             LDR      R0,[SP, #+44]
   \      0x1CC   0x2800             CMP      R0,#+0
   \      0x1CE   0xD003             BEQ.N    ??USB_DevInit_20
    433            {
    434              USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
   \      0x1D0   0x69A0             LDR      R0,[R4, #+24]
   \      0x1D2   0xF050 0x0008      ORRS     R0,R0,#0x8
   \      0x1D6   0x61A0             STR      R0,[R4, #+24]
    435            }
    436          
    437            if (cfg.vbus_sensing_enable == 1U)
   \                     ??USB_DevInit_20: (+1)
   \      0x1D8   0x980F             LDR      R0,[SP, #+60]
   \      0x1DA   0x2801             CMP      R0,#+1
   \      0x1DC   0xD105             BNE.N    ??USB_DevInit_21
    438            {
    439              USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
   \      0x1DE   0x69A0             LDR      R0,[R4, #+24]
   \      0x1E0   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \      0x1E4   0xF050 0x0004      ORRS     R0,R0,#0x4
   \      0x1E8   0x61A0             STR      R0,[R4, #+24]
    440            }
    441          
    442            return ret;
   \                     ??USB_DevInit_21: (+1)
   \      0x1EA   0x0028             MOVS     R0,R5
   \      0x1EC   0xB2C0             UXTB     R0,R0
   \      0x1EE   0xBCF0             POP      {R4-R7}
   \      0x1F0   0xF85D 0xFB10      LDR      PC,[SP], #+16
    443          }
    444          
    445          /**
    446            * @brief  USB_OTG_FlushTxFifo : Flush a Tx FIFO
    447            * @param  USBx  Selected device
    448            * @param  num  FIFO number
    449            *         This parameter can be a value from 1 to 15
    450                      15 means Flush all Tx FIFOs
    451            * @retval HAL status
    452            */

   \                                 In section .text, align 2, keep-with-next
    453          HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
    454          {
   \                     USB_FlushTxFifo: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    455            uint32_t count = 0U;
   \        0x2   0x2300             MOVS     R3,#+0
    456          
    457            USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
   \        0x4   0x0188             LSLS     R0,R1,#+6
   \        0x6   0xF050 0x0020      ORRS     R0,R0,#0x20
   \        0xA   0x6110             STR      R0,[R2, #+16]
    458          
    459            do
    460            {
    461              if (++count > 200000U)
   \                     ??USB_FlushTxFifo_0: (+1)
   \        0xC   0x1C5B             ADDS     R3,R3,#+1
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \       0x12   0x4283             CMP      R3,R0
   \       0x14   0xD301             BCC.N    ??USB_FlushTxFifo_1
    462              {
    463                return HAL_TIMEOUT;
   \       0x16   0x2003             MOVS     R0,#+3
   \       0x18   0xE003             B.N      ??USB_FlushTxFifo_2
    464              }
    465            } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
   \                     ??USB_FlushTxFifo_1: (+1)
   \       0x1A   0x6910             LDR      R0,[R2, #+16]
   \       0x1C   0x0680             LSLS     R0,R0,#+26
   \       0x1E   0xD4F5             BMI.N    ??USB_FlushTxFifo_0
    466          
    467            return HAL_OK;
   \       0x20   0x2000             MOVS     R0,#+0
   \                     ??USB_FlushTxFifo_2: (+1)
   \       0x22   0x4770             BX       LR
    468          }
    469          
    470          /**
    471            * @brief  USB_FlushRxFifo : Flush Rx FIFO
    472            * @param  USBx  Selected device
    473            * @retval HAL status
    474            */

   \                                 In section .text, align 2, keep-with-next
    475          HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
    476          {
   \                     USB_FlushRxFifo: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    477            uint32_t count = 0;
   \        0x2   0x2200             MOVS     R2,#+0
    478          
    479            USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
   \        0x4   0x2010             MOVS     R0,#+16
   \        0x6   0x6108             STR      R0,[R1, #+16]
    480          
    481            do
    482            {
    483              if (++count > 200000U)
   \                     ??USB_FlushRxFifo_0: (+1)
   \        0x8   0x1C52             ADDS     R2,R2,#+1
   \        0xA   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \        0xE   0x4282             CMP      R2,R0
   \       0x10   0xD301             BCC.N    ??USB_FlushRxFifo_1
    484              {
    485                return HAL_TIMEOUT;
   \       0x12   0x2003             MOVS     R0,#+3
   \       0x14   0xE003             B.N      ??USB_FlushRxFifo_2
    486              }
    487            } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
   \                     ??USB_FlushRxFifo_1: (+1)
   \       0x16   0x6908             LDR      R0,[R1, #+16]
   \       0x18   0x06C0             LSLS     R0,R0,#+27
   \       0x1A   0xD4F5             BMI.N    ??USB_FlushRxFifo_0
    488          
    489            return HAL_OK;
   \       0x1C   0x2000             MOVS     R0,#+0
   \                     ??USB_FlushRxFifo_2: (+1)
   \       0x1E   0x4770             BX       LR
    490          }
    491          
    492          /**
    493            * @brief  USB_SetDevSpeed  Initializes the DevSpd field of DCFG register
    494            *         depending the PHY type and the enumeration speed of the device.
    495            * @param  USBx  Selected device
    496            * @param  speed  device speed
    497            *          This parameter can be one of these values:
    498            *            @arg USB_OTG_SPEED_HIGH: High speed mode
    499            *            @arg USB_OTG_SPEED_HIGH_IN_FULL: High speed core in Full Speed mode
    500            *            @arg USB_OTG_SPEED_FULL: Full speed mode
    501            * @retval  Hal status
    502            */

   \                                 In section .text, align 2, keep-with-next
    503          HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx, uint8_t speed)
    504          {
   \                     USB_SetDevSpeed: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0002             MOVS     R2,R0
    505            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x0013             MOVS     R3,R2
    506          
    507            USBx_DEVICE->DCFG |= speed;
   \        0x6   0xF513 0x6000      ADDS     R0,R3,#+2048
   \        0xA   0x6804             LDR      R4,[R0, #+0]
   \        0xC   0x0008             MOVS     R0,R1
   \        0xE   0xB2C0             UXTB     R0,R0
   \       0x10   0x4304             ORRS     R4,R0,R4
   \       0x12   0xF513 0x6000      ADDS     R0,R3,#+2048
   \       0x16   0x6004             STR      R4,[R0, #+0]
    508            return HAL_OK;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xBC10             POP      {R4}
   \       0x1C   0x4770             BX       LR
    509          }
    510          
    511          /**
    512            * @brief  USB_GetDevSpeed  Return the Dev Speed
    513            * @param  USBx  Selected device
    514            * @retval speed  device speed
    515            *          This parameter can be one of these values:
    516            *            @arg PCD_SPEED_HIGH: High speed mode
    517            *            @arg PCD_SPEED_FULL: Full speed mode
    518            */

   \                                 In section .text, align 2, keep-with-next
    519          uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
    520          {
   \                     USB_GetDevSpeed: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    521            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x2   0x0013             MOVS     R3,R2
    522            uint8_t speed;
    523            uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
   \        0x4   0xF513 0x6000      ADDS     R0,R3,#+2048
   \        0x8   0x6881             LDR      R1,[R0, #+8]
   \        0xA   0xF011 0x0106      ANDS     R1,R1,#0x6
    524          
    525            if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD101             BNE.N    ??USB_GetDevSpeed_0
    526            {
    527              speed = USBD_HS_SPEED;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0xE006             B.N      ??USB_GetDevSpeed_1
    528            }
    529            else if ((DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||
    530                     (DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_48MHZ))
   \                     ??USB_GetDevSpeed_0: (+1)
   \       0x16   0x2902             CMP      R1,#+2
   \       0x18   0xD001             BEQ.N    ??USB_GetDevSpeed_2
   \       0x1A   0x2906             CMP      R1,#+6
   \       0x1C   0xD101             BNE.N    ??USB_GetDevSpeed_3
    531            {
    532              speed = USBD_FS_SPEED;
   \                     ??USB_GetDevSpeed_2: (+1)
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0xE000             B.N      ??USB_GetDevSpeed_1
    533            }
    534            else
    535            {
    536              speed = 0xFU;
   \                     ??USB_GetDevSpeed_3: (+1)
   \       0x22   0x200F             MOVS     R0,#+15
    537            }
    538          
    539            return speed;
   \                     ??USB_GetDevSpeed_1: (+1)
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x4770             BX       LR
    540          }
    541          
    542          /**
    543            * @brief  Activate and configure an endpoint
    544            * @param  USBx  Selected device
    545            * @param  ep pointer to endpoint structure
    546            * @retval HAL status
    547            */

   \                                 In section .text, align 2, keep-with-next
    548          HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    549          {
   \                     USB_ActivateEndpoint: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x0002             MOVS     R2,R0
    550            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x0013             MOVS     R3,R2
    551            uint32_t epnum = (uint32_t)ep->num;
   \        0x6   0x780C             LDRB     R4,[R1, #+0]
    552          
    553            if (ep->is_in == 1U)
   \        0x8   0x7848             LDRB     R0,[R1, #+1]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD12B             BNE.N    ??USB_ActivateEndpoint_0
    554            {
    555              USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
   \        0xE   0xF513 0x6000      ADDS     R0,R3,#+2048
   \       0x12   0x69C0             LDR      R0,[R0, #+28]
   \       0x14   0x2501             MOVS     R5,#+1
   \       0x16   0x780E             LDRB     R6,[R1, #+0]
   \       0x18   0xF016 0x060F      ANDS     R6,R6,#0xF
   \       0x1C   0x40B5             LSLS     R5,R5,R6
   \       0x1E   0xB2AD             UXTH     R5,R5
   \       0x20   0x4328             ORRS     R0,R5,R0
   \       0x22   0xF513 0x6500      ADDS     R5,R3,#+2048
   \       0x26   0x61E8             STR      R0,[R5, #+28]
    556          
    557              if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
   \       0x28   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x2C   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x30   0x6800             LDR      R0,[R0, #+0]
   \       0x32   0x0400             LSLS     R0,R0,#+16
   \       0x34   0xD440             BMI.N    ??USB_ActivateEndpoint_1
    558              {
    559                USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
    560                                             ((uint32_t)ep->type << 18) | (epnum << 22) |
    561                                             USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
    562                                             USB_OTG_DIEPCTL_USBAEP;
   \       0x36   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x3A   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x3E   0x6800             LDR      R0,[R0, #+0]
   \       0x40   0x688D             LDR      R5,[R1, #+8]
   \       0x42   0x056D             LSLS     R5,R5,#+21
   \       0x44   0x0D6D             LSRS     R5,R5,#+21
   \       0x46   0x4328             ORRS     R0,R5,R0
   \       0x48   0x78CD             LDRB     R5,[R1, #+3]
   \       0x4A   0xEA50 0x4085      ORRS     R0,R0,R5, LSL #+18
   \       0x4E   0xEA50 0x5084      ORRS     R0,R0,R4, LSL #+22
   \       0x52   0xF040 0x5080      ORR      R0,R0,#0x10000000
   \       0x56   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0x5A   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0x5E   0xF515 0x6510      ADDS     R5,R5,#+2304
   \       0x62   0x6028             STR      R0,[R5, #+0]
   \       0x64   0xE028             B.N      ??USB_ActivateEndpoint_1
    563              }
    564            }
    565            else
    566            {
    567              USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
   \                     ??USB_ActivateEndpoint_0: (+1)
   \       0x66   0xF513 0x6000      ADDS     R0,R3,#+2048
   \       0x6A   0x69C0             LDR      R0,[R0, #+28]
   \       0x6C   0x2501             MOVS     R5,#+1
   \       0x6E   0x780E             LDRB     R6,[R1, #+0]
   \       0x70   0xF016 0x060F      ANDS     R6,R6,#0xF
   \       0x74   0x40B5             LSLS     R5,R5,R6
   \       0x76   0xEA50 0x4005      ORRS     R0,R0,R5, LSL #+16
   \       0x7A   0xF513 0x6500      ADDS     R5,R3,#+2048
   \       0x7E   0x61E8             STR      R0,[R5, #+28]
    568          
    569              if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
   \       0x80   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x84   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x88   0x6800             LDR      R0,[R0, #+0]
   \       0x8A   0x0400             LSLS     R0,R0,#+16
   \       0x8C   0xD414             BMI.N    ??USB_ActivateEndpoint_1
    570              {
    571                USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
    572                                              ((uint32_t)ep->type << 18) |
    573                                              USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
    574                                              USB_OTG_DOEPCTL_USBAEP;
   \       0x8E   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x92   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x96   0x6800             LDR      R0,[R0, #+0]
   \       0x98   0x688D             LDR      R5,[R1, #+8]
   \       0x9A   0x056D             LSLS     R5,R5,#+21
   \       0x9C   0x0D6D             LSRS     R5,R5,#+21
   \       0x9E   0x4328             ORRS     R0,R5,R0
   \       0xA0   0x78CD             LDRB     R5,[R1, #+3]
   \       0xA2   0xEA50 0x4085      ORRS     R0,R0,R5, LSL #+18
   \       0xA6   0xF040 0x5080      ORR      R0,R0,#0x10000000
   \       0xAA   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0xAE   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0xB2   0xF515 0x6530      ADDS     R5,R5,#+2816
   \       0xB6   0x6028             STR      R0,[R5, #+0]
    575              }
    576            }
    577            return HAL_OK;
   \                     ??USB_ActivateEndpoint_1: (+1)
   \       0xB8   0x2000             MOVS     R0,#+0
   \       0xBA   0xBC70             POP      {R4-R6}
   \       0xBC   0x4770             BX       LR
    578          }
    579          
    580          /**
    581            * @brief  Activate and configure a dedicated endpoint
    582            * @param  USBx  Selected device
    583            * @param  ep pointer to endpoint structure
    584            * @retval HAL status
    585            */

   \                                 In section .text, align 2, keep-with-next
    586          HAL_StatusTypeDef USB_ActivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    587          {
   \                     USB_ActivateDedicatedEndpoint: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x0002             MOVS     R2,R0
    588            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x0013             MOVS     R3,R2
    589            uint32_t epnum = (uint32_t)ep->num;
   \        0x6   0x780C             LDRB     R4,[R1, #+0]
    590          
    591            /* Read DEPCTLn register */
    592            if (ep->is_in == 1U)
   \        0x8   0x7848             LDRB     R0,[R1, #+1]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD12B             BNE.N    ??USB_ActivateDedicatedEndpoint_0
    593            {
    594              if (((USBx_INEP(epnum)->DIEPCTL) & USB_OTG_DIEPCTL_USBAEP) == 0U)
   \        0xE   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x12   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x0400             LSLS     R0,R0,#+16
   \       0x1A   0xD416             BMI.N    ??USB_ActivateDedicatedEndpoint_1
    595              {
    596                USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
    597                                             ((uint32_t)ep->type << 18) | (epnum << 22) |
    598                                             USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
    599                                             USB_OTG_DIEPCTL_USBAEP;
   \       0x1C   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x20   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x688D             LDR      R5,[R1, #+8]
   \       0x28   0x056D             LSLS     R5,R5,#+21
   \       0x2A   0x0D6D             LSRS     R5,R5,#+21
   \       0x2C   0x4328             ORRS     R0,R5,R0
   \       0x2E   0x78CD             LDRB     R5,[R1, #+3]
   \       0x30   0xEA50 0x4085      ORRS     R0,R0,R5, LSL #+18
   \       0x34   0xEA50 0x5084      ORRS     R0,R0,R4, LSL #+22
   \       0x38   0xF040 0x5080      ORR      R0,R0,#0x10000000
   \       0x3C   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0x40   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0x44   0xF515 0x6510      ADDS     R5,R5,#+2304
   \       0x48   0x6028             STR      R0,[R5, #+0]
    600              }
    601          
    602              USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
   \                     ??USB_ActivateDedicatedEndpoint_1: (+1)
   \       0x4A   0xF513 0x6000      ADDS     R0,R3,#+2048
   \       0x4E   0x6BC0             LDR      R0,[R0, #+60]
   \       0x50   0x2501             MOVS     R5,#+1
   \       0x52   0x780E             LDRB     R6,[R1, #+0]
   \       0x54   0xF016 0x060F      ANDS     R6,R6,#0xF
   \       0x58   0x40B5             LSLS     R5,R5,R6
   \       0x5A   0xB2AD             UXTH     R5,R5
   \       0x5C   0x4328             ORRS     R0,R5,R0
   \       0x5E   0xF513 0x6500      ADDS     R5,R3,#+2048
   \       0x62   0x63E8             STR      R0,[R5, #+60]
   \       0x64   0xE028             B.N      ??USB_ActivateDedicatedEndpoint_2
    603            }
    604            else
    605            {
    606              if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
   \                     ??USB_ActivateDedicatedEndpoint_0: (+1)
   \       0x66   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x6A   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x6E   0x6800             LDR      R0,[R0, #+0]
   \       0x70   0x0400             LSLS     R0,R0,#+16
   \       0x72   0xD414             BMI.N    ??USB_ActivateDedicatedEndpoint_3
    607              {
    608                USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
    609                                              ((uint32_t)ep->type << 18) | (epnum << 22) |
    610                                              USB_OTG_DOEPCTL_USBAEP;
   \       0x74   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x78   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x7C   0x6800             LDR      R0,[R0, #+0]
   \       0x7E   0x688D             LDR      R5,[R1, #+8]
   \       0x80   0x056D             LSLS     R5,R5,#+21
   \       0x82   0x0D6D             LSRS     R5,R5,#+21
   \       0x84   0x4328             ORRS     R0,R5,R0
   \       0x86   0x78CD             LDRB     R5,[R1, #+3]
   \       0x88   0xEA50 0x4085      ORRS     R0,R0,R5, LSL #+18
   \       0x8C   0xEA50 0x5084      ORRS     R0,R0,R4, LSL #+22
   \       0x90   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0x94   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0x98   0xF515 0x6530      ADDS     R5,R5,#+2816
   \       0x9C   0x6028             STR      R0,[R5, #+0]
    611              }
    612          
    613              USBx_DEVICE->DEACHMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
   \                     ??USB_ActivateDedicatedEndpoint_3: (+1)
   \       0x9E   0xF513 0x6000      ADDS     R0,R3,#+2048
   \       0xA2   0x6BC0             LDR      R0,[R0, #+60]
   \       0xA4   0x2501             MOVS     R5,#+1
   \       0xA6   0x780E             LDRB     R6,[R1, #+0]
   \       0xA8   0xF016 0x060F      ANDS     R6,R6,#0xF
   \       0xAC   0x40B5             LSLS     R5,R5,R6
   \       0xAE   0xEA50 0x4005      ORRS     R0,R0,R5, LSL #+16
   \       0xB2   0xF513 0x6500      ADDS     R5,R3,#+2048
   \       0xB6   0x63E8             STR      R0,[R5, #+60]
    614            }
    615          
    616            return HAL_OK;
   \                     ??USB_ActivateDedicatedEndpoint_2: (+1)
   \       0xB8   0x2000             MOVS     R0,#+0
   \       0xBA   0xBC70             POP      {R4-R6}
   \       0xBC   0x4770             BX       LR
    617          }
    618          
    619          /**
    620            * @brief  De-activate and de-initialize an endpoint
    621            * @param  USBx  Selected device
    622            * @param  ep pointer to endpoint structure
    623            * @retval HAL status
    624            */

   \                                 In section .text, align 2, keep-with-next
    625          HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    626          {
   \                     USB_DeactivateEndpoint: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x0002             MOVS     R2,R0
    627            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x0013             MOVS     R3,R2
    628            uint32_t epnum = (uint32_t)ep->num;
   \        0x6   0x780C             LDRB     R4,[R1, #+0]
    629          
    630            /* Read DEPCTLn register */
    631            if (ep->is_in == 1U)
   \        0x8   0x7848             LDRB     R0,[R1, #+1]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD147             BNE.N    ??USB_DeactivateEndpoint_0
    632            {
    633              if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
   \        0xE   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x12   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD517             BPL.N    ??USB_DeactivateEndpoint_1
    634              {
    635                USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
   \       0x1C   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x20   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \       0x2A   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0x2E   0xF515 0x6510      ADDS     R5,R5,#+2304
   \       0x32   0x6028             STR      R0,[R5, #+0]
    636                USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
   \       0x34   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x38   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x3C   0x6800             LDR      R0,[R0, #+0]
   \       0x3E   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \       0x42   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0x46   0xF515 0x6510      ADDS     R5,R5,#+2304
   \       0x4A   0x6028             STR      R0,[R5, #+0]
    637              }
    638          
    639              USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
   \                     ??USB_DeactivateEndpoint_1: (+1)
   \       0x4C   0x2001             MOVS     R0,#+1
   \       0x4E   0xF513 0x6500      ADDS     R5,R3,#+2048
   \       0x52   0x6BED             LDR      R5,[R5, #+60]
   \       0x54   0x780E             LDRB     R6,[R1, #+0]
   \       0x56   0xF016 0x060F      ANDS     R6,R6,#0xF
   \       0x5A   0xFA10 0xF606      LSLS     R6,R0,R6
   \       0x5E   0xB2B6             UXTH     R6,R6
   \       0x60   0x43B5             BICS     R5,R5,R6
   \       0x62   0xF513 0x6600      ADDS     R6,R3,#+2048
   \       0x66   0x63F5             STR      R5,[R6, #+60]
    640              USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
   \       0x68   0xF513 0x6500      ADDS     R5,R3,#+2048
   \       0x6C   0x69ED             LDR      R5,[R5, #+28]
   \       0x6E   0x780E             LDRB     R6,[R1, #+0]
   \       0x70   0xF016 0x060F      ANDS     R6,R6,#0xF
   \       0x74   0x40B0             LSLS     R0,R0,R6
   \       0x76   0xB280             UXTH     R0,R0
   \       0x78   0xEA35 0x0000      BICS     R0,R5,R0
   \       0x7C   0xF513 0x6500      ADDS     R5,R3,#+2048
   \       0x80   0x61E8             STR      R0,[R5, #+28]
    641              USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
    642                                             USB_OTG_DIEPCTL_MPSIZ |
    643                                             USB_OTG_DIEPCTL_TXFNUM |
    644                                             USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
    645                                             USB_OTG_DIEPCTL_EPTYP);
   \       0x82   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x86   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x8A   0x6805             LDR      R5,[R0, #+0]
   \       0x8C   0x.... 0x....      LDR.W    R0,??DataTable9
   \       0x90   0x4005             ANDS     R5,R0,R5
   \       0x92   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x96   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x9A   0x6005             STR      R5,[R0, #+0]
   \       0x9C   0xE045             B.N      ??USB_DeactivateEndpoint_2
    646            }
    647            else
    648            {
    649              if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
   \                     ??USB_DeactivateEndpoint_0: (+1)
   \       0x9E   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0xA2   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0xA6   0x6800             LDR      R0,[R0, #+0]
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD517             BPL.N    ??USB_DeactivateEndpoint_3
    650              {
    651                USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
   \       0xAC   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0xB0   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0xB4   0x6800             LDR      R0,[R0, #+0]
   \       0xB6   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \       0xBA   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0xBE   0xF515 0x6530      ADDS     R5,R5,#+2816
   \       0xC2   0x6028             STR      R0,[R5, #+0]
    652                USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
   \       0xC4   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0xC8   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0xCC   0x6800             LDR      R0,[R0, #+0]
   \       0xCE   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \       0xD2   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0xD6   0xF515 0x6530      ADDS     R5,R5,#+2816
   \       0xDA   0x6028             STR      R0,[R5, #+0]
    653              }
    654          
    655              USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
   \                     ??USB_DeactivateEndpoint_3: (+1)
   \       0xDC   0x2001             MOVS     R0,#+1
   \       0xDE   0xF513 0x6500      ADDS     R5,R3,#+2048
   \       0xE2   0x6BED             LDR      R5,[R5, #+60]
   \       0xE4   0x780E             LDRB     R6,[R1, #+0]
   \       0xE6   0xF016 0x060F      ANDS     R6,R6,#0xF
   \       0xEA   0xFA10 0xF606      LSLS     R6,R0,R6
   \       0xEE   0xEA35 0x4506      BICS     R5,R5,R6, LSL #+16
   \       0xF2   0xF513 0x6600      ADDS     R6,R3,#+2048
   \       0xF6   0x63F5             STR      R5,[R6, #+60]
    656              USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
   \       0xF8   0xF513 0x6500      ADDS     R5,R3,#+2048
   \       0xFC   0x69ED             LDR      R5,[R5, #+28]
   \       0xFE   0x780E             LDRB     R6,[R1, #+0]
   \      0x100   0xF016 0x060F      ANDS     R6,R6,#0xF
   \      0x104   0x40B0             LSLS     R0,R0,R6
   \      0x106   0xEA35 0x4500      BICS     R5,R5,R0, LSL #+16
   \      0x10A   0xF513 0x6000      ADDS     R0,R3,#+2048
   \      0x10E   0x61C5             STR      R5,[R0, #+28]
    657              USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
    658                                              USB_OTG_DOEPCTL_MPSIZ |
    659                                              USB_OTG_DOEPCTL_SD0PID_SEVNFRM |
    660                                              USB_OTG_DOEPCTL_EPTYP);
   \      0x110   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \      0x114   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x118   0x6805             LDR      R5,[R0, #+0]
   \      0x11A   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \      0x11E   0x4005             ANDS     R5,R0,R5
   \      0x120   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \      0x124   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x128   0x6005             STR      R5,[R0, #+0]
    661            }
    662          
    663            return HAL_OK;
   \                     ??USB_DeactivateEndpoint_2: (+1)
   \      0x12A   0x2000             MOVS     R0,#+0
   \      0x12C   0xBC70             POP      {R4-R6}
   \      0x12E   0x4770             BX       LR
    664          }
    665          
    666          /**
    667            * @brief  De-activate and de-initialize a dedicated endpoint
    668            * @param  USBx  Selected device
    669            * @param  ep pointer to endpoint structure
    670            * @retval HAL status
    671            */

   \                                 In section .text, align 2, keep-with-next
    672          HAL_StatusTypeDef USB_DeactivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
    673          {
   \                     USB_DeactivateDedicatedEndpoint: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x0002             MOVS     R2,R0
    674            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x0013             MOVS     R3,R2
    675            uint32_t epnum = (uint32_t)ep->num;
   \        0x6   0x780C             LDRB     R4,[R1, #+0]
    676          
    677            /* Read DEPCTLn register */
    678            if (ep->is_in == 1U)
   \        0x8   0x7848             LDRB     R0,[R1, #+1]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD138             BNE.N    ??USB_DeactivateDedicatedEndpoint_0
    679            {
    680              if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
   \        0xE   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x12   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD517             BPL.N    ??USB_DeactivateDedicatedEndpoint_1
    681              {
    682                USBx_INEP(epnum)->DIEPCTL  |= USB_OTG_DIEPCTL_SNAK;
   \       0x1C   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x20   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \       0x2A   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0x2E   0xF515 0x6510      ADDS     R5,R5,#+2304
   \       0x32   0x6028             STR      R0,[R5, #+0]
    683                USBx_INEP(epnum)->DIEPCTL  |= USB_OTG_DIEPCTL_EPDIS;
   \       0x34   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x38   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x3C   0x6800             LDR      R0,[R0, #+0]
   \       0x3E   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \       0x42   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0x46   0xF515 0x6510      ADDS     R5,R5,#+2304
   \       0x4A   0x6028             STR      R0,[R5, #+0]
    684              }
    685          
    686              USBx_INEP(epnum)->DIEPCTL &= ~ USB_OTG_DIEPCTL_USBAEP;
   \                     ??USB_DeactivateDedicatedEndpoint_1: (+1)
   \       0x4C   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x50   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x54   0x6800             LDR      R0,[R0, #+0]
   \       0x56   0xF430 0x4000      BICS     R0,R0,#0x8000
   \       0x5A   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0x5E   0xF515 0x6510      ADDS     R5,R5,#+2304
   \       0x62   0x6028             STR      R0,[R5, #+0]
    687              USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
   \       0x64   0xF513 0x6000      ADDS     R0,R3,#+2048
   \       0x68   0x69C0             LDR      R0,[R0, #+28]
   \       0x6A   0x2501             MOVS     R5,#+1
   \       0x6C   0x780E             LDRB     R6,[R1, #+0]
   \       0x6E   0xF016 0x060F      ANDS     R6,R6,#0xF
   \       0x72   0x40B5             LSLS     R5,R5,R6
   \       0x74   0xB2AD             UXTH     R5,R5
   \       0x76   0x43A8             BICS     R0,R0,R5
   \       0x78   0xF513 0x6500      ADDS     R5,R3,#+2048
   \       0x7C   0x61E8             STR      R0,[R5, #+28]
   \       0x7E   0xE037             B.N      ??USB_DeactivateDedicatedEndpoint_2
    688            }
    689            else
    690            {
    691              if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
   \                     ??USB_DeactivateDedicatedEndpoint_0: (+1)
   \       0x80   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x84   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x88   0x6800             LDR      R0,[R0, #+0]
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD517             BPL.N    ??USB_DeactivateDedicatedEndpoint_3
    692              {
    693                USBx_OUTEP(epnum)->DOEPCTL  |= USB_OTG_DOEPCTL_SNAK;
   \       0x8E   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x92   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x96   0x6800             LDR      R0,[R0, #+0]
   \       0x98   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \       0x9C   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0xA0   0xF515 0x6530      ADDS     R5,R5,#+2816
   \       0xA4   0x6028             STR      R0,[R5, #+0]
    694                USBx_OUTEP(epnum)->DOEPCTL  |= USB_OTG_DOEPCTL_EPDIS;
   \       0xA6   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0xAA   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0xAE   0x6800             LDR      R0,[R0, #+0]
   \       0xB0   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \       0xB4   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0xB8   0xF515 0x6530      ADDS     R5,R5,#+2816
   \       0xBC   0x6028             STR      R0,[R5, #+0]
    695              }
    696          
    697              USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_USBAEP;
   \                     ??USB_DeactivateDedicatedEndpoint_3: (+1)
   \       0xBE   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0xC2   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0xC6   0x6800             LDR      R0,[R0, #+0]
   \       0xC8   0xF430 0x4000      BICS     R0,R0,#0x8000
   \       0xCC   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0xD0   0xF515 0x6530      ADDS     R5,R5,#+2816
   \       0xD4   0x6028             STR      R0,[R5, #+0]
    698              USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
   \       0xD6   0xF513 0x6000      ADDS     R0,R3,#+2048
   \       0xDA   0x69C0             LDR      R0,[R0, #+28]
   \       0xDC   0x2501             MOVS     R5,#+1
   \       0xDE   0x780E             LDRB     R6,[R1, #+0]
   \       0xE0   0xF016 0x060F      ANDS     R6,R6,#0xF
   \       0xE4   0x40B5             LSLS     R5,R5,R6
   \       0xE6   0xEA30 0x4005      BICS     R0,R0,R5, LSL #+16
   \       0xEA   0xF513 0x6500      ADDS     R5,R3,#+2048
   \       0xEE   0x61E8             STR      R0,[R5, #+28]
    699            }
    700          
    701            return HAL_OK;
   \                     ??USB_DeactivateDedicatedEndpoint_2: (+1)
   \       0xF0   0x2000             MOVS     R0,#+0
   \       0xF2   0xBC70             POP      {R4-R6}
   \       0xF4   0x4770             BX       LR
    702          }
    703          
    704          /**
    705            * @brief  USB_EPStartXfer : setup and starts a transfer over an EP
    706            * @param  USBx  Selected device
    707            * @param  ep pointer to endpoint structure
    708            * @param  dma USB dma enabled or disabled
    709            *          This parameter can be one of these values:
    710            *           0 : DMA feature not used
    711            *           1 : DMA feature used
    712            * @retval HAL status
    713            */

   \                                 In section .text, align 2, keep-with-next
    714          HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
    715          {
   \                     USB_EPStartXfer: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
    716            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0xA   0x46A8             MOV      R8,R5
    717            uint32_t epnum = (uint32_t)ep->num;
   \        0xC   0xF896 0x9000      LDRB     R9,[R6, #+0]
    718            uint16_t pktcnt;
    719          
    720            /* IN endpoint */
    721            if (ep->is_in == 1U)
   \       0x10   0x7870             LDRB     R0,[R6, #+1]
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xF040 0x8103      BNE.W    ??USB_EPStartXfer_0
    722            {
    723              /* Zero Length Packet? */
    724              if (ep->xfer_len == 0U)
   \       0x18   0x6970             LDR      R0,[R6, #+20]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD124             BNE.N    ??USB_EPStartXfer_1
    725              {
    726                USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
   \       0x1E   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \       0x22   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x26   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \       0x2A   0xF511 0x6110      ADDS     R1,R1,#+2304
   \       0x2E   0x6909             LDR      R1,[R1, #+16]
   \       0x30   0xF36F 0x41DC      BFC      R1,#+19,#+10
   \       0x34   0x6101             STR      R1,[R0, #+16]
    727                USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
   \       0x36   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \       0x3A   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x3E   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \       0x42   0xF511 0x6110      ADDS     R1,R1,#+2304
   \       0x46   0x6909             LDR      R1,[R1, #+16]
   \       0x48   0xF451 0x2100      ORRS     R1,R1,#0x80000
   \       0x4C   0x6101             STR      R1,[R0, #+16]
    728                USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
   \       0x4E   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \       0x52   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x56   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \       0x5A   0xF511 0x6110      ADDS     R1,R1,#+2304
   \       0x5E   0x6909             LDR      R1,[R1, #+16]
   \       0x60   0x0CC9             LSRS     R1,R1,#+19
   \       0x62   0x04C9             LSLS     R1,R1,#+19
   \       0x64   0x6101             STR      R1,[R0, #+16]
   \       0x66   0xE056             B.N      ??USB_EPStartXfer_2
    729              }
    730              else
    731              {
    732                /* Program the transfer size and packet count
    733                * as follows: xfersize = N * maxpacket +
    734                * short_packet pktcnt = N + (short_packet
    735                * exist ? 1 : 0)
    736                */
    737                USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
   \                     ??USB_EPStartXfer_1: (+1)
   \       0x68   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \       0x6C   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x70   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \       0x74   0xF511 0x6110      ADDS     R1,R1,#+2304
   \       0x78   0x6909             LDR      R1,[R1, #+16]
   \       0x7A   0x0CC9             LSRS     R1,R1,#+19
   \       0x7C   0x04C9             LSLS     R1,R1,#+19
   \       0x7E   0x6101             STR      R1,[R0, #+16]
    738                USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
   \       0x80   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \       0x84   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x88   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \       0x8C   0xF511 0x6110      ADDS     R1,R1,#+2304
   \       0x90   0x6909             LDR      R1,[R1, #+16]
   \       0x92   0xF36F 0x41DC      BFC      R1,#+19,#+10
   \       0x96   0x6101             STR      R1,[R0, #+16]
    739                USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
   \       0x98   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \       0x9C   0xF511 0x6110      ADDS     R1,R1,#+2304
   \       0xA0   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \       0xA4   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0xA8   0x6902             LDR      R2,[R0, #+16]
   \       0xAA   0x6973             LDR      R3,[R6, #+20]
   \       0xAC   0x68B0             LDR      R0,[R6, #+8]
   \       0xAE   0x18C3             ADDS     R3,R0,R3
   \       0xB0   0x1E5B             SUBS     R3,R3,#+1
   \       0xB2   0x68B0             LDR      R0,[R6, #+8]
   \       0xB4   0xFBB3 0xF0F0      UDIV     R0,R3,R0
   \       0xB8   0x.... 0x....      LDR.W    R3,??DataTable9_2
   \       0xBC   0xEA13 0x43C0      ANDS     R3,R3,R0, LSL #+19
   \       0xC0   0x431A             ORRS     R2,R3,R2
   \       0xC2   0x610A             STR      R2,[R1, #+16]
    740                USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
   \       0xC4   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \       0xC8   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0xCC   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \       0xD0   0xF511 0x6110      ADDS     R1,R1,#+2304
   \       0xD4   0x6909             LDR      R1,[R1, #+16]
   \       0xD6   0x6972             LDR      R2,[R6, #+20]
   \       0xD8   0x0352             LSLS     R2,R2,#+13
   \       0xDA   0x0B52             LSRS     R2,R2,#+13
   \       0xDC   0x4311             ORRS     R1,R2,R1
   \       0xDE   0x6101             STR      R1,[R0, #+16]
    741          
    742                if (ep->type == EP_TYPE_ISOC)
   \       0xE0   0x78F0             LDRB     R0,[R6, #+3]
   \       0xE2   0x2801             CMP      R0,#+1
   \       0xE4   0xD117             BNE.N    ??USB_EPStartXfer_2
    743                {
    744                  USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
   \       0xE6   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \       0xEA   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0xEE   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \       0xF2   0xF511 0x6110      ADDS     R1,R1,#+2304
   \       0xF6   0x6909             LDR      R1,[R1, #+16]
   \       0xF8   0xF031 0x41C0      BICS     R1,R1,#0x60000000
   \       0xFC   0x6101             STR      R1,[R0, #+16]
    745                  USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
   \       0xFE   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x102   0xF510 0x6010      ADDS     R0,R0,#+2304
   \      0x106   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \      0x10A   0xF511 0x6110      ADDS     R1,R1,#+2304
   \      0x10E   0x6909             LDR      R1,[R1, #+16]
   \      0x110   0xF051 0x5100      ORRS     R1,R1,#0x20000000
   \      0x114   0x6101             STR      R1,[R0, #+16]
    746                }
    747              }
    748          
    749              if (dma == 1U)
   \                     ??USB_EPStartXfer_2: (+1)
   \      0x116   0x0038             MOVS     R0,R7
   \      0x118   0xB2C0             UXTB     R0,R0
   \      0x11A   0x2801             CMP      R0,#+1
   \      0x11C   0xD136             BNE.N    ??USB_EPStartXfer_3
    750              {
    751                if ((uint32_t)ep->dma_addr != 0U)
   \      0x11E   0x6930             LDR      R0,[R6, #+16]
   \      0x120   0x2800             CMP      R0,#+0
   \      0x122   0xD005             BEQ.N    ??USB_EPStartXfer_4
    752                {
    753                  USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
   \      0x124   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x128   0xF510 0x6010      ADDS     R0,R0,#+2304
   \      0x12C   0x6931             LDR      R1,[R6, #+16]
   \      0x12E   0x6141             STR      R1,[R0, #+20]
    754                }
    755          
    756                if (ep->type == EP_TYPE_ISOC)
   \                     ??USB_EPStartXfer_4: (+1)
   \      0x130   0x78F0             LDRB     R0,[R6, #+3]
   \      0x132   0x2801             CMP      R0,#+1
   \      0x134   0xD11D             BNE.N    ??USB_EPStartXfer_5
    757                {
    758                  if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
   \      0x136   0xF518 0x6000      ADDS     R0,R8,#+2048
   \      0x13A   0x6880             LDR      R0,[R0, #+8]
   \      0x13C   0x05C0             LSLS     R0,R0,#+23
   \      0x13E   0xD40C             BMI.N    ??USB_EPStartXfer_6
    759                  {
    760                    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
   \      0x140   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x144   0xF510 0x6010      ADDS     R0,R0,#+2304
   \      0x148   0x6800             LDR      R0,[R0, #+0]
   \      0x14A   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x14E   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \      0x152   0xF511 0x6110      ADDS     R1,R1,#+2304
   \      0x156   0x6008             STR      R0,[R1, #+0]
   \      0x158   0xE00B             B.N      ??USB_EPStartXfer_5
    761                  }
    762                  else
    763                  {
    764                    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
   \                     ??USB_EPStartXfer_6: (+1)
   \      0x15A   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x15E   0xF510 0x6010      ADDS     R0,R0,#+2304
   \      0x162   0x6800             LDR      R0,[R0, #+0]
   \      0x164   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \      0x168   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \      0x16C   0xF511 0x6110      ADDS     R1,R1,#+2304
   \      0x170   0x6008             STR      R0,[R1, #+0]
    765                  }
    766                }
    767          
    768                /* EP enable, IN data in FIFO */
    769                USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
   \                     ??USB_EPStartXfer_5: (+1)
   \      0x172   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x176   0xF510 0x6010      ADDS     R0,R0,#+2304
   \      0x17A   0x6800             LDR      R0,[R0, #+0]
   \      0x17C   0xF050 0x4004      ORRS     R0,R0,#0x84000000
   \      0x180   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \      0x184   0xF511 0x6110      ADDS     R1,R1,#+2304
   \      0x188   0x6008             STR      R0,[R1, #+0]
   \      0x18A   0xE0E2             B.N      ??USB_EPStartXfer_7
    770              }
    771              else
    772              {
    773                /* EP enable, IN data in FIFO */
    774                USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
   \                     ??USB_EPStartXfer_3: (+1)
   \      0x18C   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x190   0xF510 0x6010      ADDS     R0,R0,#+2304
   \      0x194   0x6800             LDR      R0,[R0, #+0]
   \      0x196   0xF050 0x4004      ORRS     R0,R0,#0x84000000
   \      0x19A   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \      0x19E   0xF511 0x6110      ADDS     R1,R1,#+2304
   \      0x1A2   0x6008             STR      R0,[R1, #+0]
    775          
    776                if (ep->type != EP_TYPE_ISOC)
   \      0x1A4   0x78F0             LDRB     R0,[R6, #+3]
   \      0x1A6   0x2801             CMP      R0,#+1
   \      0x1A8   0xD010             BEQ.N    ??USB_EPStartXfer_8
    777                {
    778                  /* Enable the Tx FIFO Empty Interrupt for this EP */
    779                  if (ep->xfer_len > 0U)
   \      0x1AA   0x6970             LDR      R0,[R6, #+20]
   \      0x1AC   0x2800             CMP      R0,#+0
   \      0x1AE   0xF000 0x80D0      BEQ.W    ??USB_EPStartXfer_7
    780                  {
    781                    USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
   \      0x1B2   0xF518 0x6000      ADDS     R0,R8,#+2048
   \      0x1B6   0x6B40             LDR      R0,[R0, #+52]
   \      0x1B8   0x2101             MOVS     R1,#+1
   \      0x1BA   0x7832             LDRB     R2,[R6, #+0]
   \      0x1BC   0xF012 0x020F      ANDS     R2,R2,#0xF
   \      0x1C0   0x4091             LSLS     R1,R1,R2
   \      0x1C2   0x4308             ORRS     R0,R1,R0
   \      0x1C4   0xF518 0x6100      ADDS     R1,R8,#+2048
   \      0x1C8   0x6348             STR      R0,[R1, #+52]
   \      0x1CA   0xE0C2             B.N      ??USB_EPStartXfer_7
    782                  }
    783                }
    784                else
    785                {
    786                  if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
   \                     ??USB_EPStartXfer_8: (+1)
   \      0x1CC   0xF518 0x6000      ADDS     R0,R8,#+2048
   \      0x1D0   0x6880             LDR      R0,[R0, #+8]
   \      0x1D2   0x05C0             LSLS     R0,R0,#+23
   \      0x1D4   0xD40C             BMI.N    ??USB_EPStartXfer_9
    787                  {
    788                    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
   \      0x1D6   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x1DA   0xF510 0x6010      ADDS     R0,R0,#+2304
   \      0x1DE   0x6800             LDR      R0,[R0, #+0]
   \      0x1E0   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x1E4   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \      0x1E8   0xF511 0x6110      ADDS     R1,R1,#+2304
   \      0x1EC   0x6008             STR      R0,[R1, #+0]
   \      0x1EE   0xE00B             B.N      ??USB_EPStartXfer_10
    789                  }
    790                  else
    791                  {
    792                    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
   \                     ??USB_EPStartXfer_9: (+1)
   \      0x1F0   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x1F4   0xF510 0x6010      ADDS     R0,R0,#+2304
   \      0x1F8   0x6800             LDR      R0,[R0, #+0]
   \      0x1FA   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \      0x1FE   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \      0x202   0xF511 0x6110      ADDS     R1,R1,#+2304
   \      0x206   0x6008             STR      R0,[R1, #+0]
    793                  }
    794          
    795                  (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
   \                     ??USB_EPStartXfer_10: (+1)
   \      0x208   0x0038             MOVS     R0,R7
   \      0x20A   0xB2C0             UXTB     R0,R0
   \      0x20C   0x9000             STR      R0,[SP, #+0]
   \      0x20E   0x6973             LDR      R3,[R6, #+20]
   \      0x210   0xB29B             UXTH     R3,R3
   \      0x212   0x7832             LDRB     R2,[R6, #+0]
   \      0x214   0x68F1             LDR      R1,[R6, #+12]
   \      0x216   0x0028             MOVS     R0,R5
   \      0x218   0x.... 0x....      BL       USB_WritePacket
   \      0x21C   0xE099             B.N      ??USB_EPStartXfer_7
    796                }
    797              }
    798            }
    799            else /* OUT endpoint */
    800            {
    801              /* Program the transfer size and packet count as follows:
    802              * pktcnt = N
    803              * xfersize = N * maxpacket
    804              */
    805              USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
   \                     ??USB_EPStartXfer_0: (+1)
   \      0x21E   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x222   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x226   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \      0x22A   0xF511 0x6130      ADDS     R1,R1,#+2816
   \      0x22E   0x6909             LDR      R1,[R1, #+16]
   \      0x230   0x0CC9             LSRS     R1,R1,#+19
   \      0x232   0x04C9             LSLS     R1,R1,#+19
   \      0x234   0x6101             STR      R1,[R0, #+16]
    806              USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
   \      0x236   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x23A   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x23E   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \      0x242   0xF511 0x6130      ADDS     R1,R1,#+2816
   \      0x246   0x6909             LDR      R1,[R1, #+16]
   \      0x248   0xF36F 0x41DC      BFC      R1,#+19,#+10
   \      0x24C   0x6101             STR      R1,[R0, #+16]
    807          
    808              if (ep->xfer_len == 0U)
   \      0x24E   0x6970             LDR      R0,[R6, #+20]
   \      0x250   0x2800             CMP      R0,#+0
   \      0x252   0xD11A             BNE.N    ??USB_EPStartXfer_11
    809              {
    810                USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
   \      0x254   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x258   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x25C   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \      0x260   0xF511 0x6130      ADDS     R1,R1,#+2816
   \      0x264   0x6909             LDR      R1,[R1, #+16]
   \      0x266   0x68B2             LDR      R2,[R6, #+8]
   \      0x268   0x0352             LSLS     R2,R2,#+13
   \      0x26A   0x0B52             LSRS     R2,R2,#+13
   \      0x26C   0x4311             ORRS     R1,R2,R1
   \      0x26E   0x6101             STR      R1,[R0, #+16]
    811                USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
   \      0x270   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x274   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x278   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \      0x27C   0xF511 0x6130      ADDS     R1,R1,#+2816
   \      0x280   0x6909             LDR      R1,[R1, #+16]
   \      0x282   0xF451 0x2100      ORRS     R1,R1,#0x80000
   \      0x286   0x6101             STR      R1,[R0, #+16]
   \      0x288   0xE029             B.N      ??USB_EPStartXfer_12
    812              }
    813              else
    814              {
    815                pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
   \                     ??USB_EPStartXfer_11: (+1)
   \      0x28A   0x6971             LDR      R1,[R6, #+20]
   \      0x28C   0x68B0             LDR      R0,[R6, #+8]
   \      0x28E   0x1841             ADDS     R1,R0,R1
   \      0x290   0x1E49             SUBS     R1,R1,#+1
   \      0x292   0x68B0             LDR      R0,[R6, #+8]
   \      0x294   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \      0x298   0x0004             MOVS     R4,R0
    816                USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
   \      0x29A   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x29E   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x2A2   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \      0x2A6   0xF511 0x6130      ADDS     R1,R1,#+2816
   \      0x2AA   0x6909             LDR      R1,[R1, #+16]
   \      0x2AC   0x0022             MOVS     R2,R4
   \      0x2AE   0xB292             UXTH     R2,R2
   \      0x2B0   0x.... 0x....      LDR.W    R3,??DataTable9_2
   \      0x2B4   0xEA13 0x43C2      ANDS     R3,R3,R2, LSL #+19
   \      0x2B8   0x4319             ORRS     R1,R3,R1
   \      0x2BA   0x6101             STR      R1,[R0, #+16]
    817                USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt);
   \      0x2BC   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \      0x2C0   0xF511 0x6130      ADDS     R1,R1,#+2816
   \      0x2C4   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x2C8   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x2CC   0x6902             LDR      R2,[R0, #+16]
   \      0x2CE   0x68B3             LDR      R3,[R6, #+8]
   \      0x2D0   0x0020             MOVS     R0,R4
   \      0x2D2   0xB280             UXTH     R0,R0
   \      0x2D4   0x4343             MULS     R3,R0,R3
   \      0x2D6   0x035B             LSLS     R3,R3,#+13
   \      0x2D8   0x0B5B             LSRS     R3,R3,#+13
   \      0x2DA   0x431A             ORRS     R2,R3,R2
   \      0x2DC   0x610A             STR      R2,[R1, #+16]
    818              }
    819          
    820              if (dma == 1U)
   \                     ??USB_EPStartXfer_12: (+1)
   \      0x2DE   0x0038             MOVS     R0,R7
   \      0x2E0   0xB2C0             UXTB     R0,R0
   \      0x2E2   0x2801             CMP      R0,#+1
   \      0x2E4   0xD108             BNE.N    ??USB_EPStartXfer_13
    821              {
    822                if ((uint32_t)ep->xfer_buff != 0U)
   \      0x2E6   0x68F0             LDR      R0,[R6, #+12]
   \      0x2E8   0x2800             CMP      R0,#+0
   \      0x2EA   0xD005             BEQ.N    ??USB_EPStartXfer_13
    823                {
    824                  USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
   \      0x2EC   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x2F0   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x2F4   0x68F1             LDR      R1,[R6, #+12]
   \      0x2F6   0x6141             STR      R1,[R0, #+20]
    825                }
    826              }
    827          
    828              if (ep->type == EP_TYPE_ISOC)
   \                     ??USB_EPStartXfer_13: (+1)
   \      0x2F8   0x78F0             LDRB     R0,[R6, #+3]
   \      0x2FA   0x2801             CMP      R0,#+1
   \      0x2FC   0xD11D             BNE.N    ??USB_EPStartXfer_14
    829              {
    830                if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
   \      0x2FE   0xF518 0x6000      ADDS     R0,R8,#+2048
   \      0x302   0x6880             LDR      R0,[R0, #+8]
   \      0x304   0x05C0             LSLS     R0,R0,#+23
   \      0x306   0xD40C             BMI.N    ??USB_EPStartXfer_15
    831                {
    832                  USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
   \      0x308   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x30C   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x310   0x6800             LDR      R0,[R0, #+0]
   \      0x312   0xF050 0x5000      ORRS     R0,R0,#0x20000000
   \      0x316   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \      0x31A   0xF511 0x6130      ADDS     R1,R1,#+2816
   \      0x31E   0x6008             STR      R0,[R1, #+0]
   \      0x320   0xE00B             B.N      ??USB_EPStartXfer_14
    833                }
    834                else
    835                {
    836                  USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
   \                     ??USB_EPStartXfer_15: (+1)
   \      0x322   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x326   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x32A   0x6800             LDR      R0,[R0, #+0]
   \      0x32C   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \      0x330   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \      0x334   0xF511 0x6130      ADDS     R1,R1,#+2816
   \      0x338   0x6008             STR      R0,[R1, #+0]
    837                }
    838              }
    839              /* EP enable */
    840              USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
   \                     ??USB_EPStartXfer_14: (+1)
   \      0x33A   0xEB18 0x1049      ADDS     R0,R8,R9, LSL #+5
   \      0x33E   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x342   0x6800             LDR      R0,[R0, #+0]
   \      0x344   0xF050 0x4004      ORRS     R0,R0,#0x84000000
   \      0x348   0xEB18 0x1149      ADDS     R1,R8,R9, LSL #+5
   \      0x34C   0xF511 0x6130      ADDS     R1,R1,#+2816
   \      0x350   0x6008             STR      R0,[R1, #+0]
    841            }
    842          
    843            return HAL_OK;
   \                     ??USB_EPStartXfer_7: (+1)
   \      0x352   0x2000             MOVS     R0,#+0
   \      0x354   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    844          }
    845          
    846          /**
    847            * @brief  USB_EP0StartXfer : setup and starts a transfer over the EP  0
    848            * @param  USBx  Selected device
    849            * @param  ep pointer to endpoint structure
    850            * @param  dma USB dma enabled or disabled
    851            *          This parameter can be one of these values:
    852            *           0 : DMA feature not used
    853            *           1 : DMA feature used
    854            * @retval HAL status
    855            */

   \                                 In section .text, align 2, keep-with-next
    856          HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
    857          {
   \                     USB_EP0StartXfer: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   \        0x2   0x0003             MOVS     R3,R0
    858            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x001C             MOVS     R4,R3
    859            uint32_t epnum = (uint32_t)ep->num;
   \        0x6   0x780D             LDRB     R5,[R1, #+0]
    860          
    861            /* IN endpoint */
    862            if (ep->is_in == 1U)
   \        0x8   0x7848             LDRB     R0,[R1, #+1]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xF040 0x8096      BNE.W    ??USB_EP0StartXfer_0
    863            {
    864              /* Zero Length Packet? */
    865              if (ep->xfer_len == 0U)
   \       0x10   0x6948             LDR      R0,[R1, #+20]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD124             BNE.N    ??USB_EP0StartXfer_1
    866              {
    867                USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
   \       0x16   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0x1A   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x1E   0xEB14 0x1645      ADDS     R6,R4,R5, LSL #+5
   \       0x22   0xF516 0x6610      ADDS     R6,R6,#+2304
   \       0x26   0x6936             LDR      R6,[R6, #+16]
   \       0x28   0xF36F 0x46DC      BFC      R6,#+19,#+10
   \       0x2C   0x6106             STR      R6,[R0, #+16]
    868                USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
   \       0x2E   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0x32   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x36   0xEB14 0x1645      ADDS     R6,R4,R5, LSL #+5
   \       0x3A   0xF516 0x6610      ADDS     R6,R6,#+2304
   \       0x3E   0x6936             LDR      R6,[R6, #+16]
   \       0x40   0xF456 0x2600      ORRS     R6,R6,#0x80000
   \       0x44   0x6106             STR      R6,[R0, #+16]
    869                USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
   \       0x46   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0x4A   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x4E   0xEB14 0x1645      ADDS     R6,R4,R5, LSL #+5
   \       0x52   0xF516 0x6610      ADDS     R6,R6,#+2304
   \       0x56   0x6936             LDR      R6,[R6, #+16]
   \       0x58   0x0CF6             LSRS     R6,R6,#+19
   \       0x5A   0x04F6             LSLS     R6,R6,#+19
   \       0x5C   0x6106             STR      R6,[R0, #+16]
   \       0x5E   0xE037             B.N      ??USB_EP0StartXfer_2
    870              }
    871              else
    872              {
    873                /* Program the transfer size and packet count
    874                * as follows: xfersize = N * maxpacket +
    875                * short_packet pktcnt = N + (short_packet
    876                * exist ? 1 : 0)
    877                */
    878                USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
   \                     ??USB_EP0StartXfer_1: (+1)
   \       0x60   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0x64   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x68   0xEB14 0x1645      ADDS     R6,R4,R5, LSL #+5
   \       0x6C   0xF516 0x6610      ADDS     R6,R6,#+2304
   \       0x70   0x6936             LDR      R6,[R6, #+16]
   \       0x72   0x0CF6             LSRS     R6,R6,#+19
   \       0x74   0x04F6             LSLS     R6,R6,#+19
   \       0x76   0x6106             STR      R6,[R0, #+16]
    879                USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
   \       0x78   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0x7C   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x80   0xEB14 0x1645      ADDS     R6,R4,R5, LSL #+5
   \       0x84   0xF516 0x6610      ADDS     R6,R6,#+2304
   \       0x88   0x6936             LDR      R6,[R6, #+16]
   \       0x8A   0xF36F 0x46DC      BFC      R6,#+19,#+10
   \       0x8E   0x6106             STR      R6,[R0, #+16]
    880          
    881                if (ep->xfer_len > ep->maxpacket)
   \       0x90   0x6888             LDR      R0,[R1, #+8]
   \       0x92   0x694E             LDR      R6,[R1, #+20]
   \       0x94   0x42B0             CMP      R0,R6
   \       0x96   0xD201             BCS.N    ??USB_EP0StartXfer_3
    882                {
    883                  ep->xfer_len = ep->maxpacket;
   \       0x98   0x6888             LDR      R0,[R1, #+8]
   \       0x9A   0x6148             STR      R0,[R1, #+20]
    884                }
    885                USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
   \                     ??USB_EP0StartXfer_3: (+1)
   \       0x9C   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0xA0   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0xA4   0xEB14 0x1645      ADDS     R6,R4,R5, LSL #+5
   \       0xA8   0xF516 0x6610      ADDS     R6,R6,#+2304
   \       0xAC   0x6936             LDR      R6,[R6, #+16]
   \       0xAE   0xF456 0x2600      ORRS     R6,R6,#0x80000
   \       0xB2   0x6106             STR      R6,[R0, #+16]
    886                USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
   \       0xB4   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0xB8   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0xBC   0xEB14 0x1645      ADDS     R6,R4,R5, LSL #+5
   \       0xC0   0xF516 0x6610      ADDS     R6,R6,#+2304
   \       0xC4   0x6936             LDR      R6,[R6, #+16]
   \       0xC6   0x694F             LDR      R7,[R1, #+20]
   \       0xC8   0x037F             LSLS     R7,R7,#+13
   \       0xCA   0x0B7F             LSRS     R7,R7,#+13
   \       0xCC   0x433E             ORRS     R6,R7,R6
   \       0xCE   0x6106             STR      R6,[R0, #+16]
    887              }
    888          
    889              if (dma == 1U)
   \                     ??USB_EP0StartXfer_2: (+1)
   \       0xD0   0x0010             MOVS     R0,R2
   \       0xD2   0xB2C0             UXTB     R0,R0
   \       0xD4   0x2801             CMP      R0,#+1
   \       0xD6   0xD115             BNE.N    ??USB_EP0StartXfer_4
    890              {
    891                if ((uint32_t)ep->dma_addr != 0U)
   \       0xD8   0x6908             LDR      R0,[R1, #+16]
   \       0xDA   0x2800             CMP      R0,#+0
   \       0xDC   0xD005             BEQ.N    ??USB_EP0StartXfer_5
    892                {
    893                  USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
   \       0xDE   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0xE2   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0xE6   0x690E             LDR      R6,[R1, #+16]
   \       0xE8   0x6146             STR      R6,[R0, #+20]
    894                }
    895          
    896                /* EP enable, IN data in FIFO */
    897                USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
   \                     ??USB_EP0StartXfer_5: (+1)
   \       0xEA   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0xEE   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0xF2   0x6800             LDR      R0,[R0, #+0]
   \       0xF4   0xF050 0x4004      ORRS     R0,R0,#0x84000000
   \       0xF8   0xEB14 0x1645      ADDS     R6,R4,R5, LSL #+5
   \       0xFC   0xF516 0x6610      ADDS     R6,R6,#+2304
   \      0x100   0x6030             STR      R0,[R6, #+0]
   \      0x102   0xE06B             B.N      ??USB_EP0StartXfer_6
    898              }
    899              else
    900              {
    901                /* EP enable, IN data in FIFO */
    902                USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
   \                     ??USB_EP0StartXfer_4: (+1)
   \      0x104   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \      0x108   0xF510 0x6010      ADDS     R0,R0,#+2304
   \      0x10C   0x6800             LDR      R0,[R0, #+0]
   \      0x10E   0xF050 0x4004      ORRS     R0,R0,#0x84000000
   \      0x112   0xEB14 0x1645      ADDS     R6,R4,R5, LSL #+5
   \      0x116   0xF516 0x6610      ADDS     R6,R6,#+2304
   \      0x11A   0x6030             STR      R0,[R6, #+0]
    903          
    904                /* Enable the Tx FIFO Empty Interrupt for this EP */
    905                if (ep->xfer_len > 0U)
   \      0x11C   0x6948             LDR      R0,[R1, #+20]
   \      0x11E   0x2800             CMP      R0,#+0
   \      0x120   0xD05C             BEQ.N    ??USB_EP0StartXfer_6
    906                {
    907                  USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
   \      0x122   0xF514 0x6000      ADDS     R0,R4,#+2048
   \      0x126   0x6B40             LDR      R0,[R0, #+52]
   \      0x128   0x2601             MOVS     R6,#+1
   \      0x12A   0x780F             LDRB     R7,[R1, #+0]
   \      0x12C   0xF017 0x070F      ANDS     R7,R7,#0xF
   \      0x130   0x40BE             LSLS     R6,R6,R7
   \      0x132   0x4330             ORRS     R0,R6,R0
   \      0x134   0xF514 0x6600      ADDS     R6,R4,#+2048
   \      0x138   0x6370             STR      R0,[R6, #+52]
   \      0x13A   0xE04F             B.N      ??USB_EP0StartXfer_6
    908                }
    909              }
    910            }
    911            else /* OUT endpoint */
    912            {
    913              /* Program the transfer size and packet count as follows:
    914              * pktcnt = N
    915              * xfersize = N * maxpacket
    916              */
    917              USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
   \                     ??USB_EP0StartXfer_0: (+1)
   \      0x13C   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \      0x140   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x144   0xEB14 0x1645      ADDS     R6,R4,R5, LSL #+5
   \      0x148   0xF516 0x6630      ADDS     R6,R6,#+2816
   \      0x14C   0x6936             LDR      R6,[R6, #+16]
   \      0x14E   0x0CF6             LSRS     R6,R6,#+19
   \      0x150   0x04F6             LSLS     R6,R6,#+19
   \      0x152   0x6106             STR      R6,[R0, #+16]
    918              USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
   \      0x154   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \      0x158   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x15C   0xEB14 0x1645      ADDS     R6,R4,R5, LSL #+5
   \      0x160   0xF516 0x6630      ADDS     R6,R6,#+2816
   \      0x164   0x6936             LDR      R6,[R6, #+16]
   \      0x166   0xF36F 0x46DC      BFC      R6,#+19,#+10
   \      0x16A   0x6106             STR      R6,[R0, #+16]
    919          
    920              if (ep->xfer_len > 0U)
   \      0x16C   0x6948             LDR      R0,[R1, #+20]
   \      0x16E   0x2800             CMP      R0,#+0
   \      0x170   0xD001             BEQ.N    ??USB_EP0StartXfer_7
    921              {
    922                ep->xfer_len = ep->maxpacket;
   \      0x172   0x6888             LDR      R0,[R1, #+8]
   \      0x174   0x6148             STR      R0,[R1, #+20]
    923              }
    924          
    925              USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
   \                     ??USB_EP0StartXfer_7: (+1)
   \      0x176   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \      0x17A   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x17E   0xEB14 0x1645      ADDS     R6,R4,R5, LSL #+5
   \      0x182   0xF516 0x6630      ADDS     R6,R6,#+2816
   \      0x186   0x6936             LDR      R6,[R6, #+16]
   \      0x188   0xF456 0x2600      ORRS     R6,R6,#0x80000
   \      0x18C   0x6106             STR      R6,[R0, #+16]
    926              USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket));
   \      0x18E   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \      0x192   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x196   0xEB14 0x1645      ADDS     R6,R4,R5, LSL #+5
   \      0x19A   0xF516 0x6630      ADDS     R6,R6,#+2816
   \      0x19E   0x6936             LDR      R6,[R6, #+16]
   \      0x1A0   0x688F             LDR      R7,[R1, #+8]
   \      0x1A2   0x037F             LSLS     R7,R7,#+13
   \      0x1A4   0x0B7F             LSRS     R7,R7,#+13
   \      0x1A6   0x433E             ORRS     R6,R7,R6
   \      0x1A8   0x6106             STR      R6,[R0, #+16]
    927          
    928              if (dma == 1U)
   \      0x1AA   0x0010             MOVS     R0,R2
   \      0x1AC   0xB2C0             UXTB     R0,R0
   \      0x1AE   0x2801             CMP      R0,#+1
   \      0x1B0   0xD108             BNE.N    ??USB_EP0StartXfer_8
    929              {
    930                if ((uint32_t)ep->xfer_buff != 0U)
   \      0x1B2   0x68C8             LDR      R0,[R1, #+12]
   \      0x1B4   0x2800             CMP      R0,#+0
   \      0x1B6   0xD005             BEQ.N    ??USB_EP0StartXfer_8
    931                {
    932                  USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
   \      0x1B8   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \      0x1BC   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x1C0   0x68CE             LDR      R6,[R1, #+12]
   \      0x1C2   0x6146             STR      R6,[R0, #+20]
    933                }
    934              }
    935          
    936              /* EP enable */
    937              USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
   \                     ??USB_EP0StartXfer_8: (+1)
   \      0x1C4   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \      0x1C8   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x1CC   0x6800             LDR      R0,[R0, #+0]
   \      0x1CE   0xF050 0x4004      ORRS     R0,R0,#0x84000000
   \      0x1D2   0xEB14 0x1645      ADDS     R6,R4,R5, LSL #+5
   \      0x1D6   0xF516 0x6630      ADDS     R6,R6,#+2816
   \      0x1DA   0x6030             STR      R0,[R6, #+0]
    938            }
    939          
    940            return HAL_OK;
   \                     ??USB_EP0StartXfer_6: (+1)
   \      0x1DC   0x2000             MOVS     R0,#+0
   \      0x1DE   0xBCF0             POP      {R4-R7}
   \      0x1E0   0x4770             BX       LR
    941          }
    942          
    943          /**
    944            * @brief  USB_WritePacket : Writes a packet into the Tx FIFO associated
    945            *         with the EP/channel
    946            * @param  USBx  Selected device
    947            * @param  src   pointer to source buffer
    948            * @param  ch_ep_num  endpoint or host channel number
    949            * @param  len  Number of bytes to write
    950            * @param  dma USB dma enabled or disabled
    951            *          This parameter can be one of these values:
    952            *           0 : DMA feature not used
    953            *           1 : DMA feature used
    954            * @retval HAL status
    955            */

   \                                 In section .text, align 2, keep-with-next
    956          HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src,
    957                                            uint8_t ch_ep_num, uint16_t len, uint8_t dma)
    958          {
   \                     USB_WritePacket: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x9C06             LDR      R4,[SP, #+24]
    959            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x8   0x46BC             MOV      R12,R7
    960            uint32_t *pSrc = (uint32_t *)src;
   \        0xA   0x468E             MOV      LR,R1
    961            uint32_t count32b, i;
    962          
    963            if (dma == 0U)
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0xB2C0             UXTB     R0,R0
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD117             BNE.N    ??USB_WritePacket_0
    964            {
    965              count32b = ((uint32_t)len + 3U) / 4U;
   \       0x14   0x0018             MOVS     R0,R3
   \       0x16   0xB280             UXTH     R0,R0
   \       0x18   0x1CC0             ADDS     R0,R0,#+3
   \       0x1A   0x0880             LSRS     R0,R0,#+2
   \       0x1C   0x0005             MOVS     R5,R0
    966              for (i = 0U; i < count32b; i++)
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x0006             MOVS     R6,R0
   \                     ??USB_WritePacket_1: (+1)
   \       0x22   0x42AE             CMP      R6,R5
   \       0x24   0xD20E             BCS.N    ??USB_WritePacket_0
    967              {
    968                USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
   \       0x26   0x4670             MOV      R0,LR
   \       0x28   0xF8D0 0x8000      LDR      R8,[R0, #+0]
   \       0x2C   0x0010             MOVS     R0,R2
   \       0x2E   0xB2C0             UXTB     R0,R0
   \       0x30   0xEB1C 0x3000      ADDS     R0,R12,R0, LSL #+12
   \       0x34   0xF510 0x5080      ADDS     R0,R0,#+4096
   \       0x38   0xF8C0 0x8000      STR      R8,[R0, #+0]
    969                pSrc++;
   \       0x3C   0xF11E 0x0E04      ADDS     LR,LR,#+4
    970              }
   \       0x40   0x1C76             ADDS     R6,R6,#+1
   \       0x42   0xE7EE             B.N      ??USB_WritePacket_1
    971            }
    972          
    973            return HAL_OK;
   \                     ??USB_WritePacket_0: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xE8BD 0x81F0      POP      {R4-R8,PC}
    974          }
    975          
    976          /**
    977            * @brief  USB_ReadPacket : read a packet from the RX FIFO
    978            * @param  USBx  Selected device
    979            * @param  dest  source pointer
    980            * @param  len  Number of bytes to read
    981            * @retval pointer to destination buffer
    982            */

   \                                 In section .text, align 2, keep-with-next
    983          void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
    984          {
   \                     USB_ReadPacket: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   \        0x2   0x0003             MOVS     R3,R0
    985            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x001C             MOVS     R4,R3
    986            uint32_t *pDest = (uint32_t *)dest;
   \        0x6   0x0008             MOVS     R0,R1
    987            uint32_t i;
    988            uint32_t count32b = ((uint32_t)len + 3U) / 4U;
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0xB2B6             UXTH     R6,R6
   \        0xC   0x1CF6             ADDS     R6,R6,#+3
   \        0xE   0x08B6             LSRS     R6,R6,#+2
    989          
    990            for (i = 0U; i < count32b; i++)
   \       0x10   0x2500             MOVS     R5,#+0
   \                     ??USB_ReadPacket_0: (+1)
   \       0x12   0x42B5             CMP      R5,R6
   \       0x14   0xD208             BCS.N    ??USB_ReadPacket_1
    991            {
    992              __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
   \       0x16   0xF514 0x5780      ADDS     R7,R4,#+4096
   \       0x1A   0x683F             LDR      R7,[R7, #+0]
   \       0x1C   0x4684             MOV      R12,R0
   \       0x1E   0xF8CC 0x7000      STR      R7,[R12, #+0]
    993              pDest++;
   \       0x22   0x1D00             ADDS     R0,R0,#+4
    994            }
   \       0x24   0x1C6D             ADDS     R5,R5,#+1
   \       0x26   0xE7F4             B.N      ??USB_ReadPacket_0
    995          
    996            return ((void *)pDest);
   \                     ??USB_ReadPacket_1: (+1)
   \       0x28   0xBCF0             POP      {R4-R7}
   \       0x2A   0x4770             BX       LR
    997          }
    998          
    999          /**
   1000            * @brief  USB_EPSetStall : set a stall condition over an EP
   1001            * @param  USBx  Selected device
   1002            * @param  ep pointer to endpoint structure
   1003            * @retval HAL status
   1004            */

   \                                 In section .text, align 2, keep-with-next
   1005          HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
   1006          {
   \                     USB_EPSetStall: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x0003             MOVS     R3,R0
   \        0x4   0x000A             MOVS     R2,R1
   1007            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x6   0x001C             MOVS     R4,R3
   1008            uint32_t epnum = (uint32_t)ep->num;
   \        0x8   0x7811             LDRB     R1,[R2, #+0]
   1009          
   1010            if (ep->is_in == 1U)
   \        0xA   0x7850             LDRB     R0,[R2, #+1]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD121             BNE.N    ??USB_EPSetStall_0
   1011            {
   1012              if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
   \       0x10   0xEB14 0x1041      ADDS     R0,R4,R1, LSL #+5
   \       0x14   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD40D             BMI.N    ??USB_EPSetStall_1
   \       0x1E   0x2900             CMP      R1,#+0
   \       0x20   0xD00B             BEQ.N    ??USB_EPSetStall_1
   1013              {
   1014                USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
   \       0x22   0xEB14 0x1041      ADDS     R0,R4,R1, LSL #+5
   \       0x26   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0xF030 0x4080      BICS     R0,R0,#0x40000000
   \       0x30   0xEB14 0x1541      ADDS     R5,R4,R1, LSL #+5
   \       0x34   0xF515 0x6510      ADDS     R5,R5,#+2304
   \       0x38   0x6028             STR      R0,[R5, #+0]
   1015              }
   1016              USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
   \                     ??USB_EPSetStall_1: (+1)
   \       0x3A   0xEB14 0x1041      ADDS     R0,R4,R1, LSL #+5
   \       0x3E   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x42   0x6800             LDR      R0,[R0, #+0]
   \       0x44   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \       0x48   0xEB14 0x1541      ADDS     R5,R4,R1, LSL #+5
   \       0x4C   0xF515 0x6510      ADDS     R5,R5,#+2304
   \       0x50   0x6028             STR      R0,[R5, #+0]
   \       0x52   0xE020             B.N      ??USB_EPSetStall_2
   1017            }
   1018            else
   1019            {
   1020              if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
   \                     ??USB_EPSetStall_0: (+1)
   \       0x54   0xEB14 0x1041      ADDS     R0,R4,R1, LSL #+5
   \       0x58   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x5C   0x6800             LDR      R0,[R0, #+0]
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD40D             BMI.N    ??USB_EPSetStall_3
   \       0x62   0x2900             CMP      R1,#+0
   \       0x64   0xD00B             BEQ.N    ??USB_EPSetStall_3
   1021              {
   1022                USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
   \       0x66   0xEB14 0x1041      ADDS     R0,R4,R1, LSL #+5
   \       0x6A   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x6E   0x6800             LDR      R0,[R0, #+0]
   \       0x70   0xF030 0x4080      BICS     R0,R0,#0x40000000
   \       0x74   0xEB14 0x1541      ADDS     R5,R4,R1, LSL #+5
   \       0x78   0xF515 0x6530      ADDS     R5,R5,#+2816
   \       0x7C   0x6028             STR      R0,[R5, #+0]
   1023              }
   1024              USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
   \                     ??USB_EPSetStall_3: (+1)
   \       0x7E   0xEB14 0x1041      ADDS     R0,R4,R1, LSL #+5
   \       0x82   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x86   0x6800             LDR      R0,[R0, #+0]
   \       0x88   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \       0x8C   0xEB14 0x1541      ADDS     R5,R4,R1, LSL #+5
   \       0x90   0xF515 0x6530      ADDS     R5,R5,#+2816
   \       0x94   0x6028             STR      R0,[R5, #+0]
   1025            }
   1026          
   1027            return HAL_OK;
   \                     ??USB_EPSetStall_2: (+1)
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0xBC30             POP      {R4,R5}
   \       0x9A   0x4770             BX       LR
   1028          }
   1029          
   1030          /**
   1031            * @brief  USB_EPClearStall : Clear a stall condition over an EP
   1032            * @param  USBx  Selected device
   1033            * @param  ep pointer to endpoint structure
   1034            * @retval HAL status
   1035            */

   \                                 In section .text, align 2, keep-with-next
   1036          HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
   1037          {
   \                     USB_EPClearStall: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x0002             MOVS     R2,R0
   1038            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x0013             MOVS     R3,R2
   1039            uint32_t epnum = (uint32_t)ep->num;
   \        0x6   0x780C             LDRB     R4,[R1, #+0]
   1040          
   1041            if (ep->is_in == 1U)
   \        0x8   0x7848             LDRB     R0,[R1, #+1]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD11E             BNE.N    ??USB_EPClearStall_0
   1042            {
   1043              USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
   \        0xE   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x12   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0xF430 0x1000      BICS     R0,R0,#0x200000
   \       0x1C   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0x20   0xF515 0x6510      ADDS     R5,R5,#+2304
   \       0x24   0x6028             STR      R0,[R5, #+0]
   1044              if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
   \       0x26   0x78C8             LDRB     R0,[R1, #+3]
   \       0x28   0x2803             CMP      R0,#+3
   \       0x2A   0xD002             BEQ.N    ??USB_EPClearStall_1
   \       0x2C   0x78C8             LDRB     R0,[R1, #+3]
   \       0x2E   0x2802             CMP      R0,#+2
   \       0x30   0xD12A             BNE.N    ??USB_EPClearStall_2
   1045              {
   1046                USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
   \                     ??USB_EPClearStall_1: (+1)
   \       0x32   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x36   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x3A   0x6800             LDR      R0,[R0, #+0]
   \       0x3C   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \       0x40   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0x44   0xF515 0x6510      ADDS     R5,R5,#+2304
   \       0x48   0x6028             STR      R0,[R5, #+0]
   \       0x4A   0xE01D             B.N      ??USB_EPClearStall_2
   1047              }
   1048            }
   1049            else
   1050            {
   1051              USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
   \                     ??USB_EPClearStall_0: (+1)
   \       0x4C   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x50   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x54   0x6800             LDR      R0,[R0, #+0]
   \       0x56   0xF430 0x1000      BICS     R0,R0,#0x200000
   \       0x5A   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0x5E   0xF515 0x6530      ADDS     R5,R5,#+2816
   \       0x62   0x6028             STR      R0,[R5, #+0]
   1052              if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
   \       0x64   0x78C8             LDRB     R0,[R1, #+3]
   \       0x66   0x2803             CMP      R0,#+3
   \       0x68   0xD002             BEQ.N    ??USB_EPClearStall_3
   \       0x6A   0x78C8             LDRB     R0,[R1, #+3]
   \       0x6C   0x2802             CMP      R0,#+2
   \       0x6E   0xD10B             BNE.N    ??USB_EPClearStall_2
   1053              {
   1054                USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
   \                     ??USB_EPClearStall_3: (+1)
   \       0x70   0xEB13 0x1044      ADDS     R0,R3,R4, LSL #+5
   \       0x74   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x78   0x6800             LDR      R0,[R0, #+0]
   \       0x7A   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \       0x7E   0xEB13 0x1544      ADDS     R5,R3,R4, LSL #+5
   \       0x82   0xF515 0x6530      ADDS     R5,R5,#+2816
   \       0x86   0x6028             STR      R0,[R5, #+0]
   1055              }
   1056            }
   1057            return HAL_OK;
   \                     ??USB_EPClearStall_2: (+1)
   \       0x88   0x2000             MOVS     R0,#+0
   \       0x8A   0xBC30             POP      {R4,R5}
   \       0x8C   0x4770             BX       LR
   1058          }
   1059          
   1060          /**
   1061            * @brief  USB_StopDevice : Stop the usb device mode
   1062            * @param  USBx  Selected device
   1063            * @retval HAL status
   1064            */

   \                                 In section .text, align 2, keep-with-next
   1065          HAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx)
   1066          {
   \                     USB_StopDevice: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1067            HAL_StatusTypeDef ret;
   1068            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x0025             MOVS     R5,R4
   1069            uint32_t i;
   1070          
   1071            /* Clear Pending interrupt */
   1072            for (i = 0U; i < 15U; i++)
   \        0x6   0x2600             MOVS     R6,#+0
   \                     ??USB_StopDevice_0: (+1)
   \        0x8   0x2E0F             CMP      R6,#+15
   \        0xA   0xD20D             BCS.N    ??USB_StopDevice_1
   1073            {
   1074              USBx_INEP(i)->DIEPINT = 0xFB7FU;
   \        0xC   0xF64F 0x307F      MOVW     R0,#+64383
   \       0x10   0xEB15 0x1146      ADDS     R1,R5,R6, LSL #+5
   \       0x14   0xF511 0x6110      ADDS     R1,R1,#+2304
   \       0x18   0x6088             STR      R0,[R1, #+8]
   1075              USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
   \       0x1A   0xEB15 0x1146      ADDS     R1,R5,R6, LSL #+5
   \       0x1E   0xF511 0x6130      ADDS     R1,R1,#+2816
   \       0x22   0x6088             STR      R0,[R1, #+8]
   1076            }
   \       0x24   0x1C76             ADDS     R6,R6,#+1
   \       0x26   0xE7EF             B.N      ??USB_StopDevice_0
   1077          
   1078            /* Clear interrupt masks */
   1079            USBx_DEVICE->DIEPMSK  = 0U;
   \                     ??USB_StopDevice_1: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xF515 0x6100      ADDS     R1,R5,#+2048
   \       0x2E   0x6108             STR      R0,[R1, #+16]
   1080            USBx_DEVICE->DOEPMSK  = 0U;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xF515 0x6100      ADDS     R1,R5,#+2048
   \       0x36   0x6148             STR      R0,[R1, #+20]
   1081            USBx_DEVICE->DAINTMSK = 0U;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xF515 0x6100      ADDS     R1,R5,#+2048
   \       0x3E   0x61C8             STR      R0,[R1, #+28]
   1082          
   1083            /* Flush the FIFO */
   1084            ret = USB_FlushRxFifo(USBx);
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0x.... 0x....      BL       USB_FlushRxFifo
   \       0x46   0x0007             MOVS     R7,R0
   1085            if (ret != HAL_OK)
   \       0x48   0x0038             MOVS     R0,R7
   \       0x4A   0xB2C0             UXTB     R0,R0
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD002             BEQ.N    ??USB_StopDevice_2
   1086            {
   1087              return ret;
   \       0x50   0x0038             MOVS     R0,R7
   \       0x52   0xB2C0             UXTB     R0,R0
   \       0x54   0xE00A             B.N      ??USB_StopDevice_3
   1088            }
   1089          
   1090            ret = USB_FlushTxFifo(USBx,  0x10U);
   \                     ??USB_StopDevice_2: (+1)
   \       0x56   0x2110             MOVS     R1,#+16
   \       0x58   0x0020             MOVS     R0,R4
   \       0x5A   0x.... 0x....      BL       USB_FlushTxFifo
   1091            if (ret != HAL_OK)
   \       0x5E   0x0001             MOVS     R1,R0
   \       0x60   0xB2C9             UXTB     R1,R1
   \       0x62   0x2900             CMP      R1,#+0
   \       0x64   0xD001             BEQ.N    ??USB_StopDevice_4
   1092            {
   1093              return ret;
   \       0x66   0xB2C0             UXTB     R0,R0
   \       0x68   0xE000             B.N      ??USB_StopDevice_3
   1094            }
   1095          
   1096            return ret;
   \                     ??USB_StopDevice_4: (+1)
   \       0x6A   0xB2C0             UXTB     R0,R0
   \                     ??USB_StopDevice_3: (+1)
   \       0x6C   0xBDF2             POP      {R1,R4-R7,PC}
   1097          }
   1098          
   1099          /**
   1100            * @brief  USB_SetDevAddress : Stop the usb device mode
   1101            * @param  USBx  Selected device
   1102            * @param  address  new device address to be assigned
   1103            *          This parameter can be a value from 0 to 255
   1104            * @retval HAL status
   1105            */

   \                                 In section .text, align 2, keep-with-next
   1106          HAL_StatusTypeDef  USB_SetDevAddress(USB_OTG_GlobalTypeDef *USBx, uint8_t address)
   1107          {
   \                     USB_SetDevAddress: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0002             MOVS     R2,R0
   1108            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x0013             MOVS     R3,R2
   1109          
   1110            USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
   \        0x6   0xF513 0x6000      ADDS     R0,R3,#+2048
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0xF430 0x60FE      BICS     R0,R0,#0x7F0
   \       0x10   0xF513 0x6400      ADDS     R4,R3,#+2048
   \       0x14   0x6020             STR      R0,[R4, #+0]
   1111            USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
   \       0x16   0xF513 0x6000      ADDS     R0,R3,#+2048
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0x000C             MOVS     R4,R1
   \       0x1E   0xB2E4             UXTB     R4,R4
   \       0x20   0x0124             LSLS     R4,R4,#+4
   \       0x22   0xF414 0x64FE      ANDS     R4,R4,#0x7F0
   \       0x26   0x4320             ORRS     R0,R4,R0
   \       0x28   0xF513 0x6400      ADDS     R4,R3,#+2048
   \       0x2C   0x6020             STR      R0,[R4, #+0]
   1112          
   1113            return HAL_OK;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xBC10             POP      {R4}
   \       0x32   0x4770             BX       LR
   1114          }
   1115          
   1116          /**
   1117            * @brief  USB_DevConnect : Connect the USB device by enabling Rpu
   1118            * @param  USBx  Selected device
   1119            * @retval HAL status
   1120            */

   \                                 In section .text, align 2, keep-with-next
   1121          HAL_StatusTypeDef  USB_DevConnect(USB_OTG_GlobalTypeDef *USBx)
   1122          {
   \                     USB_DevConnect: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   1123            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x2   0x000A             MOVS     R2,R1
   1124          
   1125            /* In case phy is stopped, ensure to ungate and restore the phy CLK */
   1126            USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
   \        0x4   0xF512 0x6060      ADDS     R0,R2,#+3584
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0x0880             LSRS     R0,R0,#+2
   \        0xC   0x0080             LSLS     R0,R0,#+2
   \        0xE   0xF512 0x6360      ADDS     R3,R2,#+3584
   \       0x12   0x6018             STR      R0,[R3, #+0]
   1127          
   1128            USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
   \       0x14   0xF512 0x6000      ADDS     R0,R2,#+2048
   \       0x18   0x6840             LDR      R0,[R0, #+4]
   \       0x1A   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x1E   0xF512 0x6300      ADDS     R3,R2,#+2048
   \       0x22   0x6058             STR      R0,[R3, #+4]
   1129          
   1130            return HAL_OK;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x4770             BX       LR
   1131          }
   1132          
   1133          /**
   1134            * @brief  USB_DevDisconnect : Disconnect the USB device by disabling Rpu
   1135            * @param  USBx  Selected device
   1136            * @retval HAL status
   1137            */

   \                                 In section .text, align 2, keep-with-next
   1138          HAL_StatusTypeDef  USB_DevDisconnect(USB_OTG_GlobalTypeDef *USBx)
   1139          {
   \                     USB_DevDisconnect: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   1140            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x2   0x000A             MOVS     R2,R1
   1141          
   1142            /* In case phy is stopped, ensure to ungate and restore the phy CLK */
   1143            USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
   \        0x4   0xF512 0x6060      ADDS     R0,R2,#+3584
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0x0880             LSRS     R0,R0,#+2
   \        0xC   0x0080             LSLS     R0,R0,#+2
   \        0xE   0xF512 0x6360      ADDS     R3,R2,#+3584
   \       0x12   0x6018             STR      R0,[R3, #+0]
   1144          
   1145            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
   \       0x14   0xF512 0x6000      ADDS     R0,R2,#+2048
   \       0x18   0x6840             LDR      R0,[R0, #+4]
   \       0x1A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x1E   0xF512 0x6300      ADDS     R3,R2,#+2048
   \       0x22   0x6058             STR      R0,[R3, #+4]
   1146          
   1147            return HAL_OK;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x4770             BX       LR
   1148          }
   1149          
   1150          /**
   1151            * @brief  USB_ReadInterrupts: return the global USB interrupt status
   1152            * @param  USBx  Selected device
   1153            * @retval HAL status
   1154            */

   \                                 In section .text, align 2, keep-with-next
   1155          uint32_t  USB_ReadInterrupts(USB_OTG_GlobalTypeDef *USBx)
   1156          {
   \                     USB_ReadInterrupts: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   1157            uint32_t tmpreg;
   1158          
   1159            tmpreg = USBx->GINTSTS;
   \        0x2   0x6950             LDR      R0,[R2, #+20]
   1160            tmpreg &= USBx->GINTMSK;
   \        0x4   0x6991             LDR      R1,[R2, #+24]
   \        0x6   0x4008             ANDS     R0,R1,R0
   1161          
   1162            return tmpreg;
   \        0x8   0x4770             BX       LR
   1163          }
   1164          
   1165          /**
   1166            * @brief  USB_ReadDevAllOutEpInterrupt: return the USB device OUT endpoints interrupt status
   1167            * @param  USBx  Selected device
   1168            * @retval HAL status
   1169            */

   \                                 In section .text, align 2, keep-with-next
   1170          uint32_t USB_ReadDevAllOutEpInterrupt(USB_OTG_GlobalTypeDef *USBx)
   1171          {
   \                     USB_ReadDevAllOutEpInterrupt: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   1172            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x2   0x0013             MOVS     R3,R2
   1173            uint32_t tmpreg;
   1174          
   1175            tmpreg  = USBx_DEVICE->DAINT;
   \        0x4   0xF513 0x6000      ADDS     R0,R3,#+2048
   \        0x8   0x6980             LDR      R0,[R0, #+24]
   1176            tmpreg &= USBx_DEVICE->DAINTMSK;
   \        0xA   0xF513 0x6100      ADDS     R1,R3,#+2048
   \        0xE   0x69C9             LDR      R1,[R1, #+28]
   \       0x10   0x4008             ANDS     R0,R1,R0
   1177          
   1178            return ((tmpreg & 0xffff0000U) >> 16);
   \       0x12   0x0C00             LSRS     R0,R0,#+16
   \       0x14   0x4770             BX       LR
   1179          }
   1180          
   1181          /**
   1182            * @brief  USB_ReadDevAllInEpInterrupt: return the USB device IN endpoints interrupt status
   1183            * @param  USBx  Selected device
   1184            * @retval HAL status
   1185            */

   \                                 In section .text, align 2, keep-with-next
   1186          uint32_t USB_ReadDevAllInEpInterrupt(USB_OTG_GlobalTypeDef *USBx)
   1187          {
   \                     USB_ReadDevAllInEpInterrupt: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   1188            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x2   0x0013             MOVS     R3,R2
   1189            uint32_t tmpreg;
   1190          
   1191            tmpreg  = USBx_DEVICE->DAINT;
   \        0x4   0xF513 0x6000      ADDS     R0,R3,#+2048
   \        0x8   0x6980             LDR      R0,[R0, #+24]
   1192            tmpreg &= USBx_DEVICE->DAINTMSK;
   \        0xA   0xF513 0x6100      ADDS     R1,R3,#+2048
   \        0xE   0x69C9             LDR      R1,[R1, #+28]
   \       0x10   0x4008             ANDS     R0,R1,R0
   1193          
   1194            return ((tmpreg & 0xFFFFU));
   \       0x12   0xB280             UXTH     R0,R0
   \       0x14   0x4770             BX       LR
   1195          }
   1196          
   1197          /**
   1198            * @brief  Returns Device OUT EP Interrupt register
   1199            * @param  USBx  Selected device
   1200            * @param  epnum  endpoint number
   1201            *          This parameter can be a value from 0 to 15
   1202            * @retval Device OUT EP Interrupt register
   1203            */

   \                                 In section .text, align 2, keep-with-next
   1204          uint32_t USB_ReadDevOutEPInterrupt(USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
   1205          {
   \                     USB_ReadDevOutEPInterrupt: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0003             MOVS     R3,R0
   1206            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x001C             MOVS     R4,R3
   1207            uint32_t tmpreg;
   1208          
   1209            tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
   \        0x6   0x0008             MOVS     R0,R1
   \        0x8   0xB2C0             UXTB     R0,R0
   \        0xA   0xEB14 0x1040      ADDS     R0,R4,R0, LSL #+5
   \        0xE   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x12   0x6880             LDR      R0,[R0, #+8]
   1210            tmpreg &= USBx_DEVICE->DOEPMSK;
   \       0x14   0xF514 0x6200      ADDS     R2,R4,#+2048
   \       0x18   0x6952             LDR      R2,[R2, #+20]
   \       0x1A   0x4010             ANDS     R0,R2,R0
   1211          
   1212            return tmpreg;
   \       0x1C   0xBC10             POP      {R4}
   \       0x1E   0x4770             BX       LR
   1213          }
   1214          
   1215          /**
   1216            * @brief  Returns Device IN EP Interrupt register
   1217            * @param  USBx  Selected device
   1218            * @param  epnum  endpoint number
   1219            *          This parameter can be a value from 0 to 15
   1220            * @retval Device IN EP Interrupt register
   1221            */

   \                                 In section .text, align 2, keep-with-next
   1222          uint32_t USB_ReadDevInEPInterrupt(USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
   1223          {
   \                     USB_ReadDevInEPInterrupt: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x0002             MOVS     R2,R0
   1224            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x0013             MOVS     R3,R2
   1225            uint32_t tmpreg, msk, emp;
   1226          
   1227            msk = USBx_DEVICE->DIEPMSK;
   \        0x6   0xF513 0x6000      ADDS     R0,R3,#+2048
   \        0xA   0x6904             LDR      R4,[R0, #+16]
   1228            emp = USBx_DEVICE->DIEPEMPMSK;
   \        0xC   0xF513 0x6000      ADDS     R0,R3,#+2048
   \       0x10   0x6B45             LDR      R5,[R0, #+52]
   1229            msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
   \       0x12   0xF011 0x000F      ANDS     R0,R1,#0xF
   \       0x16   0x002E             MOVS     R6,R5
   \       0x18   0x40C6             LSRS     R6,R6,R0
   \       0x1A   0x01F6             LSLS     R6,R6,#+7
   \       0x1C   0xF016 0x0680      ANDS     R6,R6,#0x80
   \       0x20   0x4334             ORRS     R4,R6,R4
   1230            tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
   \       0x22   0x0008             MOVS     R0,R1
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0xEB13 0x1040      ADDS     R0,R3,R0, LSL #+5
   \       0x2A   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x2E   0x6880             LDR      R0,[R0, #+8]
   \       0x30   0x4020             ANDS     R0,R4,R0
   1231          
   1232            return tmpreg;
   \       0x32   0xBC70             POP      {R4-R6}
   \       0x34   0x4770             BX       LR
   1233          }
   1234          
   1235          /**
   1236            * @brief  USB_ClearInterrupts: clear a USB interrupt
   1237            * @param  USBx  Selected device
   1238            * @param  interrupt  flag
   1239            * @retval None
   1240            */

   \                                 In section .text, align 2, keep-with-next
   1241          void  USB_ClearInterrupts(USB_OTG_GlobalTypeDef *USBx, uint32_t interrupt)
   1242          {
   1243            USBx->GINTSTS |= interrupt;
   \                     USB_ClearInterrupts: (+1)
   \        0x0   0x6942             LDR      R2,[R0, #+20]
   \        0x2   0x430A             ORRS     R2,R1,R2
   \        0x4   0x6142             STR      R2,[R0, #+20]
   1244          }
   \        0x6   0x4770             BX       LR
   1245          
   1246          /**
   1247            * @brief  Returns USB core mode
   1248            * @param  USBx  Selected device
   1249            * @retval return core mode : Host or Device
   1250            *          This parameter can be one of these values:
   1251            *           0 : Host
   1252            *           1 : Device
   1253            */

   \                                 In section .text, align 2, keep-with-next
   1254          uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
   1255          {
   1256            return ((USBx->GINTSTS) & 0x1U);
   \                     USB_GetMode: (+1)
   \        0x0   0x6940             LDR      R0,[R0, #+20]
   \        0x2   0xF010 0x0001      ANDS     R0,R0,#0x1
   \        0x6   0x4770             BX       LR
   1257          }
   1258          
   1259          /**
   1260            * @brief  Activate EP0 for Setup transactions
   1261            * @param  USBx  Selected device
   1262            * @retval HAL status
   1263            */

   \                                 In section .text, align 2, keep-with-next
   1264          HAL_StatusTypeDef  USB_ActivateSetup(USB_OTG_GlobalTypeDef *USBx)
   1265          {
   \                     USB_ActivateSetup: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   1266            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x2   0x000A             MOVS     R2,R1
   1267          
   1268            /* Set the MPS of the IN EP0 to 64 bytes */
   1269            USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
   \        0x4   0xF512 0x6010      ADDS     R0,R2,#+2304
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0x0AC0             LSRS     R0,R0,#+11
   \        0xC   0x02C0             LSLS     R0,R0,#+11
   \        0xE   0xF512 0x6310      ADDS     R3,R2,#+2304
   \       0x12   0x6018             STR      R0,[R3, #+0]
   1270          
   1271            USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
   \       0x14   0xF512 0x6000      ADDS     R0,R2,#+2048
   \       0x18   0x6840             LDR      R0,[R0, #+4]
   \       0x1A   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x1E   0xF512 0x6300      ADDS     R3,R2,#+2048
   \       0x22   0x6058             STR      R0,[R3, #+4]
   1272          
   1273            return HAL_OK;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x4770             BX       LR
   1274          }
   1275          
   1276          /**
   1277            * @brief  Prepare the EP0 to start the first control setup
   1278            * @param  USBx  Selected device
   1279            * @param  dma USB dma enabled or disabled
   1280            *          This parameter can be one of these values:
   1281            *           0 : DMA feature not used
   1282            *           1 : DMA feature used
   1283            * @param  psetup  pointer to setup packet
   1284            * @retval HAL status
   1285            */

   \                                 In section .text, align 2, keep-with-next
   1286          HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
   1287          {
   \                     USB_EP0_OutStart: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x0003             MOVS     R3,R0
   1288            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x001C             MOVS     R4,R3
   1289            uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
   \        0x6   0x6C1D             LDR      R5,[R3, #+64]
   1290          
   1291            if (gSNPSiD > USB_OTG_CORE_ID_300A)
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable11
   \        0xC   0x4285             CMP      R5,R0
   \        0xE   0xD306             BCC.N    ??USB_EP0_OutStart_0
   1292            {
   1293              if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
   \       0x10   0xF514 0x6030      ADDS     R0,R4,#+2816
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD501             BPL.N    ??USB_EP0_OutStart_0
   1294              {
   1295                return HAL_OK;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xE02B             B.N      ??USB_EP0_OutStart_1
   1296              }
   1297            }
   1298          
   1299            USBx_OUTEP(0U)->DOEPTSIZ = 0U;
   \                     ??USB_EP0_OutStart_0: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xF514 0x6630      ADDS     R6,R4,#+2816
   \       0x24   0x6130             STR      R0,[R6, #+16]
   1300            USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
   \       0x26   0xF514 0x6030      ADDS     R0,R4,#+2816
   \       0x2A   0x6900             LDR      R0,[R0, #+16]
   \       0x2C   0xF450 0x2000      ORRS     R0,R0,#0x80000
   \       0x30   0xF514 0x6630      ADDS     R6,R4,#+2816
   \       0x34   0x6130             STR      R0,[R6, #+16]
   1301            USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
   \       0x36   0xF514 0x6030      ADDS     R0,R4,#+2816
   \       0x3A   0x6900             LDR      R0,[R0, #+16]
   \       0x3C   0xF050 0x0018      ORRS     R0,R0,#0x18
   \       0x40   0xF514 0x6630      ADDS     R6,R4,#+2816
   \       0x44   0x6130             STR      R0,[R6, #+16]
   1302            USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
   \       0x46   0xF514 0x6030      ADDS     R0,R4,#+2816
   \       0x4A   0x6900             LDR      R0,[R0, #+16]
   \       0x4C   0xF050 0x40C0      ORRS     R0,R0,#0x60000000
   \       0x50   0xF514 0x6630      ADDS     R6,R4,#+2816
   \       0x54   0x6130             STR      R0,[R6, #+16]
   1303          
   1304            if (dma == 1U)
   \       0x56   0x0008             MOVS     R0,R1
   \       0x58   0xB2C0             UXTB     R0,R0
   \       0x5A   0x2801             CMP      R0,#+1
   \       0x5C   0xD10A             BNE.N    ??USB_EP0_OutStart_2
   1305            {
   1306              USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
   \       0x5E   0xF514 0x6030      ADDS     R0,R4,#+2816
   \       0x62   0x6142             STR      R2,[R0, #+20]
   1307              /* EP enable */
   1308              USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
   \       0x64   0xF514 0x6030      ADDS     R0,R4,#+2816
   \       0x68   0x6800             LDR      R0,[R0, #+0]
   \       0x6A   0xF050 0x2080      ORRS     R0,R0,#0x80008000
   \       0x6E   0xF514 0x6630      ADDS     R6,R4,#+2816
   \       0x72   0x6030             STR      R0,[R6, #+0]
   1309            }
   1310          
   1311            return HAL_OK;
   \                     ??USB_EP0_OutStart_2: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \                     ??USB_EP0_OutStart_1: (+1)
   \       0x76   0xBC70             POP      {R4-R6}
   \       0x78   0x4770             BX       LR
   1312          }
   1313          
   1314          /**
   1315            * @brief  Reset the USB Core (needed after USB clock settings change)
   1316            * @param  USBx  Selected device
   1317            * @retval HAL status
   1318            */

   \                                 In section .text, align 2, keep-with-next
   1319          static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
   1320          {
   \                     USB_CoreReset: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0001             MOVS     R1,R0
   1321            uint32_t count = 0U;
   \        0x4   0x2200             MOVS     R2,#+0
   1322          
   1323            /* Wait for AHB master IDLE state. */
   1324            do
   1325            {
   1326              if (++count > 200000U)
   \                     ??USB_CoreReset_0: (+1)
   \        0x6   0x1C52             ADDS     R2,R2,#+1
   \        0x8   0x....             LDR.N    R0,??DataTable8_1
   \        0xA   0x4282             CMP      R2,R0
   \        0xC   0xD301             BCC.N    ??USB_CoreReset_1
   1327              {
   1328                return HAL_TIMEOUT;
   \        0xE   0x2003             MOVS     R0,#+3
   \       0x10   0xE010             B.N      ??USB_CoreReset_2
   1329              }
   1330            } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
   \                     ??USB_CoreReset_1: (+1)
   \       0x12   0x690B             LDR      R3,[R1, #+16]
   \       0x14   0x2B00             CMP      R3,#+0
   \       0x16   0xD5F6             BPL.N    ??USB_CoreReset_0
   1331          
   1332            /* Core Soft Reset */
   1333            count = 0U;
   \       0x18   0x2300             MOVS     R3,#+0
   1334            USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
   \       0x1A   0x690C             LDR      R4,[R1, #+16]
   \       0x1C   0xF054 0x0401      ORRS     R4,R4,#0x1
   \       0x20   0x610C             STR      R4,[R1, #+16]
   1335          
   1336            do
   1337            {
   1338              if (++count > 200000U)
   \                     ??USB_CoreReset_3: (+1)
   \       0x22   0x1C5B             ADDS     R3,R3,#+1
   \       0x24   0x4283             CMP      R3,R0
   \       0x26   0xD301             BCC.N    ??USB_CoreReset_4
   1339              {
   1340                return HAL_TIMEOUT;
   \       0x28   0x2003             MOVS     R0,#+3
   \       0x2A   0xE003             B.N      ??USB_CoreReset_2
   1341              }
   1342            } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
   \                     ??USB_CoreReset_4: (+1)
   \       0x2C   0x690A             LDR      R2,[R1, #+16]
   \       0x2E   0x07D2             LSLS     R2,R2,#+31
   \       0x30   0xD4F7             BMI.N    ??USB_CoreReset_3
   1343          
   1344            return HAL_OK;
   \       0x32   0x2000             MOVS     R0,#+0
   \                     ??USB_CoreReset_2: (+1)
   \       0x34   0xBC10             POP      {R4}
   \       0x36   0x4770             BX       LR
   1345          }
   1346          
   1347          /**
   1348            * @brief  USB_HostInit : Initializes the USB OTG controller registers
   1349            *         for Host mode
   1350            * @param  USBx  Selected device
   1351            * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
   1352            *         the configuration information for the specified USBx peripheral.
   1353            * @retval HAL status
   1354            */

   \                                 In section .text, align 2, keep-with-next
   1355          HAL_StatusTypeDef USB_HostInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
   1356          {
   \                     USB_HostInit: (+1)
   \        0x0   0xB40E             PUSH     {R1-R3}
   \        0x2   0xB578             PUSH     {R3-R6,LR}
   \        0x4   0x0004             MOVS     R4,R0
   1357            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x6   0x0025             MOVS     R5,R4
   1358            uint32_t i;
   1359          
   1360            /* Restart the Phy Clock */
   1361            USBx_PCGCCTL = 0U;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0xF515 0x6160      ADDS     R1,R5,#+3584
   \        0xE   0x6008             STR      R0,[R1, #+0]
   1362          
   1363          #if defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
   1364            /* Disable HW VBUS sensing */
   1365            USBx->GCCFG &= ~(USB_OTG_GCCFG_VBDEN);
   1366          #else
   1367            /*
   1368            * Disable HW VBUS sensing. VBUS is internally considered to be always
   1369            * at VBUS-Valid level (5V).
   1370            */
   1371            USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
   \       0x10   0x6BA0             LDR      R0,[R4, #+56]
   \       0x12   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \       0x16   0x63A0             STR      R0,[R4, #+56]
   1372            USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSBSEN;
   \       0x18   0x6BA0             LDR      R0,[R4, #+56]
   \       0x1A   0xF430 0x2000      BICS     R0,R0,#0x80000
   \       0x1E   0x63A0             STR      R0,[R4, #+56]
   1373            USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSASEN;
   \       0x20   0x6BA0             LDR      R0,[R4, #+56]
   \       0x22   0xF430 0x2080      BICS     R0,R0,#0x40000
   \       0x26   0x63A0             STR      R0,[R4, #+56]
   1374          #endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */
   1375          #if defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
   1376            /* Disable Battery chargin detector */
   1377            USBx->GCCFG &= ~(USB_OTG_GCCFG_BCDEN);
   1378          #endif /* defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */
   1379          
   1380            if ((USBx->CID & (0x1U << 8)) != 0U)
   \       0x28   0x6BE0             LDR      R0,[R4, #+60]
   \       0x2A   0x05C0             LSLS     R0,R0,#+23
   \       0x2C   0xD514             BPL.N    ??USB_HostInit_0
   1381            {
   1382              if (cfg.speed == USBH_FSLS_SPEED)
   \       0x2E   0x9807             LDR      R0,[SP, #+28]
   \       0x30   0x2801             CMP      R0,#+1
   \       0x32   0xD108             BNE.N    ??USB_HostInit_1
   1383              {
   1384                /* Force Device Enumeration to FS/LS mode only */
   1385                USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
   \       0x34   0xF515 0x6080      ADDS     R0,R5,#+1024
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x3E   0xF515 0x6180      ADDS     R1,R5,#+1024
   \       0x42   0x6008             STR      R0,[R1, #+0]
   \       0x44   0xE010             B.N      ??USB_HostInit_2
   1386              }
   1387              else
   1388              {
   1389                /* Set default Max speed support */
   1390                USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
   \                     ??USB_HostInit_1: (+1)
   \       0x46   0xF515 0x6080      ADDS     R0,R5,#+1024
   \       0x4A   0x6800             LDR      R0,[R0, #+0]
   \       0x4C   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0x50   0xF515 0x6180      ADDS     R1,R5,#+1024
   \       0x54   0x6008             STR      R0,[R1, #+0]
   \       0x56   0xE007             B.N      ??USB_HostInit_2
   1391              }
   1392            }
   1393            else
   1394            {
   1395              /* Set default Max speed support */
   1396              USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
   \                     ??USB_HostInit_0: (+1)
   \       0x58   0xF515 0x6080      ADDS     R0,R5,#+1024
   \       0x5C   0x6800             LDR      R0,[R0, #+0]
   \       0x5E   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0x62   0xF515 0x6180      ADDS     R1,R5,#+1024
   \       0x66   0x6008             STR      R0,[R1, #+0]
   1397            }
   1398          
   1399            /* Make sure the FIFOs are flushed. */
   1400            (void)USB_FlushTxFifo(USBx, 0x10U); /* all Tx FIFOs */
   \                     ??USB_HostInit_2: (+1)
   \       0x68   0x2110             MOVS     R1,#+16
   \       0x6A   0x0020             MOVS     R0,R4
   \       0x6C   0x.... 0x....      BL       USB_FlushTxFifo
   1401            (void)USB_FlushRxFifo(USBx);
   \       0x70   0x0020             MOVS     R0,R4
   \       0x72   0x.... 0x....      BL       USB_FlushRxFifo
   1402          
   1403            /* Clear all pending HC Interrupts */
   1404            for (i = 0U; i < cfg.Host_channels; i++)
   \       0x76   0x2600             MOVS     R6,#+0
   \                     ??USB_HostInit_3: (+1)
   \       0x78   0x9806             LDR      R0,[SP, #+24]
   \       0x7A   0x4286             CMP      R6,R0
   \       0x7C   0xD20E             BCS.N    ??USB_HostInit_4
   1405            {
   1406              USBx_HC(i)->HCINT = 0xFFFFFFFFU;
   \       0x7E   0xEB15 0x1046      ADDS     R0,R5,R6, LSL #+5
   \       0x82   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0x86   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \       0x8A   0x6081             STR      R1,[R0, #+8]
   1407              USBx_HC(i)->HCINTMSK = 0U;
   \       0x8C   0xEB15 0x1046      ADDS     R0,R5,R6, LSL #+5
   \       0x90   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0x94   0x2100             MOVS     R1,#+0
   \       0x96   0x60C1             STR      R1,[R0, #+12]
   1408            }
   \       0x98   0x1C76             ADDS     R6,R6,#+1
   \       0x9A   0xE7ED             B.N      ??USB_HostInit_3
   1409          
   1410            /* Enable VBUS driving */
   1411            (void)USB_DriveVbus(USBx, 1U);
   \                     ??USB_HostInit_4: (+1)
   \       0x9C   0x2101             MOVS     R1,#+1
   \       0x9E   0x0020             MOVS     R0,R4
   \       0xA0   0x.... 0x....      BL       USB_DriveVbus
   1412          
   1413            HAL_Delay(200U);
   \       0xA4   0x20C8             MOVS     R0,#+200
   \       0xA6   0x.... 0x....      BL       HAL_Delay
   1414          
   1415            /* Disable all interrupts. */
   1416            USBx->GINTMSK = 0U;
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0x61A0             STR      R0,[R4, #+24]
   1417          
   1418            /* Clear any pending interrupts */
   1419            USBx->GINTSTS = 0xFFFFFFFFU;
   \       0xAE   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0xB2   0x6160             STR      R0,[R4, #+20]
   1420          
   1421            if ((USBx->CID & (0x1U << 8)) != 0U)
   \       0xB4   0x6BE0             LDR      R0,[R4, #+60]
   \       0xB6   0x05C0             LSLS     R0,R0,#+23
   \       0xB8   0xD50A             BPL.N    ??USB_HostInit_5
   1422            {
   1423              /* set Rx FIFO size */
   1424              USBx->GRXFSIZ  = 0x200U;
   \       0xBA   0xF44F 0x7000      MOV      R0,#+512
   \       0xBE   0x6260             STR      R0,[R4, #+36]
   1425              USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
   \       0xC0   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \       0xC4   0x62A0             STR      R0,[R4, #+40]
   1426              USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
   \       0xC6   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \       0xCA   0xF8C4 0x0100      STR      R0,[R4, #+256]
   \       0xCE   0xE008             B.N      ??USB_HostInit_6
   1427            }
   1428            else
   1429            {
   1430              /* set Rx FIFO size */
   1431              USBx->GRXFSIZ  = 0x80U;
   \                     ??USB_HostInit_5: (+1)
   \       0xD0   0x2080             MOVS     R0,#+128
   \       0xD2   0x6260             STR      R0,[R4, #+36]
   1432              USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
   \       0xD4   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \       0xD8   0x62A0             STR      R0,[R4, #+40]
   1433              USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
   \       0xDA   0x.... 0x....      LDR.W    R0,??DataTable11_4
   \       0xDE   0xF8C4 0x0100      STR      R0,[R4, #+256]
   1434            }
   1435          
   1436            /* Enable the common interrupts */
   1437            if (cfg.dma_enable == 0U)
   \                     ??USB_HostInit_6: (+1)
   \       0xE2   0x9808             LDR      R0,[SP, #+32]
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD103             BNE.N    ??USB_HostInit_7
   1438            {
   1439              USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
   \       0xE8   0x69A0             LDR      R0,[R4, #+24]
   \       0xEA   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xEE   0x61A0             STR      R0,[R4, #+24]
   1440            }
   1441          
   1442            /* Enable interrupts matching to the Host mode ONLY */
   1443            USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
   1444                              USB_OTG_GINTMSK_SOFM             | USB_OTG_GINTSTS_DISCINT | \
   1445                              USB_OTG_GINTMSK_PXFRM_IISOOXFRM  | USB_OTG_GINTMSK_WUIM);
   \                     ??USB_HostInit_7: (+1)
   \       0xF0   0x69A1             LDR      R1,[R4, #+24]
   \       0xF2   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \       0xF6   0x4301             ORRS     R1,R0,R1
   \       0xF8   0x61A1             STR      R1,[R4, #+24]
   1446          
   1447            return HAL_OK;
   \       0xFA   0x2000             MOVS     R0,#+0
   \       0xFC   0xBC72             POP      {R1,R4-R6}
   \       0xFE   0xF85D 0xFB10      LDR      PC,[SP], #+16
   1448          }
   1449          
   1450          /**
   1451            * @brief  USB_InitFSLSPClkSel : Initializes the FSLSPClkSel field of the
   1452            *         HCFG register on the PHY type and set the right frame interval
   1453            * @param  USBx  Selected device
   1454            * @param  freq  clock frequency
   1455            *          This parameter can be one of these values:
   1456            *           HCFG_48_MHZ : Full Speed 48 MHz Clock
   1457            *           HCFG_6_MHZ : Low Speed 6 MHz Clock
   1458            * @retval HAL status
   1459            */

   \                                 In section .text, align 2, keep-with-next
   1460          HAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx, uint8_t freq)
   1461          {
   \                     USB_InitFSLSPClkSel: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0002             MOVS     R2,R0
   1462            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x0013             MOVS     R3,R2
   1463          
   1464            USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
   \        0x6   0xF513 0x6080      ADDS     R0,R3,#+1024
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0x0880             LSRS     R0,R0,#+2
   \        0xE   0x0080             LSLS     R0,R0,#+2
   \       0x10   0xF513 0x6480      ADDS     R4,R3,#+1024
   \       0x14   0x6020             STR      R0,[R4, #+0]
   1465            USBx_HOST->HCFG |= (uint32_t)freq & USB_OTG_HCFG_FSLSPCS;
   \       0x16   0xF513 0x6080      ADDS     R0,R3,#+1024
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0x000C             MOVS     R4,R1
   \       0x1E   0xB2E4             UXTB     R4,R4
   \       0x20   0xF014 0x0403      ANDS     R4,R4,#0x3
   \       0x24   0x4320             ORRS     R0,R4,R0
   \       0x26   0xF513 0x6480      ADDS     R4,R3,#+1024
   \       0x2A   0x6020             STR      R0,[R4, #+0]
   1466          
   1467            if (freq == HCFG_48_MHZ)
   \       0x2C   0x0008             MOVS     R0,R1
   \       0x2E   0xB2C0             UXTB     R0,R0
   \       0x30   0x2801             CMP      R0,#+1
   \       0x32   0xD105             BNE.N    ??USB_InitFSLSPClkSel_0
   1468            {
   1469              USBx_HOST->HFIR = 48000U;
   \       0x34   0xF64B 0x3080      MOVW     R0,#+48000
   \       0x38   0xF513 0x6480      ADDS     R4,R3,#+1024
   \       0x3C   0x6060             STR      R0,[R4, #+4]
   \       0x3E   0xE008             B.N      ??USB_InitFSLSPClkSel_1
   1470            }
   1471            else if (freq == HCFG_6_MHZ)
   \                     ??USB_InitFSLSPClkSel_0: (+1)
   \       0x40   0x0008             MOVS     R0,R1
   \       0x42   0xB2C0             UXTB     R0,R0
   \       0x44   0x2802             CMP      R0,#+2
   \       0x46   0xD104             BNE.N    ??USB_InitFSLSPClkSel_1
   1472            {
   1473              USBx_HOST->HFIR = 6000U;
   \       0x48   0xF241 0x7070      MOVW     R0,#+6000
   \       0x4C   0xF513 0x6480      ADDS     R4,R3,#+1024
   \       0x50   0x6060             STR      R0,[R4, #+4]
   1474            }
   1475            else
   1476            {
   1477              /* ... */
   1478            }
   1479          
   1480            return HAL_OK;
   \                     ??USB_InitFSLSPClkSel_1: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xBC10             POP      {R4}
   \       0x56   0x4770             BX       LR
   1481          }
   1482          
   1483          /**
   1484            * @brief  USB_OTG_ResetPort : Reset Host Port
   1485            * @param  USBx  Selected device
   1486            * @retval HAL status
   1487            * @note (1)The application must wait at least 10 ms
   1488            *   before clearing the reset bit.
   1489            */

   \                                 In section .text, align 2, keep-with-next
   1490          HAL_StatusTypeDef USB_ResetPort(USB_OTG_GlobalTypeDef *USBx)
   1491          {
   \                     USB_ResetPort: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1492            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x0025             MOVS     R5,R4
   1493          
   1494            __IO uint32_t hprt0 = 0U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9000             STR      R0,[SP, #+0]
   1495          
   1496            hprt0 = USBx_HPRT0;
   \        0xA   0xF515 0x6088      ADDS     R0,R5,#+1088
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0x9000             STR      R0,[SP, #+0]
   1497          
   1498            hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
   1499                       USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);
   \       0x12   0x9800             LDR      R0,[SP, #+0]
   \       0x14   0xF030 0x002E      BICS     R0,R0,#0x2E
   \       0x18   0x9000             STR      R0,[SP, #+0]
   1500          
   1501            USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);
   \       0x1A   0x9800             LDR      R0,[SP, #+0]
   \       0x1C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x20   0xF515 0x6188      ADDS     R1,R5,#+1088
   \       0x24   0x6008             STR      R0,[R1, #+0]
   1502            HAL_Delay(100U);                                 /* See Note #1 */
   \       0x26   0x2064             MOVS     R0,#+100
   \       0x28   0x.... 0x....      BL       HAL_Delay
   1503            USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
   \       0x2C   0x9800             LDR      R0,[SP, #+0]
   \       0x2E   0xF430 0x7080      BICS     R0,R0,#0x100
   \       0x32   0xF515 0x6188      ADDS     R1,R5,#+1088
   \       0x36   0x6008             STR      R0,[R1, #+0]
   1504            HAL_Delay(10U);
   \       0x38   0x200A             MOVS     R0,#+10
   \       0x3A   0x.... 0x....      BL       HAL_Delay
   1505          
   1506            return HAL_OK;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xBD32             POP      {R1,R4,R5,PC}
   1507          }
   1508          
   1509          /**
   1510            * @brief  USB_DriveVbus : activate or de-activate vbus
   1511            * @param  state  VBUS state
   1512            *          This parameter can be one of these values:
   1513            *           0 : Deactivate VBUS
   1514            *           1 : Activate VBUS
   1515            * @retval HAL status
   1516            */

   \                                 In section .text, align 2, keep-with-next
   1517          HAL_StatusTypeDef USB_DriveVbus(USB_OTG_GlobalTypeDef *USBx, uint8_t state)
   1518          {
   \                     USB_DriveVbus: (+1)
   \        0x0   0xB418             PUSH     {R3,R4}
   \        0x2   0x0002             MOVS     R2,R0
   1519            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x0013             MOVS     R3,R2
   1520            __IO uint32_t hprt0 = 0U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9000             STR      R0,[SP, #+0]
   1521          
   1522            hprt0 = USBx_HPRT0;
   \        0xA   0xF513 0x6088      ADDS     R0,R3,#+1088
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0x9000             STR      R0,[SP, #+0]
   1523          
   1524            hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
   1525                       USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);
   \       0x12   0x9800             LDR      R0,[SP, #+0]
   \       0x14   0xF030 0x002E      BICS     R0,R0,#0x2E
   \       0x18   0x9000             STR      R0,[SP, #+0]
   1526          
   1527            if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
   \       0x1A   0x9800             LDR      R0,[SP, #+0]
   \       0x1C   0x04C0             LSLS     R0,R0,#+19
   \       0x1E   0xD409             BMI.N    ??USB_DriveVbus_0
   \       0x20   0x0008             MOVS     R0,R1
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xD105             BNE.N    ??USB_DriveVbus_0
   1528            {
   1529              USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
   \       0x28   0x9800             LDR      R0,[SP, #+0]
   \       0x2A   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \       0x2E   0xF513 0x6488      ADDS     R4,R3,#+1088
   \       0x32   0x6020             STR      R0,[R4, #+0]
   1530            }
   1531            if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
   \                     ??USB_DriveVbus_0: (+1)
   \       0x34   0x9800             LDR      R0,[SP, #+0]
   \       0x36   0x04C0             LSLS     R0,R0,#+19
   \       0x38   0xD509             BPL.N    ??USB_DriveVbus_1
   \       0x3A   0x0008             MOVS     R0,R1
   \       0x3C   0xB2C0             UXTB     R0,R0
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD105             BNE.N    ??USB_DriveVbus_1
   1532            {
   1533              USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
   \       0x42   0x9800             LDR      R0,[SP, #+0]
   \       0x44   0xF430 0x5080      BICS     R0,R0,#0x1000
   \       0x48   0xF513 0x6488      ADDS     R4,R3,#+1088
   \       0x4C   0x6020             STR      R0,[R4, #+0]
   1534            }
   1535            return HAL_OK;
   \                     ??USB_DriveVbus_1: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xBC12             POP      {R1,R4}
   \       0x52   0x4770             BX       LR
   1536          }
   1537          
   1538          /**
   1539            * @brief  Return Host Core speed
   1540            * @param  USBx  Selected device
   1541            * @retval speed : Host speed
   1542            *          This parameter can be one of these values:
   1543            *            @arg HCD_SPEED_HIGH: High speed mode
   1544            *            @arg HCD_SPEED_FULL: Full speed mode
   1545            *            @arg HCD_SPEED_LOW: Low speed mode
   1546            */

   \                                 In section .text, align 2, keep-with-next
   1547          uint32_t USB_GetHostSpeed(USB_OTG_GlobalTypeDef *USBx)
   1548          {
   \                     USB_GetHostSpeed: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x0001             MOVS     R1,R0
   1549            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x000A             MOVS     R2,R1
   1550            __IO uint32_t hprt0 = 0U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9000             STR      R0,[SP, #+0]
   1551          
   1552            hprt0 = USBx_HPRT0;
   \        0xA   0xF512 0x6088      ADDS     R0,R2,#+1088
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0x9000             STR      R0,[SP, #+0]
   1553            return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
   \       0x12   0x9800             LDR      R0,[SP, #+0]
   \       0x14   0xF3C0 0x4041      UBFX     R0,R0,#+17,#+2
   \       0x18   0xB001             ADD      SP,SP,#+4
   \       0x1A   0x4770             BX       LR
   1554          }
   1555          
   1556          /**
   1557            * @brief  Return Host Current Frame number
   1558            * @param  USBx  Selected device
   1559            * @retval current frame number
   1560            */

   \                                 In section .text, align 2, keep-with-next
   1561          uint32_t USB_GetCurrentFrame(USB_OTG_GlobalTypeDef *USBx)
   1562          {
   \                     USB_GetCurrentFrame: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   1563            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x2   0x0008             MOVS     R0,R1
   1564          
   1565            return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);
   \        0x4   0xF510 0x6080      ADDS     R0,R0,#+1024
   \        0x8   0x6880             LDR      R0,[R0, #+8]
   \        0xA   0xB280             UXTH     R0,R0
   \        0xC   0x4770             BX       LR
   1566          }
   1567          
   1568          /**
   1569            * @brief  Initialize a host channel
   1570            * @param  USBx  Selected device
   1571            * @param  ch_num  Channel number
   1572            *         This parameter can be a value from 1 to 15
   1573            * @param  epnum  Endpoint number
   1574            *          This parameter can be a value from 1 to 15
   1575            * @param  dev_address  Current device address
   1576            *          This parameter can be a value from 0 to 255
   1577            * @param  speed  Current device speed
   1578            *          This parameter can be one of these values:
   1579            *            @arg USB_OTG_SPEED_HIGH: High speed mode
   1580            *            @arg USB_OTG_SPEED_FULL: Full speed mode
   1581            *            @arg USB_OTG_SPEED_LOW: Low speed mode
   1582            * @param  ep_type  Endpoint Type
   1583            *          This parameter can be one of these values:
   1584            *            @arg EP_TYPE_CTRL: Control type
   1585            *            @arg EP_TYPE_ISOC: Isochronous type
   1586            *            @arg EP_TYPE_BULK: Bulk type
   1587            *            @arg EP_TYPE_INTR: Interrupt type
   1588            * @param  mps  Max Packet Size
   1589            *          This parameter can be a value from 0 to32K
   1590            * @retval HAL state
   1591            */

   \                                 In section .text, align 2, keep-with-next
   1592          HAL_StatusTypeDef USB_HC_Init(USB_OTG_GlobalTypeDef *USBx, uint8_t ch_num,
   1593                                        uint8_t epnum, uint8_t dev_address, uint8_t speed,
   1594                                        uint8_t ep_type, uint16_t mps)
   1595          {
   \                     USB_HC_Init: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4684             MOV      R12,R0
   \        0x6   0x9C08             LDR      R4,[SP, #+32]
   \        0x8   0x9D09             LDR      R5,[SP, #+36]
   \        0xA   0x9E0A             LDR      R6,[SP, #+40]
   1596            HAL_StatusTypeDef ret = HAL_OK;
   \        0xC   0x2000             MOVS     R0,#+0
   1597            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0xE   0x46E6             MOV      LR,R12
   1598            uint32_t HCcharEpDir, HCcharLowSpeed;
   1599          
   1600            /* Clear old interrupt conditions for this host channel. */
   1601            USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
   \       0x10   0x000F             MOVS     R7,R1
   \       0x12   0xB2FF             UXTB     R7,R7
   \       0x14   0xEB1E 0x1747      ADDS     R7,LR,R7, LSL #+5
   \       0x18   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \       0x1C   0xF05F 0x38FF      MOVS     R8,#+4294967295
   \       0x20   0xF8C7 0x8008      STR      R8,[R7, #+8]
   1602          
   1603            /* Enable channel interrupts required for this transfer. */
   1604            switch (ep_type)
   \       0x24   0x002F             MOVS     R7,R5
   \       0x26   0xB2FF             UXTB     R7,R7
   \       0x28   0x2F00             CMP      R7,#+0
   \       0x2A   0xD005             BEQ.N    ??USB_HC_Init_0
   \       0x2C   0x2F02             CMP      R7,#+2
   \       0x2E   0xD003             BEQ.N    ??USB_HC_Init_0
   \       0x30   0xD35A             BCC.N    ??USB_HC_Init_1
   \       0x32   0x2F03             CMP      R7,#+3
   \       0x34   0xD038             BEQ.N    ??USB_HC_Init_2
   \       0x36   0xE077             B.N      ??USB_HC_Init_3
   1605            {
   1606              case EP_TYPE_CTRL:
   1607              case EP_TYPE_BULK:
   1608                USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   1609                                                      USB_OTG_HCINTMSK_STALLM |
   1610                                                      USB_OTG_HCINTMSK_TXERRM |
   1611                                                      USB_OTG_HCINTMSK_DTERRM |
   1612                                                      USB_OTG_HCINTMSK_AHBERR |
   1613                                                      USB_OTG_HCINTMSK_NAKM;
   \                     ??USB_HC_Init_0: (+1)
   \       0x38   0x000F             MOVS     R7,R1
   \       0x3A   0xB2FF             UXTB     R7,R7
   \       0x3C   0xEB1E 0x1747      ADDS     R7,LR,R7, LSL #+5
   \       0x40   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \       0x44   0xF240 0x489D      MOVW     R8,#+1181
   \       0x48   0xF8C7 0x800C      STR      R8,[R7, #+12]
   1614          
   1615                if ((epnum & 0x80U) == 0x80U)
   \       0x4C   0x0617             LSLS     R7,R2,#+24
   \       0x4E   0xD513             BPL.N    ??USB_HC_Init_4
   1616                {
   1617                  USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
   \       0x50   0x000F             MOVS     R7,R1
   \       0x52   0xB2FF             UXTB     R7,R7
   \       0x54   0xEB1E 0x1747      ADDS     R7,LR,R7, LSL #+5
   \       0x58   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \       0x5C   0x4688             MOV      R8,R1
   \       0x5E   0xFA5F 0xF888      UXTB     R8,R8
   \       0x62   0xEB1E 0x1848      ADDS     R8,LR,R8, LSL #+5
   \       0x66   0xF518 0x68A0      ADDS     R8,R8,#+1280
   \       0x6A   0xF8D8 0x800C      LDR      R8,[R8, #+12]
   \       0x6E   0xF458 0x7880      ORRS     R8,R8,#0x100
   \       0x72   0xF8C7 0x800C      STR      R8,[R7, #+12]
   \       0x76   0xE016             B.N      ??USB_HC_Init_5
   1618                }
   1619                else
   1620                {
   1621                  if ((USBx->CID & (0x1U << 8)) != 0U)
   \                     ??USB_HC_Init_4: (+1)
   \       0x78   0xF8DC 0x703C      LDR      R7,[R12, #+60]
   \       0x7C   0x05FF             LSLS     R7,R7,#+23
   \       0x7E   0xD512             BPL.N    ??USB_HC_Init_5
   1622                  {
   1623                    USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
   \       0x80   0x000F             MOVS     R7,R1
   \       0x82   0xB2FF             UXTB     R7,R7
   \       0x84   0xEB1E 0x1747      ADDS     R7,LR,R7, LSL #+5
   \       0x88   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \       0x8C   0x4688             MOV      R8,R1
   \       0x8E   0xFA5F 0xF888      UXTB     R8,R8
   \       0x92   0xEB1E 0x1848      ADDS     R8,LR,R8, LSL #+5
   \       0x96   0xF518 0x68A0      ADDS     R8,R8,#+1280
   \       0x9A   0xF8D8 0x800C      LDR      R8,[R8, #+12]
   \       0x9E   0xF058 0x0860      ORRS     R8,R8,#0x60
   \       0xA2   0xF8C7 0x800C      STR      R8,[R7, #+12]
   1624                  }
   1625                }
   1626                break;
   \                     ??USB_HC_Init_5: (+1)
   \       0xA6   0xE041             B.N      ??USB_HC_Init_6
   1627          
   1628              case EP_TYPE_INTR:
   1629                USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   1630                                                      USB_OTG_HCINTMSK_STALLM |
   1631                                                      USB_OTG_HCINTMSK_TXERRM |
   1632                                                      USB_OTG_HCINTMSK_DTERRM |
   1633                                                      USB_OTG_HCINTMSK_NAKM   |
   1634                                                      USB_OTG_HCINTMSK_AHBERR |
   1635                                                      USB_OTG_HCINTMSK_FRMORM;
   \                     ??USB_HC_Init_2: (+1)
   \       0xA8   0x000F             MOVS     R7,R1
   \       0xAA   0xB2FF             UXTB     R7,R7
   \       0xAC   0xEB1E 0x1747      ADDS     R7,LR,R7, LSL #+5
   \       0xB0   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \       0xB4   0xF240 0x689D      MOVW     R8,#+1693
   \       0xB8   0xF8C7 0x800C      STR      R8,[R7, #+12]
   1636          
   1637                if ((epnum & 0x80U) == 0x80U)
   \       0xBC   0x0617             LSLS     R7,R2,#+24
   \       0xBE   0xD512             BPL.N    ??USB_HC_Init_7
   1638                {
   1639                  USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
   \       0xC0   0x000F             MOVS     R7,R1
   \       0xC2   0xB2FF             UXTB     R7,R7
   \       0xC4   0xEB1E 0x1747      ADDS     R7,LR,R7, LSL #+5
   \       0xC8   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \       0xCC   0x4688             MOV      R8,R1
   \       0xCE   0xFA5F 0xF888      UXTB     R8,R8
   \       0xD2   0xEB1E 0x1848      ADDS     R8,LR,R8, LSL #+5
   \       0xD6   0xF518 0x68A0      ADDS     R8,R8,#+1280
   \       0xDA   0xF8D8 0x800C      LDR      R8,[R8, #+12]
   \       0xDE   0xF458 0x7880      ORRS     R8,R8,#0x100
   \       0xE2   0xF8C7 0x800C      STR      R8,[R7, #+12]
   1640                }
   1641          
   1642                break;
   \                     ??USB_HC_Init_7: (+1)
   \       0xE6   0xE021             B.N      ??USB_HC_Init_6
   1643          
   1644              case EP_TYPE_ISOC:
   1645                USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
   1646                                                      USB_OTG_HCINTMSK_ACKM   |
   1647                                                      USB_OTG_HCINTMSK_AHBERR |
   1648                                                      USB_OTG_HCINTMSK_FRMORM;
   \                     ??USB_HC_Init_1: (+1)
   \       0xE8   0x000F             MOVS     R7,R1
   \       0xEA   0xB2FF             UXTB     R7,R7
   \       0xEC   0xEB1E 0x1747      ADDS     R7,LR,R7, LSL #+5
   \       0xF0   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \       0xF4   0xF240 0x2825      MOVW     R8,#+549
   \       0xF8   0xF8C7 0x800C      STR      R8,[R7, #+12]
   1649          
   1650                if ((epnum & 0x80U) == 0x80U)
   \       0xFC   0x0617             LSLS     R7,R2,#+24
   \       0xFE   0xD512             BPL.N    ??USB_HC_Init_8
   1651                {
   1652                  USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);
   \      0x100   0x000F             MOVS     R7,R1
   \      0x102   0xB2FF             UXTB     R7,R7
   \      0x104   0xEB1E 0x1747      ADDS     R7,LR,R7, LSL #+5
   \      0x108   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \      0x10C   0x4688             MOV      R8,R1
   \      0x10E   0xFA5F 0xF888      UXTB     R8,R8
   \      0x112   0xEB1E 0x1848      ADDS     R8,LR,R8, LSL #+5
   \      0x116   0xF518 0x68A0      ADDS     R8,R8,#+1280
   \      0x11A   0xF8D8 0x800C      LDR      R8,[R8, #+12]
   \      0x11E   0xF458 0x78C0      ORRS     R8,R8,#0x180
   \      0x122   0xF8C7 0x800C      STR      R8,[R7, #+12]
   1653                }
   1654                break;
   \                     ??USB_HC_Init_8: (+1)
   \      0x126   0xE001             B.N      ??USB_HC_Init_6
   1655          
   1656              default:
   1657                ret = HAL_ERROR;
   \                     ??USB_HC_Init_3: (+1)
   \      0x128   0x2701             MOVS     R7,#+1
   \      0x12A   0x0038             MOVS     R0,R7
   1658                break;
   1659            }
   1660          
   1661            /* Enable the top level host channel interrupt. */
   1662            USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
   \                     ??USB_HC_Init_6: (+1)
   \      0x12C   0xF51E 0x6780      ADDS     R7,LR,#+1024
   \      0x130   0xF8D7 0x8018      LDR      R8,[R7, #+24]
   \      0x134   0xF05F 0x0901      MOVS     R9,#+1
   \      0x138   0xF011 0x070F      ANDS     R7,R1,#0xF
   \      0x13C   0xFA19 0xF907      LSLS     R9,R9,R7
   \      0x140   0xEA59 0x0808      ORRS     R8,R9,R8
   \      0x144   0xF51E 0x6780      ADDS     R7,LR,#+1024
   \      0x148   0xF8C7 0x8018      STR      R8,[R7, #+24]
   1663          
   1664            /* Make sure host channel interrupts are enabled. */
   1665            USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
   \      0x14C   0xF8DC 0x7018      LDR      R7,[R12, #+24]
   \      0x150   0xF057 0x7700      ORRS     R7,R7,#0x2000000
   \      0x154   0xF8CC 0x7018      STR      R7,[R12, #+24]
   1666          
   1667            /* Program the HCCHAR register */
   1668            if ((epnum & 0x80U) == 0x80U)
   \      0x158   0x0617             LSLS     R7,R2,#+24
   \      0x15A   0xD502             BPL.N    ??USB_HC_Init_9
   1669            {
   1670              HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
   \      0x15C   0xF44F 0x4700      MOV      R7,#+32768
   \      0x160   0xE000             B.N      ??USB_HC_Init_10
   1671            }
   1672            else
   1673            {
   1674              HCcharEpDir = 0U;
   \                     ??USB_HC_Init_9: (+1)
   \      0x162   0x2700             MOVS     R7,#+0
   1675            }
   1676          
   1677            if (speed == HPRT0_PRTSPD_LOW_SPEED)
   \                     ??USB_HC_Init_10: (+1)
   \      0x164   0x46A0             MOV      R8,R4
   \      0x166   0xFA5F 0xF888      UXTB     R8,R8
   \      0x16A   0xF1B8 0x0F02      CMP      R8,#+2
   \      0x16E   0xD102             BNE.N    ??USB_HC_Init_11
   1678            {
   1679              HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
   \      0x170   0xF45F 0x3800      MOVS     R8,#+131072
   \      0x174   0xE001             B.N      ??USB_HC_Init_12
   1680            }
   1681            else
   1682            {
   1683              HCcharLowSpeed = 0U;
   \                     ??USB_HC_Init_11: (+1)
   \      0x176   0xF05F 0x0800      MOVS     R8,#+0
   1684            }
   1685          
   1686            USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
   1687                                                ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
   1688                                                (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
   1689                                                ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
   \                     ??USB_HC_Init_12: (+1)
   \      0x17A   0x4699             MOV      R9,R3
   \      0x17C   0xFA5F 0xF989      UXTB     R9,R9
   \      0x180   0xEA5F 0x5989      LSLS     R9,R9,#+22
   \      0x184   0xF019 0x59FE      ANDS     R9,R9,#0x1FC00000
   \      0x188   0x4692             MOV      R10,R2
   \      0x18A   0xFA5F 0xFA8A      UXTB     R10,R10
   \      0x18E   0xEA5F 0x2ACA      LSLS     R10,R10,#+11
   \      0x192   0xF41A 0x4AF0      ANDS     R10,R10,#0x7800
   \      0x196   0xEA5A 0x0909      ORRS     R9,R10,R9
   \      0x19A   0x46AA             MOV      R10,R5
   \      0x19C   0xFA5F 0xFA8A      UXTB     R10,R10
   \      0x1A0   0xEA5F 0x4A8A      LSLS     R10,R10,#+18
   \      0x1A4   0xF41A 0x2A40      ANDS     R10,R10,#0xC0000
   \      0x1A8   0xEA5A 0x0909      ORRS     R9,R10,R9
   \      0x1AC   0x46B2             MOV      R10,R6
   \      0x1AE   0xFA1F 0xFA8A      UXTH     R10,R10
   \      0x1B2   0xEA5F 0x5A4A      LSLS     R10,R10,#+21
   \      0x1B6   0xEA5F 0x5A5A      LSRS     R10,R10,#+21
   \      0x1BA   0xEA5A 0x0909      ORRS     R9,R10,R9
   \      0x1BE   0xEA57 0x0909      ORRS     R9,R7,R9
   \      0x1C2   0xEA58 0x0909      ORRS     R9,R8,R9
   \      0x1C6   0x468A             MOV      R10,R1
   \      0x1C8   0xFA5F 0xFA8A      UXTB     R10,R10
   \      0x1CC   0xEB1E 0x1A4A      ADDS     R10,LR,R10, LSL #+5
   \      0x1D0   0xF51A 0x6AA0      ADDS     R10,R10,#+1280
   \      0x1D4   0xF8CA 0x9000      STR      R9,[R10, #+0]
   1690          
   1691            if (ep_type == EP_TYPE_INTR)
   \      0x1D8   0x46A9             MOV      R9,R5
   \      0x1DA   0xFA5F 0xF989      UXTB     R9,R9
   \      0x1DE   0xF1B9 0x0F03      CMP      R9,#+3
   \      0x1E2   0xD113             BNE.N    ??USB_HC_Init_13
   1692            {
   1693              USBx_HC((uint32_t)ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM ;
   \      0x1E4   0x4689             MOV      R9,R1
   \      0x1E6   0xFA5F 0xF989      UXTB     R9,R9
   \      0x1EA   0xEB1E 0x1949      ADDS     R9,LR,R9, LSL #+5
   \      0x1EE   0xF519 0x69A0      ADDS     R9,R9,#+1280
   \      0x1F2   0xF8D9 0x9000      LDR      R9,[R9, #+0]
   \      0x1F6   0xF059 0x5900      ORRS     R9,R9,#0x20000000
   \      0x1FA   0x468A             MOV      R10,R1
   \      0x1FC   0xFA5F 0xFA8A      UXTB     R10,R10
   \      0x200   0xEB1E 0x1A4A      ADDS     R10,LR,R10, LSL #+5
   \      0x204   0xF51A 0x6AA0      ADDS     R10,R10,#+1280
   \      0x208   0xF8CA 0x9000      STR      R9,[R10, #+0]
   1694            }
   1695          
   1696            return ret;
   \                     ??USB_HC_Init_13: (+1)
   \      0x20C   0xB2C0             UXTB     R0,R0
   \      0x20E   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1697          }
   1698          
   1699          /**
   1700            * @brief  Start a transfer over a host channel
   1701            * @param  USBx  Selected device
   1702            * @param  hc  pointer to host channel structure
   1703            * @param  dma USB dma enabled or disabled
   1704            *          This parameter can be one of these values:
   1705            *           0 : DMA feature not used
   1706            *           1 : DMA feature used
   1707            * @retval HAL state
   1708            */

   \                                 In section .text, align 2, keep-with-next
   1709          HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)
   1710          {
   \                     USB_HC_StartXfer: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   1711            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0xA   0x0027             MOVS     R7,R4
   1712            uint32_t ch_num = (uint32_t)hc->ch_num;
   \        0xC   0xF895 0x8001      LDRB     R8,[R5, #+1]
   1713            static __IO uint32_t tmpreg = 0U;
   1714            uint8_t  is_oddframe;
   1715            uint16_t len_words;
   1716            uint16_t num_packets;
   1717            uint16_t max_hc_pkt_count = 256U;
   \       0x10   0xF44F 0x7980      MOV      R9,#+256
   1718          
   1719            if (((USBx->CID & (0x1U << 8)) != 0U) && (hc->speed == USBH_HS_SPEED))
   \       0x14   0x6BE0             LDR      R0,[R4, #+60]
   \       0x16   0x05C0             LSLS     R0,R0,#+23
   \       0x18   0xD521             BPL.N    ??USB_HC_StartXfer_0
   \       0x1A   0x7928             LDRB     R0,[R5, #+4]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD11E             BNE.N    ??USB_HC_StartXfer_0
   1720            {
   1721              if ((dma == 0U) && (hc->do_ping == 1U))
   \       0x20   0x0030             MOVS     R0,R6
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD108             BNE.N    ??USB_HC_StartXfer_1
   \       0x28   0x7968             LDRB     R0,[R5, #+5]
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD105             BNE.N    ??USB_HC_StartXfer_1
   1722              {
   1723                (void)USB_DoPing(USBx, hc->ch_num);
   \       0x2E   0x7869             LDRB     R1,[R5, #+1]
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       USB_DoPing
   1724                return HAL_OK;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xE0D3             B.N      ??USB_HC_StartXfer_2
   1725              }
   1726              else if (dma == 1U)
   \                     ??USB_HC_StartXfer_1: (+1)
   \       0x3A   0x0030             MOVS     R0,R6
   \       0x3C   0xB2C0             UXTB     R0,R0
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD10D             BNE.N    ??USB_HC_StartXfer_0
   1727              {
   1728                USBx_HC(ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
   \       0x42   0xEB17 0x1048      ADDS     R0,R7,R8, LSL #+5
   \       0x46   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0x4A   0xEB17 0x1148      ADDS     R1,R7,R8, LSL #+5
   \       0x4E   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \       0x52   0x68C9             LDR      R1,[R1, #+12]
   \       0x54   0xF031 0x0160      BICS     R1,R1,#0x60
   \       0x58   0x60C1             STR      R1,[R0, #+12]
   1729                hc->do_ping = 0U;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x7168             STRB     R0,[R5, #+5]
   1730              }
   1731              else
   1732              {
   1733                /* ... */
   1734              }
   1735            }
   1736          
   1737            /* Compute the expected number of packets associated to the transfer */
   1738            if (hc->xfer_len > 0U)
   \                     ??USB_HC_StartXfer_0: (+1)
   \       0x5E   0x6928             LDR      R0,[R5, #+16]
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD013             BEQ.N    ??USB_HC_StartXfer_3
   1739            {
   1740              num_packets = (uint16_t)((hc->xfer_len + hc->max_packet - 1U) / hc->max_packet);
   \       0x64   0x6928             LDR      R0,[R5, #+16]
   \       0x66   0x8929             LDRH     R1,[R5, #+8]
   \       0x68   0x1840             ADDS     R0,R0,R1
   \       0x6A   0x1E40             SUBS     R0,R0,#+1
   \       0x6C   0x8929             LDRH     R1,[R5, #+8]
   \       0x6E   0xFBB0 0xFAF1      UDIV     R10,R0,R1
   1741          
   1742              if (num_packets > max_hc_pkt_count)
   \       0x72   0x4648             MOV      R0,R9
   \       0x74   0x4651             MOV      R1,R10
   \       0x76   0xB280             UXTH     R0,R0
   \       0x78   0xB289             UXTH     R1,R1
   \       0x7A   0x4288             CMP      R0,R1
   \       0x7C   0xD208             BCS.N    ??USB_HC_StartXfer_4
   1743              {
   1744                num_packets = max_hc_pkt_count;
   \       0x7E   0x46CA             MOV      R10,R9
   1745                hc->xfer_len = (uint32_t)num_packets * hc->max_packet;
   \       0x80   0x4651             MOV      R1,R10
   \       0x82   0xB289             UXTH     R1,R1
   \       0x84   0x8928             LDRH     R0,[R5, #+8]
   \       0x86   0x4341             MULS     R1,R0,R1
   \       0x88   0x6129             STR      R1,[R5, #+16]
   \       0x8A   0xE001             B.N      ??USB_HC_StartXfer_4
   1746              }
   1747            }
   1748            else
   1749            {
   1750              num_packets = 1U;
   \                     ??USB_HC_StartXfer_3: (+1)
   \       0x8C   0xF05F 0x0A01      MOVS     R10,#+1
   1751            }
   1752            if (hc->ep_is_in != 0U)
   \                     ??USB_HC_StartXfer_4: (+1)
   \       0x90   0x78E8             LDRB     R0,[R5, #+3]
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD004             BEQ.N    ??USB_HC_StartXfer_5
   1753            {
   1754              hc->xfer_len = (uint32_t)num_packets * hc->max_packet;
   \       0x96   0x4651             MOV      R1,R10
   \       0x98   0xB289             UXTH     R1,R1
   \       0x9A   0x8928             LDRH     R0,[R5, #+8]
   \       0x9C   0x4341             MULS     R1,R0,R1
   \       0x9E   0x6129             STR      R1,[R5, #+16]
   1755            }
   1756          
   1757            /* Initialize the HCTSIZn register */
   1758            USBx_HC(ch_num)->HCTSIZ = (hc->xfer_len & USB_OTG_HCTSIZ_XFRSIZ) |
   1759                                      (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
   1760                                      (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
   \                     ??USB_HC_StartXfer_5: (+1)
   \       0xA0   0xEB17 0x1048      ADDS     R0,R7,R8, LSL #+5
   \       0xA4   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0xA8   0x6929             LDR      R1,[R5, #+16]
   \       0xAA   0x0349             LSLS     R1,R1,#+13
   \       0xAC   0x0B49             LSRS     R1,R1,#+13
   \       0xAE   0x4652             MOV      R2,R10
   \       0xB0   0xB292             UXTH     R2,R2
   \       0xB2   0x....             LDR.N    R3,??DataTable11_6
   \       0xB4   0xEA13 0x43C2      ANDS     R3,R3,R2, LSL #+19
   \       0xB8   0x4319             ORRS     R1,R3,R1
   \       0xBA   0x7AAA             LDRB     R2,[R5, #+10]
   \       0xBC   0x0752             LSLS     R2,R2,#+29
   \       0xBE   0xF012 0x42C0      ANDS     R2,R2,#0x60000000
   \       0xC2   0x4311             ORRS     R1,R2,R1
   \       0xC4   0x6101             STR      R1,[R0, #+16]
   1761          
   1762            if (dma != 0U)
   \       0xC6   0x0030             MOVS     R0,R6
   \       0xC8   0xB2C0             UXTB     R0,R0
   \       0xCA   0x2800             CMP      R0,#+0
   \       0xCC   0xD005             BEQ.N    ??USB_HC_StartXfer_6
   1763            {
   1764              /* xfer_buff MUST be 32-bits aligned */
   1765              USBx_HC(ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
   \       0xCE   0xEB17 0x1048      ADDS     R0,R7,R8, LSL #+5
   \       0xD2   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0xD6   0x68E9             LDR      R1,[R5, #+12]
   \       0xD8   0x6141             STR      R1,[R0, #+20]
   1766            }
   1767          
   1768            is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;
   \                     ??USB_HC_StartXfer_6: (+1)
   \       0xDA   0xF517 0x6080      ADDS     R0,R7,#+1024
   \       0xDE   0xF8D0 0xB008      LDR      R11,[R0, #+8]
   \       0xE2   0xF01B 0x0B01      ANDS     R11,R11,#0x1
   \       0xE6   0xF09B 0x0B01      EORS     R11,R11,#0x1
   1769            USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
   \       0xEA   0xEB17 0x1048      ADDS     R0,R7,R8, LSL #+5
   \       0xEE   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0xF2   0x6800             LDR      R0,[R0, #+0]
   \       0xF4   0xF030 0x5000      BICS     R0,R0,#0x20000000
   \       0xF8   0xEB17 0x1148      ADDS     R1,R7,R8, LSL #+5
   \       0xFC   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \      0x100   0x6008             STR      R0,[R1, #+0]
   1770            USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
   \      0x102   0xEB17 0x1048      ADDS     R0,R7,R8, LSL #+5
   \      0x106   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \      0x10A   0x6800             LDR      R0,[R0, #+0]
   \      0x10C   0x4659             MOV      R1,R11
   \      0x10E   0xB2C9             UXTB     R1,R1
   \      0x110   0xEA50 0x7041      ORRS     R0,R0,R1, LSL #+29
   \      0x114   0xEB17 0x1148      ADDS     R1,R7,R8, LSL #+5
   \      0x118   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \      0x11C   0x6008             STR      R0,[R1, #+0]
   1771          
   1772            /* Set host channel enable */
   1773            tmpreg = USBx_HC(ch_num)->HCCHAR;
   \      0x11E   0x....             LDR.N    R1,??DataTable11_7
   \      0x120   0xEB17 0x1048      ADDS     R0,R7,R8, LSL #+5
   \      0x124   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \      0x128   0x6800             LDR      R0,[R0, #+0]
   \      0x12A   0x6008             STR      R0,[R1, #+0]
   1774            tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   \      0x12C   0x6808             LDR      R0,[R1, #+0]
   \      0x12E   0xF030 0x4080      BICS     R0,R0,#0x40000000
   \      0x132   0x6008             STR      R0,[R1, #+0]
   1775          
   1776            /* make sure to set the correct ep direction */
   1777            if (hc->ep_is_in != 0U)
   \      0x134   0x78E8             LDRB     R0,[R5, #+3]
   \      0x136   0x2800             CMP      R0,#+0
   \      0x138   0xD004             BEQ.N    ??USB_HC_StartXfer_7
   1778            {
   1779              tmpreg |= USB_OTG_HCCHAR_EPDIR;
   \      0x13A   0x6808             LDR      R0,[R1, #+0]
   \      0x13C   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \      0x140   0x6008             STR      R0,[R1, #+0]
   \      0x142   0xE003             B.N      ??USB_HC_StartXfer_8
   1780            }
   1781            else
   1782            {
   1783              tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
   \                     ??USB_HC_StartXfer_7: (+1)
   \      0x144   0x6808             LDR      R0,[R1, #+0]
   \      0x146   0xF430 0x4000      BICS     R0,R0,#0x8000
   \      0x14A   0x6008             STR      R0,[R1, #+0]
   1784            }
   1785            tmpreg |= USB_OTG_HCCHAR_CHENA;
   \                     ??USB_HC_StartXfer_8: (+1)
   \      0x14C   0x6808             LDR      R0,[R1, #+0]
   \      0x14E   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \      0x152   0x6008             STR      R0,[R1, #+0]
   1786            USBx_HC(ch_num)->HCCHAR = tmpreg;
   \      0x154   0x6808             LDR      R0,[R1, #+0]
   \      0x156   0xEB17 0x1148      ADDS     R1,R7,R8, LSL #+5
   \      0x15A   0xF511 0x61A0      ADDS     R1,R1,#+1280
   \      0x15E   0x6008             STR      R0,[R1, #+0]
   1787          
   1788            if (dma != 0U) /* dma mode */
   \      0x160   0x0030             MOVS     R0,R6
   \      0x162   0xB2C0             UXTB     R0,R0
   \      0x164   0x2800             CMP      R0,#+0
   \      0x166   0xD001             BEQ.N    ??USB_HC_StartXfer_9
   1789            {
   1790              return HAL_OK;
   \      0x168   0x2000             MOVS     R0,#+0
   \      0x16A   0xE03A             B.N      ??USB_HC_StartXfer_2
   1791            }
   1792          
   1793            if ((hc->ep_is_in == 0U) && (hc->xfer_len > 0U))
   \                     ??USB_HC_StartXfer_9: (+1)
   \      0x16C   0x78E8             LDRB     R0,[R5, #+3]
   \      0x16E   0x2800             CMP      R0,#+0
   \      0x170   0xD136             BNE.N    ??USB_HC_StartXfer_10
   \      0x172   0x6928             LDR      R0,[R5, #+16]
   \      0x174   0x2800             CMP      R0,#+0
   \      0x176   0xD033             BEQ.N    ??USB_HC_StartXfer_10
   1794            {
   1795              switch (hc->ep_type)
   \      0x178   0x79E8             LDRB     R0,[R5, #+7]
   \      0x17A   0x2800             CMP      R0,#+0
   \      0x17C   0xD005             BEQ.N    ??USB_HC_StartXfer_11
   \      0x17E   0x2802             CMP      R0,#+2
   \      0x180   0xD003             BEQ.N    ??USB_HC_StartXfer_11
   \      0x182   0xD312             BCC.N    ??USB_HC_StartXfer_12
   \      0x184   0x2803             CMP      R0,#+3
   \      0x186   0xD010             BEQ.N    ??USB_HC_StartXfer_12
   \      0x188   0xE021             B.N      ??USB_HC_StartXfer_13
   1796              {
   1797                /* Non periodic transfer */
   1798                case EP_TYPE_CTRL:
   1799                case EP_TYPE_BULK:
   1800          
   1801                  len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
   \                     ??USB_HC_StartXfer_11: (+1)
   \      0x18A   0x6928             LDR      R0,[R5, #+16]
   \      0x18C   0x1CC0             ADDS     R0,R0,#+3
   \      0x18E   0x0880             LSRS     R0,R0,#+2
   \      0x190   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1802          
   1803                  /* check if there is enough space in FIFO space */
   1804                  if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
   \      0x194   0x6AE0             LDR      R0,[R4, #+44]
   \      0x196   0xB280             UXTH     R0,R0
   \      0x198   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \      0x19C   0x4288             CMP      R0,R1
   \      0x19E   0xD203             BCS.N    ??USB_HC_StartXfer_14
   1805                  {
   1806                    /* need to process data in nptxfempty interrupt */
   1807                    USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
   \      0x1A0   0x69A0             LDR      R0,[R4, #+24]
   \      0x1A2   0xF050 0x0020      ORRS     R0,R0,#0x20
   \      0x1A6   0x61A0             STR      R0,[R4, #+24]
   1808                  }
   1809                  break;
   \                     ??USB_HC_StartXfer_14: (+1)
   \      0x1A8   0xE011             B.N      ??USB_HC_StartXfer_15
   1810          
   1811                /* Periodic transfer */
   1812                case EP_TYPE_INTR:
   1813                case EP_TYPE_ISOC:
   1814                  len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
   \                     ??USB_HC_StartXfer_12: (+1)
   \      0x1AA   0x6928             LDR      R0,[R5, #+16]
   \      0x1AC   0x1CC0             ADDS     R0,R0,#+3
   \      0x1AE   0x0880             LSRS     R0,R0,#+2
   \      0x1B0   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   1815                  /* check if there is enough space in FIFO space */
   1816                  if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
   \      0x1B4   0xF517 0x6080      ADDS     R0,R7,#+1024
   \      0x1B8   0x6900             LDR      R0,[R0, #+16]
   \      0x1BA   0xB280             UXTH     R0,R0
   \      0x1BC   0xF8BD 0x1004      LDRH     R1,[SP, #+4]
   \      0x1C0   0x4288             CMP      R0,R1
   \      0x1C2   0xD203             BCS.N    ??USB_HC_StartXfer_16
   1817                  {
   1818                    /* need to process data in ptxfempty interrupt */
   1819                    USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;
   \      0x1C4   0x69A0             LDR      R0,[R4, #+24]
   \      0x1C6   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \      0x1CA   0x61A0             STR      R0,[R4, #+24]
   1820                  }
   1821                  break;
   \                     ??USB_HC_StartXfer_16: (+1)
   \      0x1CC   0xE7FF             B.N      ??USB_HC_StartXfer_15
   1822          
   1823                default:
   1824                  break;
   1825              }
   1826          
   1827              /* Write packet into the Tx FIFO. */
   1828              (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);
   \                     ??USB_HC_StartXfer_13: (+1)
   \                     ??USB_HC_StartXfer_15: (+1)
   \      0x1CE   0x2000             MOVS     R0,#+0
   \      0x1D0   0x9000             STR      R0,[SP, #+0]
   \      0x1D2   0x692B             LDR      R3,[R5, #+16]
   \      0x1D4   0xB29B             UXTH     R3,R3
   \      0x1D6   0x786A             LDRB     R2,[R5, #+1]
   \      0x1D8   0x68E9             LDR      R1,[R5, #+12]
   \      0x1DA   0x0020             MOVS     R0,R4
   \      0x1DC   0x.... 0x....      BL       USB_WritePacket
   1829            }
   1830          
   1831            return HAL_OK;
   \                     ??USB_HC_StartXfer_10: (+1)
   \      0x1E0   0x2000             MOVS     R0,#+0
   \                     ??USB_HC_StartXfer_2: (+1)
   \      0x1E2   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   1832          }

   \                                 In section .bss, align 4
   \                     `USB_HC_StartXfer::tmpreg`:
   \        0x0                      DS8 4
   1833          
   1834          /**
   1835            * @brief Read all host channel interrupts status
   1836            * @param  USBx  Selected device
   1837            * @retval HAL state
   1838            */

   \                                 In section .text, align 2, keep-with-next
   1839          uint32_t USB_HC_ReadInterrupt(USB_OTG_GlobalTypeDef *USBx)
   1840          {
   \                     USB_HC_ReadInterrupt: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   1841            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x2   0x0008             MOVS     R0,R1
   1842          
   1843            return ((USBx_HOST->HAINT) & 0xFFFFU);
   \        0x4   0xF510 0x6080      ADDS     R0,R0,#+1024
   \        0x8   0x6940             LDR      R0,[R0, #+20]
   \        0xA   0xB280             UXTH     R0,R0
   \        0xC   0x4770             BX       LR
   1844          }
   1845          
   1846          /**
   1847            * @brief  Halt a host channel
   1848            * @param  USBx  Selected device
   1849            * @param  hc_num  Host Channel number
   1850            *         This parameter can be a value from 1 to 15
   1851            * @retval HAL state
   1852            */

   \                                 In section .text, align 2, keep-with-next
   1853          HAL_StatusTypeDef USB_HC_Halt(USB_OTG_GlobalTypeDef *USBx, uint8_t hc_num)
   1854          {
   \                     USB_HC_Halt: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   \        0x2   0x0003             MOVS     R3,R0
   1855            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x001C             MOVS     R4,R3
   1856            uint32_t hcnum = (uint32_t)hc_num;
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0xB2ED             UXTB     R5,R5
   1857            uint32_t count = 0U;
   \        0xA   0x2600             MOVS     R6,#+0
   1858            uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
   \        0xC   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0x10   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0xF3C0 0x4281      UBFX     R2,R0,#+18,#+2
   1859          
   1860            /* Check for space in the request queue to issue the halt. */
   1861            if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
   \       0x1A   0x2A00             CMP      R2,#+0
   \       0x1C   0xD001             BEQ.N    ??USB_HC_Halt_0
   \       0x1E   0x2A02             CMP      R2,#+2
   \       0x20   0xD14D             BNE.N    ??USB_HC_Halt_1
   1862            {
   1863              USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
   \                     ??USB_HC_Halt_0: (+1)
   \       0x22   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0x26   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \       0x30   0xEB14 0x1745      ADDS     R7,R4,R5, LSL #+5
   \       0x34   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \       0x38   0x6038             STR      R0,[R7, #+0]
   1864          
   1865              if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
   \       0x3A   0x6AD8             LDR      R0,[R3, #+44]
   \       0x3C   0xF410 0x0F7F      TST      R0,#0xFF0000
   \       0x40   0xD130             BNE.N    ??USB_HC_Halt_2
   1866              {
   1867                USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   \       0x42   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0x46   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0x4A   0x6800             LDR      R0,[R0, #+0]
   \       0x4C   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \       0x50   0xEB14 0x1745      ADDS     R7,R4,R5, LSL #+5
   \       0x54   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \       0x58   0x6038             STR      R0,[R7, #+0]
   1868                USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
   \       0x5A   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0x5E   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0x62   0x6800             LDR      R0,[R0, #+0]
   \       0x64   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \       0x68   0xEB14 0x1745      ADDS     R7,R4,R5, LSL #+5
   \       0x6C   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \       0x70   0x6038             STR      R0,[R7, #+0]
   1869                USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   \       0x72   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0x76   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0x7A   0x6800             LDR      R0,[R0, #+0]
   \       0x7C   0xF430 0x4000      BICS     R0,R0,#0x8000
   \       0x80   0xEB14 0x1745      ADDS     R7,R4,R5, LSL #+5
   \       0x84   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \       0x88   0x6038             STR      R0,[R7, #+0]
   1870                do
   1871                {
   1872                  if (++count > 1000U)
   \                     ??USB_HC_Halt_3: (+1)
   \       0x8A   0x1C76             ADDS     R6,R6,#+1
   \       0x8C   0xF240 0x30E9      MOVW     R0,#+1001
   \       0x90   0x4286             CMP      R6,R0
   \       0x92   0xD263             BCS.N    ??USB_HC_Halt_4
   1873                  {
   1874                    break;
   1875                  }
   1876                } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
   \                     ??USB_HC_Halt_5: (+1)
   \       0x94   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0x98   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0x9C   0x6800             LDR      R0,[R0, #+0]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD4F3             BMI.N    ??USB_HC_Halt_3
   \       0xA2   0xE05B             B.N      ??USB_HC_Halt_4
   1877              }
   1878              else
   1879              {
   1880                USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
   \                     ??USB_HC_Halt_2: (+1)
   \       0xA4   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0xA8   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0xAC   0x6800             LDR      R0,[R0, #+0]
   \       0xAE   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \       0xB2   0xEB14 0x1745      ADDS     R7,R4,R5, LSL #+5
   \       0xB6   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \       0xBA   0x6038             STR      R0,[R7, #+0]
   \       0xBC   0xE04E             B.N      ??USB_HC_Halt_4
   1881              }
   1882            }
   1883            else
   1884            {
   1885              USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
   \                     ??USB_HC_Halt_1: (+1)
   \       0xBE   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0xC2   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0xC6   0x6800             LDR      R0,[R0, #+0]
   \       0xC8   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \       0xCC   0xEB14 0x1745      ADDS     R7,R4,R5, LSL #+5
   \       0xD0   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \       0xD4   0x6038             STR      R0,[R7, #+0]
   1886          
   1887              if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
   \       0xD6   0xF514 0x6080      ADDS     R0,R4,#+1024
   \       0xDA   0x6900             LDR      R0,[R0, #+16]
   \       0xDC   0xF410 0x0F7F      TST      R0,#0xFF0000
   \       0xE0   0xD130             BNE.N    ??USB_HC_Halt_6
   1888              {
   1889                USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
   \       0xE2   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0xE6   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0xEA   0x6800             LDR      R0,[R0, #+0]
   \       0xEC   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \       0xF0   0xEB14 0x1745      ADDS     R7,R4,R5, LSL #+5
   \       0xF4   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \       0xF8   0x6038             STR      R0,[R7, #+0]
   1890                USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
   \       0xFA   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \       0xFE   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \      0x102   0x6800             LDR      R0,[R0, #+0]
   \      0x104   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \      0x108   0xEB14 0x1745      ADDS     R7,R4,R5, LSL #+5
   \      0x10C   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \      0x110   0x6038             STR      R0,[R7, #+0]
   1891                USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
   \      0x112   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \      0x116   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \      0x11A   0x6800             LDR      R0,[R0, #+0]
   \      0x11C   0xF430 0x4000      BICS     R0,R0,#0x8000
   \      0x120   0xEB14 0x1745      ADDS     R7,R4,R5, LSL #+5
   \      0x124   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \      0x128   0x6038             STR      R0,[R7, #+0]
   1892                do
   1893                {
   1894                  if (++count > 1000U)
   \                     ??USB_HC_Halt_7: (+1)
   \      0x12A   0x1C76             ADDS     R6,R6,#+1
   \      0x12C   0xF240 0x30E9      MOVW     R0,#+1001
   \      0x130   0x4286             CMP      R6,R0
   \      0x132   0xD213             BCS.N    ??USB_HC_Halt_4
   1895                  {
   1896                    break;
   1897                  }
   1898                } while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
   \                     ??USB_HC_Halt_8: (+1)
   \      0x134   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \      0x138   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \      0x13C   0x6800             LDR      R0,[R0, #+0]
   \      0x13E   0x2800             CMP      R0,#+0
   \      0x140   0xD4F3             BMI.N    ??USB_HC_Halt_7
   \      0x142   0xE00B             B.N      ??USB_HC_Halt_4
   1899              }
   1900              else
   1901              {
   1902                USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
   \                     ??USB_HC_Halt_6: (+1)
   \      0x144   0xEB14 0x1045      ADDS     R0,R4,R5, LSL #+5
   \      0x148   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \      0x14C   0x6800             LDR      R0,[R0, #+0]
   \      0x14E   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \      0x152   0xEB14 0x1745      ADDS     R7,R4,R5, LSL #+5
   \      0x156   0xF517 0x67A0      ADDS     R7,R7,#+1280
   \      0x15A   0x6038             STR      R0,[R7, #+0]
   1903              }
   1904            }
   1905          
   1906            return HAL_OK;
   \                     ??USB_HC_Halt_4: (+1)
   \      0x15C   0x2000             MOVS     R0,#+0
   \      0x15E   0xBCF0             POP      {R4-R7}
   \      0x160   0x4770             BX       LR
   1907          }
   1908          
   1909          /**
   1910            * @brief  Initiate Do Ping protocol
   1911            * @param  USBx  Selected device
   1912            * @param  hc_num  Host Channel number
   1913            *         This parameter can be a value from 1 to 15
   1914            * @retval HAL state
   1915            */

   \                                 In section .text, align 2, keep-with-next
   1916          HAL_StatusTypeDef USB_DoPing(USB_OTG_GlobalTypeDef *USBx, uint8_t ch_num)
   1917          {
   \                     USB_DoPing: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x0002             MOVS     R2,R0
   1918            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x4   0x0013             MOVS     R3,R2
   1919            uint32_t chnum = (uint32_t)ch_num;
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0xB2ED             UXTB     R5,R5
   1920            uint32_t num_packets = 1U;
   \        0xA   0x2601             MOVS     R6,#+1
   1921            uint32_t tmpreg;
   1922          
   1923            USBx_HC(chnum)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
   1924                                     USB_OTG_HCTSIZ_DOPING;
   \        0xC   0xEB13 0x1045      ADDS     R0,R3,R5, LSL #+5
   \       0x10   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0x14   0x....             LDR.N    R4,??DataTable11_6
   \       0x16   0xEA14 0x44C6      ANDS     R4,R4,R6, LSL #+19
   \       0x1A   0xF054 0x4400      ORRS     R4,R4,#0x80000000
   \       0x1E   0x6104             STR      R4,[R0, #+16]
   1925          
   1926            /* Set host channel enable */
   1927            tmpreg = USBx_HC(chnum)->HCCHAR;
   \       0x20   0xEB13 0x1045      ADDS     R0,R3,R5, LSL #+5
   \       0x24   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0x28   0x6804             LDR      R4,[R0, #+0]
   1928            tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
   \       0x2A   0xF034 0x4480      BICS     R4,R4,#0x40000000
   1929            tmpreg |= USB_OTG_HCCHAR_CHENA;
   \       0x2E   0xF054 0x4400      ORRS     R4,R4,#0x80000000
   1930            USBx_HC(chnum)->HCCHAR = tmpreg;
   \       0x32   0xEB13 0x1045      ADDS     R0,R3,R5, LSL #+5
   \       0x36   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0x3A   0x6004             STR      R4,[R0, #+0]
   1931          
   1932            return HAL_OK;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xBC70             POP      {R4-R6}
   \       0x40   0x4770             BX       LR
   1933          }
   1934          
   1935          /**
   1936            * @brief  Stop Host Core
   1937            * @param  USBx  Selected device
   1938            * @retval HAL state
   1939            */

   \                                 In section .text, align 2, keep-with-next
   1940          HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
   1941          {
   \                     USB_StopHost: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   1942            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x6   0x002E             MOVS     R6,R5
   1943            uint32_t count = 0U;
   \        0x8   0x2700             MOVS     R7,#+0
   1944            uint32_t value;
   1945            uint32_t i;
   1946          
   1947            (void)USB_DisableGlobalInt(USBx);
   \        0xA   0x0028             MOVS     R0,R5
   \        0xC   0x.... 0x....      BL       USB_DisableGlobalInt
   1948          
   1949            /* Flush FIFO */
   1950            (void)USB_FlushTxFifo(USBx, 0x10U);
   \       0x10   0x2110             MOVS     R1,#+16
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0x.... 0x....      BL       USB_FlushTxFifo
   1951            (void)USB_FlushRxFifo(USBx);
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0x.... 0x....      BL       USB_FlushRxFifo
   1952          
   1953            /* Flush out any leftover queued requests. */
   1954            for (i = 0U; i <= 15U; i++)
   \       0x1E   0x2100             MOVS     R1,#+0
   \                     ??USB_StopHost_0: (+1)
   \       0x20   0x2910             CMP      R1,#+16
   \       0x22   0xD212             BCS.N    ??USB_StopHost_1
   1955            {
   1956              value = USBx_HC(i)->HCCHAR;
   \       0x24   0xEB16 0x1041      ADDS     R0,R6,R1, LSL #+5
   \       0x28   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0x2C   0x6800             LDR      R0,[R0, #+0]
   1957              value |=  USB_OTG_HCCHAR_CHDIS;
   \       0x2E   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   1958              value &= ~USB_OTG_HCCHAR_CHENA;
   \       0x32   0xF020 0x4000      BIC      R0,R0,#0x80000000
   1959              value &= ~USB_OTG_HCCHAR_EPDIR;
   \       0x36   0xF430 0x4000      BICS     R0,R0,#0x8000
   \       0x3A   0x0004             MOVS     R4,R0
   1960              USBx_HC(i)->HCCHAR = value;
   \       0x3C   0xEB16 0x1041      ADDS     R0,R6,R1, LSL #+5
   \       0x40   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0x44   0x6004             STR      R4,[R0, #+0]
   1961            }
   \       0x46   0x1C49             ADDS     R1,R1,#+1
   \       0x48   0xE7EA             B.N      ??USB_StopHost_0
   1962          
   1963            /* Halt all channels to put them into a known state. */
   1964            for (i = 0U; i <= 15U; i++)
   \                     ??USB_StopHost_1: (+1)
   \       0x4A   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??USB_StopHost_2: (+1)
   \       0x4E   0xF1B8 0x0F10      CMP      R8,#+16
   \       0x52   0xD21F             BCS.N    ??USB_StopHost_3
   1965            {
   1966              value = USBx_HC(i)->HCCHAR;
   \       0x54   0xEB16 0x1048      ADDS     R0,R6,R8, LSL #+5
   \       0x58   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0x5C   0x6800             LDR      R0,[R0, #+0]
   1967              value |= USB_OTG_HCCHAR_CHDIS;
   \       0x5E   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   1968              value |= USB_OTG_HCCHAR_CHENA;
   \       0x62   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   1969              value &= ~USB_OTG_HCCHAR_EPDIR;
   \       0x66   0xF430 0x4000      BICS     R0,R0,#0x8000
   \       0x6A   0x0004             MOVS     R4,R0
   1970              USBx_HC(i)->HCCHAR = value;
   \       0x6C   0xEB16 0x1048      ADDS     R0,R6,R8, LSL #+5
   \       0x70   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0x74   0x6004             STR      R4,[R0, #+0]
   1971          
   1972              do
   1973              {
   1974                if (++count > 1000U)
   \                     ??USB_StopHost_4: (+1)
   \       0x76   0x1C7F             ADDS     R7,R7,#+1
   \       0x78   0xF240 0x30E9      MOVW     R0,#+1001
   \       0x7C   0x4287             CMP      R7,R0
   \       0x7E   0xD206             BCS.N    ??USB_StopHost_5
   1975                {
   1976                  break;
   1977                }
   1978              } while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
   \                     ??USB_StopHost_6: (+1)
   \       0x80   0xEB16 0x1048      ADDS     R0,R6,R8, LSL #+5
   \       0x84   0xF510 0x60A0      ADDS     R0,R0,#+1280
   \       0x88   0x6800             LDR      R0,[R0, #+0]
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD4F3             BMI.N    ??USB_StopHost_4
   1979            }
   \                     ??USB_StopHost_5: (+1)
   \       0x8E   0xF118 0x0801      ADDS     R8,R8,#+1
   \       0x92   0xE7DC             B.N      ??USB_StopHost_2
   1980          
   1981            /* Clear any pending Host interrupts */
   1982            USBx_HOST->HAINT = 0xFFFFFFFFU;
   \                     ??USB_StopHost_3: (+1)
   \       0x94   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x98   0xF516 0x6180      ADDS     R1,R6,#+1024
   \       0x9C   0x6148             STR      R0,[R1, #+20]
   1983            USBx->GINTSTS = 0xFFFFFFFFU;
   \       0x9E   0x6168             STR      R0,[R5, #+20]
   1984          
   1985            (void)USB_EnableGlobalInt(USBx);
   \       0xA0   0x0028             MOVS     R0,R5
   \       0xA2   0x.... 0x....      BL       USB_EnableGlobalInt
   1986          
   1987            return HAL_OK;
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1988          }
   1989          
   1990          /**
   1991            * @brief  USB_ActivateRemoteWakeup active remote wakeup signalling
   1992            * @param  USBx Selected device
   1993            * @retval HAL status
   1994            */

   \                                 In section .text, align 2, keep-with-next
   1995          HAL_StatusTypeDef USB_ActivateRemoteWakeup(USB_OTG_GlobalTypeDef *USBx)
   1996          {
   \                     USB_ActivateRemoteWakeup: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   1997            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x2   0x000A             MOVS     R2,R1
   1998          
   1999            if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
   \        0x4   0xF512 0x6000      ADDS     R0,R2,#+2048
   \        0x8   0x6880             LDR      R0,[R0, #+8]
   \        0xA   0x07C0             LSLS     R0,R0,#+31
   \        0xC   0xD507             BPL.N    ??USB_ActivateRemoteWakeup_0
   2000            {
   2001              /* active Remote wakeup signalling */
   2002              USBx_DEVICE->DCTL |= USB_OTG_DCTL_RWUSIG;
   \        0xE   0xF512 0x6000      ADDS     R0,R2,#+2048
   \       0x12   0x6840             LDR      R0,[R0, #+4]
   \       0x14   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x18   0xF512 0x6300      ADDS     R3,R2,#+2048
   \       0x1C   0x6058             STR      R0,[R3, #+4]
   2003            }
   2004          
   2005            return HAL_OK;
   \                     ??USB_ActivateRemoteWakeup_0: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x4770             BX       LR
   2006          }
   2007          
   2008          /**
   2009            * @brief  USB_DeActivateRemoteWakeup de-active remote wakeup signalling
   2010            * @param  USBx Selected device
   2011            * @retval HAL status
   2012            */

   \                                 In section .text, align 2, keep-with-next
   2013          HAL_StatusTypeDef USB_DeActivateRemoteWakeup(USB_OTG_GlobalTypeDef *USBx)
   2014          {
   \                     USB_DeActivateRemoteWakeup: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   2015            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0x2   0x000A             MOVS     R2,R1
   2016          
   2017            /* active Remote wakeup signalling */
   2018            USBx_DEVICE->DCTL &= ~(USB_OTG_DCTL_RWUSIG);
   \        0x4   0xF512 0x6000      ADDS     R0,R2,#+2048
   \        0x8   0x6840             LDR      R0,[R0, #+4]
   \        0xA   0x0840             LSRS     R0,R0,#+1
   \        0xC   0x0040             LSLS     R0,R0,#+1
   \        0xE   0xF512 0x6300      ADDS     R3,R2,#+2048
   \       0x12   0x6058             STR      R0,[R3, #+4]
   2019          
   2020            return HAL_OK;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x4770             BX       LR
   2021          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0xFFBD'FFBF        DC32     0xffbdffbf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x00D8'ACC0        DC32     0xd8acc0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x00E4'E1C0        DC32     0xe4e1c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0x00F4'2400        DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \        0x0   0x0106'7380        DC32     0x1067380

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \        0x0   0x011A'49A0        DC32     0x11a49a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \        0x0   0x0131'2D00        DC32     0x1312d00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \        0x0   0x014C'A440        DC32     0x14ca440

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \        0x0   0x016E'3600        DC32     0x16e3600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \        0x0   0x01A6'AB20        DC32     0x1a6ab20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \        0x0   0x01E8'4800        DC32     0x1e84800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x803C'3800        DC32     0x803c3800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x0003'0D41        DC32     0x30d41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0xEC33'7800        DC32     0xec337800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0xEFF3'7800        DC32     0xeff37800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x1FF8'0000        DC32     0x1ff80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x4F54'300B        DC32     0x4f54300b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x0100'0200        DC32     0x1000200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0x00E0'0300        DC32     0xe00300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0x0060'0080        DC32     0x600080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \        0x0   0x0040'00E0        DC32     0x4000e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \        0x0   0xA320'0008        DC32     0xa3200008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \        0x0   0x1FF8'0000        DC32     0x1ff80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \        0x0   0x....'....        DC32     `USB_HC_StartXfer::tmpreg`
   2022          #endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */
   2023          
   2024          
   2025          /**
   2026            * @}
   2027            */
   2028          
   2029          /**
   2030            * @}
   2031            */
   2032          #endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */
   2033          #endif /* defined (HAL_PCD_MODULE_ENABLED) || defined (HAL_HCD_MODULE_ENABLED) */
   2034          
   2035          /**
   2036            * @}
   2037            */
   2038          
   2039          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   USB_ActivateDedicatedEndpoint
      12   USB_ActivateEndpoint
       0   USB_ActivateRemoteWakeup
       0   USB_ActivateSetup
       0   USB_ClearInterrupts
      24   USB_CoreInit
        24   -> USB_CoreReset
       4   USB_CoreReset
       0   USB_DeActivateRemoteWakeup
      12   USB_DeactivateDedicatedEndpoint
      12   USB_DeactivateEndpoint
       0   USB_DevConnect
       0   USB_DevDisconnect
      32   USB_DevInit
        32   -> USB_FlushRxFifo
        32   -> USB_FlushTxFifo
        32   -> USB_SetDevSpeed
       0   USB_DisableGlobalInt
      12   USB_DoPing
       8   USB_DriveVbus
      16   USB_EP0StartXfer
      12   USB_EP0_OutStart
       8   USB_EPClearStall
       8   USB_EPSetStall
      32   USB_EPStartXfer
        32   -> USB_WritePacket
       0   USB_EnableGlobalInt
       0   USB_FlushRxFifo
       0   USB_FlushTxFifo
       0   USB_GetCurrentFrame
       0   USB_GetDevSpeed
       4   USB_GetHostSpeed
       0   USB_GetMode
      16   USB_HC_Halt
      32   USB_HC_Init
       0   USB_HC_ReadInterrupt
      48   USB_HC_StartXfer
        48   -> USB_DoPing
        48   -> USB_WritePacket
      32   USB_HostInit
        32   -> HAL_Delay
        32   -> USB_DriveVbus
        32   -> USB_FlushRxFifo
        32   -> USB_FlushTxFifo
       4   USB_InitFSLSPClkSel
       0   USB_ReadDevAllInEpInterrupt
       0   USB_ReadDevAllOutEpInterrupt
      12   USB_ReadDevInEPInterrupt
       4   USB_ReadDevOutEPInterrupt
       0   USB_ReadInterrupts
      16   USB_ReadPacket
      16   USB_ResetPort
        16   -> HAL_Delay
      16   USB_SetCurrentMode
        16   -> HAL_Delay
       4   USB_SetDevAddress
       4   USB_SetDevSpeed
       8   USB_SetTurnaroundTime
      24   USB_StopDevice
        24   -> USB_FlushRxFifo
        24   -> USB_FlushTxFifo
      24   USB_StopHost
        24   -> USB_DisableGlobalInt
        24   -> USB_EnableGlobalInt
        24   -> USB_FlushRxFifo
        24   -> USB_FlushTxFifo
      24   USB_WritePacket


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
     190  USB_ActivateDedicatedEndpoint
     190  USB_ActivateEndpoint
      34  USB_ActivateRemoteWakeup
      40  USB_ActivateSetup
       8  USB_ClearInterrupts
     128  USB_CoreInit
      56  USB_CoreReset
      24  USB_DeActivateRemoteWakeup
     246  USB_DeactivateDedicatedEndpoint
     304  USB_DeactivateEndpoint
      40  USB_DevConnect
      40  USB_DevDisconnect
     500  USB_DevInit
      14  USB_DisableGlobalInt
      66  USB_DoPing
      84  USB_DriveVbus
     482  USB_EP0StartXfer
     122  USB_EP0_OutStart
     142  USB_EPClearStall
     156  USB_EPSetStall
     856  USB_EPStartXfer
      14  USB_EnableGlobalInt
      32  USB_FlushRxFifo
      36  USB_FlushTxFifo
      14  USB_GetCurrentFrame
      40  USB_GetDevSpeed
      28  USB_GetHostSpeed
       8  USB_GetMode
     354  USB_HC_Halt
     530  USB_HC_Init
      14  USB_HC_ReadInterrupt
     486  USB_HC_StartXfer
     258  USB_HostInit
      88  USB_InitFSLSPClkSel
      22  USB_ReadDevAllInEpInterrupt
      22  USB_ReadDevAllOutEpInterrupt
      54  USB_ReadDevInEPInterrupt
      32  USB_ReadDevOutEPInterrupt
      10  USB_ReadInterrupts
      44  USB_ReadPacket
      66  USB_ResetPort
      64  USB_SetCurrentMode
      52  USB_SetDevAddress
      30  USB_SetDevSpeed
     236  USB_SetTurnaroundTime
     110  USB_StopDevice
     172  USB_StopHost
      74  USB_WritePacket
       4  tmpreg

 
     4 bytes in section .bss
 6'708 bytes in section .text
 
 6'708 bytes of CODE memory
     4 bytes of DATA memory

Errors: none
Warnings: none
