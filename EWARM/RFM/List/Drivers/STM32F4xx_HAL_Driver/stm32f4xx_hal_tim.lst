###############################################################################
#
#                                                         30/Sep/2022  17:12:34
# IAR ANSI C/C++ Compiler V9.20.3.326/W64 for ARM Functional Safety
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c
#    Command line      =
#        -f
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_tim.o.rsp
#        (C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c
#        -D USE_HAL_DRIVER -D STM32F407xx -lC
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver
#        -o
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0 EWARM FS
#        9.20.3\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/App\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Core/Inc\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Include\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/display\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Library\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.0 EWARM FS 9.20.3\arm\CMSIS\Core\Include\\")
#        --dependencies=n
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_tim.o.d
#    Locale            =  C
#    List file         =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_tim.lst
#    Object file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_tim.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @brief   TIM HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Timer (TIM) peripheral:
      8            *           + TIM Time Base Initialization
      9            *           + TIM Time Base Start
     10            *           + TIM Time Base Start Interruption
     11            *           + TIM Time Base Start DMA
     12            *           + TIM Output Compare/PWM Initialization
     13            *           + TIM Output Compare/PWM Channel Configuration
     14            *           + TIM Output Compare/PWM  Start
     15            *           + TIM Output Compare/PWM  Start Interruption
     16            *           + TIM Output Compare/PWM Start DMA
     17            *           + TIM Input Capture Initialization
     18            *           + TIM Input Capture Channel Configuration
     19            *           + TIM Input Capture Start
     20            *           + TIM Input Capture Start Interruption
     21            *           + TIM Input Capture Start DMA
     22            *           + TIM One Pulse Initialization
     23            *           + TIM One Pulse Channel Configuration
     24            *           + TIM One Pulse Start
     25            *           + TIM Encoder Interface Initialization
     26            *           + TIM Encoder Interface Start
     27            *           + TIM Encoder Interface Start Interruption
     28            *           + TIM Encoder Interface Start DMA
     29            *           + Commutation Event configuration with Interruption and DMA
     30            *           + TIM OCRef clear configuration
     31            *           + TIM External Clock configuration
     32            @verbatim
     33            ==============================================================================
     34                                ##### TIMER Generic features #####
     35            ==============================================================================
     36            [..] The Timer features include:
     37                 (#) 16-bit up, down, up/down auto-reload counter.
     38                 (#) 16-bit programmable prescaler allowing dividing (also on the fly) the
     39                     counter clock frequency either by any factor between 1 and 65536.
     40                 (#) Up to 4 independent channels for:
     41                     (++) Input Capture
     42                     (++) Output Compare
     43                     (++) PWM generation (Edge and Center-aligned Mode)
     44                     (++) One-pulse mode output
     45                 (#) Synchronization circuit to control the timer with external signals and to interconnect
     46                      several timers together.
     47                 (#) Supports incremental encoder for positioning purposes
     48          
     49                      ##### How to use this driver #####
     50            ==============================================================================
     51              [..]
     52               (#) Initialize the TIM low level resources by implementing the following functions
     53                   depending on the selected feature:
     54                     (++) Time Base : HAL_TIM_Base_MspInit()
     55                     (++) Input Capture : HAL_TIM_IC_MspInit()
     56                     (++) Output Compare : HAL_TIM_OC_MspInit()
     57                     (++) PWM generation : HAL_TIM_PWM_MspInit()
     58                     (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     59                     (++) Encoder mode output : HAL_TIM_Encoder_MspInit()
     60          
     61               (#) Initialize the TIM low level resources :
     62                  (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
     63                  (##) TIM pins configuration
     64                      (+++) Enable the clock for the TIM GPIOs using the following function:
     65                       __HAL_RCC_GPIOx_CLK_ENABLE();
     66                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();
     67          
     68               (#) The external Clock can be configured, if needed (the default clock is the
     69                   internal clock from the APBx), using the following function:
     70                   HAL_TIM_ConfigClockSource, the clock configuration should be done before
     71                   any start function.
     72          
     73               (#) Configure the TIM in the desired functioning mode using one of the
     74                 Initialization function of this driver:
     75                 (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     76                 (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an
     77                      Output Compare signal.
     78                 (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a
     79                      PWM signal.
     80                 (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an
     81                      external signal.
     82                 (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer
     83                      in One Pulse Mode.
     84                 (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     85          
     86               (#) Activate the TIM peripheral using one of the start functions depending from the feature used:
     87                     (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
     88                     (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
     89                     (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
     90                     (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
     91                     (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
     92                     (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().
     93          
     94               (#) The DMA Burst is managed with the two following functions:
     95                   HAL_TIM_DMABurst_WriteStart()
     96                   HAL_TIM_DMABurst_ReadStart()
     97          
     98              *** Callback registration ***
     99            =============================================
    100          
    101            [..]
    102            The compilation define  USE_HAL_TIM_REGISTER_CALLBACKS when set to 1
    103            allows the user to configure dynamically the driver callbacks.
    104          
    105            [..]
    106            Use Function @ref HAL_TIM_RegisterCallback() to register a callback.
    107            @ref HAL_TIM_RegisterCallback() takes as parameters the HAL peripheral handle,
    108            the Callback ID and a pointer to the user callback function.
    109          
    110            [..]
    111            Use function @ref HAL_TIM_UnRegisterCallback() to reset a callback to the default
    112            weak function.
    113            @ref HAL_TIM_UnRegisterCallback takes as parameters the HAL peripheral handle,
    114            and the Callback ID.
    115          
    116            [..]
    117            These functions allow to register/unregister following callbacks:
    118              (+) Base_MspInitCallback              : TIM Base Msp Init Callback.
    119              (+) Base_MspDeInitCallback            : TIM Base Msp DeInit Callback.
    120              (+) IC_MspInitCallback                : TIM IC Msp Init Callback.
    121              (+) IC_MspDeInitCallback              : TIM IC Msp DeInit Callback.
    122              (+) OC_MspInitCallback                : TIM OC Msp Init Callback.
    123              (+) OC_MspDeInitCallback              : TIM OC Msp DeInit Callback.
    124              (+) PWM_MspInitCallback               : TIM PWM Msp Init Callback.
    125              (+) PWM_MspDeInitCallback             : TIM PWM Msp DeInit Callback.
    126              (+) OnePulse_MspInitCallback          : TIM One Pulse Msp Init Callback.
    127              (+) OnePulse_MspDeInitCallback        : TIM One Pulse Msp DeInit Callback.
    128              (+) Encoder_MspInitCallback           : TIM Encoder Msp Init Callback.
    129              (+) Encoder_MspDeInitCallback         : TIM Encoder Msp DeInit Callback.
    130              (+) HallSensor_MspInitCallback        : TIM Hall Sensor Msp Init Callback.
    131              (+) HallSensor_MspDeInitCallback      : TIM Hall Sensor Msp DeInit Callback.
    132              (+) PeriodElapsedCallback             : TIM Period Elapsed Callback.
    133              (+) PeriodElapsedHalfCpltCallback     : TIM Period Elapsed half complete Callback.
    134              (+) TriggerCallback                   : TIM Trigger Callback.
    135              (+) TriggerHalfCpltCallback           : TIM Trigger half complete Callback.
    136              (+) IC_CaptureCallback                : TIM Input Capture Callback.
    137              (+) IC_CaptureHalfCpltCallback        : TIM Input Capture half complete Callback.
    138              (+) OC_DelayElapsedCallback           : TIM Output Compare Delay Elapsed Callback.
    139              (+) PWM_PulseFinishedCallback         : TIM PWM Pulse Finished Callback.
    140              (+) PWM_PulseFinishedHalfCpltCallback : TIM PWM Pulse Finished half complete Callback.
    141              (+) ErrorCallback                     : TIM Error Callback.
    142              (+) CommutationCallback               : TIM Commutation Callback.
    143              (+) CommutationHalfCpltCallback       : TIM Commutation half complete Callback.
    144              (+) BreakCallback                     : TIM Break Callback.
    145          
    146            [..]
    147          By default, after the Init and when the state is HAL_TIM_STATE_RESET
    148          all interrupt callbacks are set to the corresponding weak functions:
    149            examples @ref HAL_TIM_TriggerCallback(), @ref HAL_TIM_ErrorCallback().
    150          
    151            [..]
    152            Exception done for MspInit and MspDeInit functions that are reset to the legacy weak
    153            functionalities in the Init / DeInit only when these callbacks are null
    154            (not registered beforehand). If not, MspInit or MspDeInit are not null, the Init / DeInit
    155              keep and use the user MspInit / MspDeInit callbacks(registered beforehand)
    156          
    157            [..]
    158              Callbacks can be registered / unregistered in HAL_TIM_STATE_READY state only.
    159              Exception done MspInit / MspDeInit that can be registered / unregistered
    160              in HAL_TIM_STATE_READY or HAL_TIM_STATE_RESET state,
    161              thus registered(user) MspInit / DeInit callbacks can be used during the Init / DeInit.
    162            In that case first register the MspInit/MspDeInit user callbacks
    163                using @ref HAL_TIM_RegisterCallback() before calling DeInit or Init function.
    164          
    165            [..]
    166                When The compilation define USE_HAL_TIM_REGISTER_CALLBACKS is set to 0 or
    167                not defined, the callback registration feature is not available and all callbacks
    168                are set to the corresponding weak functions.
    169          
    170            @endverbatim
    171            ******************************************************************************
    172            * @attention
    173            *
    174            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
    175            * All rights reserved.</center></h2>
    176            *
    177            * This software component is licensed by ST under BSD 3-Clause license,
    178            * the "License"; You may not use this file except in compliance with the
    179            * License. You may obtain a copy of the License at:
    180            *                        opensource.org/licenses/BSD-3-Clause
    181            *
    182            ******************************************************************************
    183            */
    184          
    185          /* Includes ------------------------------------------------------------------*/
    186          #include "stm32f4xx_hal.h"
    187          
    188          /** @addtogroup STM32F4xx_HAL_Driver
    189            * @{
    190            */
    191          
    192          /** @defgroup TIM TIM
    193            * @brief TIM HAL module driver
    194            * @{
    195            */
    196          
    197          #ifdef HAL_TIM_MODULE_ENABLED
    198          
    199          /* Private typedef -----------------------------------------------------------*/
    200          /* Private define ------------------------------------------------------------*/
    201          /* Private macro -------------------------------------------------------------*/
    202          /* Private variables ---------------------------------------------------------*/
    203          /* Private function prototypes -----------------------------------------------*/
    204          /** @addtogroup TIM_Private_Functions
    205            * @{
    206            */
    207          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    208          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    209          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    210          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    211          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    212                                        uint32_t TIM_ICFilter);
    213          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    214          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    215                                        uint32_t TIM_ICFilter);
    216          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    217                                        uint32_t TIM_ICFilter);
    218          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource);
    219          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    220          static void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma);
    221          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    222          static void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma);
    223          static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
    224                                                            TIM_SlaveConfigTypeDef *sSlaveConfig);
    225          /**
    226            * @}
    227            */
    228          /* Exported functions --------------------------------------------------------*/
    229          
    230          /** @defgroup TIM_Exported_Functions TIM Exported Functions
    231            * @{
    232            */
    233          
    234          /** @defgroup TIM_Exported_Functions_Group1 TIM Time Base functions
    235            *  @brief    Time Base functions
    236            *
    237          @verbatim
    238            ==============================================================================
    239                        ##### Time Base functions #####
    240            ==============================================================================
    241            [..]
    242              This section provides functions allowing to:
    243              (+) Initialize and configure the TIM base.
    244              (+) De-initialize the TIM base.
    245              (+) Start the Time Base.
    246              (+) Stop the Time Base.
    247              (+) Start the Time Base and enable interrupt.
    248              (+) Stop the Time Base and disable interrupt.
    249              (+) Start the Time Base and enable DMA transfer.
    250              (+) Stop the Time Base and disable DMA transfer.
    251          
    252          @endverbatim
    253            * @{
    254            */
    255          /**
    256            * @brief  Initializes the TIM Time base Unit according to the specified
    257            *         parameters in the TIM_HandleTypeDef and initialize the associated handle.
    258            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
    259            *         requires a timer reset to avoid unexpected direction
    260            *         due to DIR bit readonly in center aligned mode.
    261            *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
    262            * @param  htim TIM Base handle
    263            * @retval HAL status
    264            */

   \                                 In section .text, align 2, keep-with-next
    265          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    266          {
   \                     HAL_TIM_Base_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    267            /* Check the TIM handle allocation */
    268            if (htim == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_TIM_Base_Init_0
    269            {
    270              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE014             B.N      ??HAL_TIM_Base_Init_1
    271            }
    272          
    273            /* Check the parameters */
    274            assert_param(IS_TIM_INSTANCE(htim->Instance));
    275            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    276            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    277            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    278          
    279            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Base_Init_0: (+1)
   \        0xC   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD105             BNE.N    ??HAL_TIM_Base_Init_2
    280            {
    281              /* Allocate lock resource and initialize it */
    282              htim->Lock = HAL_UNLOCKED;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xF884 0x003C      STRB     R0,[R4, #+60]
    283          
    284          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    285              /* Reset interrupt callbacks to legacy weak callbacks */
    286              TIM_ResetCallback(htim);
    287          
    288              if (htim->Base_MspInitCallback == NULL)
    289              {
    290                htim->Base_MspInitCallback = HAL_TIM_Base_MspInit;
    291              }
    292              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    293              htim->Base_MspInitCallback(htim);
    294          #else
    295              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    296              HAL_TIM_Base_MspInit(htim);
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       HAL_TIM_Base_MspInit
    297          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    298            }
    299          
    300            /* Set the TIM state */
    301            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Init_2: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xF884 0x003D      STRB     R0,[R4, #+61]
    302          
    303            /* Set the Time Base configuration */
    304            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x26   0x1D21             ADDS     R1,R4,#+4
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x.... 0x....      BL       TIM_Base_SetConfig
    305          
    306            /* Initialize the TIM state*/
    307            htim->State = HAL_TIM_STATE_READY;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xF884 0x003D      STRB     R0,[R4, #+61]
    308          
    309            return HAL_OK;
   \       0x34   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Base_Init_1: (+1)
   \       0x36   0xBD10             POP      {R4,PC}
    310          }
    311          
    312          /**
    313            * @brief  DeInitializes the TIM Base peripheral
    314            * @param  htim TIM Base handle
    315            * @retval HAL status
    316            */

   \                                 In section .text, align 2, keep-with-next
    317          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    318          {
   \                     HAL_TIM_Base_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    319            /* Check the parameters */
    320            assert_param(IS_TIM_INSTANCE(htim->Instance));
    321          
    322            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0xF884 0x003D      STRB     R0,[R4, #+61]
    323          
    324            /* Disable the TIM Peripheral Clock */
    325            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0xF241 0x1111      MOVW     R1,#+4369
   \       0x12   0x4208             TST      R0,R1
   \       0x14   0xD10B             BNE.N    ??HAL_TIM_Base_DeInit_0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6A00             LDR      R0,[R0, #+32]
   \       0x1A   0xF240 0x4144      MOVW     R1,#+1092
   \       0x1E   0x4208             TST      R0,R1
   \       0x20   0xD105             BNE.N    ??HAL_TIM_Base_DeInit_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x0840             LSRS     R0,R0,#+1
   \       0x28   0x0040             LSLS     R0,R0,#+1
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6008             STR      R0,[R1, #+0]
    326          
    327          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    328            if (htim->Base_MspDeInitCallback == NULL)
    329            {
    330              htim->Base_MspDeInitCallback = HAL_TIM_Base_MspDeInit;
    331            }
    332            /* DeInit the low level hardware */
    333            htim->Base_MspDeInitCallback(htim);
    334          #else
    335            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    336            HAL_TIM_Base_MspDeInit(htim);
   \                     ??HAL_TIM_Base_DeInit_0: (+1)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       HAL_TIM_Base_MspDeInit
    337          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    338          
    339            /* Change TIM state */
    340            htim->State = HAL_TIM_STATE_RESET;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF884 0x003D      STRB     R0,[R4, #+61]
    341          
    342            /* Release Lock */
    343            __HAL_UNLOCK(htim);
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xF884 0x003C      STRB     R0,[R4, #+60]
    344          
    345            return HAL_OK;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD10             POP      {R4,PC}
    346          }
    347          
    348          /**
    349            * @brief  Initializes the TIM Base MSP.
    350            * @param  htim TIM Base handle
    351            * @retval None
    352            */

   \                                 In section .text, align 2
    353          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    354          {
    355            /* Prevent unused argument(s) compilation warning */
    356            UNUSED(htim);
    357          
    358            /* NOTE : This function should not be modified, when the callback is needed,
    359                      the HAL_TIM_Base_MspInit could be implemented in the user file
    360             */
    361          }
   \                     HAL_TIM_Base_MspInit: (+1)
   \        0x0   0x4770             BX       LR
    362          
    363          /**
    364            * @brief  DeInitializes TIM Base MSP.
    365            * @param  htim TIM Base handle
    366            * @retval None
    367            */

   \                                 In section .text, align 2
    368          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    369          {
    370            /* Prevent unused argument(s) compilation warning */
    371            UNUSED(htim);
    372          
    373            /* NOTE : This function should not be modified, when the callback is needed,
    374                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    375             */
    376          }
   \                     HAL_TIM_Base_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
    377          
    378          
    379          /**
    380            * @brief  Starts the TIM Base generation.
    381            * @param  htim TIM Base handle
    382            * @retval HAL status
    383            */

   \                                 In section .text, align 2, keep-with-next
    384          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    385          {
   \                     HAL_TIM_Base_Start: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    386            uint32_t tmpsmcr;
    387          
    388            /* Check the parameters */
    389            assert_param(IS_TIM_INSTANCE(htim->Instance));
    390          
    391            /* Set the TIM state */
    392            htim->State = HAL_TIM_STATE_BUSY;
   \        0x2   0x2002             MOVS     R0,#+2
   \        0x4   0xF881 0x003D      STRB     R0,[R1, #+61]
    393          
    394            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    395            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \        0x8   0x6808             LDR      R0,[R1, #+0]
   \        0xA   0x6882             LDR      R2,[R0, #+8]
   \        0xC   0xF012 0x0207      ANDS     R2,R2,#0x7
    396            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x10   0x2A06             CMP      R2,#+6
   \       0x12   0xD005             BEQ.N    ??HAL_TIM_Base_Start_0
    397            {
    398              __HAL_TIM_ENABLE(htim);
   \       0x14   0x6808             LDR      R0,[R1, #+0]
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x1C   0x680B             LDR      R3,[R1, #+0]
   \       0x1E   0x6018             STR      R0,[R3, #+0]
    399            }
    400          
    401            /* Change the TIM state*/
    402            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Start_0: (+1)
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xF881 0x003D      STRB     R0,[R1, #+61]
    403          
    404            /* Return function status */
    405            return HAL_OK;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x4770             BX       LR
    406          }
    407          
    408          /**
    409            * @brief  Stops the TIM Base generation.
    410            * @param  htim TIM Base handle
    411            * @retval HAL status
    412            */

   \                                 In section .text, align 2, keep-with-next
    413          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    414          {
   \                     HAL_TIM_Base_Stop: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    415            /* Check the parameters */
    416            assert_param(IS_TIM_INSTANCE(htim->Instance));
    417          
    418            /* Set the TIM state */
    419            htim->State = HAL_TIM_STATE_BUSY;
   \        0x2   0x2002             MOVS     R0,#+2
   \        0x4   0xF881 0x003D      STRB     R0,[R1, #+61]
    420          
    421            /* Disable the Peripheral */
    422            __HAL_TIM_DISABLE(htim);
   \        0x8   0x6808             LDR      R0,[R1, #+0]
   \        0xA   0x6A00             LDR      R0,[R0, #+32]
   \        0xC   0xF241 0x1211      MOVW     R2,#+4369
   \       0x10   0x4210             TST      R0,R2
   \       0x12   0xD10B             BNE.N    ??HAL_TIM_Base_Stop_0
   \       0x14   0x6808             LDR      R0,[R1, #+0]
   \       0x16   0x6A00             LDR      R0,[R0, #+32]
   \       0x18   0xF240 0x4244      MOVW     R2,#+1092
   \       0x1C   0x4210             TST      R0,R2
   \       0x1E   0xD105             BNE.N    ??HAL_TIM_Base_Stop_0
   \       0x20   0x6808             LDR      R0,[R1, #+0]
   \       0x22   0x6800             LDR      R0,[R0, #+0]
   \       0x24   0x0840             LSRS     R0,R0,#+1
   \       0x26   0x0040             LSLS     R0,R0,#+1
   \       0x28   0x680A             LDR      R2,[R1, #+0]
   \       0x2A   0x6010             STR      R0,[R2, #+0]
    423          
    424            /* Change the TIM state*/
    425            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_0: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xF881 0x003D      STRB     R0,[R1, #+61]
    426          
    427            /* Return function status */
    428            return HAL_OK;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x4770             BX       LR
    429          }
    430          
    431          /**
    432            * @brief  Starts the TIM Base generation in interrupt mode.
    433            * @param  htim TIM Base handle
    434            * @retval HAL status
    435            */

   \                                 In section .text, align 2, keep-with-next
    436          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    437          {
   \                     HAL_TIM_Base_Start_IT: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    438            uint32_t tmpsmcr;
    439          
    440            /* Check the parameters */
    441            assert_param(IS_TIM_INSTANCE(htim->Instance));
    442          
    443            /* Enable the TIM Update interrupt */
    444            __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
   \        0x2   0x6808             LDR      R0,[R1, #+0]
   \        0x4   0x68C0             LDR      R0,[R0, #+12]
   \        0x6   0xF050 0x0001      ORRS     R0,R0,#0x1
   \        0xA   0x680A             LDR      R2,[R1, #+0]
   \        0xC   0x60D0             STR      R0,[R2, #+12]
    445          
    446            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    447            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \        0xE   0x6808             LDR      R0,[R1, #+0]
   \       0x10   0x6882             LDR      R2,[R0, #+8]
   \       0x12   0xF012 0x0207      ANDS     R2,R2,#0x7
    448            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x16   0x2A06             CMP      R2,#+6
   \       0x18   0xD005             BEQ.N    ??HAL_TIM_Base_Start_IT_0
    449            {
    450              __HAL_TIM_ENABLE(htim);
   \       0x1A   0x6808             LDR      R0,[R1, #+0]
   \       0x1C   0x6800             LDR      R0,[R0, #+0]
   \       0x1E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x22   0x680B             LDR      R3,[R1, #+0]
   \       0x24   0x6018             STR      R0,[R3, #+0]
    451            }
    452          
    453            /* Return function status */
    454            return HAL_OK;
   \                     ??HAL_TIM_Base_Start_IT_0: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x4770             BX       LR
    455          }
    456          
    457          /**
    458            * @brief  Stops the TIM Base generation in interrupt mode.
    459            * @param  htim TIM Base handle
    460            * @retval HAL status
    461            */

   \                                 In section .text, align 2, keep-with-next
    462          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    463          {
   \                     HAL_TIM_Base_Stop_IT: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    464            /* Check the parameters */
    465            assert_param(IS_TIM_INSTANCE(htim->Instance));
    466            /* Disable the TIM Update interrupt */
    467            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
   \        0x2   0x6808             LDR      R0,[R1, #+0]
   \        0x4   0x68C0             LDR      R0,[R0, #+12]
   \        0x6   0x0840             LSRS     R0,R0,#+1
   \        0x8   0x0040             LSLS     R0,R0,#+1
   \        0xA   0x680A             LDR      R2,[R1, #+0]
   \        0xC   0x60D0             STR      R0,[R2, #+12]
    468          
    469            /* Disable the Peripheral */
    470            __HAL_TIM_DISABLE(htim);
   \        0xE   0x6808             LDR      R0,[R1, #+0]
   \       0x10   0x6A00             LDR      R0,[R0, #+32]
   \       0x12   0xF241 0x1211      MOVW     R2,#+4369
   \       0x16   0x4210             TST      R0,R2
   \       0x18   0xD10B             BNE.N    ??HAL_TIM_Base_Stop_IT_0
   \       0x1A   0x6808             LDR      R0,[R1, #+0]
   \       0x1C   0x6A00             LDR      R0,[R0, #+32]
   \       0x1E   0xF240 0x4244      MOVW     R2,#+1092
   \       0x22   0x4210             TST      R0,R2
   \       0x24   0xD105             BNE.N    ??HAL_TIM_Base_Stop_IT_0
   \       0x26   0x6808             LDR      R0,[R1, #+0]
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0x0840             LSRS     R0,R0,#+1
   \       0x2C   0x0040             LSLS     R0,R0,#+1
   \       0x2E   0x680A             LDR      R2,[R1, #+0]
   \       0x30   0x6010             STR      R0,[R2, #+0]
    471          
    472            /* Return function status */
    473            return HAL_OK;
   \                     ??HAL_TIM_Base_Stop_IT_0: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x4770             BX       LR
    474          }
    475          
    476          /**
    477            * @brief  Starts the TIM Base generation in DMA mode.
    478            * @param  htim TIM Base handle
    479            * @param  pData The source Buffer address.
    480            * @param  Length The length of data to be transferred from memory to peripheral.
    481            * @retval HAL status
    482            */

   \                                 In section .text, align 2, keep-with-next
    483          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    484          {
   \                     HAL_TIM_Base_Start_DMA: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0016             MOVS     R6,R2
    485            uint32_t tmpsmcr;
    486          
    487            /* Check the parameters */
    488            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    489          
    490            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0x8   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD101             BNE.N    ??HAL_TIM_Base_Start_DMA_0
    491            {
    492              return HAL_BUSY;
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE03A             B.N      ??HAL_TIM_Base_Start_DMA_1
    493            }
    494            else if (htim->State == HAL_TIM_STATE_READY)
   \                     ??HAL_TIM_Base_Start_DMA_0: (+1)
   \       0x14   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD10A             BNE.N    ??HAL_TIM_Base_Start_DMA_2
    495            {
    496              if ((pData == NULL) && (Length > 0U))
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD105             BNE.N    ??HAL_TIM_Base_Start_DMA_3
   \       0x20   0x0030             MOVS     R0,R6
   \       0x22   0xB280             UXTH     R0,R0
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD001             BEQ.N    ??HAL_TIM_Base_Start_DMA_3
    497              {
    498                return HAL_ERROR;
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE02E             B.N      ??HAL_TIM_Base_Start_DMA_1
    499              }
    500              else
    501              {
    502                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Start_DMA_3: (+1)
   \       0x2C   0x2002             MOVS     R0,#+2
   \       0x2E   0xF885 0x003D      STRB     R0,[R5, #+61]
    503              }
    504            }
    505            else
    506            {
    507              /* nothing to do */
    508            }
    509          
    510            /* Set the DMA Period elapsed callbacks */
    511            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_Base_Start_DMA_2: (+1)
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable13
   \       0x36   0x6A29             LDR      R1,[R5, #+32]
   \       0x38   0x63C8             STR      R0,[R1, #+60]
    512            htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \       0x3E   0x6A29             LDR      R1,[R5, #+32]
   \       0x40   0x6408             STR      R0,[R1, #+64]
    513          
    514            /* Set the DMA error callback */
    515            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \       0x42   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x46   0x6A29             LDR      R1,[R5, #+32]
   \       0x48   0x64C8             STR      R0,[R1, #+76]
    516          
    517            /* Enable the DMA stream */
    518            if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length) != HAL_OK)
   \       0x4A   0x0033             MOVS     R3,R6
   \       0x4C   0xB29B             UXTH     R3,R3
   \       0x4E   0x6828             LDR      R0,[R5, #+0]
   \       0x50   0xF110 0x022C      ADDS     R2,R0,#+44
   \       0x54   0x0021             MOVS     R1,R4
   \       0x56   0x6A28             LDR      R0,[R5, #+32]
   \       0x58   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD001             BEQ.N    ??HAL_TIM_Base_Start_DMA_4
    519            {
    520              return HAL_ERROR;
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0xE012             B.N      ??HAL_TIM_Base_Start_DMA_1
    521            }
    522          
    523            /* Enable the TIM Update DMA request */
    524            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
   \                     ??HAL_TIM_Base_Start_DMA_4: (+1)
   \       0x64   0x6828             LDR      R0,[R5, #+0]
   \       0x66   0x68C0             LDR      R0,[R0, #+12]
   \       0x68   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x6C   0x6829             LDR      R1,[R5, #+0]
   \       0x6E   0x60C8             STR      R0,[R1, #+12]
    525          
    526            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    527            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0x70   0x6828             LDR      R0,[R5, #+0]
   \       0x72   0x6881             LDR      R1,[R0, #+8]
   \       0x74   0xF011 0x0107      ANDS     R1,R1,#0x7
    528            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x78   0x2906             CMP      R1,#+6
   \       0x7A   0xD005             BEQ.N    ??HAL_TIM_Base_Start_DMA_5
    529            {
    530              __HAL_TIM_ENABLE(htim);
   \       0x7C   0x6828             LDR      R0,[R5, #+0]
   \       0x7E   0x6800             LDR      R0,[R0, #+0]
   \       0x80   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x84   0x682A             LDR      R2,[R5, #+0]
   \       0x86   0x6010             STR      R0,[R2, #+0]
    531            }
    532          
    533            /* Return function status */
    534            return HAL_OK;
   \                     ??HAL_TIM_Base_Start_DMA_5: (+1)
   \       0x88   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Base_Start_DMA_1: (+1)
   \       0x8A   0xBD70             POP      {R4-R6,PC}
    535          }
    536          
    537          /**
    538            * @brief  Stops the TIM Base generation in DMA mode.
    539            * @param  htim TIM Base handle
    540            * @retval HAL status
    541            */

   \                                 In section .text, align 2, keep-with-next
    542          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    543          {
   \                     HAL_TIM_Base_Stop_DMA: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    544            /* Check the parameters */
    545            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    546          
    547            /* Disable the TIM Update DMA request */
    548            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C0             LDR      R0,[R0, #+12]
   \        0x8   0xF430 0x7080      BICS     R0,R0,#0x100
   \        0xC   0x6821             LDR      R1,[R4, #+0]
   \        0xE   0x60C8             STR      R0,[R1, #+12]
    549          
    550            (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   \       0x10   0x6A20             LDR      R0,[R4, #+32]
   \       0x12   0x.... 0x....      BL       HAL_DMA_Abort_IT
    551          
    552            /* Disable the Peripheral */
    553            __HAL_TIM_DISABLE(htim);
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6A00             LDR      R0,[R0, #+32]
   \       0x1A   0xF241 0x1111      MOVW     R1,#+4369
   \       0x1E   0x4208             TST      R0,R1
   \       0x20   0xD10B             BNE.N    ??HAL_TIM_Base_Stop_DMA_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6A00             LDR      R0,[R0, #+32]
   \       0x26   0xF240 0x4144      MOVW     R1,#+1092
   \       0x2A   0x4208             TST      R0,R1
   \       0x2C   0xD105             BNE.N    ??HAL_TIM_Base_Stop_DMA_0
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x6800             LDR      R0,[R0, #+0]
   \       0x32   0x0840             LSRS     R0,R0,#+1
   \       0x34   0x0040             LSLS     R0,R0,#+1
   \       0x36   0x6821             LDR      R1,[R4, #+0]
   \       0x38   0x6008             STR      R0,[R1, #+0]
    554          
    555            /* Change the htim state */
    556            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_DMA_0: (+1)
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0xF884 0x003D      STRB     R0,[R4, #+61]
    557          
    558            /* Return function status */
    559            return HAL_OK;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD10             POP      {R4,PC}
    560          }
    561          
    562          /**
    563            * @}
    564            */
    565          
    566          /** @defgroup TIM_Exported_Functions_Group2 TIM Output Compare functions
    567            *  @brief    TIM Output Compare functions
    568            *
    569          @verbatim
    570            ==============================================================================
    571                            ##### TIM Output Compare functions #####
    572            ==============================================================================
    573            [..]
    574              This section provides functions allowing to:
    575              (+) Initialize and configure the TIM Output Compare.
    576              (+) De-initialize the TIM Output Compare.
    577              (+) Start the TIM Output Compare.
    578              (+) Stop the TIM Output Compare.
    579              (+) Start the TIM Output Compare and enable interrupt.
    580              (+) Stop the TIM Output Compare and disable interrupt.
    581              (+) Start the TIM Output Compare and enable DMA transfer.
    582              (+) Stop the TIM Output Compare and disable DMA transfer.
    583          
    584          @endverbatim
    585            * @{
    586            */
    587          /**
    588            * @brief  Initializes the TIM Output Compare according to the specified
    589            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
    590            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
    591            *         requires a timer reset to avoid unexpected direction
    592            *         due to DIR bit readonly in center aligned mode.
    593            *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
    594            * @param  htim TIM Output Compare handle
    595            * @retval HAL status
    596            */

   \                                 In section .text, align 2, keep-with-next
    597          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)
    598          {
   \                     HAL_TIM_OC_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    599            /* Check the TIM handle allocation */
    600            if (htim == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_TIM_OC_Init_0
    601            {
    602              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE014             B.N      ??HAL_TIM_OC_Init_1
    603            }
    604          
    605            /* Check the parameters */
    606            assert_param(IS_TIM_INSTANCE(htim->Instance));
    607            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    608            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    609            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    610          
    611            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OC_Init_0: (+1)
   \        0xC   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD105             BNE.N    ??HAL_TIM_OC_Init_2
    612            {
    613              /* Allocate lock resource and initialize it */
    614              htim->Lock = HAL_UNLOCKED;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xF884 0x003C      STRB     R0,[R4, #+60]
    615          
    616          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    617              /* Reset interrupt callbacks to legacy weak callbacks */
    618              TIM_ResetCallback(htim);
    619          
    620              if (htim->OC_MspInitCallback == NULL)
    621              {
    622                htim->OC_MspInitCallback = HAL_TIM_OC_MspInit;
    623              }
    624              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    625              htim->OC_MspInitCallback(htim);
    626          #else
    627              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    628              HAL_TIM_OC_MspInit(htim);
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       HAL_TIM_OC_MspInit
    629          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    630            }
    631          
    632            /* Set the TIM state */
    633            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Init_2: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xF884 0x003D      STRB     R0,[R4, #+61]
    634          
    635            /* Init the base time for the Output Compare */
    636            TIM_Base_SetConfig(htim->Instance,  &htim->Init);
   \       0x26   0x1D21             ADDS     R1,R4,#+4
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x.... 0x....      BL       TIM_Base_SetConfig
    637          
    638            /* Initialize the TIM state*/
    639            htim->State = HAL_TIM_STATE_READY;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xF884 0x003D      STRB     R0,[R4, #+61]
    640          
    641            return HAL_OK;
   \       0x34   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Init_1: (+1)
   \       0x36   0xBD10             POP      {R4,PC}
    642          }
    643          
    644          /**
    645            * @brief  DeInitializes the TIM peripheral
    646            * @param  htim TIM Output Compare handle
    647            * @retval HAL status
    648            */

   \                                 In section .text, align 2, keep-with-next
    649          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    650          {
   \                     HAL_TIM_OC_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    651            /* Check the parameters */
    652            assert_param(IS_TIM_INSTANCE(htim->Instance));
    653          
    654            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0xF884 0x003D      STRB     R0,[R4, #+61]
    655          
    656            /* Disable the TIM Peripheral Clock */
    657            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0xF241 0x1111      MOVW     R1,#+4369
   \       0x12   0x4208             TST      R0,R1
   \       0x14   0xD10B             BNE.N    ??HAL_TIM_OC_DeInit_0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6A00             LDR      R0,[R0, #+32]
   \       0x1A   0xF240 0x4144      MOVW     R1,#+1092
   \       0x1E   0x4208             TST      R0,R1
   \       0x20   0xD105             BNE.N    ??HAL_TIM_OC_DeInit_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x0840             LSRS     R0,R0,#+1
   \       0x28   0x0040             LSLS     R0,R0,#+1
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6008             STR      R0,[R1, #+0]
    658          
    659          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    660            if (htim->OC_MspDeInitCallback == NULL)
    661            {
    662              htim->OC_MspDeInitCallback = HAL_TIM_OC_MspDeInit;
    663            }
    664            /* DeInit the low level hardware */
    665            htim->OC_MspDeInitCallback(htim);
    666          #else
    667            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    668            HAL_TIM_OC_MspDeInit(htim);
   \                     ??HAL_TIM_OC_DeInit_0: (+1)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       HAL_TIM_OC_MspDeInit
    669          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    670          
    671            /* Change TIM state */
    672            htim->State = HAL_TIM_STATE_RESET;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF884 0x003D      STRB     R0,[R4, #+61]
    673          
    674            /* Release Lock */
    675            __HAL_UNLOCK(htim);
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xF884 0x003C      STRB     R0,[R4, #+60]
    676          
    677            return HAL_OK;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD10             POP      {R4,PC}
    678          }
    679          
    680          /**
    681            * @brief  Initializes the TIM Output Compare MSP.
    682            * @param  htim TIM Output Compare handle
    683            * @retval None
    684            */

   \                                 In section .text, align 2
    685          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    686          {
    687            /* Prevent unused argument(s) compilation warning */
    688            UNUSED(htim);
    689          
    690            /* NOTE : This function should not be modified, when the callback is needed,
    691                      the HAL_TIM_OC_MspInit could be implemented in the user file
    692             */
    693          }
   \                     HAL_TIM_OC_MspInit: (+1)
   \        0x0   0x4770             BX       LR
    694          
    695          /**
    696            * @brief  DeInitializes TIM Output Compare MSP.
    697            * @param  htim TIM Output Compare handle
    698            * @retval None
    699            */

   \                                 In section .text, align 2
    700          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    701          {
    702            /* Prevent unused argument(s) compilation warning */
    703            UNUSED(htim);
    704          
    705            /* NOTE : This function should not be modified, when the callback is needed,
    706                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    707             */
    708          }
   \                     HAL_TIM_OC_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
    709          
    710          /**
    711            * @brief  Starts the TIM Output Compare signal generation.
    712            * @param  htim TIM Output Compare handle
    713            * @param  Channel TIM Channel to be enabled
    714            *          This parameter can be one of the following values:
    715            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    716            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    717            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    718            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    719            * @retval HAL status
    720            */

   \                                 In section .text, align 2, keep-with-next
    721          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    722          {
   \                     HAL_TIM_OC_Start: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    723            uint32_t tmpsmcr;
    724          
    725            /* Check the parameters */
    726            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    727          
    728            /* Enable the Output compare channel */
    729            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \        0x6   0x2201             MOVS     R2,#+1
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x.... 0x....      BL       TIM_CCxChannelCmd
    730          
    731            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \       0x16   0x4288             CMP      R0,R1
   \       0x18   0xD004             BEQ.N    ??HAL_TIM_OC_Start_0
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD101             BNE.N    ??HAL_TIM_OC_Start_1
   \                     ??HAL_TIM_OC_Start_0: (+1)
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xE000             B.N      ??HAL_TIM_OC_Start_2
   \                     ??HAL_TIM_OC_Start_1: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Start_2: (+1)
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD005             BEQ.N    ??HAL_TIM_OC_Start_3
    732            {
    733              /* Enable the main output */
    734              __HAL_TIM_MOE_ENABLE(htim);
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6C40             LDR      R0,[R0, #+68]
   \       0x34   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0x38   0x6821             LDR      R1,[R4, #+0]
   \       0x3A   0x6448             STR      R0,[R1, #+68]
    735            }
    736          
    737            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    738            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIM_OC_Start_3: (+1)
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x6881             LDR      R1,[R0, #+8]
   \       0x40   0xF011 0x0107      ANDS     R1,R1,#0x7
    739            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x44   0x2906             CMP      R1,#+6
   \       0x46   0xD005             BEQ.N    ??HAL_TIM_OC_Start_4
    740            {
    741              __HAL_TIM_ENABLE(htim);
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x6800             LDR      R0,[R0, #+0]
   \       0x4C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x50   0x6822             LDR      R2,[R4, #+0]
   \       0x52   0x6010             STR      R0,[R2, #+0]
    742            }
    743          
    744            /* Return function status */
    745            return HAL_OK;
   \                     ??HAL_TIM_OC_Start_4: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xBD32             POP      {R1,R4,R5,PC}
    746          }
    747          
    748          /**
    749            * @brief  Stops the TIM Output Compare signal generation.
    750            * @param  htim TIM Output Compare handle
    751            * @param  Channel TIM Channel to be disabled
    752            *          This parameter can be one of the following values:
    753            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    754            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    755            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    756            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    757            * @retval HAL status
    758            */

   \                                 In section .text, align 2, keep-with-next
    759          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    760          {
   \                     HAL_TIM_OC_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    761            /* Check the parameters */
    762            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    763          
    764            /* Disable the Output compare channel */
    765            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x.... 0x....      BL       TIM_CCxChannelCmd
    766          
    767            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \       0x16   0x4288             CMP      R0,R1
   \       0x18   0xD004             BEQ.N    ??HAL_TIM_OC_Stop_0
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD101             BNE.N    ??HAL_TIM_OC_Stop_1
   \                     ??HAL_TIM_OC_Stop_0: (+1)
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xE000             B.N      ??HAL_TIM_OC_Stop_2
   \                     ??HAL_TIM_OC_Stop_1: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Stop_2: (+1)
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD011             BEQ.N    ??HAL_TIM_OC_Stop_3
    768            {
    769              /* Disable the Main Output */
    770              __HAL_TIM_MOE_DISABLE(htim);
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6A00             LDR      R0,[R0, #+32]
   \       0x34   0xF241 0x1111      MOVW     R1,#+4369
   \       0x38   0x4208             TST      R0,R1
   \       0x3A   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_4
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x6A00             LDR      R0,[R0, #+32]
   \       0x40   0xF240 0x4144      MOVW     R1,#+1092
   \       0x44   0x4208             TST      R0,R1
   \       0x46   0xD105             BNE.N    ??HAL_TIM_OC_Stop_4
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x6C40             LDR      R0,[R0, #+68]
   \       0x4C   0xF430 0x4000      BICS     R0,R0,#0x8000
   \       0x50   0x6821             LDR      R1,[R4, #+0]
   \       0x52   0x6448             STR      R0,[R1, #+68]
    771            }
    772          
    773            /* Disable the Peripheral */
    774            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OC_Stop_4: (+1)
   \                     ??HAL_TIM_OC_Stop_3: (+1)
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x6A00             LDR      R0,[R0, #+32]
   \       0x58   0xF241 0x1111      MOVW     R1,#+4369
   \       0x5C   0x4208             TST      R0,R1
   \       0x5E   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_5
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x6A00             LDR      R0,[R0, #+32]
   \       0x64   0xF240 0x4144      MOVW     R1,#+1092
   \       0x68   0x4208             TST      R0,R1
   \       0x6A   0xD105             BNE.N    ??HAL_TIM_OC_Stop_5
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x6800             LDR      R0,[R0, #+0]
   \       0x70   0x0840             LSRS     R0,R0,#+1
   \       0x72   0x0040             LSLS     R0,R0,#+1
   \       0x74   0x6821             LDR      R1,[R4, #+0]
   \       0x76   0x6008             STR      R0,[R1, #+0]
    775          
    776            /* Return function status */
    777            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_5: (+1)
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0xBD32             POP      {R1,R4,R5,PC}
    778          }
    779          
    780          /**
    781            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
    782            * @param  htim TIM Output Compare handle
    783            * @param  Channel TIM Channel to be enabled
    784            *          This parameter can be one of the following values:
    785            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    786            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    787            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    788            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    789            * @retval HAL status
    790            */

   \                                 In section .text, align 2, keep-with-next
    791          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    792          {
   \                     HAL_TIM_OC_Start_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    793            uint32_t tmpsmcr;
    794          
    795            /* Check the parameters */
    796            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    797          
    798            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ.N    ??HAL_TIM_OC_Start_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00B             BEQ.N    ??HAL_TIM_OC_Start_IT_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD010             BEQ.N    ??HAL_TIM_OC_Start_IT_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD015             BEQ.N    ??HAL_TIM_OC_Start_IT_3
   \       0x18   0xE01B             B.N      ??HAL_TIM_OC_Start_IT_4
    799            {
    800              case TIM_CHANNEL_1:
    801              {
    802                /* Enable the TIM Capture/Compare 1 interrupt */
    803                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Start_IT_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x60C8             STR      R0,[R1, #+12]
    804                break;
   \       0x26   0xE014             B.N      ??HAL_TIM_OC_Start_IT_5
    805              }
    806          
    807              case TIM_CHANNEL_2:
    808              {
    809                /* Enable the TIM Capture/Compare 2 interrupt */
    810                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Start_IT_1: (+1)
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x68C0             LDR      R0,[R0, #+12]
   \       0x2C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x60C8             STR      R0,[R1, #+12]
    811                break;
   \       0x34   0xE00D             B.N      ??HAL_TIM_OC_Start_IT_5
    812              }
    813          
    814              case TIM_CHANNEL_3:
    815              {
    816                /* Enable the TIM Capture/Compare 3 interrupt */
    817                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Start_IT_2: (+1)
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x68C0             LDR      R0,[R0, #+12]
   \       0x3A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0x3E   0x6821             LDR      R1,[R4, #+0]
   \       0x40   0x60C8             STR      R0,[R1, #+12]
    818                break;
   \       0x42   0xE006             B.N      ??HAL_TIM_OC_Start_IT_5
    819              }
    820          
    821              case TIM_CHANNEL_4:
    822              {
    823                /* Enable the TIM Capture/Compare 4 interrupt */
    824                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Start_IT_3: (+1)
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x60C8             STR      R0,[R1, #+12]
    825                break;
   \       0x50   0xE7FF             B.N      ??HAL_TIM_OC_Start_IT_5
    826              }
    827          
    828              default:
    829                break;
    830            }
    831          
    832            /* Enable the Output compare channel */
    833            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_IT_4: (+1)
   \                     ??HAL_TIM_OC_Start_IT_5: (+1)
   \       0x52   0x2201             MOVS     R2,#+1
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x.... 0x....      BL       TIM_CCxChannelCmd
    834          
    835            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \       0x62   0x4288             CMP      R0,R1
   \       0x64   0xD004             BEQ.N    ??HAL_TIM_OC_Start_IT_6
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \       0x6C   0x4288             CMP      R0,R1
   \       0x6E   0xD101             BNE.N    ??HAL_TIM_OC_Start_IT_7
   \                     ??HAL_TIM_OC_Start_IT_6: (+1)
   \       0x70   0x2001             MOVS     R0,#+1
   \       0x72   0xE000             B.N      ??HAL_TIM_OC_Start_IT_8
   \                     ??HAL_TIM_OC_Start_IT_7: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Start_IT_8: (+1)
   \       0x76   0xB2C0             UXTB     R0,R0
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD005             BEQ.N    ??HAL_TIM_OC_Start_IT_9
    836            {
    837              /* Enable the main output */
    838              __HAL_TIM_MOE_ENABLE(htim);
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x6C40             LDR      R0,[R0, #+68]
   \       0x80   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0x84   0x6821             LDR      R1,[R4, #+0]
   \       0x86   0x6448             STR      R0,[R1, #+68]
    839            }
    840          
    841            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    842            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIM_OC_Start_IT_9: (+1)
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6881             LDR      R1,[R0, #+8]
   \       0x8C   0xF011 0x0107      ANDS     R1,R1,#0x7
    843            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x90   0x2906             CMP      R1,#+6
   \       0x92   0xD005             BEQ.N    ??HAL_TIM_OC_Start_IT_10
    844            {
    845              __HAL_TIM_ENABLE(htim);
   \       0x94   0x6820             LDR      R0,[R4, #+0]
   \       0x96   0x6800             LDR      R0,[R0, #+0]
   \       0x98   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x9C   0x6822             LDR      R2,[R4, #+0]
   \       0x9E   0x6010             STR      R0,[R2, #+0]
    846            }
    847          
    848            /* Return function status */
    849            return HAL_OK;
   \                     ??HAL_TIM_OC_Start_IT_10: (+1)
   \       0xA0   0x2000             MOVS     R0,#+0
   \       0xA2   0xBD32             POP      {R1,R4,R5,PC}
    850          }
    851          
    852          /**
    853            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
    854            * @param  htim TIM Output Compare handle
    855            * @param  Channel TIM Channel to be disabled
    856            *          This parameter can be one of the following values:
    857            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    858            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    859            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    860            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    861            * @retval HAL status
    862            */

   \                                 In section .text, align 2, keep-with-next
    863          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    864          {
   \                     HAL_TIM_OC_Stop_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    865            /* Check the parameters */
    866            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    867          
    868            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ.N    ??HAL_TIM_OC_Stop_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00B             BEQ.N    ??HAL_TIM_OC_Stop_IT_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD010             BEQ.N    ??HAL_TIM_OC_Stop_IT_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD015             BEQ.N    ??HAL_TIM_OC_Stop_IT_3
   \       0x18   0xE01B             B.N      ??HAL_TIM_OC_Stop_IT_4
    869            {
    870              case TIM_CHANNEL_1:
    871              {
    872                /* Disable the TIM Capture/Compare 1 interrupt */
    873                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Stop_IT_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x60C8             STR      R0,[R1, #+12]
    874                break;
   \       0x26   0xE014             B.N      ??HAL_TIM_OC_Stop_IT_5
    875              }
    876          
    877              case TIM_CHANNEL_2:
    878              {
    879                /* Disable the TIM Capture/Compare 2 interrupt */
    880                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Stop_IT_1: (+1)
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x68C0             LDR      R0,[R0, #+12]
   \       0x2C   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x60C8             STR      R0,[R1, #+12]
    881                break;
   \       0x34   0xE00D             B.N      ??HAL_TIM_OC_Stop_IT_5
    882              }
    883          
    884              case TIM_CHANNEL_3:
    885              {
    886                /* Disable the TIM Capture/Compare 3 interrupt */
    887                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Stop_IT_2: (+1)
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x68C0             LDR      R0,[R0, #+12]
   \       0x3A   0xF030 0x0008      BICS     R0,R0,#0x8
   \       0x3E   0x6821             LDR      R1,[R4, #+0]
   \       0x40   0x60C8             STR      R0,[R1, #+12]
    888                break;
   \       0x42   0xE006             B.N      ??HAL_TIM_OC_Stop_IT_5
    889              }
    890          
    891              case TIM_CHANNEL_4:
    892              {
    893                /* Disable the TIM Capture/Compare 4 interrupt */
    894                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Stop_IT_3: (+1)
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0xF030 0x0010      BICS     R0,R0,#0x10
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x60C8             STR      R0,[R1, #+12]
    895                break;
   \       0x50   0xE7FF             B.N      ??HAL_TIM_OC_Stop_IT_5
    896              }
    897          
    898              default:
    899                break;
    900            }
    901          
    902            /* Disable the Output compare channel */
    903            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_OC_Stop_IT_4: (+1)
   \                     ??HAL_TIM_OC_Stop_IT_5: (+1)
   \       0x52   0x2200             MOVS     R2,#+0
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x.... 0x....      BL       TIM_CCxChannelCmd
    904          
    905            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \       0x62   0x4288             CMP      R0,R1
   \       0x64   0xD004             BEQ.N    ??HAL_TIM_OC_Stop_IT_6
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \       0x6C   0x4288             CMP      R0,R1
   \       0x6E   0xD101             BNE.N    ??HAL_TIM_OC_Stop_IT_7
   \                     ??HAL_TIM_OC_Stop_IT_6: (+1)
   \       0x70   0x2001             MOVS     R0,#+1
   \       0x72   0xE000             B.N      ??HAL_TIM_OC_Stop_IT_8
   \                     ??HAL_TIM_OC_Stop_IT_7: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Stop_IT_8: (+1)
   \       0x76   0xB2C0             UXTB     R0,R0
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD011             BEQ.N    ??HAL_TIM_OC_Stop_IT_9
    906            {
    907              /* Disable the Main Output */
    908              __HAL_TIM_MOE_DISABLE(htim);
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x6A00             LDR      R0,[R0, #+32]
   \       0x80   0xF241 0x1111      MOVW     R1,#+4369
   \       0x84   0x4208             TST      R0,R1
   \       0x86   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_IT_10
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6A00             LDR      R0,[R0, #+32]
   \       0x8C   0xF240 0x4144      MOVW     R1,#+1092
   \       0x90   0x4208             TST      R0,R1
   \       0x92   0xD105             BNE.N    ??HAL_TIM_OC_Stop_IT_10
   \       0x94   0x6820             LDR      R0,[R4, #+0]
   \       0x96   0x6C40             LDR      R0,[R0, #+68]
   \       0x98   0xF430 0x4000      BICS     R0,R0,#0x8000
   \       0x9C   0x6821             LDR      R1,[R4, #+0]
   \       0x9E   0x6448             STR      R0,[R1, #+68]
    909            }
    910          
    911            /* Disable the Peripheral */
    912            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OC_Stop_IT_10: (+1)
   \                     ??HAL_TIM_OC_Stop_IT_9: (+1)
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x6A00             LDR      R0,[R0, #+32]
   \       0xA4   0xF241 0x1111      MOVW     R1,#+4369
   \       0xA8   0x4208             TST      R0,R1
   \       0xAA   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_IT_11
   \       0xAC   0x6820             LDR      R0,[R4, #+0]
   \       0xAE   0x6A00             LDR      R0,[R0, #+32]
   \       0xB0   0xF240 0x4144      MOVW     R1,#+1092
   \       0xB4   0x4208             TST      R0,R1
   \       0xB6   0xD105             BNE.N    ??HAL_TIM_OC_Stop_IT_11
   \       0xB8   0x6820             LDR      R0,[R4, #+0]
   \       0xBA   0x6800             LDR      R0,[R0, #+0]
   \       0xBC   0x0840             LSRS     R0,R0,#+1
   \       0xBE   0x0040             LSLS     R0,R0,#+1
   \       0xC0   0x6821             LDR      R1,[R4, #+0]
   \       0xC2   0x6008             STR      R0,[R1, #+0]
    913          
    914            /* Return function status */
    915            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_IT_11: (+1)
   \       0xC4   0x2000             MOVS     R0,#+0
   \       0xC6   0xBD32             POP      {R1,R4,R5,PC}
    916          }
    917          
    918          /**
    919            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
    920            * @param  htim TIM Output Compare handle
    921            * @param  Channel TIM Channel to be enabled
    922            *          This parameter can be one of the following values:
    923            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    924            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    925            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    926            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    927            * @param  pData The source Buffer address.
    928            * @param  Length The length of data to be transferred from memory to TIM peripheral
    929            * @retval HAL status
    930            */

   \                                 In section .text, align 2, keep-with-next
    931          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    932          {
   \                     HAL_TIM_OC_Start_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0014             MOVS     R4,R2
   \        0x8   0x001F             MOVS     R7,R3
    933            uint32_t tmpsmcr;
    934          
    935            /* Check the parameters */
    936            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    937          
    938            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0xA   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD101             BNE.N    ??HAL_TIM_OC_Start_DMA_0
    939            {
    940              return HAL_BUSY;
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xE0C0             B.N      ??HAL_TIM_OC_Start_DMA_1
    941            }
    942            else if (htim->State == HAL_TIM_STATE_READY)
   \                     ??HAL_TIM_OC_Start_DMA_0: (+1)
   \       0x16   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD10A             BNE.N    ??HAL_TIM_OC_Start_DMA_2
    943            {
    944              if ((pData == NULL) && (Length > 0U))
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD105             BNE.N    ??HAL_TIM_OC_Start_DMA_3
   \       0x22   0x0038             MOVS     R0,R7
   \       0x24   0xB280             UXTH     R0,R0
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD001             BEQ.N    ??HAL_TIM_OC_Start_DMA_3
    945              {
    946                return HAL_ERROR;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE0B4             B.N      ??HAL_TIM_OC_Start_DMA_1
    947              }
    948              else
    949              {
    950                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Start_DMA_3: (+1)
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0xF885 0x003D      STRB     R0,[R5, #+61]
    951              }
    952            }
    953            else
    954            {
    955              /* nothing to do */
    956            }
    957          
    958            switch (Channel)
   \                     ??HAL_TIM_OC_Start_DMA_2: (+1)
   \       0x34   0x0030             MOVS     R0,R6
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD006             BEQ.N    ??HAL_TIM_OC_Start_DMA_4
   \       0x3A   0x2804             CMP      R0,#+4
   \       0x3C   0xD024             BEQ.N    ??HAL_TIM_OC_Start_DMA_5
   \       0x3E   0x2808             CMP      R0,#+8
   \       0x40   0xD042             BEQ.N    ??HAL_TIM_OC_Start_DMA_6
   \       0x42   0x280C             CMP      R0,#+12
   \       0x44   0xD060             BEQ.N    ??HAL_TIM_OC_Start_DMA_7
   \       0x46   0xE07F             B.N      ??HAL_TIM_OC_Start_DMA_8
    959            {
    960              case TIM_CHANNEL_1:
    961              {
    962                /* Set the DMA compare callbacks */
    963                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_4: (+1)
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x4C   0x6A69             LDR      R1,[R5, #+36]
   \       0x4E   0x63C8             STR      R0,[R1, #+60]
    964                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \       0x54   0x6A69             LDR      R1,[R5, #+36]
   \       0x56   0x6408             STR      R0,[R1, #+64]
    965          
    966                /* Set the DMA error callback */
    967                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x5C   0x6A69             LDR      R1,[R5, #+36]
   \       0x5E   0x64C8             STR      R0,[R1, #+76]
    968          
    969                /* Enable the DMA stream */
    970                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
   \       0x60   0x003B             MOVS     R3,R7
   \       0x62   0xB29B             UXTH     R3,R3
   \       0x64   0x6828             LDR      R0,[R5, #+0]
   \       0x66   0xF110 0x0234      ADDS     R2,R0,#+52
   \       0x6A   0x0021             MOVS     R1,R4
   \       0x6C   0x6A68             LDR      R0,[R5, #+36]
   \       0x6E   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD001             BEQ.N    ??HAL_TIM_OC_Start_DMA_9
    971                {
    972                  return HAL_ERROR;
   \       0x76   0x2001             MOVS     R0,#+1
   \       0x78   0xE08E             B.N      ??HAL_TIM_OC_Start_DMA_1
    973                }
    974          
    975                /* Enable the TIM Capture/Compare 1 DMA request */
    976                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_OC_Start_DMA_9: (+1)
   \       0x7A   0x6828             LDR      R0,[R5, #+0]
   \       0x7C   0x68C0             LDR      R0,[R0, #+12]
   \       0x7E   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0x82   0x6829             LDR      R1,[R5, #+0]
   \       0x84   0x60C8             STR      R0,[R1, #+12]
    977                break;
   \       0x86   0xE05F             B.N      ??HAL_TIM_OC_Start_DMA_10
    978              }
    979          
    980              case TIM_CHANNEL_2:
    981              {
    982                /* Set the DMA compare callbacks */
    983                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_5: (+1)
   \       0x88   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x8C   0x6AA9             LDR      R1,[R5, #+40]
   \       0x8E   0x63C8             STR      R0,[R1, #+60]
    984                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x90   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \       0x94   0x6AA9             LDR      R1,[R5, #+40]
   \       0x96   0x6408             STR      R0,[R1, #+64]
    985          
    986                /* Set the DMA error callback */
    987                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \       0x98   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0x9C   0x6AA9             LDR      R1,[R5, #+40]
   \       0x9E   0x64C8             STR      R0,[R1, #+76]
    988          
    989                /* Enable the DMA stream */
    990                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
   \       0xA0   0x003B             MOVS     R3,R7
   \       0xA2   0xB29B             UXTH     R3,R3
   \       0xA4   0x6828             LDR      R0,[R5, #+0]
   \       0xA6   0xF110 0x0238      ADDS     R2,R0,#+56
   \       0xAA   0x0021             MOVS     R1,R4
   \       0xAC   0x6AA8             LDR      R0,[R5, #+40]
   \       0xAE   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD001             BEQ.N    ??HAL_TIM_OC_Start_DMA_11
    991                {
    992                  return HAL_ERROR;
   \       0xB6   0x2001             MOVS     R0,#+1
   \       0xB8   0xE06E             B.N      ??HAL_TIM_OC_Start_DMA_1
    993                }
    994          
    995                /* Enable the TIM Capture/Compare 2 DMA request */
    996                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_OC_Start_DMA_11: (+1)
   \       0xBA   0x6828             LDR      R0,[R5, #+0]
   \       0xBC   0x68C0             LDR      R0,[R0, #+12]
   \       0xBE   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0xC2   0x6829             LDR      R1,[R5, #+0]
   \       0xC4   0x60C8             STR      R0,[R1, #+12]
    997                break;
   \       0xC6   0xE03F             B.N      ??HAL_TIM_OC_Start_DMA_10
    998              }
    999          
   1000              case TIM_CHANNEL_3:
   1001              {
   1002                /* Set the DMA compare callbacks */
   1003                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_6: (+1)
   \       0xC8   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0xCC   0x6AE9             LDR      R1,[R5, #+44]
   \       0xCE   0x63C8             STR      R0,[R1, #+60]
   1004                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0xD0   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \       0xD4   0x6AE9             LDR      R1,[R5, #+44]
   \       0xD6   0x6408             STR      R0,[R1, #+64]
   1005          
   1006                /* Set the DMA error callback */
   1007                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \       0xD8   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \       0xDC   0x6AE9             LDR      R1,[R5, #+44]
   \       0xDE   0x64C8             STR      R0,[R1, #+76]
   1008          
   1009                /* Enable the DMA stream */
   1010                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
   \       0xE0   0x003B             MOVS     R3,R7
   \       0xE2   0xB29B             UXTH     R3,R3
   \       0xE4   0x6828             LDR      R0,[R5, #+0]
   \       0xE6   0xF110 0x023C      ADDS     R2,R0,#+60
   \       0xEA   0x0021             MOVS     R1,R4
   \       0xEC   0x6AE8             LDR      R0,[R5, #+44]
   \       0xEE   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xF2   0x2800             CMP      R0,#+0
   \       0xF4   0xD001             BEQ.N    ??HAL_TIM_OC_Start_DMA_12
   1011                {
   1012                  return HAL_ERROR;
   \       0xF6   0x2001             MOVS     R0,#+1
   \       0xF8   0xE04E             B.N      ??HAL_TIM_OC_Start_DMA_1
   1013                }
   1014                /* Enable the TIM Capture/Compare 3 DMA request */
   1015                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_OC_Start_DMA_12: (+1)
   \       0xFA   0x6828             LDR      R0,[R5, #+0]
   \       0xFC   0x68C0             LDR      R0,[R0, #+12]
   \       0xFE   0xF450 0x6000      ORRS     R0,R0,#0x800
   \      0x102   0x6829             LDR      R1,[R5, #+0]
   \      0x104   0x60C8             STR      R0,[R1, #+12]
   1016                break;
   \      0x106   0xE01F             B.N      ??HAL_TIM_OC_Start_DMA_10
   1017              }
   1018          
   1019              case TIM_CHANNEL_4:
   1020              {
   1021                /* Set the DMA compare callbacks */
   1022                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_7: (+1)
   \      0x108   0x.... 0x....      LDR.W    R0,??DataTable14
   \      0x10C   0x6B29             LDR      R1,[R5, #+48]
   \      0x10E   0x63C8             STR      R0,[R1, #+60]
   1023                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \      0x110   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \      0x114   0x6B29             LDR      R1,[R5, #+48]
   \      0x116   0x6408             STR      R0,[R1, #+64]
   1024          
   1025                /* Set the DMA error callback */
   1026                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \      0x118   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \      0x11C   0x6B29             LDR      R1,[R5, #+48]
   \      0x11E   0x64C8             STR      R0,[R1, #+76]
   1027          
   1028                /* Enable the DMA stream */
   1029                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
   \      0x120   0x003B             MOVS     R3,R7
   \      0x122   0xB29B             UXTH     R3,R3
   \      0x124   0x6828             LDR      R0,[R5, #+0]
   \      0x126   0xF110 0x0240      ADDS     R2,R0,#+64
   \      0x12A   0x0021             MOVS     R1,R4
   \      0x12C   0x6B28             LDR      R0,[R5, #+48]
   \      0x12E   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x132   0x2800             CMP      R0,#+0
   \      0x134   0xD001             BEQ.N    ??HAL_TIM_OC_Start_DMA_13
   1030                {
   1031                  return HAL_ERROR;
   \      0x136   0x2001             MOVS     R0,#+1
   \      0x138   0xE02E             B.N      ??HAL_TIM_OC_Start_DMA_1
   1032                }
   1033                /* Enable the TIM Capture/Compare 4 DMA request */
   1034                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_OC_Start_DMA_13: (+1)
   \      0x13A   0x6828             LDR      R0,[R5, #+0]
   \      0x13C   0x68C0             LDR      R0,[R0, #+12]
   \      0x13E   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \      0x142   0x6829             LDR      R1,[R5, #+0]
   \      0x144   0x60C8             STR      R0,[R1, #+12]
   1035                break;
   \      0x146   0xE7FF             B.N      ??HAL_TIM_OC_Start_DMA_10
   1036              }
   1037          
   1038              default:
   1039                break;
   1040            }
   1041          
   1042            /* Enable the Output compare channel */
   1043            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_DMA_8: (+1)
   \                     ??HAL_TIM_OC_Start_DMA_10: (+1)
   \      0x148   0x2201             MOVS     R2,#+1
   \      0x14A   0x0031             MOVS     R1,R6
   \      0x14C   0x6828             LDR      R0,[R5, #+0]
   \      0x14E   0x.... 0x....      BL       TIM_CCxChannelCmd
   1044          
   1045            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \      0x152   0x6828             LDR      R0,[R5, #+0]
   \      0x154   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \      0x158   0x4288             CMP      R0,R1
   \      0x15A   0xD004             BEQ.N    ??HAL_TIM_OC_Start_DMA_14
   \      0x15C   0x6828             LDR      R0,[R5, #+0]
   \      0x15E   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \      0x162   0x4288             CMP      R0,R1
   \      0x164   0xD101             BNE.N    ??HAL_TIM_OC_Start_DMA_15
   \                     ??HAL_TIM_OC_Start_DMA_14: (+1)
   \      0x166   0x2001             MOVS     R0,#+1
   \      0x168   0xE000             B.N      ??HAL_TIM_OC_Start_DMA_16
   \                     ??HAL_TIM_OC_Start_DMA_15: (+1)
   \      0x16A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Start_DMA_16: (+1)
   \      0x16C   0xB2C0             UXTB     R0,R0
   \      0x16E   0x2800             CMP      R0,#+0
   \      0x170   0xD005             BEQ.N    ??HAL_TIM_OC_Start_DMA_17
   1046            {
   1047              /* Enable the main output */
   1048              __HAL_TIM_MOE_ENABLE(htim);
   \      0x172   0x6828             LDR      R0,[R5, #+0]
   \      0x174   0x6C40             LDR      R0,[R0, #+68]
   \      0x176   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \      0x17A   0x6829             LDR      R1,[R5, #+0]
   \      0x17C   0x6448             STR      R0,[R1, #+68]
   1049            }
   1050          
   1051            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1052            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIM_OC_Start_DMA_17: (+1)
   \      0x17E   0x6828             LDR      R0,[R5, #+0]
   \      0x180   0x6881             LDR      R1,[R0, #+8]
   \      0x182   0xF011 0x0107      ANDS     R1,R1,#0x7
   1053            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \      0x186   0x2906             CMP      R1,#+6
   \      0x188   0xD005             BEQ.N    ??HAL_TIM_OC_Start_DMA_18
   1054            {
   1055              __HAL_TIM_ENABLE(htim);
   \      0x18A   0x6828             LDR      R0,[R5, #+0]
   \      0x18C   0x6800             LDR      R0,[R0, #+0]
   \      0x18E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x192   0x682A             LDR      R2,[R5, #+0]
   \      0x194   0x6010             STR      R0,[R2, #+0]
   1056            }
   1057          
   1058            /* Return function status */
   1059            return HAL_OK;
   \                     ??HAL_TIM_OC_Start_DMA_18: (+1)
   \      0x196   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Start_DMA_1: (+1)
   \      0x198   0xBDF2             POP      {R1,R4-R7,PC}
   1060          }
   1061          
   1062          /**
   1063            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
   1064            * @param  htim TIM Output Compare handle
   1065            * @param  Channel TIM Channel to be disabled
   1066            *          This parameter can be one of the following values:
   1067            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1068            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1069            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1070            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1071            * @retval HAL status
   1072            */

   \                                 In section .text, align 2, keep-with-next
   1073          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1074          {
   \                     HAL_TIM_OC_Stop_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1075            /* Check the parameters */
   1076            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1077          
   1078            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ.N    ??HAL_TIM_OC_Stop_DMA_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00E             BEQ.N    ??HAL_TIM_OC_Stop_DMA_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD016             BEQ.N    ??HAL_TIM_OC_Stop_DMA_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD01E             BEQ.N    ??HAL_TIM_OC_Stop_DMA_3
   \       0x18   0xE027             B.N      ??HAL_TIM_OC_Stop_DMA_4
   1079            {
   1080              case TIM_CHANNEL_1:
   1081              {
   1082                /* Disable the TIM Capture/Compare 1 DMA request */
   1083                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_OC_Stop_DMA_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0xF430 0x7000      BICS     R0,R0,#0x200
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x60C8             STR      R0,[R1, #+12]
   1084                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x26   0x6A60             LDR      R0,[R4, #+36]
   \       0x28   0x.... 0x....      BL       HAL_DMA_Abort_IT
   1085                break;
   \       0x2C   0xE01D             B.N      ??HAL_TIM_OC_Stop_DMA_5
   1086              }
   1087          
   1088              case TIM_CHANNEL_2:
   1089              {
   1090                /* Disable the TIM Capture/Compare 2 DMA request */
   1091                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_OC_Stop_DMA_1: (+1)
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x68C0             LDR      R0,[R0, #+12]
   \       0x32   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x36   0x6821             LDR      R1,[R4, #+0]
   \       0x38   0x60C8             STR      R0,[R1, #+12]
   1092                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \       0x3A   0x6AA0             LDR      R0,[R4, #+40]
   \       0x3C   0x.... 0x....      BL       HAL_DMA_Abort_IT
   1093                break;
   \       0x40   0xE013             B.N      ??HAL_TIM_OC_Stop_DMA_5
   1094              }
   1095          
   1096              case TIM_CHANNEL_3:
   1097              {
   1098                /* Disable the TIM Capture/Compare 3 DMA request */
   1099                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_OC_Stop_DMA_2: (+1)
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x68C0             LDR      R0,[R0, #+12]
   \       0x46   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x4A   0x6821             LDR      R1,[R4, #+0]
   \       0x4C   0x60C8             STR      R0,[R1, #+12]
   1100                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   \       0x4E   0x6AE0             LDR      R0,[R4, #+44]
   \       0x50   0x.... 0x....      BL       HAL_DMA_Abort_IT
   1101                break;
   \       0x54   0xE009             B.N      ??HAL_TIM_OC_Stop_DMA_5
   1102              }
   1103          
   1104              case TIM_CHANNEL_4:
   1105              {
   1106                /* Disable the TIM Capture/Compare 4 interrupt */
   1107                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_OC_Stop_DMA_3: (+1)
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x68C0             LDR      R0,[R0, #+12]
   \       0x5A   0xF430 0x5080      BICS     R0,R0,#0x1000
   \       0x5E   0x6821             LDR      R1,[R4, #+0]
   \       0x60   0x60C8             STR      R0,[R1, #+12]
   1108                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   \       0x62   0x6B20             LDR      R0,[R4, #+48]
   \       0x64   0x.... 0x....      BL       HAL_DMA_Abort_IT
   1109                break;
   \       0x68   0xE7FF             B.N      ??HAL_TIM_OC_Stop_DMA_5
   1110              }
   1111          
   1112              default:
   1113                break;
   1114            }
   1115          
   1116            /* Disable the Output compare channel */
   1117            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_OC_Stop_DMA_4: (+1)
   \                     ??HAL_TIM_OC_Stop_DMA_5: (+1)
   \       0x6A   0x2200             MOVS     R2,#+0
   \       0x6C   0x0029             MOVS     R1,R5
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x.... 0x....      BL       TIM_CCxChannelCmd
   1118          
   1119            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \       0x7A   0x4288             CMP      R0,R1
   \       0x7C   0xD004             BEQ.N    ??HAL_TIM_OC_Stop_DMA_6
   \       0x7E   0x6820             LDR      R0,[R4, #+0]
   \       0x80   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \       0x84   0x4288             CMP      R0,R1
   \       0x86   0xD101             BNE.N    ??HAL_TIM_OC_Stop_DMA_7
   \                     ??HAL_TIM_OC_Stop_DMA_6: (+1)
   \       0x88   0x2001             MOVS     R0,#+1
   \       0x8A   0xE000             B.N      ??HAL_TIM_OC_Stop_DMA_8
   \                     ??HAL_TIM_OC_Stop_DMA_7: (+1)
   \       0x8C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Stop_DMA_8: (+1)
   \       0x8E   0xB2C0             UXTB     R0,R0
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD011             BEQ.N    ??HAL_TIM_OC_Stop_DMA_9
   1120            {
   1121              /* Disable the Main Output */
   1122              __HAL_TIM_MOE_DISABLE(htim);
   \       0x94   0x6820             LDR      R0,[R4, #+0]
   \       0x96   0x6A00             LDR      R0,[R0, #+32]
   \       0x98   0xF241 0x1111      MOVW     R1,#+4369
   \       0x9C   0x4208             TST      R0,R1
   \       0x9E   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_DMA_10
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x6A00             LDR      R0,[R0, #+32]
   \       0xA4   0xF240 0x4144      MOVW     R1,#+1092
   \       0xA8   0x4208             TST      R0,R1
   \       0xAA   0xD105             BNE.N    ??HAL_TIM_OC_Stop_DMA_10
   \       0xAC   0x6820             LDR      R0,[R4, #+0]
   \       0xAE   0x6C40             LDR      R0,[R0, #+68]
   \       0xB0   0xF430 0x4000      BICS     R0,R0,#0x8000
   \       0xB4   0x6821             LDR      R1,[R4, #+0]
   \       0xB6   0x6448             STR      R0,[R1, #+68]
   1123            }
   1124          
   1125            /* Disable the Peripheral */
   1126            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OC_Stop_DMA_10: (+1)
   \                     ??HAL_TIM_OC_Stop_DMA_9: (+1)
   \       0xB8   0x6820             LDR      R0,[R4, #+0]
   \       0xBA   0x6A00             LDR      R0,[R0, #+32]
   \       0xBC   0xF241 0x1111      MOVW     R1,#+4369
   \       0xC0   0x4208             TST      R0,R1
   \       0xC2   0xD10B             BNE.N    ??HAL_TIM_OC_Stop_DMA_11
   \       0xC4   0x6820             LDR      R0,[R4, #+0]
   \       0xC6   0x6A00             LDR      R0,[R0, #+32]
   \       0xC8   0xF240 0x4144      MOVW     R1,#+1092
   \       0xCC   0x4208             TST      R0,R1
   \       0xCE   0xD105             BNE.N    ??HAL_TIM_OC_Stop_DMA_11
   \       0xD0   0x6820             LDR      R0,[R4, #+0]
   \       0xD2   0x6800             LDR      R0,[R0, #+0]
   \       0xD4   0x0840             LSRS     R0,R0,#+1
   \       0xD6   0x0040             LSLS     R0,R0,#+1
   \       0xD8   0x6821             LDR      R1,[R4, #+0]
   \       0xDA   0x6008             STR      R0,[R1, #+0]
   1127          
   1128            /* Change the htim state */
   1129            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_Stop_DMA_11: (+1)
   \       0xDC   0x2001             MOVS     R0,#+1
   \       0xDE   0xF884 0x003D      STRB     R0,[R4, #+61]
   1130          
   1131            /* Return function status */
   1132            return HAL_OK;
   \       0xE2   0x2000             MOVS     R0,#+0
   \       0xE4   0xBD32             POP      {R1,R4,R5,PC}
   1133          }
   1134          
   1135          /**
   1136            * @}
   1137            */
   1138          
   1139          /** @defgroup TIM_Exported_Functions_Group3 TIM PWM functions
   1140            *  @brief    TIM PWM functions
   1141            *
   1142          @verbatim
   1143            ==============================================================================
   1144                                    ##### TIM PWM functions #####
   1145            ==============================================================================
   1146            [..]
   1147              This section provides functions allowing to:
   1148              (+) Initialize and configure the TIM PWM.
   1149              (+) De-initialize the TIM PWM.
   1150              (+) Start the TIM PWM.
   1151              (+) Stop the TIM PWM.
   1152              (+) Start the TIM PWM and enable interrupt.
   1153              (+) Stop the TIM PWM and disable interrupt.
   1154              (+) Start the TIM PWM and enable DMA transfer.
   1155              (+) Stop the TIM PWM and disable DMA transfer.
   1156          
   1157          @endverbatim
   1158            * @{
   1159            */
   1160          /**
   1161            * @brief  Initializes the TIM PWM Time Base according to the specified
   1162            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   1163            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   1164            *         requires a timer reset to avoid unexpected direction
   1165            *         due to DIR bit readonly in center aligned mode.
   1166            *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
   1167            * @param  htim TIM PWM handle
   1168            * @retval HAL status
   1169            */

   \                                 In section .text, align 2, keep-with-next
   1170          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
   1171          {
   \                     HAL_TIM_PWM_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1172            /* Check the TIM handle allocation */
   1173            if (htim == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_TIM_PWM_Init_0
   1174            {
   1175              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE014             B.N      ??HAL_TIM_PWM_Init_1
   1176            }
   1177          
   1178            /* Check the parameters */
   1179            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1180            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1181            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1182            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1183          
   1184            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_PWM_Init_0: (+1)
   \        0xC   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD105             BNE.N    ??HAL_TIM_PWM_Init_2
   1185            {
   1186              /* Allocate lock resource and initialize it */
   1187              htim->Lock = HAL_UNLOCKED;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xF884 0x003C      STRB     R0,[R4, #+60]
   1188          
   1189          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1190              /* Reset interrupt callbacks to legacy weak callbacks */
   1191              TIM_ResetCallback(htim);
   1192          
   1193              if (htim->PWM_MspInitCallback == NULL)
   1194              {
   1195                htim->PWM_MspInitCallback = HAL_TIM_PWM_MspInit;
   1196              }
   1197              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   1198              htim->PWM_MspInitCallback(htim);
   1199          #else
   1200              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1201              HAL_TIM_PWM_MspInit(htim);
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       HAL_TIM_PWM_MspInit
   1202          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1203            }
   1204          
   1205            /* Set the TIM state */
   1206            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Init_2: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xF884 0x003D      STRB     R0,[R4, #+61]
   1207          
   1208            /* Init the base time for the PWM */
   1209            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x26   0x1D21             ADDS     R1,R4,#+4
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x.... 0x....      BL       TIM_Base_SetConfig
   1210          
   1211            /* Initialize the TIM state*/
   1212            htim->State = HAL_TIM_STATE_READY;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xF884 0x003D      STRB     R0,[R4, #+61]
   1213          
   1214            return HAL_OK;
   \       0x34   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Init_1: (+1)
   \       0x36   0xBD10             POP      {R4,PC}
   1215          }
   1216          
   1217          /**
   1218            * @brief  DeInitializes the TIM peripheral
   1219            * @param  htim TIM PWM handle
   1220            * @retval HAL status
   1221            */

   \                                 In section .text, align 2, keep-with-next
   1222          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
   1223          {
   \                     HAL_TIM_PWM_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1224            /* Check the parameters */
   1225            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1226          
   1227            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0xF884 0x003D      STRB     R0,[R4, #+61]
   1228          
   1229            /* Disable the TIM Peripheral Clock */
   1230            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0xF241 0x1111      MOVW     R1,#+4369
   \       0x12   0x4208             TST      R0,R1
   \       0x14   0xD10B             BNE.N    ??HAL_TIM_PWM_DeInit_0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6A00             LDR      R0,[R0, #+32]
   \       0x1A   0xF240 0x4144      MOVW     R1,#+1092
   \       0x1E   0x4208             TST      R0,R1
   \       0x20   0xD105             BNE.N    ??HAL_TIM_PWM_DeInit_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x0840             LSRS     R0,R0,#+1
   \       0x28   0x0040             LSLS     R0,R0,#+1
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6008             STR      R0,[R1, #+0]
   1231          
   1232          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1233            if (htim->PWM_MspDeInitCallback == NULL)
   1234            {
   1235              htim->PWM_MspDeInitCallback = HAL_TIM_PWM_MspDeInit;
   1236            }
   1237            /* DeInit the low level hardware */
   1238            htim->PWM_MspDeInitCallback(htim);
   1239          #else
   1240            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1241            HAL_TIM_PWM_MspDeInit(htim);
   \                     ??HAL_TIM_PWM_DeInit_0: (+1)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       HAL_TIM_PWM_MspDeInit
   1242          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1243          
   1244            /* Change TIM state */
   1245            htim->State = HAL_TIM_STATE_RESET;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF884 0x003D      STRB     R0,[R4, #+61]
   1246          
   1247            /* Release Lock */
   1248            __HAL_UNLOCK(htim);
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xF884 0x003C      STRB     R0,[R4, #+60]
   1249          
   1250            return HAL_OK;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD10             POP      {R4,PC}
   1251          }
   1252          
   1253          /**
   1254            * @brief  Initializes the TIM PWM MSP.
   1255            * @param  htim TIM PWM handle
   1256            * @retval None
   1257            */

   \                                 In section .text, align 2
   1258          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
   1259          {
   1260            /* Prevent unused argument(s) compilation warning */
   1261            UNUSED(htim);
   1262          
   1263            /* NOTE : This function should not be modified, when the callback is needed,
   1264                      the HAL_TIM_PWM_MspInit could be implemented in the user file
   1265             */
   1266          }
   \                     HAL_TIM_PWM_MspInit: (+1)
   \        0x0   0x4770             BX       LR
   1267          
   1268          /**
   1269            * @brief  DeInitializes TIM PWM MSP.
   1270            * @param  htim TIM PWM handle
   1271            * @retval None
   1272            */

   \                                 In section .text, align 2
   1273          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
   1274          {
   1275            /* Prevent unused argument(s) compilation warning */
   1276            UNUSED(htim);
   1277          
   1278            /* NOTE : This function should not be modified, when the callback is needed,
   1279                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   1280             */
   1281          }
   \                     HAL_TIM_PWM_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
   1282          
   1283          /**
   1284            * @brief  Starts the PWM signal generation.
   1285            * @param  htim TIM handle
   1286            * @param  Channel TIM Channels to be enabled
   1287            *          This parameter can be one of the following values:
   1288            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1289            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1290            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1291            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1292            * @retval HAL status
   1293            */

   \                                 In section .text, align 2, keep-with-next
   1294          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1295          {
   \                     HAL_TIM_PWM_Start: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1296            uint32_t tmpsmcr;
   1297          
   1298            /* Check the parameters */
   1299            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1300          
   1301            /* Enable the Capture compare channel */
   1302            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \        0x6   0x2201             MOVS     R2,#+1
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x.... 0x....      BL       TIM_CCxChannelCmd
   1303          
   1304            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \       0x16   0x4288             CMP      R0,R1
   \       0x18   0xD004             BEQ.N    ??HAL_TIM_PWM_Start_0
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD101             BNE.N    ??HAL_TIM_PWM_Start_1
   \                     ??HAL_TIM_PWM_Start_0: (+1)
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xE000             B.N      ??HAL_TIM_PWM_Start_2
   \                     ??HAL_TIM_PWM_Start_1: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Start_2: (+1)
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD005             BEQ.N    ??HAL_TIM_PWM_Start_3
   1305            {
   1306              /* Enable the main output */
   1307              __HAL_TIM_MOE_ENABLE(htim);
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6C40             LDR      R0,[R0, #+68]
   \       0x34   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0x38   0x6821             LDR      R1,[R4, #+0]
   \       0x3A   0x6448             STR      R0,[R1, #+68]
   1308            }
   1309          
   1310            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1311            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIM_PWM_Start_3: (+1)
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x6881             LDR      R1,[R0, #+8]
   \       0x40   0xF011 0x0107      ANDS     R1,R1,#0x7
   1312            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x44   0x2906             CMP      R1,#+6
   \       0x46   0xD005             BEQ.N    ??HAL_TIM_PWM_Start_4
   1313            {
   1314              __HAL_TIM_ENABLE(htim);
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x6800             LDR      R0,[R0, #+0]
   \       0x4C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x50   0x6822             LDR      R2,[R4, #+0]
   \       0x52   0x6010             STR      R0,[R2, #+0]
   1315            }
   1316          
   1317            /* Return function status */
   1318            return HAL_OK;
   \                     ??HAL_TIM_PWM_Start_4: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xBD32             POP      {R1,R4,R5,PC}
   1319          }
   1320          
   1321          /**
   1322            * @brief  Stops the PWM signal generation.
   1323            * @param  htim TIM PWM handle
   1324            * @param  Channel TIM Channels to be disabled
   1325            *          This parameter can be one of the following values:
   1326            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1327            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1328            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1329            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1330            * @retval HAL status
   1331            */

   \                                 In section .text, align 2, keep-with-next
   1332          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1333          {
   \                     HAL_TIM_PWM_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1334            /* Check the parameters */
   1335            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1336          
   1337            /* Disable the Capture compare channel */
   1338            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x.... 0x....      BL       TIM_CCxChannelCmd
   1339          
   1340            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \       0x16   0x4288             CMP      R0,R1
   \       0x18   0xD004             BEQ.N    ??HAL_TIM_PWM_Stop_0
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD101             BNE.N    ??HAL_TIM_PWM_Stop_1
   \                     ??HAL_TIM_PWM_Stop_0: (+1)
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xE000             B.N      ??HAL_TIM_PWM_Stop_2
   \                     ??HAL_TIM_PWM_Stop_1: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Stop_2: (+1)
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD011             BEQ.N    ??HAL_TIM_PWM_Stop_3
   1341            {
   1342              /* Disable the Main Output */
   1343              __HAL_TIM_MOE_DISABLE(htim);
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6A00             LDR      R0,[R0, #+32]
   \       0x34   0xF241 0x1111      MOVW     R1,#+4369
   \       0x38   0x4208             TST      R0,R1
   \       0x3A   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_4
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x6A00             LDR      R0,[R0, #+32]
   \       0x40   0xF240 0x4144      MOVW     R1,#+1092
   \       0x44   0x4208             TST      R0,R1
   \       0x46   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_4
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x6C40             LDR      R0,[R0, #+68]
   \       0x4C   0xF430 0x4000      BICS     R0,R0,#0x8000
   \       0x50   0x6821             LDR      R1,[R4, #+0]
   \       0x52   0x6448             STR      R0,[R1, #+68]
   1344            }
   1345          
   1346            /* Disable the Peripheral */
   1347            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_4: (+1)
   \                     ??HAL_TIM_PWM_Stop_3: (+1)
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x6A00             LDR      R0,[R0, #+32]
   \       0x58   0xF241 0x1111      MOVW     R1,#+4369
   \       0x5C   0x4208             TST      R0,R1
   \       0x5E   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_5
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x6A00             LDR      R0,[R0, #+32]
   \       0x64   0xF240 0x4144      MOVW     R1,#+1092
   \       0x68   0x4208             TST      R0,R1
   \       0x6A   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_5
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x6800             LDR      R0,[R0, #+0]
   \       0x70   0x0840             LSRS     R0,R0,#+1
   \       0x72   0x0040             LSLS     R0,R0,#+1
   \       0x74   0x6821             LDR      R1,[R4, #+0]
   \       0x76   0x6008             STR      R0,[R1, #+0]
   1348          
   1349            /* Change the htim state */
   1350            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_5: (+1)
   \       0x78   0x2001             MOVS     R0,#+1
   \       0x7A   0xF884 0x003D      STRB     R0,[R4, #+61]
   1351          
   1352            /* Return function status */
   1353            return HAL_OK;
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0xBD32             POP      {R1,R4,R5,PC}
   1354          }
   1355          
   1356          /**
   1357            * @brief  Starts the PWM signal generation in interrupt mode.
   1358            * @param  htim TIM PWM handle
   1359            * @param  Channel TIM Channel to be enabled
   1360            *          This parameter can be one of the following values:
   1361            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1362            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1363            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1364            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1365            * @retval HAL status
   1366            */

   \                                 In section .text, align 2, keep-with-next
   1367          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1368          {
   \                     HAL_TIM_PWM_Start_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1369            uint32_t tmpsmcr;
   1370            /* Check the parameters */
   1371            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1372          
   1373            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ.N    ??HAL_TIM_PWM_Start_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00B             BEQ.N    ??HAL_TIM_PWM_Start_IT_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD010             BEQ.N    ??HAL_TIM_PWM_Start_IT_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD015             BEQ.N    ??HAL_TIM_PWM_Start_IT_3
   \       0x18   0xE01B             B.N      ??HAL_TIM_PWM_Start_IT_4
   1374            {
   1375              case TIM_CHANNEL_1:
   1376              {
   1377                /* Enable the TIM Capture/Compare 1 interrupt */
   1378                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Start_IT_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x60C8             STR      R0,[R1, #+12]
   1379                break;
   \       0x26   0xE014             B.N      ??HAL_TIM_PWM_Start_IT_5
   1380              }
   1381          
   1382              case TIM_CHANNEL_2:
   1383              {
   1384                /* Enable the TIM Capture/Compare 2 interrupt */
   1385                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Start_IT_1: (+1)
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x68C0             LDR      R0,[R0, #+12]
   \       0x2C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x60C8             STR      R0,[R1, #+12]
   1386                break;
   \       0x34   0xE00D             B.N      ??HAL_TIM_PWM_Start_IT_5
   1387              }
   1388          
   1389              case TIM_CHANNEL_3:
   1390              {
   1391                /* Enable the TIM Capture/Compare 3 interrupt */
   1392                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Start_IT_2: (+1)
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x68C0             LDR      R0,[R0, #+12]
   \       0x3A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0x3E   0x6821             LDR      R1,[R4, #+0]
   \       0x40   0x60C8             STR      R0,[R1, #+12]
   1393                break;
   \       0x42   0xE006             B.N      ??HAL_TIM_PWM_Start_IT_5
   1394              }
   1395          
   1396              case TIM_CHANNEL_4:
   1397              {
   1398                /* Enable the TIM Capture/Compare 4 interrupt */
   1399                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Start_IT_3: (+1)
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x60C8             STR      R0,[R1, #+12]
   1400                break;
   \       0x50   0xE7FF             B.N      ??HAL_TIM_PWM_Start_IT_5
   1401              }
   1402          
   1403              default:
   1404                break;
   1405            }
   1406          
   1407            /* Enable the Capture compare channel */
   1408            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_IT_4: (+1)
   \                     ??HAL_TIM_PWM_Start_IT_5: (+1)
   \       0x52   0x2201             MOVS     R2,#+1
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x.... 0x....      BL       TIM_CCxChannelCmd
   1409          
   1410            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x.... 0x....      LDR.W    R1,??DataTable13_3
   \       0x62   0x4288             CMP      R0,R1
   \       0x64   0xD004             BEQ.N    ??HAL_TIM_PWM_Start_IT_6
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \       0x6C   0x4288             CMP      R0,R1
   \       0x6E   0xD101             BNE.N    ??HAL_TIM_PWM_Start_IT_7
   \                     ??HAL_TIM_PWM_Start_IT_6: (+1)
   \       0x70   0x2001             MOVS     R0,#+1
   \       0x72   0xE000             B.N      ??HAL_TIM_PWM_Start_IT_8
   \                     ??HAL_TIM_PWM_Start_IT_7: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Start_IT_8: (+1)
   \       0x76   0xB2C0             UXTB     R0,R0
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD005             BEQ.N    ??HAL_TIM_PWM_Start_IT_9
   1411            {
   1412              /* Enable the main output */
   1413              __HAL_TIM_MOE_ENABLE(htim);
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x6C40             LDR      R0,[R0, #+68]
   \       0x80   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0x84   0x6821             LDR      R1,[R4, #+0]
   \       0x86   0x6448             STR      R0,[R1, #+68]
   1414            }
   1415          
   1416            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1417            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIM_PWM_Start_IT_9: (+1)
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6881             LDR      R1,[R0, #+8]
   \       0x8C   0xF011 0x0107      ANDS     R1,R1,#0x7
   1418            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x90   0x2906             CMP      R1,#+6
   \       0x92   0xD005             BEQ.N    ??HAL_TIM_PWM_Start_IT_10
   1419            {
   1420              __HAL_TIM_ENABLE(htim);
   \       0x94   0x6820             LDR      R0,[R4, #+0]
   \       0x96   0x6800             LDR      R0,[R0, #+0]
   \       0x98   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x9C   0x6822             LDR      R2,[R4, #+0]
   \       0x9E   0x6010             STR      R0,[R2, #+0]
   1421            }
   1422          
   1423            /* Return function status */
   1424            return HAL_OK;
   \                     ??HAL_TIM_PWM_Start_IT_10: (+1)
   \       0xA0   0x2000             MOVS     R0,#+0
   \       0xA2   0xBD32             POP      {R1,R4,R5,PC}
   1425          }
   1426          
   1427          /**
   1428            * @brief  Stops the PWM signal generation in interrupt mode.
   1429            * @param  htim TIM PWM handle
   1430            * @param  Channel TIM Channels to be disabled
   1431            *          This parameter can be one of the following values:
   1432            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1433            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1434            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1435            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1436            * @retval HAL status
   1437            */

   \                                 In section .text, align 2, keep-with-next
   1438          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1439          {
   \                     HAL_TIM_PWM_Stop_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1440            /* Check the parameters */
   1441            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1442          
   1443            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ.N    ??HAL_TIM_PWM_Stop_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00B             BEQ.N    ??HAL_TIM_PWM_Stop_IT_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD010             BEQ.N    ??HAL_TIM_PWM_Stop_IT_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD015             BEQ.N    ??HAL_TIM_PWM_Stop_IT_3
   \       0x18   0xE01B             B.N      ??HAL_TIM_PWM_Stop_IT_4
   1444            {
   1445              case TIM_CHANNEL_1:
   1446              {
   1447                /* Disable the TIM Capture/Compare 1 interrupt */
   1448                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Stop_IT_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x60C8             STR      R0,[R1, #+12]
   1449                break;
   \       0x26   0xE014             B.N      ??HAL_TIM_PWM_Stop_IT_5
   1450              }
   1451          
   1452              case TIM_CHANNEL_2:
   1453              {
   1454                /* Disable the TIM Capture/Compare 2 interrupt */
   1455                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Stop_IT_1: (+1)
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x68C0             LDR      R0,[R0, #+12]
   \       0x2C   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x60C8             STR      R0,[R1, #+12]
   1456                break;
   \       0x34   0xE00D             B.N      ??HAL_TIM_PWM_Stop_IT_5
   1457              }
   1458          
   1459              case TIM_CHANNEL_3:
   1460              {
   1461                /* Disable the TIM Capture/Compare 3 interrupt */
   1462                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Stop_IT_2: (+1)
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x68C0             LDR      R0,[R0, #+12]
   \       0x3A   0xF030 0x0008      BICS     R0,R0,#0x8
   \       0x3E   0x6821             LDR      R1,[R4, #+0]
   \       0x40   0x60C8             STR      R0,[R1, #+12]
   1463                break;
   \       0x42   0xE006             B.N      ??HAL_TIM_PWM_Stop_IT_5
   1464              }
   1465          
   1466              case TIM_CHANNEL_4:
   1467              {
   1468                /* Disable the TIM Capture/Compare 4 interrupt */
   1469                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Stop_IT_3: (+1)
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0xF030 0x0010      BICS     R0,R0,#0x10
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x60C8             STR      R0,[R1, #+12]
   1470                break;
   \       0x50   0xE7FF             B.N      ??HAL_TIM_PWM_Stop_IT_5
   1471              }
   1472          
   1473              default:
   1474                break;
   1475            }
   1476          
   1477            /* Disable the Capture compare channel */
   1478            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_IT_4: (+1)
   \                     ??HAL_TIM_PWM_Stop_IT_5: (+1)
   \       0x52   0x2200             MOVS     R2,#+0
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x.... 0x....      BL       TIM_CCxChannelCmd
   1479          
   1480            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x....             LDR.N    R1,??DataTable13_3
   \       0x60   0x4288             CMP      R0,R1
   \       0x62   0xD003             BEQ.N    ??HAL_TIM_PWM_Stop_IT_6
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x....             LDR.N    R1,??DataTable13_4
   \       0x68   0x4288             CMP      R0,R1
   \       0x6A   0xD101             BNE.N    ??HAL_TIM_PWM_Stop_IT_7
   \                     ??HAL_TIM_PWM_Stop_IT_6: (+1)
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0xE000             B.N      ??HAL_TIM_PWM_Stop_IT_8
   \                     ??HAL_TIM_PWM_Stop_IT_7: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Stop_IT_8: (+1)
   \       0x72   0xB2C0             UXTB     R0,R0
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD011             BEQ.N    ??HAL_TIM_PWM_Stop_IT_9
   1481            {
   1482              /* Disable the Main Output */
   1483              __HAL_TIM_MOE_DISABLE(htim);
   \       0x78   0x6820             LDR      R0,[R4, #+0]
   \       0x7A   0x6A00             LDR      R0,[R0, #+32]
   \       0x7C   0xF241 0x1111      MOVW     R1,#+4369
   \       0x80   0x4208             TST      R0,R1
   \       0x82   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_IT_10
   \       0x84   0x6820             LDR      R0,[R4, #+0]
   \       0x86   0x6A00             LDR      R0,[R0, #+32]
   \       0x88   0xF240 0x4144      MOVW     R1,#+1092
   \       0x8C   0x4208             TST      R0,R1
   \       0x8E   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_IT_10
   \       0x90   0x6820             LDR      R0,[R4, #+0]
   \       0x92   0x6C40             LDR      R0,[R0, #+68]
   \       0x94   0xF430 0x4000      BICS     R0,R0,#0x8000
   \       0x98   0x6821             LDR      R1,[R4, #+0]
   \       0x9A   0x6448             STR      R0,[R1, #+68]
   1484            }
   1485          
   1486            /* Disable the Peripheral */
   1487            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_IT_10: (+1)
   \                     ??HAL_TIM_PWM_Stop_IT_9: (+1)
   \       0x9C   0x6820             LDR      R0,[R4, #+0]
   \       0x9E   0x6A00             LDR      R0,[R0, #+32]
   \       0xA0   0xF241 0x1111      MOVW     R1,#+4369
   \       0xA4   0x4208             TST      R0,R1
   \       0xA6   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_IT_11
   \       0xA8   0x6820             LDR      R0,[R4, #+0]
   \       0xAA   0x6A00             LDR      R0,[R0, #+32]
   \       0xAC   0xF240 0x4144      MOVW     R1,#+1092
   \       0xB0   0x4208             TST      R0,R1
   \       0xB2   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_IT_11
   \       0xB4   0x6820             LDR      R0,[R4, #+0]
   \       0xB6   0x6800             LDR      R0,[R0, #+0]
   \       0xB8   0x0840             LSRS     R0,R0,#+1
   \       0xBA   0x0040             LSLS     R0,R0,#+1
   \       0xBC   0x6821             LDR      R1,[R4, #+0]
   \       0xBE   0x6008             STR      R0,[R1, #+0]
   1488          
   1489            /* Return function status */
   1490            return HAL_OK;
   \                     ??HAL_TIM_PWM_Stop_IT_11: (+1)
   \       0xC0   0x2000             MOVS     R0,#+0
   \       0xC2   0xBD32             POP      {R1,R4,R5,PC}
   1491          }
   1492          
   1493          /**
   1494            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1495            * @param  htim TIM PWM handle
   1496            * @param  Channel TIM Channels to be enabled
   1497            *          This parameter can be one of the following values:
   1498            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1499            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1500            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1501            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1502            * @param  pData The source Buffer address.
   1503            * @param  Length The length of data to be transferred from memory to TIM peripheral
   1504            * @retval HAL status
   1505            */

   \                                 In section .text, align 2, keep-with-next
   1506          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1507          {
   \                     HAL_TIM_PWM_Start_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0014             MOVS     R4,R2
   \        0x8   0x001F             MOVS     R7,R3
   1508            uint32_t tmpsmcr;
   1509          
   1510            /* Check the parameters */
   1511            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1512          
   1513            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0xA   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD101             BNE.N    ??HAL_TIM_PWM_Start_DMA_0
   1514            {
   1515              return HAL_BUSY;
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xE0BA             B.N      ??HAL_TIM_PWM_Start_DMA_1
   1516            }
   1517            else if (htim->State == HAL_TIM_STATE_READY)
   \                     ??HAL_TIM_PWM_Start_DMA_0: (+1)
   \       0x16   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD10A             BNE.N    ??HAL_TIM_PWM_Start_DMA_2
   1518            {
   1519              if ((pData == NULL) && (Length > 0U))
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD105             BNE.N    ??HAL_TIM_PWM_Start_DMA_3
   \       0x22   0x0038             MOVS     R0,R7
   \       0x24   0xB280             UXTH     R0,R0
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD001             BEQ.N    ??HAL_TIM_PWM_Start_DMA_3
   1520              {
   1521                return HAL_ERROR;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE0AE             B.N      ??HAL_TIM_PWM_Start_DMA_1
   1522              }
   1523              else
   1524              {
   1525                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Start_DMA_3: (+1)
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0xF885 0x003D      STRB     R0,[R5, #+61]
   1526              }
   1527            }
   1528            else
   1529            {
   1530              /* nothing to do */
   1531            }
   1532          
   1533            switch (Channel)
   \                     ??HAL_TIM_PWM_Start_DMA_2: (+1)
   \       0x34   0x0030             MOVS     R0,R6
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD006             BEQ.N    ??HAL_TIM_PWM_Start_DMA_4
   \       0x3A   0x2804             CMP      R0,#+4
   \       0x3C   0xD023             BEQ.N    ??HAL_TIM_PWM_Start_DMA_5
   \       0x3E   0x2808             CMP      R0,#+8
   \       0x40   0xD040             BEQ.N    ??HAL_TIM_PWM_Start_DMA_6
   \       0x42   0x280C             CMP      R0,#+12
   \       0x44   0xD05D             BEQ.N    ??HAL_TIM_PWM_Start_DMA_7
   \       0x46   0xE07B             B.N      ??HAL_TIM_PWM_Start_DMA_8
   1534            {
   1535              case TIM_CHANNEL_1:
   1536              {
   1537                /* Set the DMA compare callbacks */
   1538                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_4: (+1)
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x4C   0x6A69             LDR      R1,[R5, #+36]
   \       0x4E   0x63C8             STR      R0,[R1, #+60]
   1539                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \       0x54   0x6A69             LDR      R1,[R5, #+36]
   \       0x56   0x6408             STR      R0,[R1, #+64]
   1540          
   1541                /* Set the DMA error callback */
   1542                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0x58   0x....             LDR.N    R0,??DataTable13_2
   \       0x5A   0x6A69             LDR      R1,[R5, #+36]
   \       0x5C   0x64C8             STR      R0,[R1, #+76]
   1543          
   1544                /* Enable the DMA stream */
   1545                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
   \       0x5E   0x003B             MOVS     R3,R7
   \       0x60   0xB29B             UXTH     R3,R3
   \       0x62   0x6828             LDR      R0,[R5, #+0]
   \       0x64   0xF110 0x0234      ADDS     R2,R0,#+52
   \       0x68   0x0021             MOVS     R1,R4
   \       0x6A   0x6A68             LDR      R0,[R5, #+36]
   \       0x6C   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD001             BEQ.N    ??HAL_TIM_PWM_Start_DMA_9
   1546                {
   1547                  return HAL_ERROR;
   \       0x74   0x2001             MOVS     R0,#+1
   \       0x76   0xE089             B.N      ??HAL_TIM_PWM_Start_DMA_1
   1548                }
   1549          
   1550                /* Enable the TIM Capture/Compare 1 DMA request */
   1551                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_PWM_Start_DMA_9: (+1)
   \       0x78   0x6828             LDR      R0,[R5, #+0]
   \       0x7A   0x68C0             LDR      R0,[R0, #+12]
   \       0x7C   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0x80   0x6829             LDR      R1,[R5, #+0]
   \       0x82   0x60C8             STR      R0,[R1, #+12]
   1552                break;
   \       0x84   0xE05C             B.N      ??HAL_TIM_PWM_Start_DMA_10
   1553              }
   1554          
   1555              case TIM_CHANNEL_2:
   1556              {
   1557                /* Set the DMA compare callbacks */
   1558                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_5: (+1)
   \       0x86   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x8A   0x6AA9             LDR      R1,[R5, #+40]
   \       0x8C   0x63C8             STR      R0,[R1, #+60]
   1559                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x8E   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \       0x92   0x6AA9             LDR      R1,[R5, #+40]
   \       0x94   0x6408             STR      R0,[R1, #+64]
   1560          
   1561                /* Set the DMA error callback */
   1562                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \       0x96   0x....             LDR.N    R0,??DataTable13_2
   \       0x98   0x6AA9             LDR      R1,[R5, #+40]
   \       0x9A   0x64C8             STR      R0,[R1, #+76]
   1563          
   1564                /* Enable the DMA stream */
   1565                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
   \       0x9C   0x003B             MOVS     R3,R7
   \       0x9E   0xB29B             UXTH     R3,R3
   \       0xA0   0x6828             LDR      R0,[R5, #+0]
   \       0xA2   0xF110 0x0238      ADDS     R2,R0,#+56
   \       0xA6   0x0021             MOVS     R1,R4
   \       0xA8   0x6AA8             LDR      R0,[R5, #+40]
   \       0xAA   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD001             BEQ.N    ??HAL_TIM_PWM_Start_DMA_11
   1566                {
   1567                  return HAL_ERROR;
   \       0xB2   0x2001             MOVS     R0,#+1
   \       0xB4   0xE06A             B.N      ??HAL_TIM_PWM_Start_DMA_1
   1568                }
   1569                /* Enable the TIM Capture/Compare 2 DMA request */
   1570                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_PWM_Start_DMA_11: (+1)
   \       0xB6   0x6828             LDR      R0,[R5, #+0]
   \       0xB8   0x68C0             LDR      R0,[R0, #+12]
   \       0xBA   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0xBE   0x6829             LDR      R1,[R5, #+0]
   \       0xC0   0x60C8             STR      R0,[R1, #+12]
   1571                break;
   \       0xC2   0xE03D             B.N      ??HAL_TIM_PWM_Start_DMA_10
   1572              }
   1573          
   1574              case TIM_CHANNEL_3:
   1575              {
   1576                /* Set the DMA compare callbacks */
   1577                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_6: (+1)
   \       0xC4   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0xC8   0x6AE9             LDR      R1,[R5, #+44]
   \       0xCA   0x63C8             STR      R0,[R1, #+60]
   1578                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0xCC   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \       0xD0   0x6AE9             LDR      R1,[R5, #+44]
   \       0xD2   0x6408             STR      R0,[R1, #+64]
   1579          
   1580                /* Set the DMA error callback */
   1581                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \       0xD4   0x....             LDR.N    R0,??DataTable13_2
   \       0xD6   0x6AE9             LDR      R1,[R5, #+44]
   \       0xD8   0x64C8             STR      R0,[R1, #+76]
   1582          
   1583                /* Enable the DMA stream */
   1584                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
   \       0xDA   0x003B             MOVS     R3,R7
   \       0xDC   0xB29B             UXTH     R3,R3
   \       0xDE   0x6828             LDR      R0,[R5, #+0]
   \       0xE0   0xF110 0x023C      ADDS     R2,R0,#+60
   \       0xE4   0x0021             MOVS     R1,R4
   \       0xE6   0x6AE8             LDR      R0,[R5, #+44]
   \       0xE8   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD001             BEQ.N    ??HAL_TIM_PWM_Start_DMA_12
   1585                {
   1586                  return HAL_ERROR;
   \       0xF0   0x2001             MOVS     R0,#+1
   \       0xF2   0xE04B             B.N      ??HAL_TIM_PWM_Start_DMA_1
   1587                }
   1588                /* Enable the TIM Output Capture/Compare 3 request */
   1589                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_PWM_Start_DMA_12: (+1)
   \       0xF4   0x6828             LDR      R0,[R5, #+0]
   \       0xF6   0x68C0             LDR      R0,[R0, #+12]
   \       0xF8   0xF450 0x6000      ORRS     R0,R0,#0x800
   \       0xFC   0x6829             LDR      R1,[R5, #+0]
   \       0xFE   0x60C8             STR      R0,[R1, #+12]
   1590                break;
   \      0x100   0xE01E             B.N      ??HAL_TIM_PWM_Start_DMA_10
   1591              }
   1592          
   1593              case TIM_CHANNEL_4:
   1594              {
   1595                /* Set the DMA compare callbacks */
   1596                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_7: (+1)
   \      0x102   0x.... 0x....      LDR.W    R0,??DataTable14
   \      0x106   0x6B29             LDR      R1,[R5, #+48]
   \      0x108   0x63C8             STR      R0,[R1, #+60]
   1597                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \      0x10A   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \      0x10E   0x6B29             LDR      R1,[R5, #+48]
   \      0x110   0x6408             STR      R0,[R1, #+64]
   1598          
   1599                /* Set the DMA error callback */
   1600                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \      0x112   0x....             LDR.N    R0,??DataTable13_2
   \      0x114   0x6B29             LDR      R1,[R5, #+48]
   \      0x116   0x64C8             STR      R0,[R1, #+76]
   1601          
   1602                /* Enable the DMA stream */
   1603                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
   \      0x118   0x003B             MOVS     R3,R7
   \      0x11A   0xB29B             UXTH     R3,R3
   \      0x11C   0x6828             LDR      R0,[R5, #+0]
   \      0x11E   0xF110 0x0240      ADDS     R2,R0,#+64
   \      0x122   0x0021             MOVS     R1,R4
   \      0x124   0x6B28             LDR      R0,[R5, #+48]
   \      0x126   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x12A   0x2800             CMP      R0,#+0
   \      0x12C   0xD001             BEQ.N    ??HAL_TIM_PWM_Start_DMA_13
   1604                {
   1605                  return HAL_ERROR;
   \      0x12E   0x2001             MOVS     R0,#+1
   \      0x130   0xE02C             B.N      ??HAL_TIM_PWM_Start_DMA_1
   1606                }
   1607                /* Enable the TIM Capture/Compare 4 DMA request */
   1608                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_PWM_Start_DMA_13: (+1)
   \      0x132   0x6828             LDR      R0,[R5, #+0]
   \      0x134   0x68C0             LDR      R0,[R0, #+12]
   \      0x136   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \      0x13A   0x6829             LDR      R1,[R5, #+0]
   \      0x13C   0x60C8             STR      R0,[R1, #+12]
   1609                break;
   \      0x13E   0xE7FF             B.N      ??HAL_TIM_PWM_Start_DMA_10
   1610              }
   1611          
   1612              default:
   1613                break;
   1614            }
   1615          
   1616            /* Enable the Capture compare channel */
   1617            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_DMA_8: (+1)
   \                     ??HAL_TIM_PWM_Start_DMA_10: (+1)
   \      0x140   0x2201             MOVS     R2,#+1
   \      0x142   0x0031             MOVS     R1,R6
   \      0x144   0x6828             LDR      R0,[R5, #+0]
   \      0x146   0x.... 0x....      BL       TIM_CCxChannelCmd
   1618          
   1619            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \      0x14A   0x6828             LDR      R0,[R5, #+0]
   \      0x14C   0x....             LDR.N    R1,??DataTable13_3
   \      0x14E   0x4288             CMP      R0,R1
   \      0x150   0xD003             BEQ.N    ??HAL_TIM_PWM_Start_DMA_14
   \      0x152   0x6828             LDR      R0,[R5, #+0]
   \      0x154   0x....             LDR.N    R1,??DataTable13_4
   \      0x156   0x4288             CMP      R0,R1
   \      0x158   0xD101             BNE.N    ??HAL_TIM_PWM_Start_DMA_15
   \                     ??HAL_TIM_PWM_Start_DMA_14: (+1)
   \      0x15A   0x2001             MOVS     R0,#+1
   \      0x15C   0xE000             B.N      ??HAL_TIM_PWM_Start_DMA_16
   \                     ??HAL_TIM_PWM_Start_DMA_15: (+1)
   \      0x15E   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Start_DMA_16: (+1)
   \      0x160   0xB2C0             UXTB     R0,R0
   \      0x162   0x2800             CMP      R0,#+0
   \      0x164   0xD005             BEQ.N    ??HAL_TIM_PWM_Start_DMA_17
   1620            {
   1621              /* Enable the main output */
   1622              __HAL_TIM_MOE_ENABLE(htim);
   \      0x166   0x6828             LDR      R0,[R5, #+0]
   \      0x168   0x6C40             LDR      R0,[R0, #+68]
   \      0x16A   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \      0x16E   0x6829             LDR      R1,[R5, #+0]
   \      0x170   0x6448             STR      R0,[R1, #+68]
   1623            }
   1624          
   1625            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1626            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIM_PWM_Start_DMA_17: (+1)
   \      0x172   0x6828             LDR      R0,[R5, #+0]
   \      0x174   0x6881             LDR      R1,[R0, #+8]
   \      0x176   0xF011 0x0107      ANDS     R1,R1,#0x7
   1627            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \      0x17A   0x2906             CMP      R1,#+6
   \      0x17C   0xD005             BEQ.N    ??HAL_TIM_PWM_Start_DMA_18
   1628            {
   1629              __HAL_TIM_ENABLE(htim);
   \      0x17E   0x6828             LDR      R0,[R5, #+0]
   \      0x180   0x6800             LDR      R0,[R0, #+0]
   \      0x182   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x186   0x682A             LDR      R2,[R5, #+0]
   \      0x188   0x6010             STR      R0,[R2, #+0]
   1630            }
   1631          
   1632            /* Return function status */
   1633            return HAL_OK;
   \                     ??HAL_TIM_PWM_Start_DMA_18: (+1)
   \      0x18A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Start_DMA_1: (+1)
   \      0x18C   0xBDF2             POP      {R1,R4-R7,PC}
   1634          }
   1635          
   1636          /**
   1637            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1638            * @param  htim TIM PWM handle
   1639            * @param  Channel TIM Channels to be disabled
   1640            *          This parameter can be one of the following values:
   1641            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1642            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1643            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1644            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1645            * @retval HAL status
   1646            */

   \                                 In section .text, align 2, keep-with-next
   1647          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1648          {
   \                     HAL_TIM_PWM_Stop_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1649            /* Check the parameters */
   1650            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1651          
   1652            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00E             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD016             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD01E             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_3
   \       0x18   0xE027             B.N      ??HAL_TIM_PWM_Stop_DMA_4
   1653            {
   1654              case TIM_CHANNEL_1:
   1655              {
   1656                /* Disable the TIM Capture/Compare 1 DMA request */
   1657                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_PWM_Stop_DMA_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0xF430 0x7000      BICS     R0,R0,#0x200
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x60C8             STR      R0,[R1, #+12]
   1658                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x26   0x6A60             LDR      R0,[R4, #+36]
   \       0x28   0x.... 0x....      BL       HAL_DMA_Abort_IT
   1659                break;
   \       0x2C   0xE01D             B.N      ??HAL_TIM_PWM_Stop_DMA_5
   1660              }
   1661          
   1662              case TIM_CHANNEL_2:
   1663              {
   1664                /* Disable the TIM Capture/Compare 2 DMA request */
   1665                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_PWM_Stop_DMA_1: (+1)
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x68C0             LDR      R0,[R0, #+12]
   \       0x32   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x36   0x6821             LDR      R1,[R4, #+0]
   \       0x38   0x60C8             STR      R0,[R1, #+12]
   1666                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \       0x3A   0x6AA0             LDR      R0,[R4, #+40]
   \       0x3C   0x.... 0x....      BL       HAL_DMA_Abort_IT
   1667                break;
   \       0x40   0xE013             B.N      ??HAL_TIM_PWM_Stop_DMA_5
   1668              }
   1669          
   1670              case TIM_CHANNEL_3:
   1671              {
   1672                /* Disable the TIM Capture/Compare 3 DMA request */
   1673                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_PWM_Stop_DMA_2: (+1)
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x68C0             LDR      R0,[R0, #+12]
   \       0x46   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x4A   0x6821             LDR      R1,[R4, #+0]
   \       0x4C   0x60C8             STR      R0,[R1, #+12]
   1674                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   \       0x4E   0x6AE0             LDR      R0,[R4, #+44]
   \       0x50   0x.... 0x....      BL       HAL_DMA_Abort_IT
   1675                break;
   \       0x54   0xE009             B.N      ??HAL_TIM_PWM_Stop_DMA_5
   1676              }
   1677          
   1678              case TIM_CHANNEL_4:
   1679              {
   1680                /* Disable the TIM Capture/Compare 4 interrupt */
   1681                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_PWM_Stop_DMA_3: (+1)
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x68C0             LDR      R0,[R0, #+12]
   \       0x5A   0xF430 0x5080      BICS     R0,R0,#0x1000
   \       0x5E   0x6821             LDR      R1,[R4, #+0]
   \       0x60   0x60C8             STR      R0,[R1, #+12]
   1682                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   \       0x62   0x6B20             LDR      R0,[R4, #+48]
   \       0x64   0x.... 0x....      BL       HAL_DMA_Abort_IT
   1683                break;
   \       0x68   0xE7FF             B.N      ??HAL_TIM_PWM_Stop_DMA_5
   1684              }
   1685          
   1686              default:
   1687                break;
   1688            }
   1689          
   1690            /* Disable the Capture compare channel */
   1691            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_DMA_4: (+1)
   \                     ??HAL_TIM_PWM_Stop_DMA_5: (+1)
   \       0x6A   0x2200             MOVS     R2,#+0
   \       0x6C   0x0029             MOVS     R1,R5
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x.... 0x....      BL       TIM_CCxChannelCmd
   1692          
   1693            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x....             LDR.N    R1,??DataTable13_3
   \       0x78   0x4288             CMP      R0,R1
   \       0x7A   0xD003             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_6
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x....             LDR.N    R1,??DataTable13_4
   \       0x80   0x4288             CMP      R0,R1
   \       0x82   0xD101             BNE.N    ??HAL_TIM_PWM_Stop_DMA_7
   \                     ??HAL_TIM_PWM_Stop_DMA_6: (+1)
   \       0x84   0x2001             MOVS     R0,#+1
   \       0x86   0xE000             B.N      ??HAL_TIM_PWM_Stop_DMA_8
   \                     ??HAL_TIM_PWM_Stop_DMA_7: (+1)
   \       0x88   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Stop_DMA_8: (+1)
   \       0x8A   0xB2C0             UXTB     R0,R0
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0xD011             BEQ.N    ??HAL_TIM_PWM_Stop_DMA_9
   1694            {
   1695              /* Disable the Main Output */
   1696              __HAL_TIM_MOE_DISABLE(htim);
   \       0x90   0x6820             LDR      R0,[R4, #+0]
   \       0x92   0x6A00             LDR      R0,[R0, #+32]
   \       0x94   0xF241 0x1111      MOVW     R1,#+4369
   \       0x98   0x4208             TST      R0,R1
   \       0x9A   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_DMA_10
   \       0x9C   0x6820             LDR      R0,[R4, #+0]
   \       0x9E   0x6A00             LDR      R0,[R0, #+32]
   \       0xA0   0xF240 0x4144      MOVW     R1,#+1092
   \       0xA4   0x4208             TST      R0,R1
   \       0xA6   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_DMA_10
   \       0xA8   0x6820             LDR      R0,[R4, #+0]
   \       0xAA   0x6C40             LDR      R0,[R0, #+68]
   \       0xAC   0xF430 0x4000      BICS     R0,R0,#0x8000
   \       0xB0   0x6821             LDR      R1,[R4, #+0]
   \       0xB2   0x6448             STR      R0,[R1, #+68]
   1697            }
   1698          
   1699            /* Disable the Peripheral */
   1700            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_DMA_10: (+1)
   \                     ??HAL_TIM_PWM_Stop_DMA_9: (+1)
   \       0xB4   0x6820             LDR      R0,[R4, #+0]
   \       0xB6   0x6A00             LDR      R0,[R0, #+32]
   \       0xB8   0xF241 0x1111      MOVW     R1,#+4369
   \       0xBC   0x4208             TST      R0,R1
   \       0xBE   0xD10B             BNE.N    ??HAL_TIM_PWM_Stop_DMA_11
   \       0xC0   0x6820             LDR      R0,[R4, #+0]
   \       0xC2   0x6A00             LDR      R0,[R0, #+32]
   \       0xC4   0xF240 0x4144      MOVW     R1,#+1092
   \       0xC8   0x4208             TST      R0,R1
   \       0xCA   0xD105             BNE.N    ??HAL_TIM_PWM_Stop_DMA_11
   \       0xCC   0x6820             LDR      R0,[R4, #+0]
   \       0xCE   0x6800             LDR      R0,[R0, #+0]
   \       0xD0   0x0840             LSRS     R0,R0,#+1
   \       0xD2   0x0040             LSLS     R0,R0,#+1
   \       0xD4   0x6821             LDR      R1,[R4, #+0]
   \       0xD6   0x6008             STR      R0,[R1, #+0]
   1701          
   1702            /* Change the htim state */
   1703            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_DMA_11: (+1)
   \       0xD8   0x2001             MOVS     R0,#+1
   \       0xDA   0xF884 0x003D      STRB     R0,[R4, #+61]
   1704          
   1705            /* Return function status */
   1706            return HAL_OK;
   \       0xDE   0x2000             MOVS     R0,#+0
   \       0xE0   0xBD32             POP      {R1,R4,R5,PC}
   1707          }
   1708          
   1709          /**
   1710            * @}
   1711            */
   1712          
   1713          /** @defgroup TIM_Exported_Functions_Group4 TIM Input Capture functions
   1714            *  @brief    TIM Input Capture functions
   1715            *
   1716          @verbatim
   1717            ==============================================================================
   1718                        ##### TIM Input Capture functions #####
   1719            ==============================================================================
   1720           [..]
   1721             This section provides functions allowing to:
   1722             (+) Initialize and configure the TIM Input Capture.
   1723             (+) De-initialize the TIM Input Capture.
   1724             (+) Start the TIM Input Capture.
   1725             (+) Stop the TIM Input Capture.
   1726             (+) Start the TIM Input Capture and enable interrupt.
   1727             (+) Stop the TIM Input Capture and disable interrupt.
   1728             (+) Start the TIM Input Capture and enable DMA transfer.
   1729             (+) Stop the TIM Input Capture and disable DMA transfer.
   1730          
   1731          @endverbatim
   1732            * @{
   1733            */
   1734          /**
   1735            * @brief  Initializes the TIM Input Capture Time base according to the specified
   1736            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   1737            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   1738            *         requires a timer reset to avoid unexpected direction
   1739            *         due to DIR bit readonly in center aligned mode.
   1740            *         Ex: call @ref HAL_TIM_IC_DeInit() before HAL_TIM_IC_Init()
   1741            * @param  htim TIM Input Capture handle
   1742            * @retval HAL status
   1743            */

   \                                 In section .text, align 2, keep-with-next
   1744          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
   1745          {
   \                     HAL_TIM_IC_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1746            /* Check the TIM handle allocation */
   1747            if (htim == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_TIM_IC_Init_0
   1748            {
   1749              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE014             B.N      ??HAL_TIM_IC_Init_1
   1750            }
   1751          
   1752            /* Check the parameters */
   1753            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1754            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1755            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1756            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1757          
   1758            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_IC_Init_0: (+1)
   \        0xC   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD105             BNE.N    ??HAL_TIM_IC_Init_2
   1759            {
   1760              /* Allocate lock resource and initialize it */
   1761              htim->Lock = HAL_UNLOCKED;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xF884 0x003C      STRB     R0,[R4, #+60]
   1762          
   1763          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1764              /* Reset interrupt callbacks to legacy weak callbacks */
   1765              TIM_ResetCallback(htim);
   1766          
   1767              if (htim->IC_MspInitCallback == NULL)
   1768              {
   1769                htim->IC_MspInitCallback = HAL_TIM_IC_MspInit;
   1770              }
   1771              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   1772              htim->IC_MspInitCallback(htim);
   1773          #else
   1774              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1775              HAL_TIM_IC_MspInit(htim);
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       HAL_TIM_IC_MspInit
   1776          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1777            }
   1778          
   1779            /* Set the TIM state */
   1780            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Init_2: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xF884 0x003D      STRB     R0,[R4, #+61]
   1781          
   1782            /* Init the base time for the input capture */
   1783            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x26   0x1D21             ADDS     R1,R4,#+4
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x.... 0x....      BL       TIM_Base_SetConfig
   1784          
   1785            /* Initialize the TIM state*/
   1786            htim->State = HAL_TIM_STATE_READY;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xF884 0x003D      STRB     R0,[R4, #+61]
   1787          
   1788            return HAL_OK;
   \       0x34   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_Init_1: (+1)
   \       0x36   0xBD10             POP      {R4,PC}
   1789          }
   1790          
   1791          /**
   1792            * @brief  DeInitializes the TIM peripheral
   1793            * @param  htim TIM Input Capture handle
   1794            * @retval HAL status
   1795            */

   \                                 In section .text, align 2, keep-with-next
   1796          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
   1797          {
   \                     HAL_TIM_IC_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1798            /* Check the parameters */
   1799            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1800          
   1801            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0xF884 0x003D      STRB     R0,[R4, #+61]
   1802          
   1803            /* Disable the TIM Peripheral Clock */
   1804            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0xF241 0x1111      MOVW     R1,#+4369
   \       0x12   0x4208             TST      R0,R1
   \       0x14   0xD10B             BNE.N    ??HAL_TIM_IC_DeInit_0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6A00             LDR      R0,[R0, #+32]
   \       0x1A   0xF240 0x4144      MOVW     R1,#+1092
   \       0x1E   0x4208             TST      R0,R1
   \       0x20   0xD105             BNE.N    ??HAL_TIM_IC_DeInit_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x0840             LSRS     R0,R0,#+1
   \       0x28   0x0040             LSLS     R0,R0,#+1
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6008             STR      R0,[R1, #+0]
   1805          
   1806          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1807            if (htim->IC_MspDeInitCallback == NULL)
   1808            {
   1809              htim->IC_MspDeInitCallback = HAL_TIM_IC_MspDeInit;
   1810            }
   1811            /* DeInit the low level hardware */
   1812            htim->IC_MspDeInitCallback(htim);
   1813          #else
   1814            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1815            HAL_TIM_IC_MspDeInit(htim);
   \                     ??HAL_TIM_IC_DeInit_0: (+1)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       HAL_TIM_IC_MspDeInit
   1816          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1817          
   1818            /* Change TIM state */
   1819            htim->State = HAL_TIM_STATE_RESET;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF884 0x003D      STRB     R0,[R4, #+61]
   1820          
   1821            /* Release Lock */
   1822            __HAL_UNLOCK(htim);
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xF884 0x003C      STRB     R0,[R4, #+60]
   1823          
   1824            return HAL_OK;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD10             POP      {R4,PC}
   1825          }
   1826          
   1827          /**
   1828            * @brief  Initializes the TIM Input Capture MSP.
   1829            * @param  htim TIM Input Capture handle
   1830            * @retval None
   1831            */

   \                                 In section .text, align 2
   1832          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
   1833          {
   1834            /* Prevent unused argument(s) compilation warning */
   1835            UNUSED(htim);
   1836          
   1837            /* NOTE : This function should not be modified, when the callback is needed,
   1838                      the HAL_TIM_IC_MspInit could be implemented in the user file
   1839             */
   1840          }
   \                     HAL_TIM_IC_MspInit: (+1)
   \        0x0   0x4770             BX       LR
   1841          
   1842          /**
   1843            * @brief  DeInitializes TIM Input Capture MSP.
   1844            * @param  htim TIM handle
   1845            * @retval None
   1846            */

   \                                 In section .text, align 2
   1847          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
   1848          {
   1849            /* Prevent unused argument(s) compilation warning */
   1850            UNUSED(htim);
   1851          
   1852            /* NOTE : This function should not be modified, when the callback is needed,
   1853                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
   1854             */
   1855          }
   \                     HAL_TIM_IC_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
   1856          
   1857          /**
   1858            * @brief  Starts the TIM Input Capture measurement.
   1859            * @param  htim TIM Input Capture handle
   1860            * @param  Channel TIM Channels to be enabled
   1861            *          This parameter can be one of the following values:
   1862            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1863            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1864            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1865            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1866            * @retval HAL status
   1867            */

   \                                 In section .text, align 2, keep-with-next
   1868          HAL_StatusTypeDef HAL_TIM_IC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1869          {
   \                     HAL_TIM_IC_Start: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1870            uint32_t tmpsmcr;
   1871          
   1872            /* Check the parameters */
   1873            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1874          
   1875            /* Enable the Input Capture channel */
   1876            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \        0x6   0x2201             MOVS     R2,#+1
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x.... 0x....      BL       TIM_CCxChannelCmd
   1877          
   1878            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1879            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6881             LDR      R1,[R0, #+8]
   \       0x14   0xF011 0x0107      ANDS     R1,R1,#0x7
   1880            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x18   0x2906             CMP      R1,#+6
   \       0x1A   0xD005             BEQ.N    ??HAL_TIM_IC_Start_0
   1881            {
   1882              __HAL_TIM_ENABLE(htim);
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x6800             LDR      R0,[R0, #+0]
   \       0x20   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x24   0x6822             LDR      R2,[R4, #+0]
   \       0x26   0x6010             STR      R0,[R2, #+0]
   1883            }
   1884          
   1885            /* Return function status */
   1886            return HAL_OK;
   \                     ??HAL_TIM_IC_Start_0: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD32             POP      {R1,R4,R5,PC}
   1887          }
   1888          
   1889          /**
   1890            * @brief  Stops the TIM Input Capture measurement.
   1891            * @param  htim TIM Input Capture handle
   1892            * @param  Channel TIM Channels to be disabled
   1893            *          This parameter can be one of the following values:
   1894            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1895            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1896            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1897            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1898            * @retval HAL status
   1899            */

   \                                 In section .text, align 2, keep-with-next
   1900          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1901          {
   \                     HAL_TIM_IC_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1902            /* Check the parameters */
   1903            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1904          
   1905            /* Disable the Input Capture channel */
   1906            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x.... 0x....      BL       TIM_CCxChannelCmd
   1907          
   1908            /* Disable the Peripheral */
   1909            __HAL_TIM_DISABLE(htim);
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6A00             LDR      R0,[R0, #+32]
   \       0x14   0xF241 0x1111      MOVW     R1,#+4369
   \       0x18   0x4208             TST      R0,R1
   \       0x1A   0xD10B             BNE.N    ??HAL_TIM_IC_Stop_0
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x6A00             LDR      R0,[R0, #+32]
   \       0x20   0xF240 0x4144      MOVW     R1,#+1092
   \       0x24   0x4208             TST      R0,R1
   \       0x26   0xD105             BNE.N    ??HAL_TIM_IC_Stop_0
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0x0840             LSRS     R0,R0,#+1
   \       0x2E   0x0040             LSLS     R0,R0,#+1
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x6008             STR      R0,[R1, #+0]
   1910          
   1911            /* Return function status */
   1912            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_0: (+1)
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}
   1913          }
   1914          
   1915          /**
   1916            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   1917            * @param  htim TIM Input Capture handle
   1918            * @param  Channel TIM Channels to be enabled
   1919            *          This parameter can be one of the following values:
   1920            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1921            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1922            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1923            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1924            * @retval HAL status
   1925            */

   \                                 In section .text, align 2, keep-with-next
   1926          HAL_StatusTypeDef HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1927          {
   \                     HAL_TIM_IC_Start_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1928            uint32_t tmpsmcr;
   1929          
   1930            /* Check the parameters */
   1931            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1932          
   1933            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ.N    ??HAL_TIM_IC_Start_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00B             BEQ.N    ??HAL_TIM_IC_Start_IT_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD010             BEQ.N    ??HAL_TIM_IC_Start_IT_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD015             BEQ.N    ??HAL_TIM_IC_Start_IT_3
   \       0x18   0xE01B             B.N      ??HAL_TIM_IC_Start_IT_4
   1934            {
   1935              case TIM_CHANNEL_1:
   1936              {
   1937                /* Enable the TIM Capture/Compare 1 interrupt */
   1938                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Start_IT_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x60C8             STR      R0,[R1, #+12]
   1939                break;
   \       0x26   0xE014             B.N      ??HAL_TIM_IC_Start_IT_5
   1940              }
   1941          
   1942              case TIM_CHANNEL_2:
   1943              {
   1944                /* Enable the TIM Capture/Compare 2 interrupt */
   1945                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Start_IT_1: (+1)
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x68C0             LDR      R0,[R0, #+12]
   \       0x2C   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x60C8             STR      R0,[R1, #+12]
   1946                break;
   \       0x34   0xE00D             B.N      ??HAL_TIM_IC_Start_IT_5
   1947              }
   1948          
   1949              case TIM_CHANNEL_3:
   1950              {
   1951                /* Enable the TIM Capture/Compare 3 interrupt */
   1952                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Start_IT_2: (+1)
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x68C0             LDR      R0,[R0, #+12]
   \       0x3A   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0x3E   0x6821             LDR      R1,[R4, #+0]
   \       0x40   0x60C8             STR      R0,[R1, #+12]
   1953                break;
   \       0x42   0xE006             B.N      ??HAL_TIM_IC_Start_IT_5
   1954              }
   1955          
   1956              case TIM_CHANNEL_4:
   1957              {
   1958                /* Enable the TIM Capture/Compare 4 interrupt */
   1959                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Start_IT_3: (+1)
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x60C8             STR      R0,[R1, #+12]
   1960                break;
   \       0x50   0xE7FF             B.N      ??HAL_TIM_IC_Start_IT_5
   1961              }
   1962          
   1963              default:
   1964                break;
   1965            }
   1966            /* Enable the Input Capture channel */
   1967            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_IT_4: (+1)
   \                     ??HAL_TIM_IC_Start_IT_5: (+1)
   \       0x52   0x2201             MOVS     R2,#+1
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x.... 0x....      BL       TIM_CCxChannelCmd
   1968          
   1969            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1970            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x6881             LDR      R1,[R0, #+8]
   \       0x60   0xF011 0x0107      ANDS     R1,R1,#0x7
   1971            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x64   0x2906             CMP      R1,#+6
   \       0x66   0xD005             BEQ.N    ??HAL_TIM_IC_Start_IT_6
   1972            {
   1973              __HAL_TIM_ENABLE(htim);
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x6800             LDR      R0,[R0, #+0]
   \       0x6C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x70   0x6822             LDR      R2,[R4, #+0]
   \       0x72   0x6010             STR      R0,[R2, #+0]
   1974            }
   1975          
   1976            /* Return function status */
   1977            return HAL_OK;
   \                     ??HAL_TIM_IC_Start_IT_6: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xBD32             POP      {R1,R4,R5,PC}
   1978          }
   1979          
   1980          /**
   1981            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   1982            * @param  htim TIM Input Capture handle
   1983            * @param  Channel TIM Channels to be disabled
   1984            *          This parameter can be one of the following values:
   1985            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1986            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1987            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1988            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1989            * @retval HAL status
   1990            */

   \                                 In section .text, align 2, keep-with-next
   1991          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1992          {
   \                     HAL_TIM_IC_Stop_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1993            /* Check the parameters */
   1994            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1995          
   1996            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ.N    ??HAL_TIM_IC_Stop_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00B             BEQ.N    ??HAL_TIM_IC_Stop_IT_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD010             BEQ.N    ??HAL_TIM_IC_Stop_IT_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD015             BEQ.N    ??HAL_TIM_IC_Stop_IT_3
   \       0x18   0xE01B             B.N      ??HAL_TIM_IC_Stop_IT_4
   1997            {
   1998              case TIM_CHANNEL_1:
   1999              {
   2000                /* Disable the TIM Capture/Compare 1 interrupt */
   2001                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Stop_IT_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x60C8             STR      R0,[R1, #+12]
   2002                break;
   \       0x26   0xE014             B.N      ??HAL_TIM_IC_Stop_IT_5
   2003              }
   2004          
   2005              case TIM_CHANNEL_2:
   2006              {
   2007                /* Disable the TIM Capture/Compare 2 interrupt */
   2008                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Stop_IT_1: (+1)
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x68C0             LDR      R0,[R0, #+12]
   \       0x2C   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x60C8             STR      R0,[R1, #+12]
   2009                break;
   \       0x34   0xE00D             B.N      ??HAL_TIM_IC_Stop_IT_5
   2010              }
   2011          
   2012              case TIM_CHANNEL_3:
   2013              {
   2014                /* Disable the TIM Capture/Compare 3 interrupt */
   2015                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Stop_IT_2: (+1)
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x68C0             LDR      R0,[R0, #+12]
   \       0x3A   0xF030 0x0008      BICS     R0,R0,#0x8
   \       0x3E   0x6821             LDR      R1,[R4, #+0]
   \       0x40   0x60C8             STR      R0,[R1, #+12]
   2016                break;
   \       0x42   0xE006             B.N      ??HAL_TIM_IC_Stop_IT_5
   2017              }
   2018          
   2019              case TIM_CHANNEL_4:
   2020              {
   2021                /* Disable the TIM Capture/Compare 4 interrupt */
   2022                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Stop_IT_3: (+1)
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0xF030 0x0010      BICS     R0,R0,#0x10
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x60C8             STR      R0,[R1, #+12]
   2023                break;
   \       0x50   0xE7FF             B.N      ??HAL_TIM_IC_Stop_IT_5
   2024              }
   2025          
   2026              default:
   2027                break;
   2028            }
   2029          
   2030            /* Disable the Input Capture channel */
   2031            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_IC_Stop_IT_4: (+1)
   \                     ??HAL_TIM_IC_Stop_IT_5: (+1)
   \       0x52   0x2200             MOVS     R2,#+0
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x.... 0x....      BL       TIM_CCxChannelCmd
   2032          
   2033            /* Disable the Peripheral */
   2034            __HAL_TIM_DISABLE(htim);
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x6A00             LDR      R0,[R0, #+32]
   \       0x60   0xF241 0x1111      MOVW     R1,#+4369
   \       0x64   0x4208             TST      R0,R1
   \       0x66   0xD10B             BNE.N    ??HAL_TIM_IC_Stop_IT_6
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x6A00             LDR      R0,[R0, #+32]
   \       0x6C   0xF240 0x4144      MOVW     R1,#+1092
   \       0x70   0x4208             TST      R0,R1
   \       0x72   0xD105             BNE.N    ??HAL_TIM_IC_Stop_IT_6
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x6800             LDR      R0,[R0, #+0]
   \       0x78   0x0840             LSRS     R0,R0,#+1
   \       0x7A   0x0040             LSLS     R0,R0,#+1
   \       0x7C   0x6821             LDR      R1,[R4, #+0]
   \       0x7E   0x6008             STR      R0,[R1, #+0]
   2035          
   2036            /* Return function status */
   2037            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_IT_6: (+1)
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0xBD32             POP      {R1,R4,R5,PC}
   2038          }
   2039          
   2040          /**
   2041            * @brief  Starts the TIM Input Capture measurement in DMA mode.
   2042            * @param  htim TIM Input Capture handle
   2043            * @param  Channel TIM Channels to be enabled
   2044            *          This parameter can be one of the following values:
   2045            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2046            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2047            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2048            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2049            * @param  pData The destination Buffer address.
   2050            * @param  Length The length of data to be transferred from TIM peripheral to memory.
   2051            * @retval HAL status
   2052            */

   \                                 In section .text, align 2, keep-with-next
   2053          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   2054          {
   \                     HAL_TIM_IC_Start_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0014             MOVS     R4,R2
   \        0x8   0x001F             MOVS     R7,R3
   2055            uint32_t tmpsmcr;
   2056          
   2057            /* Check the parameters */
   2058            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   2059            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2060          
   2061            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0xA   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD101             BNE.N    ??HAL_TIM_IC_Start_DMA_0
   2062            {
   2063              return HAL_BUSY;
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xE0A6             B.N      ??HAL_TIM_IC_Start_DMA_1
   2064            }
   2065            else if (htim->State == HAL_TIM_STATE_READY)
   \                     ??HAL_TIM_IC_Start_DMA_0: (+1)
   \       0x16   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD10A             BNE.N    ??HAL_TIM_IC_Start_DMA_2
   2066            {
   2067              if ((pData == NULL) && (Length > 0U))
   \       0x1E   0x2C00             CMP      R4,#+0
   \       0x20   0xD105             BNE.N    ??HAL_TIM_IC_Start_DMA_3
   \       0x22   0x0038             MOVS     R0,R7
   \       0x24   0xB280             UXTH     R0,R0
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD001             BEQ.N    ??HAL_TIM_IC_Start_DMA_3
   2068              {
   2069                return HAL_ERROR;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE09A             B.N      ??HAL_TIM_IC_Start_DMA_1
   2070              }
   2071              else
   2072              {
   2073                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Start_DMA_3: (+1)
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0xF885 0x003D      STRB     R0,[R5, #+61]
   2074              }
   2075            }
   2076            else
   2077            {
   2078              /* nothing to do */
   2079            }
   2080          
   2081            switch (Channel)
   \                     ??HAL_TIM_IC_Start_DMA_2: (+1)
   \       0x34   0x0030             MOVS     R0,R6
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD006             BEQ.N    ??HAL_TIM_IC_Start_DMA_4
   \       0x3A   0x2804             CMP      R0,#+4
   \       0x3C   0xD023             BEQ.N    ??HAL_TIM_IC_Start_DMA_5
   \       0x3E   0x2808             CMP      R0,#+8
   \       0x40   0xD040             BEQ.N    ??HAL_TIM_IC_Start_DMA_6
   \       0x42   0x280C             CMP      R0,#+12
   \       0x44   0xD05D             BEQ.N    ??HAL_TIM_IC_Start_DMA_7
   \       0x46   0xE07B             B.N      ??HAL_TIM_IC_Start_DMA_8
   2082            {
   2083              case TIM_CHANNEL_1:
   2084              {
   2085                /* Set the DMA capture callbacks */
   2086                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_4: (+1)
   \       0x48   0x.... 0x....      LDR.W    R0,??DataTable20
   \       0x4C   0x6A69             LDR      R1,[R5, #+36]
   \       0x4E   0x63C8             STR      R0,[R1, #+60]
   2087                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x54   0x6A69             LDR      R1,[R5, #+36]
   \       0x56   0x6408             STR      R0,[R1, #+64]
   2088          
   2089                /* Set the DMA error callback */
   2090                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0x58   0x....             LDR.N    R0,??DataTable14_2
   \       0x5A   0x6A69             LDR      R1,[R5, #+36]
   \       0x5C   0x64C8             STR      R0,[R1, #+76]
   2091          
   2092                /* Enable the DMA stream */
   2093                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
   \       0x5E   0x003B             MOVS     R3,R7
   \       0x60   0xB29B             UXTH     R3,R3
   \       0x62   0x0022             MOVS     R2,R4
   \       0x64   0x6828             LDR      R0,[R5, #+0]
   \       0x66   0xF110 0x0134      ADDS     R1,R0,#+52
   \       0x6A   0x6A68             LDR      R0,[R5, #+36]
   \       0x6C   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD001             BEQ.N    ??HAL_TIM_IC_Start_DMA_9
   2094                {
   2095                  return HAL_ERROR;
   \       0x74   0x2001             MOVS     R0,#+1
   \       0x76   0xE075             B.N      ??HAL_TIM_IC_Start_DMA_1
   2096                }
   2097                /* Enable the TIM Capture/Compare 1 DMA request */
   2098                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_IC_Start_DMA_9: (+1)
   \       0x78   0x6828             LDR      R0,[R5, #+0]
   \       0x7A   0x68C0             LDR      R0,[R0, #+12]
   \       0x7C   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0x80   0x6829             LDR      R1,[R5, #+0]
   \       0x82   0x60C8             STR      R0,[R1, #+12]
   2099                break;
   \       0x84   0xE05C             B.N      ??HAL_TIM_IC_Start_DMA_10
   2100              }
   2101          
   2102              case TIM_CHANNEL_2:
   2103              {
   2104                /* Set the DMA capture callbacks */
   2105                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_5: (+1)
   \       0x86   0x.... 0x....      LDR.W    R0,??DataTable20
   \       0x8A   0x6AA9             LDR      R1,[R5, #+40]
   \       0x8C   0x63C8             STR      R0,[R1, #+60]
   2106                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x8E   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0x92   0x6AA9             LDR      R1,[R5, #+40]
   \       0x94   0x6408             STR      R0,[R1, #+64]
   2107          
   2108                /* Set the DMA error callback */
   2109                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \       0x96   0x....             LDR.N    R0,??DataTable14_2
   \       0x98   0x6AA9             LDR      R1,[R5, #+40]
   \       0x9A   0x64C8             STR      R0,[R1, #+76]
   2110          
   2111                /* Enable the DMA stream */
   2112                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length) != HAL_OK)
   \       0x9C   0x003B             MOVS     R3,R7
   \       0x9E   0xB29B             UXTH     R3,R3
   \       0xA0   0x0022             MOVS     R2,R4
   \       0xA2   0x6828             LDR      R0,[R5, #+0]
   \       0xA4   0xF110 0x0138      ADDS     R1,R0,#+56
   \       0xA8   0x6AA8             LDR      R0,[R5, #+40]
   \       0xAA   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD001             BEQ.N    ??HAL_TIM_IC_Start_DMA_11
   2113                {
   2114                  return HAL_ERROR;
   \       0xB2   0x2001             MOVS     R0,#+1
   \       0xB4   0xE056             B.N      ??HAL_TIM_IC_Start_DMA_1
   2115                }
   2116                /* Enable the TIM Capture/Compare 2  DMA request */
   2117                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_IC_Start_DMA_11: (+1)
   \       0xB6   0x6828             LDR      R0,[R5, #+0]
   \       0xB8   0x68C0             LDR      R0,[R0, #+12]
   \       0xBA   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0xBE   0x6829             LDR      R1,[R5, #+0]
   \       0xC0   0x60C8             STR      R0,[R1, #+12]
   2118                break;
   \       0xC2   0xE03D             B.N      ??HAL_TIM_IC_Start_DMA_10
   2119              }
   2120          
   2121              case TIM_CHANNEL_3:
   2122              {
   2123                /* Set the DMA capture callbacks */
   2124                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_6: (+1)
   \       0xC4   0x.... 0x....      LDR.W    R0,??DataTable20
   \       0xC8   0x6AE9             LDR      R1,[R5, #+44]
   \       0xCA   0x63C8             STR      R0,[R1, #+60]
   2125                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0xCC   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \       0xD0   0x6AE9             LDR      R1,[R5, #+44]
   \       0xD2   0x6408             STR      R0,[R1, #+64]
   2126          
   2127                /* Set the DMA error callback */
   2128                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \       0xD4   0x....             LDR.N    R0,??DataTable14_2
   \       0xD6   0x6AE9             LDR      R1,[R5, #+44]
   \       0xD8   0x64C8             STR      R0,[R1, #+76]
   2129          
   2130                /* Enable the DMA stream */
   2131                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length) != HAL_OK)
   \       0xDA   0x003B             MOVS     R3,R7
   \       0xDC   0xB29B             UXTH     R3,R3
   \       0xDE   0x0022             MOVS     R2,R4
   \       0xE0   0x6828             LDR      R0,[R5, #+0]
   \       0xE2   0xF110 0x013C      ADDS     R1,R0,#+60
   \       0xE6   0x6AE8             LDR      R0,[R5, #+44]
   \       0xE8   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD001             BEQ.N    ??HAL_TIM_IC_Start_DMA_12
   2132                {
   2133                  return HAL_ERROR;
   \       0xF0   0x2001             MOVS     R0,#+1
   \       0xF2   0xE037             B.N      ??HAL_TIM_IC_Start_DMA_1
   2134                }
   2135                /* Enable the TIM Capture/Compare 3  DMA request */
   2136                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_IC_Start_DMA_12: (+1)
   \       0xF4   0x6828             LDR      R0,[R5, #+0]
   \       0xF6   0x68C0             LDR      R0,[R0, #+12]
   \       0xF8   0xF450 0x6000      ORRS     R0,R0,#0x800
   \       0xFC   0x6829             LDR      R1,[R5, #+0]
   \       0xFE   0x60C8             STR      R0,[R1, #+12]
   2137                break;
   \      0x100   0xE01E             B.N      ??HAL_TIM_IC_Start_DMA_10
   2138              }
   2139          
   2140              case TIM_CHANNEL_4:
   2141              {
   2142                /* Set the DMA capture callbacks */
   2143                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_7: (+1)
   \      0x102   0x.... 0x....      LDR.W    R0,??DataTable20
   \      0x106   0x6B29             LDR      R1,[R5, #+48]
   \      0x108   0x63C8             STR      R0,[R1, #+60]
   2144                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \      0x10A   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \      0x10E   0x6B29             LDR      R1,[R5, #+48]
   \      0x110   0x6408             STR      R0,[R1, #+64]
   2145          
   2146                /* Set the DMA error callback */
   2147                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \      0x112   0x....             LDR.N    R0,??DataTable14_2
   \      0x114   0x6B29             LDR      R1,[R5, #+48]
   \      0x116   0x64C8             STR      R0,[R1, #+76]
   2148          
   2149                /* Enable the DMA stream */
   2150                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length) != HAL_OK)
   \      0x118   0x003B             MOVS     R3,R7
   \      0x11A   0xB29B             UXTH     R3,R3
   \      0x11C   0x0022             MOVS     R2,R4
   \      0x11E   0x6828             LDR      R0,[R5, #+0]
   \      0x120   0xF110 0x0140      ADDS     R1,R0,#+64
   \      0x124   0x6B28             LDR      R0,[R5, #+48]
   \      0x126   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x12A   0x2800             CMP      R0,#+0
   \      0x12C   0xD001             BEQ.N    ??HAL_TIM_IC_Start_DMA_13
   2151                {
   2152                  return HAL_ERROR;
   \      0x12E   0x2001             MOVS     R0,#+1
   \      0x130   0xE018             B.N      ??HAL_TIM_IC_Start_DMA_1
   2153                }
   2154                /* Enable the TIM Capture/Compare 4  DMA request */
   2155                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_IC_Start_DMA_13: (+1)
   \      0x132   0x6828             LDR      R0,[R5, #+0]
   \      0x134   0x68C0             LDR      R0,[R0, #+12]
   \      0x136   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \      0x13A   0x6829             LDR      R1,[R5, #+0]
   \      0x13C   0x60C8             STR      R0,[R1, #+12]
   2156                break;
   \      0x13E   0xE7FF             B.N      ??HAL_TIM_IC_Start_DMA_10
   2157              }
   2158          
   2159              default:
   2160                break;
   2161            }
   2162          
   2163            /* Enable the Input Capture channel */
   2164            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_DMA_8: (+1)
   \                     ??HAL_TIM_IC_Start_DMA_10: (+1)
   \      0x140   0x2201             MOVS     R2,#+1
   \      0x142   0x0031             MOVS     R1,R6
   \      0x144   0x6828             LDR      R0,[R5, #+0]
   \      0x146   0x.... 0x....      BL       TIM_CCxChannelCmd
   2165          
   2166            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   2167            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \      0x14A   0x6828             LDR      R0,[R5, #+0]
   \      0x14C   0x6881             LDR      R1,[R0, #+8]
   \      0x14E   0xF011 0x0107      ANDS     R1,R1,#0x7
   2168            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \      0x152   0x2906             CMP      R1,#+6
   \      0x154   0xD005             BEQ.N    ??HAL_TIM_IC_Start_DMA_14
   2169            {
   2170              __HAL_TIM_ENABLE(htim);
   \      0x156   0x6828             LDR      R0,[R5, #+0]
   \      0x158   0x6800             LDR      R0,[R0, #+0]
   \      0x15A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x15E   0x682A             LDR      R2,[R5, #+0]
   \      0x160   0x6010             STR      R0,[R2, #+0]
   2171            }
   2172          
   2173            /* Return function status */
   2174            return HAL_OK;
   \                     ??HAL_TIM_IC_Start_DMA_14: (+1)
   \      0x162   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_Start_DMA_1: (+1)
   \      0x164   0xBDF2             POP      {R1,R4-R7,PC}
   2175          }
   2176          
   2177          /**
   2178            * @brief  Stops the TIM Input Capture measurement in DMA mode.
   2179            * @param  htim TIM Input Capture handle
   2180            * @param  Channel TIM Channels to be disabled
   2181            *          This parameter can be one of the following values:
   2182            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2183            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2184            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2185            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2186            * @retval HAL status
   2187            */

   \                                 In section .text, align 2, keep-with-next
   2188          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2189          {
   \                     HAL_TIM_IC_Stop_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2190            /* Check the parameters */
   2191            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   2192            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2193          
   2194            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ.N    ??HAL_TIM_IC_Stop_DMA_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00E             BEQ.N    ??HAL_TIM_IC_Stop_DMA_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD016             BEQ.N    ??HAL_TIM_IC_Stop_DMA_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD01E             BEQ.N    ??HAL_TIM_IC_Stop_DMA_3
   \       0x18   0xE027             B.N      ??HAL_TIM_IC_Stop_DMA_4
   2195            {
   2196              case TIM_CHANNEL_1:
   2197              {
   2198                /* Disable the TIM Capture/Compare 1 DMA request */
   2199                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_IC_Stop_DMA_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0xF430 0x7000      BICS     R0,R0,#0x200
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x60C8             STR      R0,[R1, #+12]
   2200                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x26   0x6A60             LDR      R0,[R4, #+36]
   \       0x28   0x.... 0x....      BL       HAL_DMA_Abort_IT
   2201                break;
   \       0x2C   0xE01D             B.N      ??HAL_TIM_IC_Stop_DMA_5
   2202              }
   2203          
   2204              case TIM_CHANNEL_2:
   2205              {
   2206                /* Disable the TIM Capture/Compare 2 DMA request */
   2207                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_IC_Stop_DMA_1: (+1)
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x68C0             LDR      R0,[R0, #+12]
   \       0x32   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x36   0x6821             LDR      R1,[R4, #+0]
   \       0x38   0x60C8             STR      R0,[R1, #+12]
   2208                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \       0x3A   0x6AA0             LDR      R0,[R4, #+40]
   \       0x3C   0x.... 0x....      BL       HAL_DMA_Abort_IT
   2209                break;
   \       0x40   0xE013             B.N      ??HAL_TIM_IC_Stop_DMA_5
   2210              }
   2211          
   2212              case TIM_CHANNEL_3:
   2213              {
   2214                /* Disable the TIM Capture/Compare 3  DMA request */
   2215                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_IC_Stop_DMA_2: (+1)
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x68C0             LDR      R0,[R0, #+12]
   \       0x46   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x4A   0x6821             LDR      R1,[R4, #+0]
   \       0x4C   0x60C8             STR      R0,[R1, #+12]
   2216                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   \       0x4E   0x6AE0             LDR      R0,[R4, #+44]
   \       0x50   0x.... 0x....      BL       HAL_DMA_Abort_IT
   2217                break;
   \       0x54   0xE009             B.N      ??HAL_TIM_IC_Stop_DMA_5
   2218              }
   2219          
   2220              case TIM_CHANNEL_4:
   2221              {
   2222                /* Disable the TIM Capture/Compare 4  DMA request */
   2223                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_IC_Stop_DMA_3: (+1)
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x68C0             LDR      R0,[R0, #+12]
   \       0x5A   0xF430 0x5080      BICS     R0,R0,#0x1000
   \       0x5E   0x6821             LDR      R1,[R4, #+0]
   \       0x60   0x60C8             STR      R0,[R1, #+12]
   2224                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   \       0x62   0x6B20             LDR      R0,[R4, #+48]
   \       0x64   0x.... 0x....      BL       HAL_DMA_Abort_IT
   2225                break;
   \       0x68   0xE7FF             B.N      ??HAL_TIM_IC_Stop_DMA_5
   2226              }
   2227          
   2228              default:
   2229                break;
   2230            }
   2231          
   2232            /* Disable the Input Capture channel */
   2233            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_IC_Stop_DMA_4: (+1)
   \                     ??HAL_TIM_IC_Stop_DMA_5: (+1)
   \       0x6A   0x2200             MOVS     R2,#+0
   \       0x6C   0x0029             MOVS     R1,R5
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x.... 0x....      BL       TIM_CCxChannelCmd
   2234          
   2235            /* Disable the Peripheral */
   2236            __HAL_TIM_DISABLE(htim);
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x6A00             LDR      R0,[R0, #+32]
   \       0x78   0xF241 0x1111      MOVW     R1,#+4369
   \       0x7C   0x4208             TST      R0,R1
   \       0x7E   0xD10B             BNE.N    ??HAL_TIM_IC_Stop_DMA_6
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x6A00             LDR      R0,[R0, #+32]
   \       0x84   0xF240 0x4144      MOVW     R1,#+1092
   \       0x88   0x4208             TST      R0,R1
   \       0x8A   0xD105             BNE.N    ??HAL_TIM_IC_Stop_DMA_6
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x6800             LDR      R0,[R0, #+0]
   \       0x90   0x0840             LSRS     R0,R0,#+1
   \       0x92   0x0040             LSLS     R0,R0,#+1
   \       0x94   0x6821             LDR      R1,[R4, #+0]
   \       0x96   0x6008             STR      R0,[R1, #+0]
   2237          
   2238            /* Change the htim state */
   2239            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_Stop_DMA_6: (+1)
   \       0x98   0x2001             MOVS     R0,#+1
   \       0x9A   0xF884 0x003D      STRB     R0,[R4, #+61]
   2240          
   2241            /* Return function status */
   2242            return HAL_OK;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0xBD32             POP      {R1,R4,R5,PC}
   2243          }
   2244          /**
   2245            * @}
   2246            */
   2247          
   2248          /** @defgroup TIM_Exported_Functions_Group5 TIM One Pulse functions
   2249            *  @brief    TIM One Pulse functions
   2250            *
   2251          @verbatim
   2252            ==============================================================================
   2253                                  ##### TIM One Pulse functions #####
   2254            ==============================================================================
   2255            [..]
   2256              This section provides functions allowing to:
   2257              (+) Initialize and configure the TIM One Pulse.
   2258              (+) De-initialize the TIM One Pulse.
   2259              (+) Start the TIM One Pulse.
   2260              (+) Stop the TIM One Pulse.
   2261              (+) Start the TIM One Pulse and enable interrupt.
   2262              (+) Stop the TIM One Pulse and disable interrupt.
   2263              (+) Start the TIM One Pulse and enable DMA transfer.
   2264              (+) Stop the TIM One Pulse and disable DMA transfer.
   2265          
   2266          @endverbatim
   2267            * @{
   2268            */
   2269          /**
   2270            * @brief  Initializes the TIM One Pulse Time Base according to the specified
   2271            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   2272            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   2273            *         requires a timer reset to avoid unexpected direction
   2274            *         due to DIR bit readonly in center aligned mode.
   2275            *         Ex: call @ref HAL_TIM_OnePulse_DeInit() before HAL_TIM_OnePulse_Init()
   2276            * @param  htim TIM One Pulse handle
   2277            * @param  OnePulseMode Select the One pulse mode.
   2278            *         This parameter can be one of the following values:
   2279            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
   2280            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.
   2281            * @retval HAL status
   2282            */

   \                                 In section .text, align 2, keep-with-next
   2283          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
   2284          {
   \                     HAL_TIM_OnePulse_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2285            /* Check the TIM handle allocation */
   2286            if (htim == NULL)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??HAL_TIM_OnePulse_Init_0
   2287            {
   2288              return HAL_ERROR;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE01F             B.N      ??HAL_TIM_OnePulse_Init_1
   2289            }
   2290          
   2291            /* Check the parameters */
   2292            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2293            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2294            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2295            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
   2296            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   2297          
   2298            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OnePulse_Init_0: (+1)
   \        0xE   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD105             BNE.N    ??HAL_TIM_OnePulse_Init_2
   2299            {
   2300              /* Allocate lock resource and initialize it */
   2301              htim->Lock = HAL_UNLOCKED;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xF884 0x003C      STRB     R0,[R4, #+60]
   2302          
   2303          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2304              /* Reset interrupt callbacks to legacy weak callbacks */
   2305              TIM_ResetCallback(htim);
   2306          
   2307              if (htim->OnePulse_MspInitCallback == NULL)
   2308              {
   2309                htim->OnePulse_MspInitCallback = HAL_TIM_OnePulse_MspInit;
   2310              }
   2311              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   2312              htim->OnePulse_MspInitCallback(htim);
   2313          #else
   2314              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2315              HAL_TIM_OnePulse_MspInit(htim);
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       HAL_TIM_OnePulse_MspInit
   2316          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2317            }
   2318          
   2319            /* Set the TIM state */
   2320            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OnePulse_Init_2: (+1)
   \       0x22   0x2002             MOVS     R0,#+2
   \       0x24   0xF884 0x003D      STRB     R0,[R4, #+61]
   2321          
   2322            /* Configure the Time base in the One Pulse Mode */
   2323            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x28   0x1D21             ADDS     R1,R4,#+4
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x.... 0x....      BL       TIM_Base_SetConfig
   2324          
   2325            /* Reset the OPM Bit */
   2326            htim->Instance->CR1 &= ~TIM_CR1_OPM;
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6800             LDR      R0,[R0, #+0]
   \       0x34   0xF030 0x0008      BICS     R0,R0,#0x8
   \       0x38   0x6821             LDR      R1,[R4, #+0]
   \       0x3A   0x6008             STR      R0,[R1, #+0]
   2327          
   2328            /* Configure the OPM Mode */
   2329            htim->Instance->CR1 |= OnePulseMode;
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x6800             LDR      R0,[R0, #+0]
   \       0x40   0x4328             ORRS     R0,R5,R0
   \       0x42   0x6821             LDR      R1,[R4, #+0]
   \       0x44   0x6008             STR      R0,[R1, #+0]
   2330          
   2331            /* Initialize the TIM state*/
   2332            htim->State = HAL_TIM_STATE_READY;
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0xF884 0x003D      STRB     R0,[R4, #+61]
   2333          
   2334            return HAL_OK;
   \       0x4C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OnePulse_Init_1: (+1)
   \       0x4E   0xBD32             POP      {R1,R4,R5,PC}
   2335          }
   2336          
   2337          /**
   2338            * @brief  DeInitializes the TIM One Pulse
   2339            * @param  htim TIM One Pulse handle
   2340            * @retval HAL status
   2341            */

   \                                 In section .text, align 2, keep-with-next
   2342          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
   2343          {
   \                     HAL_TIM_OnePulse_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2344            /* Check the parameters */
   2345            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2346          
   2347            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0xF884 0x003D      STRB     R0,[R4, #+61]
   2348          
   2349            /* Disable the TIM Peripheral Clock */
   2350            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0xF241 0x1111      MOVW     R1,#+4369
   \       0x12   0x4208             TST      R0,R1
   \       0x14   0xD10B             BNE.N    ??HAL_TIM_OnePulse_DeInit_0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6A00             LDR      R0,[R0, #+32]
   \       0x1A   0xF240 0x4144      MOVW     R1,#+1092
   \       0x1E   0x4208             TST      R0,R1
   \       0x20   0xD105             BNE.N    ??HAL_TIM_OnePulse_DeInit_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x0840             LSRS     R0,R0,#+1
   \       0x28   0x0040             LSLS     R0,R0,#+1
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6008             STR      R0,[R1, #+0]
   2351          
   2352          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2353            if (htim->OnePulse_MspDeInitCallback == NULL)
   2354            {
   2355              htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspDeInit;
   2356            }
   2357            /* DeInit the low level hardware */
   2358            htim->OnePulse_MspDeInitCallback(htim);
   2359          #else
   2360            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2361            HAL_TIM_OnePulse_MspDeInit(htim);
   \                     ??HAL_TIM_OnePulse_DeInit_0: (+1)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       HAL_TIM_OnePulse_MspDeInit
   2362          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2363          
   2364            /* Change TIM state */
   2365            htim->State = HAL_TIM_STATE_RESET;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF884 0x003D      STRB     R0,[R4, #+61]
   2366          
   2367            /* Release Lock */
   2368            __HAL_UNLOCK(htim);
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xF884 0x003C      STRB     R0,[R4, #+60]
   2369          
   2370            return HAL_OK;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD10             POP      {R4,PC}
   2371          }
   2372          
   2373          /**
   2374            * @brief  Initializes the TIM One Pulse MSP.
   2375            * @param  htim TIM One Pulse handle
   2376            * @retval None
   2377            */

   \                                 In section .text, align 2
   2378          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
   2379          {
   2380            /* Prevent unused argument(s) compilation warning */
   2381            UNUSED(htim);
   2382          
   2383            /* NOTE : This function should not be modified, when the callback is needed,
   2384                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   2385             */
   2386          }
   \                     HAL_TIM_OnePulse_MspInit: (+1)
   \        0x0   0x4770             BX       LR
   2387          
   2388          /**
   2389            * @brief  DeInitializes TIM One Pulse MSP.
   2390            * @param  htim TIM One Pulse handle
   2391            * @retval None
   2392            */

   \                                 In section .text, align 2
   2393          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
   2394          {
   2395            /* Prevent unused argument(s) compilation warning */
   2396            UNUSED(htim);
   2397          
   2398            /* NOTE : This function should not be modified, when the callback is needed,
   2399                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   2400             */
   2401          }
   \                     HAL_TIM_OnePulse_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
   2402          
   2403          /**
   2404            * @brief  Starts the TIM One Pulse signal generation.
   2405            * @param  htim TIM One Pulse handle
   2406            * @param  OutputChannel TIM Channels to be enabled
   2407            *          This parameter can be one of the following values:
   2408            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2409            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2410            * @retval HAL status
   2411            */

   \                                 In section .text, align 2, keep-with-next
   2412          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2413          {
   \                     HAL_TIM_OnePulse_Start: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2414            /* Prevent unused argument(s) compilation warning */
   2415            UNUSED(OutputChannel);
   2416          
   2417            /* Enable the Capture compare and the Input Capture channels
   2418              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2419              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2420              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2421              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
   2422          
   2423              No need to enable the counter, it's enabled automatically by hardware
   2424              (the counter starts in response to a stimulus and generate a pulse */
   2425          
   2426            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \        0x6   0x2201             MOVS     R2,#+1
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x.... 0x....      BL       TIM_CCxChannelCmd
   2427            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \       0x10   0x2201             MOVS     R2,#+1
   \       0x12   0x2104             MOVS     R1,#+4
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x.... 0x....      BL       TIM_CCxChannelCmd
   2428          
   2429            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD004             BEQ.N    ??HAL_TIM_OnePulse_Start_0
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \       0x2A   0x4288             CMP      R0,R1
   \       0x2C   0xD101             BNE.N    ??HAL_TIM_OnePulse_Start_1
   \                     ??HAL_TIM_OnePulse_Start_0: (+1)
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xE000             B.N      ??HAL_TIM_OnePulse_Start_2
   \                     ??HAL_TIM_OnePulse_Start_1: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OnePulse_Start_2: (+1)
   \       0x34   0xB2C0             UXTB     R0,R0
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD005             BEQ.N    ??HAL_TIM_OnePulse_Start_3
   2430            {
   2431              /* Enable the main output */
   2432              __HAL_TIM_MOE_ENABLE(htim);
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x6C40             LDR      R0,[R0, #+68]
   \       0x3E   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0x42   0x6821             LDR      R1,[R4, #+0]
   \       0x44   0x6448             STR      R0,[R1, #+68]
   2433            }
   2434          
   2435            /* Return function status */
   2436            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Start_3: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0xBD32             POP      {R1,R4,R5,PC}
   2437          }
   2438          
   2439          /**
   2440            * @brief  Stops the TIM One Pulse signal generation.
   2441            * @param  htim TIM One Pulse handle
   2442            * @param  OutputChannel TIM Channels to be disable
   2443            *          This parameter can be one of the following values:
   2444            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2445            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2446            * @retval HAL status
   2447            */

   \                                 In section .text, align 2, keep-with-next
   2448          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2449          {
   \                     HAL_TIM_OnePulse_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2450            /* Prevent unused argument(s) compilation warning */
   2451            UNUSED(OutputChannel);
   2452          
   2453            /* Disable the Capture compare and the Input Capture channels
   2454            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2455            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2456            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2457            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2458          
   2459            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x.... 0x....      BL       TIM_CCxChannelCmd
   2460            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x10   0x2200             MOVS     R2,#+0
   \       0x12   0x2104             MOVS     R1,#+4
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x.... 0x....      BL       TIM_CCxChannelCmd
   2461          
   2462            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD004             BEQ.N    ??HAL_TIM_OnePulse_Stop_0
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \       0x2A   0x4288             CMP      R0,R1
   \       0x2C   0xD101             BNE.N    ??HAL_TIM_OnePulse_Stop_1
   \                     ??HAL_TIM_OnePulse_Stop_0: (+1)
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xE000             B.N      ??HAL_TIM_OnePulse_Stop_2
   \                     ??HAL_TIM_OnePulse_Stop_1: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OnePulse_Stop_2: (+1)
   \       0x34   0xB2C0             UXTB     R0,R0
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD011             BEQ.N    ??HAL_TIM_OnePulse_Stop_3
   2463            {
   2464              /* Disable the Main Output */
   2465              __HAL_TIM_MOE_DISABLE(htim);
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x6A00             LDR      R0,[R0, #+32]
   \       0x3E   0xF241 0x1111      MOVW     R1,#+4369
   \       0x42   0x4208             TST      R0,R1
   \       0x44   0xD10B             BNE.N    ??HAL_TIM_OnePulse_Stop_4
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x6A00             LDR      R0,[R0, #+32]
   \       0x4A   0xF240 0x4144      MOVW     R1,#+1092
   \       0x4E   0x4208             TST      R0,R1
   \       0x50   0xD105             BNE.N    ??HAL_TIM_OnePulse_Stop_4
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x6C40             LDR      R0,[R0, #+68]
   \       0x56   0xF430 0x4000      BICS     R0,R0,#0x8000
   \       0x5A   0x6821             LDR      R1,[R4, #+0]
   \       0x5C   0x6448             STR      R0,[R1, #+68]
   2466            }
   2467          
   2468            /* Disable the Peripheral */
   2469            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OnePulse_Stop_4: (+1)
   \                     ??HAL_TIM_OnePulse_Stop_3: (+1)
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6A00             LDR      R0,[R0, #+32]
   \       0x62   0xF241 0x1111      MOVW     R1,#+4369
   \       0x66   0x4208             TST      R0,R1
   \       0x68   0xD10B             BNE.N    ??HAL_TIM_OnePulse_Stop_5
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x6A00             LDR      R0,[R0, #+32]
   \       0x6E   0xF240 0x4144      MOVW     R1,#+1092
   \       0x72   0x4208             TST      R0,R1
   \       0x74   0xD105             BNE.N    ??HAL_TIM_OnePulse_Stop_5
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x6800             LDR      R0,[R0, #+0]
   \       0x7A   0x0840             LSRS     R0,R0,#+1
   \       0x7C   0x0040             LSLS     R0,R0,#+1
   \       0x7E   0x6821             LDR      R1,[R4, #+0]
   \       0x80   0x6008             STR      R0,[R1, #+0]
   2470          
   2471            /* Return function status */
   2472            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_5: (+1)
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0xBD32             POP      {R1,R4,R5,PC}
   2473          }
   2474          
   2475          /**
   2476            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2477            * @param  htim TIM One Pulse handle
   2478            * @param  OutputChannel TIM Channels to be enabled
   2479            *          This parameter can be one of the following values:
   2480            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2481            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2482            * @retval HAL status
   2483            */

   \                                 In section .text, align 2, keep-with-next
   2484          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2485          {
   \                     HAL_TIM_OnePulse_Start_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2486            /* Prevent unused argument(s) compilation warning */
   2487            UNUSED(OutputChannel);
   2488          
   2489            /* Enable the Capture compare and the Input Capture channels
   2490              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2491              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2492              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2493              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
   2494          
   2495              No need to enable the counter, it's enabled automatically by hardware
   2496              (the counter starts in response to a stimulus and generate a pulse */
   2497          
   2498            /* Enable the TIM Capture/Compare 1 interrupt */
   2499            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x68C0             LDR      R0,[R0, #+12]
   \        0xA   0xF050 0x0002      ORRS     R0,R0,#0x2
   \        0xE   0x6821             LDR      R1,[R4, #+0]
   \       0x10   0x60C8             STR      R0,[R1, #+12]
   2500          
   2501            /* Enable the TIM Capture/Compare 2 interrupt */
   2502            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x68C0             LDR      R0,[R0, #+12]
   \       0x16   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x1A   0x6821             LDR      R1,[R4, #+0]
   \       0x1C   0x60C8             STR      R0,[R1, #+12]
   2503          
   2504            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \       0x1E   0x2201             MOVS     R2,#+1
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x.... 0x....      BL       TIM_CCxChannelCmd
   2505            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \       0x28   0x2201             MOVS     R2,#+1
   \       0x2A   0x2104             MOVS     R1,#+4
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2506          
   2507            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \       0x38   0x4288             CMP      R0,R1
   \       0x3A   0xD004             BEQ.N    ??HAL_TIM_OnePulse_Start_IT_0
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \       0x42   0x4288             CMP      R0,R1
   \       0x44   0xD101             BNE.N    ??HAL_TIM_OnePulse_Start_IT_1
   \                     ??HAL_TIM_OnePulse_Start_IT_0: (+1)
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0xE000             B.N      ??HAL_TIM_OnePulse_Start_IT_2
   \                     ??HAL_TIM_OnePulse_Start_IT_1: (+1)
   \       0x4A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OnePulse_Start_IT_2: (+1)
   \       0x4C   0xB2C0             UXTB     R0,R0
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD005             BEQ.N    ??HAL_TIM_OnePulse_Start_IT_3
   2508            {
   2509              /* Enable the main output */
   2510              __HAL_TIM_MOE_ENABLE(htim);
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x6C40             LDR      R0,[R0, #+68]
   \       0x56   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0x5A   0x6821             LDR      R1,[R4, #+0]
   \       0x5C   0x6448             STR      R0,[R1, #+68]
   2511            }
   2512          
   2513            /* Return function status */
   2514            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Start_IT_3: (+1)
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xBD32             POP      {R1,R4,R5,PC}
   2515          }
   2516          
   2517          /**
   2518            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2519            * @param  htim TIM One Pulse handle
   2520            * @param  OutputChannel TIM Channels to be enabled
   2521            *          This parameter can be one of the following values:
   2522            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2523            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2524            * @retval HAL status
   2525            */

   \                                 In section .text, align 2, keep-with-next
   2526          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2527          {
   \                     HAL_TIM_OnePulse_Stop_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2528            /* Prevent unused argument(s) compilation warning */
   2529            UNUSED(OutputChannel);
   2530          
   2531            /* Disable the TIM Capture/Compare 1 interrupt */
   2532            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x68C0             LDR      R0,[R0, #+12]
   \        0xA   0xF030 0x0002      BICS     R0,R0,#0x2
   \        0xE   0x6821             LDR      R1,[R4, #+0]
   \       0x10   0x60C8             STR      R0,[R1, #+12]
   2533          
   2534            /* Disable the TIM Capture/Compare 2 interrupt */
   2535            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x68C0             LDR      R0,[R0, #+12]
   \       0x16   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0x1A   0x6821             LDR      R1,[R4, #+0]
   \       0x1C   0x60C8             STR      R0,[R1, #+12]
   2536          
   2537            /* Disable the Capture compare and the Input Capture channels
   2538            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2539            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2540            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2541            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2542            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \       0x1E   0x2200             MOVS     R2,#+0
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x.... 0x....      BL       TIM_CCxChannelCmd
   2543            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x28   0x2200             MOVS     R2,#+0
   \       0x2A   0x2104             MOVS     R1,#+4
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2544          
   2545            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \       0x38   0x4288             CMP      R0,R1
   \       0x3A   0xD004             BEQ.N    ??HAL_TIM_OnePulse_Stop_IT_0
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \       0x42   0x4288             CMP      R0,R1
   \       0x44   0xD101             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_1
   \                     ??HAL_TIM_OnePulse_Stop_IT_0: (+1)
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0xE000             B.N      ??HAL_TIM_OnePulse_Stop_IT_2
   \                     ??HAL_TIM_OnePulse_Stop_IT_1: (+1)
   \       0x4A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OnePulse_Stop_IT_2: (+1)
   \       0x4C   0xB2C0             UXTB     R0,R0
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD011             BEQ.N    ??HAL_TIM_OnePulse_Stop_IT_3
   2546            {
   2547              /* Disable the Main Output */
   2548              __HAL_TIM_MOE_DISABLE(htim);
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x6A00             LDR      R0,[R0, #+32]
   \       0x56   0xF241 0x1111      MOVW     R1,#+4369
   \       0x5A   0x4208             TST      R0,R1
   \       0x5C   0xD10B             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_4
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6A00             LDR      R0,[R0, #+32]
   \       0x62   0xF240 0x4144      MOVW     R1,#+1092
   \       0x66   0x4208             TST      R0,R1
   \       0x68   0xD105             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_4
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x6C40             LDR      R0,[R0, #+68]
   \       0x6E   0xF430 0x4000      BICS     R0,R0,#0x8000
   \       0x72   0x6821             LDR      R1,[R4, #+0]
   \       0x74   0x6448             STR      R0,[R1, #+68]
   2549            }
   2550          
   2551            /* Disable the Peripheral */
   2552            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OnePulse_Stop_IT_4: (+1)
   \                     ??HAL_TIM_OnePulse_Stop_IT_3: (+1)
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x6A00             LDR      R0,[R0, #+32]
   \       0x7A   0xF241 0x1111      MOVW     R1,#+4369
   \       0x7E   0x4208             TST      R0,R1
   \       0x80   0xD10B             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_5
   \       0x82   0x6820             LDR      R0,[R4, #+0]
   \       0x84   0x6A00             LDR      R0,[R0, #+32]
   \       0x86   0xF240 0x4144      MOVW     R1,#+1092
   \       0x8A   0x4208             TST      R0,R1
   \       0x8C   0xD105             BNE.N    ??HAL_TIM_OnePulse_Stop_IT_5
   \       0x8E   0x6820             LDR      R0,[R4, #+0]
   \       0x90   0x6800             LDR      R0,[R0, #+0]
   \       0x92   0x0840             LSRS     R0,R0,#+1
   \       0x94   0x0040             LSLS     R0,R0,#+1
   \       0x96   0x6821             LDR      R1,[R4, #+0]
   \       0x98   0x6008             STR      R0,[R1, #+0]
   2553          
   2554            /* Return function status */
   2555            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_IT_5: (+1)
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0xBD32             POP      {R1,R4,R5,PC}
   2556          }
   2557          
   2558          /**
   2559            * @}
   2560            */
   2561          
   2562          /** @defgroup TIM_Exported_Functions_Group6 TIM Encoder functions
   2563            *  @brief    TIM Encoder functions
   2564            *
   2565          @verbatim
   2566            ==============================================================================
   2567                                    ##### TIM Encoder functions #####
   2568            ==============================================================================
   2569            [..]
   2570              This section provides functions allowing to:
   2571              (+) Initialize and configure the TIM Encoder.
   2572              (+) De-initialize the TIM Encoder.
   2573              (+) Start the TIM Encoder.
   2574              (+) Stop the TIM Encoder.
   2575              (+) Start the TIM Encoder and enable interrupt.
   2576              (+) Stop the TIM Encoder and disable interrupt.
   2577              (+) Start the TIM Encoder and enable DMA transfer.
   2578              (+) Stop the TIM Encoder and disable DMA transfer.
   2579          
   2580          @endverbatim
   2581            * @{
   2582            */
   2583          /**
   2584            * @brief  Initializes the TIM Encoder Interface and initialize the associated handle.
   2585            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   2586            *         requires a timer reset to avoid unexpected direction
   2587            *         due to DIR bit readonly in center aligned mode.
   2588            *         Ex: call @ref HAL_TIM_Encoder_DeInit() before HAL_TIM_Encoder_Init()
   2589            * @note   Encoder mode and External clock mode 2 are not compatible and must not be selected together
   2590            *         Ex: A call for @ref HAL_TIM_Encoder_Init will erase the settings of @ref HAL_TIM_ConfigClockSource
   2591            *         using TIM_CLOCKSOURCE_ETRMODE2 and vice versa
   2592            * @param  htim TIM Encoder Interface handle
   2593            * @param  sConfig TIM Encoder Interface configuration structure
   2594            * @retval HAL status
   2595            */

   \                                 In section .text, align 2, keep-with-next
   2596          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef *sConfig)
   2597          {
   \                     HAL_TIM_Encoder_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2598            uint32_t tmpsmcr;
   2599            uint32_t tmpccmr1;
   2600            uint32_t tmpccer;
   2601          
   2602            /* Check the TIM handle allocation */
   2603            if (htim == NULL)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??HAL_TIM_Encoder_Init_0
   2604            {
   2605              return HAL_ERROR;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE04B             B.N      ??HAL_TIM_Encoder_Init_1
   2606            }
   2607          
   2608            /* Check the parameters */
   2609            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2610            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2611            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   2612            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2613            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
   2614            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
   2615            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
   2616            assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC1Polarity));
   2617            assert_param(IS_TIM_ENCODERINPUT_POLARITY(sConfig->IC2Polarity));
   2618            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
   2619            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
   2620            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
   2621            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
   2622          
   2623            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Encoder_Init_0: (+1)
   \        0xE   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD105             BNE.N    ??HAL_TIM_Encoder_Init_2
   2624            {
   2625              /* Allocate lock resource and initialize it */
   2626              htim->Lock = HAL_UNLOCKED;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xF884 0x003C      STRB     R0,[R4, #+60]
   2627          
   2628          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2629              /* Reset interrupt callbacks to legacy weak callbacks */
   2630              TIM_ResetCallback(htim);
   2631          
   2632              if (htim->Encoder_MspInitCallback == NULL)
   2633              {
   2634                htim->Encoder_MspInitCallback = HAL_TIM_Encoder_MspInit;
   2635              }
   2636              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   2637              htim->Encoder_MspInitCallback(htim);
   2638          #else
   2639              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2640              HAL_TIM_Encoder_MspInit(htim);
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       HAL_TIM_Encoder_MspInit
   2641          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2642            }
   2643          
   2644            /* Set the TIM state */
   2645            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Init_2: (+1)
   \       0x22   0x2002             MOVS     R0,#+2
   \       0x24   0xF884 0x003D      STRB     R0,[R4, #+61]
   2646          
   2647            /* Reset the SMS and ECE bits */
   2648            htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x6881             LDR      R1,[R0, #+8]
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable21
   \       0x30   0x4001             ANDS     R1,R0,R1
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x6081             STR      R1,[R0, #+8]
   2649          
   2650            /* Configure the Time base in the Encoder Mode */
   2651            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x36   0x1D21             ADDS     R1,R4,#+4
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x.... 0x....      BL       TIM_Base_SetConfig
   2652          
   2653            /* Get the TIMx SMCR register value */
   2654            tmpsmcr = htim->Instance->SMCR;
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6881             LDR      R1,[R0, #+8]
   2655          
   2656            /* Get the TIMx CCMR1 register value */
   2657            tmpccmr1 = htim->Instance->CCMR1;
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x6982             LDR      R2,[R0, #+24]
   2658          
   2659            /* Get the TIMx CCER register value */
   2660            tmpccer = htim->Instance->CCER;
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x6A03             LDR      R3,[R0, #+32]
   2661          
   2662            /* Set the encoder Mode */
   2663            tmpsmcr |= sConfig->EncoderMode;
   \       0x4A   0x6828             LDR      R0,[R5, #+0]
   \       0x4C   0x4301             ORRS     R1,R0,R1
   2664          
   2665            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2666            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
   \       0x4E   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \       0x52   0x4002             ANDS     R2,R0,R2
   2667            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
   \       0x54   0x68A8             LDR      R0,[R5, #+8]
   \       0x56   0x4302             ORRS     R2,R0,R2
   \       0x58   0x69A8             LDR      R0,[R5, #+24]
   \       0x5A   0xEA52 0x2200      ORRS     R2,R2,R0, LSL #+8
   2668          
   2669            /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
   2670            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable21_2
   \       0x62   0x4002             ANDS     R2,R0,R2
   2671            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
   \       0x64   0x.... 0x....      LDR.W    R0,??DataTable21_3
   \       0x68   0x4002             ANDS     R2,R0,R2
   2672            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
   \       0x6A   0x68E8             LDR      R0,[R5, #+12]
   \       0x6C   0x4302             ORRS     R2,R0,R2
   \       0x6E   0x69E8             LDR      R0,[R5, #+28]
   \       0x70   0xEA52 0x2200      ORRS     R2,R2,R0, LSL #+8
   2673            tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
   \       0x74   0x6928             LDR      R0,[R5, #+16]
   \       0x76   0xEA52 0x1200      ORRS     R2,R2,R0, LSL #+4
   \       0x7A   0x6A28             LDR      R0,[R5, #+32]
   \       0x7C   0xEA52 0x3200      ORRS     R2,R2,R0, LSL #+12
   2674          
   2675            /* Set the TI1 and the TI2 Polarities */
   2676            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
   \       0x80   0xF033 0x0322      BICS     R3,R3,#0x22
   2677            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
   \       0x84   0xF033 0x0388      BICS     R3,R3,#0x88
   2678            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
   \       0x88   0x6868             LDR      R0,[R5, #+4]
   \       0x8A   0x4303             ORRS     R3,R0,R3
   \       0x8C   0x6968             LDR      R0,[R5, #+20]
   \       0x8E   0xEA53 0x1300      ORRS     R3,R3,R0, LSL #+4
   2679          
   2680            /* Write to TIMx SMCR */
   2681            htim->Instance->SMCR = tmpsmcr;
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x6081             STR      R1,[R0, #+8]
   2682          
   2683            /* Write to TIMx CCMR1 */
   2684            htim->Instance->CCMR1 = tmpccmr1;
   \       0x96   0x6820             LDR      R0,[R4, #+0]
   \       0x98   0x6182             STR      R2,[R0, #+24]
   2685          
   2686            /* Write to TIMx CCER */
   2687            htim->Instance->CCER = tmpccer;
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0x6203             STR      R3,[R0, #+32]
   2688          
   2689            /* Initialize the TIM state*/
   2690            htim->State = HAL_TIM_STATE_READY;
   \       0x9E   0x2001             MOVS     R0,#+1
   \       0xA0   0xF884 0x003D      STRB     R0,[R4, #+61]
   2691          
   2692            return HAL_OK;
   \       0xA4   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Encoder_Init_1: (+1)
   \       0xA6   0xBD32             POP      {R1,R4,R5,PC}
   2693          }
   2694          
   2695          
   2696          /**
   2697            * @brief  DeInitializes the TIM Encoder interface
   2698            * @param  htim TIM Encoder Interface handle
   2699            * @retval HAL status
   2700            */

   \                                 In section .text, align 2, keep-with-next
   2701          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
   2702          {
   \                     HAL_TIM_Encoder_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2703            /* Check the parameters */
   2704            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2705          
   2706            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0xF884 0x003D      STRB     R0,[R4, #+61]
   2707          
   2708            /* Disable the TIM Peripheral Clock */
   2709            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0xF241 0x1111      MOVW     R1,#+4369
   \       0x12   0x4208             TST      R0,R1
   \       0x14   0xD10B             BNE.N    ??HAL_TIM_Encoder_DeInit_0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6A00             LDR      R0,[R0, #+32]
   \       0x1A   0xF240 0x4144      MOVW     R1,#+1092
   \       0x1E   0x4208             TST      R0,R1
   \       0x20   0xD105             BNE.N    ??HAL_TIM_Encoder_DeInit_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x0840             LSRS     R0,R0,#+1
   \       0x28   0x0040             LSLS     R0,R0,#+1
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6008             STR      R0,[R1, #+0]
   2710          
   2711          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2712            if (htim->Encoder_MspDeInitCallback == NULL)
   2713            {
   2714              htim->Encoder_MspDeInitCallback = HAL_TIM_Encoder_MspDeInit;
   2715            }
   2716            /* DeInit the low level hardware */
   2717            htim->Encoder_MspDeInitCallback(htim);
   2718          #else
   2719            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2720            HAL_TIM_Encoder_MspDeInit(htim);
   \                     ??HAL_TIM_Encoder_DeInit_0: (+1)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x.... 0x....      BL       HAL_TIM_Encoder_MspDeInit
   2721          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2722          
   2723            /* Change TIM state */
   2724            htim->State = HAL_TIM_STATE_RESET;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF884 0x003D      STRB     R0,[R4, #+61]
   2725          
   2726            /* Release Lock */
   2727            __HAL_UNLOCK(htim);
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xF884 0x003C      STRB     R0,[R4, #+60]
   2728          
   2729            return HAL_OK;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD10             POP      {R4,PC}
   2730          }
   2731          
   2732          /**
   2733            * @brief  Initializes the TIM Encoder Interface MSP.
   2734            * @param  htim TIM Encoder Interface handle
   2735            * @retval None
   2736            */

   \                                 In section .text, align 2
   2737          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
   2738          {
   2739            /* Prevent unused argument(s) compilation warning */
   2740            UNUSED(htim);
   2741          
   2742            /* NOTE : This function should not be modified, when the callback is needed,
   2743                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
   2744             */
   2745          }
   \                     HAL_TIM_Encoder_MspInit: (+1)
   \        0x0   0x4770             BX       LR
   2746          
   2747          /**
   2748            * @brief  DeInitializes TIM Encoder Interface MSP.
   2749            * @param  htim TIM Encoder Interface handle
   2750            * @retval None
   2751            */

   \                                 In section .text, align 2
   2752          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
   2753          {
   2754            /* Prevent unused argument(s) compilation warning */
   2755            UNUSED(htim);
   2756          
   2757            /* NOTE : This function should not be modified, when the callback is needed,
   2758                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   2759             */
   2760          }
   \                     HAL_TIM_Encoder_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
   2761          
   2762          /**
   2763            * @brief  Starts the TIM Encoder Interface.
   2764            * @param  htim TIM Encoder Interface handle
   2765            * @param  Channel TIM Channels to be enabled
   2766            *          This parameter can be one of the following values:
   2767            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2768            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2769            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2770            * @retval HAL status
   2771            */

   \                                 In section .text, align 2, keep-with-next
   2772          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2773          {
   \                     HAL_TIM_Encoder_Start: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2774            /* Check the parameters */
   2775            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2776          
   2777            /* Enable the encoder interface channels */
   2778            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??HAL_TIM_Encoder_Start_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD006             BEQ.N    ??HAL_TIM_Encoder_Start_1
   \       0x10   0xE00B             B.N      ??HAL_TIM_Encoder_Start_2
   2779            {
   2780              case TIM_CHANNEL_1:
   2781              {
   2782                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_0: (+1)
   \       0x12   0x2201             MOVS     R2,#+1
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x.... 0x....      BL       TIM_CCxChannelCmd
   2783                break;
   \       0x1C   0xE00F             B.N      ??HAL_TIM_Encoder_Start_3
   2784              }
   2785          
   2786              case TIM_CHANNEL_2:
   2787              {
   2788                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_1: (+1)
   \       0x1E   0x2201             MOVS     R2,#+1
   \       0x20   0x2104             MOVS     R1,#+4
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x.... 0x....      BL       TIM_CCxChannelCmd
   2789                break;
   \       0x28   0xE009             B.N      ??HAL_TIM_Encoder_Start_3
   2790              }
   2791          
   2792              default :
   2793              {
   2794                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_2: (+1)
   \       0x2A   0x2201             MOVS     R2,#+1
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x.... 0x....      BL       TIM_CCxChannelCmd
   2795                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \       0x34   0x2201             MOVS     R2,#+1
   \       0x36   0x2104             MOVS     R1,#+4
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2796                break;
   2797              }
   2798            }
   2799            /* Enable the Peripheral */
   2800            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_3: (+1)
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6800             LDR      R0,[R0, #+0]
   \       0x42   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x46   0x6821             LDR      R1,[R4, #+0]
   \       0x48   0x6008             STR      R0,[R1, #+0]
   2801          
   2802            /* Return function status */
   2803            return HAL_OK;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xBD32             POP      {R1,R4,R5,PC}
   2804          }
   2805          
   2806          /**
   2807            * @brief  Stops the TIM Encoder Interface.
   2808            * @param  htim TIM Encoder Interface handle
   2809            * @param  Channel TIM Channels to be disabled
   2810            *          This parameter can be one of the following values:
   2811            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2812            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2813            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2814            * @retval HAL status
   2815            */

   \                                 In section .text, align 2, keep-with-next
   2816          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2817          {
   \                     HAL_TIM_Encoder_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2818            /* Check the parameters */
   2819            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2820          
   2821            /* Disable the Input Capture channels 1 and 2
   2822              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2823            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??HAL_TIM_Encoder_Stop_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD006             BEQ.N    ??HAL_TIM_Encoder_Stop_1
   \       0x10   0xE00B             B.N      ??HAL_TIM_Encoder_Stop_2
   2824            {
   2825              case TIM_CHANNEL_1:
   2826              {
   2827                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_0: (+1)
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x.... 0x....      BL       TIM_CCxChannelCmd
   2828                break;
   \       0x1C   0xE00F             B.N      ??HAL_TIM_Encoder_Stop_3
   2829              }
   2830          
   2831              case TIM_CHANNEL_2:
   2832              {
   2833                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_1: (+1)
   \       0x1E   0x2200             MOVS     R2,#+0
   \       0x20   0x2104             MOVS     R1,#+4
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x.... 0x....      BL       TIM_CCxChannelCmd
   2834                break;
   \       0x28   0xE009             B.N      ??HAL_TIM_Encoder_Stop_3
   2835              }
   2836          
   2837              default :
   2838              {
   2839                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_2: (+1)
   \       0x2A   0x2200             MOVS     R2,#+0
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x.... 0x....      BL       TIM_CCxChannelCmd
   2840                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x34   0x2200             MOVS     R2,#+0
   \       0x36   0x2104             MOVS     R1,#+4
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x.... 0x....      BL       TIM_CCxChannelCmd
   2841                break;
   2842              }
   2843            }
   2844          
   2845            /* Disable the Peripheral */
   2846            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_3: (+1)
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6A00             LDR      R0,[R0, #+32]
   \       0x42   0xF241 0x1111      MOVW     R1,#+4369
   \       0x46   0x4208             TST      R0,R1
   \       0x48   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_4
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x6A00             LDR      R0,[R0, #+32]
   \       0x4E   0xF240 0x4144      MOVW     R1,#+1092
   \       0x52   0x4208             TST      R0,R1
   \       0x54   0xD105             BNE.N    ??HAL_TIM_Encoder_Stop_4
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x6800             LDR      R0,[R0, #+0]
   \       0x5A   0x0840             LSRS     R0,R0,#+1
   \       0x5C   0x0040             LSLS     R0,R0,#+1
   \       0x5E   0x6821             LDR      R1,[R4, #+0]
   \       0x60   0x6008             STR      R0,[R1, #+0]
   2847          
   2848            /* Return function status */
   2849            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Stop_4: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xBD32             POP      {R1,R4,R5,PC}
   2850          }
   2851          
   2852          /**
   2853            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   2854            * @param  htim TIM Encoder Interface handle
   2855            * @param  Channel TIM Channels to be enabled
   2856            *          This parameter can be one of the following values:
   2857            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2858            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2859            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2860            * @retval HAL status
   2861            */

   \                                 In section .text, align 2, keep-with-next
   2862          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2863          {
   \                     HAL_TIM_Encoder_Start_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2864            /* Check the parameters */
   2865            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2866          
   2867            /* Enable the encoder interface channels */
   2868            /* Enable the capture compare Interrupts 1 and/or 2 */
   2869            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??HAL_TIM_Encoder_Start_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00C             BEQ.N    ??HAL_TIM_Encoder_Start_IT_1
   \       0x10   0xE017             B.N      ??HAL_TIM_Encoder_Start_IT_2
   2870            {
   2871              case TIM_CHANNEL_1:
   2872              {
   2873                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_0: (+1)
   \       0x12   0x2201             MOVS     R2,#+1
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x.... 0x....      BL       TIM_CCxChannelCmd
   2874                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x68C0             LDR      R0,[R0, #+12]
   \       0x20   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x24   0x6821             LDR      R1,[R4, #+0]
   \       0x26   0x60C8             STR      R0,[R1, #+12]
   2875                break;
   \       0x28   0xE021             B.N      ??HAL_TIM_Encoder_Start_IT_3
   2876              }
   2877          
   2878              case TIM_CHANNEL_2:
   2879              {
   2880                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_1: (+1)
   \       0x2A   0x2201             MOVS     R2,#+1
   \       0x2C   0x2104             MOVS     R1,#+4
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x.... 0x....      BL       TIM_CCxChannelCmd
   2881                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x68C0             LDR      R0,[R0, #+12]
   \       0x38   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x3C   0x6821             LDR      R1,[R4, #+0]
   \       0x3E   0x60C8             STR      R0,[R1, #+12]
   2882                break;
   \       0x40   0xE015             B.N      ??HAL_TIM_Encoder_Start_IT_3
   2883              }
   2884          
   2885              default :
   2886              {
   2887                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_2: (+1)
   \       0x42   0x2201             MOVS     R2,#+1
   \       0x44   0x2100             MOVS     R1,#+0
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x.... 0x....      BL       TIM_CCxChannelCmd
   2888                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \       0x4C   0x2201             MOVS     R2,#+1
   \       0x4E   0x2104             MOVS     R1,#+4
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x.... 0x....      BL       TIM_CCxChannelCmd
   2889                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x68C0             LDR      R0,[R0, #+12]
   \       0x5A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x5E   0x6821             LDR      R1,[R4, #+0]
   \       0x60   0x60C8             STR      R0,[R1, #+12]
   2890                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x68C0             LDR      R0,[R0, #+12]
   \       0x66   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x6A   0x6821             LDR      R1,[R4, #+0]
   \       0x6C   0x60C8             STR      R0,[R1, #+12]
   2891                break;
   2892              }
   2893            }
   2894          
   2895            /* Enable the Peripheral */
   2896            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_IT_3: (+1)
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x6800             LDR      R0,[R0, #+0]
   \       0x72   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x76   0x6821             LDR      R1,[R4, #+0]
   \       0x78   0x6008             STR      R0,[R1, #+0]
   2897          
   2898            /* Return function status */
   2899            return HAL_OK;
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0xBD32             POP      {R1,R4,R5,PC}
   2900          }
   2901          
   2902          /**
   2903            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   2904            * @param  htim TIM Encoder Interface handle
   2905            * @param  Channel TIM Channels to be disabled
   2906            *          This parameter can be one of the following values:
   2907            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2908            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2909            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2910            * @retval HAL status
   2911            */

   \                                 In section .text, align 2, keep-with-next
   2912          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2913          {
   \                     HAL_TIM_Encoder_Stop_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   2914            /* Check the parameters */
   2915            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2916          
   2917            /* Disable the Input Capture channels 1 and 2
   2918              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2919            if (Channel == TIM_CHANNEL_1)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_IT_0
   2920            {
   2921              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x.... 0x....      BL       TIM_CCxChannelCmd
   2922          
   2923              /* Disable the capture compare Interrupts 1 */
   2924              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x68C0             LDR      R0,[R0, #+12]
   \       0x18   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x1C   0x6829             LDR      R1,[R5, #+0]
   \       0x1E   0x60C8             STR      R0,[R1, #+12]
   \       0x20   0xE023             B.N      ??HAL_TIM_Encoder_Stop_IT_1
   2925            }
   2926            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_IT_0: (+1)
   \       0x22   0x2C04             CMP      R4,#+4
   \       0x24   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_IT_2
   2927            {
   2928              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0x2104             MOVS     R1,#+4
   \       0x2A   0x6828             LDR      R0,[R5, #+0]
   \       0x2C   0x.... 0x....      BL       TIM_CCxChannelCmd
   2929          
   2930              /* Disable the capture compare Interrupts 2 */
   2931              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \       0x30   0x6828             LDR      R0,[R5, #+0]
   \       0x32   0x68C0             LDR      R0,[R0, #+12]
   \       0x34   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0x38   0x6829             LDR      R1,[R5, #+0]
   \       0x3A   0x60C8             STR      R0,[R1, #+12]
   \       0x3C   0xE015             B.N      ??HAL_TIM_Encoder_Stop_IT_1
   2932            }
   2933            else
   2934            {
   2935              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_IT_2: (+1)
   \       0x3E   0x2200             MOVS     R2,#+0
   \       0x40   0x2100             MOVS     R1,#+0
   \       0x42   0x6828             LDR      R0,[R5, #+0]
   \       0x44   0x.... 0x....      BL       TIM_CCxChannelCmd
   2936              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x48   0x2200             MOVS     R2,#+0
   \       0x4A   0x2104             MOVS     R1,#+4
   \       0x4C   0x6828             LDR      R0,[R5, #+0]
   \       0x4E   0x.... 0x....      BL       TIM_CCxChannelCmd
   2937          
   2938              /* Disable the capture compare Interrupts 1 and 2 */
   2939              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \       0x52   0x6828             LDR      R0,[R5, #+0]
   \       0x54   0x68C0             LDR      R0,[R0, #+12]
   \       0x56   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x5A   0x6829             LDR      R1,[R5, #+0]
   \       0x5C   0x60C8             STR      R0,[R1, #+12]
   2940              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \       0x5E   0x6828             LDR      R0,[R5, #+0]
   \       0x60   0x68C0             LDR      R0,[R0, #+12]
   \       0x62   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0x66   0x6829             LDR      R1,[R5, #+0]
   \       0x68   0x60C8             STR      R0,[R1, #+12]
   2941            }
   2942          
   2943            /* Disable the Peripheral */
   2944            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_IT_1: (+1)
   \       0x6A   0x6828             LDR      R0,[R5, #+0]
   \       0x6C   0x6A00             LDR      R0,[R0, #+32]
   \       0x6E   0xF241 0x1111      MOVW     R1,#+4369
   \       0x72   0x4208             TST      R0,R1
   \       0x74   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_IT_3
   \       0x76   0x6828             LDR      R0,[R5, #+0]
   \       0x78   0x6A00             LDR      R0,[R0, #+32]
   \       0x7A   0xF240 0x4144      MOVW     R1,#+1092
   \       0x7E   0x4208             TST      R0,R1
   \       0x80   0xD105             BNE.N    ??HAL_TIM_Encoder_Stop_IT_3
   \       0x82   0x6828             LDR      R0,[R5, #+0]
   \       0x84   0x6800             LDR      R0,[R0, #+0]
   \       0x86   0x0840             LSRS     R0,R0,#+1
   \       0x88   0x0040             LSLS     R0,R0,#+1
   \       0x8A   0x6829             LDR      R1,[R5, #+0]
   \       0x8C   0x6008             STR      R0,[R1, #+0]
   2945          
   2946            /* Change the htim state */
   2947            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_IT_3: (+1)
   \       0x8E   0x2001             MOVS     R0,#+1
   \       0x90   0xF885 0x003D      STRB     R0,[R5, #+61]
   2948          
   2949            /* Return function status */
   2950            return HAL_OK;
   \       0x94   0x2000             MOVS     R0,#+0
   \       0x96   0xBD32             POP      {R1,R4,R5,PC}
   2951          }
   2952          
   2953          /**
   2954            * @brief  Starts the TIM Encoder Interface in DMA mode.
   2955            * @param  htim TIM Encoder Interface handle
   2956            * @param  Channel TIM Channels to be enabled
   2957            *          This parameter can be one of the following values:
   2958            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2959            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2960            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2961            * @param  pData1 The destination Buffer address for IC1.
   2962            * @param  pData2 The destination Buffer address for IC2.
   2963            * @param  Length The length of data to be transferred from TIM peripheral to memory.
   2964            * @retval HAL status
   2965            */

   \                                 In section .text, align 2, keep-with-next
   2966          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1,
   2967                                                      uint32_t *pData2, uint16_t Length)
   2968          {
   \                     HAL_TIM_Encoder_Start_DMA: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x0014             MOVS     R4,R2
   \        0xA   0x001D             MOVS     R5,R3
   \        0xC   0x9E0A             LDR      R6,[SP, #+40]
   2969            /* Check the parameters */
   2970            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2971          
   2972            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0xE   0xF897 0x003D      LDRB     R0,[R7, #+61]
   \       0x12   0x2802             CMP      R0,#+2
   \       0x14   0xD101             BNE.N    ??HAL_TIM_Encoder_Start_DMA_0
   2973            {
   2974              return HAL_BUSY;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0xE0BA             B.N      ??HAL_TIM_Encoder_Start_DMA_1
   2975            }
   2976            else if (htim->State == HAL_TIM_STATE_READY)
   \                     ??HAL_TIM_Encoder_Start_DMA_0: (+1)
   \       0x1A   0xF897 0x003D      LDRB     R0,[R7, #+61]
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xD10C             BNE.N    ??HAL_TIM_Encoder_Start_DMA_2
   2977            {
   2978              if ((((pData1 == NULL) || (pData2 == NULL))) && (Length > 0U))
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD001             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_3
   \       0x26   0x2D00             CMP      R5,#+0
   \       0x28   0xD105             BNE.N    ??HAL_TIM_Encoder_Start_DMA_4
   \                     ??HAL_TIM_Encoder_Start_DMA_3: (+1)
   \       0x2A   0x0030             MOVS     R0,R6
   \       0x2C   0xB280             UXTH     R0,R0
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD001             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_4
   2979              {
   2980                return HAL_ERROR;
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0xE0AC             B.N      ??HAL_TIM_Encoder_Start_DMA_1
   2981              }
   2982              else
   2983              {
   2984                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Start_DMA_4: (+1)
   \       0x36   0x2002             MOVS     R0,#+2
   \       0x38   0xF887 0x003D      STRB     R0,[R7, #+61]
   2985              }
   2986            }
   2987            else
   2988            {
   2989              /* nothing to do */
   2990            }
   2991          
   2992            switch (Channel)
   \                     ??HAL_TIM_Encoder_Start_DMA_2: (+1)
   \       0x3C   0x4640             MOV      R0,R8
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD004             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_5
   \       0x42   0x2804             CMP      R0,#+4
   \       0x44   0xD02B             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_6
   \       0x46   0x283C             CMP      R0,#+60
   \       0x48   0xD052             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_7
   \       0x4A   0xE0A0             B.N      ??HAL_TIM_Encoder_Start_DMA_8
   2993            {
   2994              case TIM_CHANNEL_1:
   2995              {
   2996                /* Set the DMA capture callbacks */
   2997                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_5: (+1)
   \       0x4C   0x....             LDR.N    R0,??DataTable20
   \       0x4E   0x6A79             LDR      R1,[R7, #+36]
   \       0x50   0x63C8             STR      R0,[R1, #+60]
   2998                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x52   0x....             LDR.N    R0,??DataTable20_1
   \       0x54   0x6A79             LDR      R1,[R7, #+36]
   \       0x56   0x6408             STR      R0,[R1, #+64]
   2999          
   3000                /* Set the DMA error callback */
   3001                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0x58   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x5C   0x6A79             LDR      R1,[R7, #+36]
   \       0x5E   0x64C8             STR      R0,[R1, #+76]
   3002          
   3003                /* Enable the DMA stream */
   3004                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
   \       0x60   0x0033             MOVS     R3,R6
   \       0x62   0xB29B             UXTH     R3,R3
   \       0x64   0x0022             MOVS     R2,R4
   \       0x66   0x6838             LDR      R0,[R7, #+0]
   \       0x68   0xF110 0x0134      ADDS     R1,R0,#+52
   \       0x6C   0x6A78             LDR      R0,[R7, #+36]
   \       0x6E   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD001             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_9
   3005                {
   3006                  return HAL_ERROR;
   \       0x76   0x2001             MOVS     R0,#+1
   \       0x78   0xE08A             B.N      ??HAL_TIM_Encoder_Start_DMA_1
   3007                }
   3008                /* Enable the TIM Input Capture DMA request */
   3009                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_Encoder_Start_DMA_9: (+1)
   \       0x7A   0x6838             LDR      R0,[R7, #+0]
   \       0x7C   0x68C0             LDR      R0,[R0, #+12]
   \       0x7E   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0x82   0x6839             LDR      R1,[R7, #+0]
   \       0x84   0x60C8             STR      R0,[R1, #+12]
   3010          
   3011                /* Enable the Peripheral */
   3012                __HAL_TIM_ENABLE(htim);
   \       0x86   0x6838             LDR      R0,[R7, #+0]
   \       0x88   0x6800             LDR      R0,[R0, #+0]
   \       0x8A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x8E   0x6839             LDR      R1,[R7, #+0]
   \       0x90   0x6008             STR      R0,[R1, #+0]
   3013          
   3014                /* Enable the Capture compare channel */
   3015                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \       0x92   0x2201             MOVS     R2,#+1
   \       0x94   0x2100             MOVS     R1,#+0
   \       0x96   0x6838             LDR      R0,[R7, #+0]
   \       0x98   0x.... 0x....      BL       TIM_CCxChannelCmd
   3016                break;
   \       0x9C   0xE077             B.N      ??HAL_TIM_Encoder_Start_DMA_10
   3017              }
   3018          
   3019              case TIM_CHANNEL_2:
   3020              {
   3021                /* Set the DMA capture callbacks */
   3022                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_6: (+1)
   \       0x9E   0x....             LDR.N    R0,??DataTable20
   \       0xA0   0x6AB9             LDR      R1,[R7, #+40]
   \       0xA2   0x63C8             STR      R0,[R1, #+60]
   3023                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0xA4   0x....             LDR.N    R0,??DataTable20_1
   \       0xA6   0x6AB9             LDR      R1,[R7, #+40]
   \       0xA8   0x6408             STR      R0,[R1, #+64]
   3024          
   3025                /* Set the DMA error callback */
   3026                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
   \       0xAA   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0xAE   0x6AB9             LDR      R1,[R7, #+40]
   \       0xB0   0x64C8             STR      R0,[R1, #+76]
   3027                /* Enable the DMA stream */
   3028                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
   \       0xB2   0x0033             MOVS     R3,R6
   \       0xB4   0xB29B             UXTH     R3,R3
   \       0xB6   0x002A             MOVS     R2,R5
   \       0xB8   0x6838             LDR      R0,[R7, #+0]
   \       0xBA   0xF110 0x0138      ADDS     R1,R0,#+56
   \       0xBE   0x6AB8             LDR      R0,[R7, #+40]
   \       0xC0   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xD001             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_11
   3029                {
   3030                  return HAL_ERROR;
   \       0xC8   0x2001             MOVS     R0,#+1
   \       0xCA   0xE061             B.N      ??HAL_TIM_Encoder_Start_DMA_1
   3031                }
   3032                /* Enable the TIM Input Capture  DMA request */
   3033                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_Encoder_Start_DMA_11: (+1)
   \       0xCC   0x6838             LDR      R0,[R7, #+0]
   \       0xCE   0x68C0             LDR      R0,[R0, #+12]
   \       0xD0   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0xD4   0x6839             LDR      R1,[R7, #+0]
   \       0xD6   0x60C8             STR      R0,[R1, #+12]
   3034          
   3035                /* Enable the Peripheral */
   3036                __HAL_TIM_ENABLE(htim);
   \       0xD8   0x6838             LDR      R0,[R7, #+0]
   \       0xDA   0x6800             LDR      R0,[R0, #+0]
   \       0xDC   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xE0   0x6839             LDR      R1,[R7, #+0]
   \       0xE2   0x6008             STR      R0,[R1, #+0]
   3037          
   3038                /* Enable the Capture compare channel */
   3039                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \       0xE4   0x2201             MOVS     R2,#+1
   \       0xE6   0x2104             MOVS     R1,#+4
   \       0xE8   0x6838             LDR      R0,[R7, #+0]
   \       0xEA   0x.... 0x....      BL       TIM_CCxChannelCmd
   3040                break;
   \       0xEE   0xE04E             B.N      ??HAL_TIM_Encoder_Start_DMA_10
   3041              }
   3042          
   3043              case TIM_CHANNEL_ALL:
   3044              {
   3045                /* Set the DMA capture callbacks */
   3046                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_7: (+1)
   \       0xF0   0x.... 0x....      LDR.W    R9,??DataTable20
   \       0xF4   0x6A78             LDR      R0,[R7, #+36]
   \       0xF6   0xF8C0 0x903C      STR      R9,[R0, #+60]
   3047                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0xFA   0x.... 0x....      LDR.W    R10,??DataTable20_1
   \       0xFE   0x6A78             LDR      R0,[R7, #+36]
   \      0x100   0xF8C0 0xA040      STR      R10,[R0, #+64]
   3048          
   3049                /* Set the DMA error callback */
   3050                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \      0x104   0x.... 0x....      LDR.W    R11,??DataTable22
   \      0x108   0x6A78             LDR      R0,[R7, #+36]
   \      0x10A   0xF8C0 0xB04C      STR      R11,[R0, #+76]
   3051          
   3052                /* Enable the DMA stream */
   3053                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
   \      0x10E   0x0033             MOVS     R3,R6
   \      0x110   0xB29B             UXTH     R3,R3
   \      0x112   0x0022             MOVS     R2,R4
   \      0x114   0x6838             LDR      R0,[R7, #+0]
   \      0x116   0xF110 0x0134      ADDS     R1,R0,#+52
   \      0x11A   0x6A78             LDR      R0,[R7, #+36]
   \      0x11C   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x120   0x2800             CMP      R0,#+0
   \      0x122   0xD001             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_12
   3054                {
   3055                  return HAL_ERROR;
   \      0x124   0x2001             MOVS     R0,#+1
   \      0x126   0xE033             B.N      ??HAL_TIM_Encoder_Start_DMA_1
   3056                }
   3057          
   3058                /* Set the DMA capture callbacks */
   3059                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_12: (+1)
   \      0x128   0x6AB8             LDR      R0,[R7, #+40]
   \      0x12A   0xF8C0 0x903C      STR      R9,[R0, #+60]
   3060                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \      0x12E   0x6AB8             LDR      R0,[R7, #+40]
   \      0x130   0xF8C0 0xA040      STR      R10,[R0, #+64]
   3061          
   3062                /* Set the DMA error callback */
   3063                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \      0x134   0x6AB8             LDR      R0,[R7, #+40]
   \      0x136   0xF8C0 0xB04C      STR      R11,[R0, #+76]
   3064          
   3065                /* Enable the DMA stream */
   3066                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
   \      0x13A   0x0033             MOVS     R3,R6
   \      0x13C   0xB29B             UXTH     R3,R3
   \      0x13E   0x002A             MOVS     R2,R5
   \      0x140   0x6838             LDR      R0,[R7, #+0]
   \      0x142   0xF110 0x0138      ADDS     R1,R0,#+56
   \      0x146   0x6AB8             LDR      R0,[R7, #+40]
   \      0x148   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x14C   0x2800             CMP      R0,#+0
   \      0x14E   0xD001             BEQ.N    ??HAL_TIM_Encoder_Start_DMA_13
   3067                {
   3068                  return HAL_ERROR;
   \      0x150   0x2001             MOVS     R0,#+1
   \      0x152   0xE01D             B.N      ??HAL_TIM_Encoder_Start_DMA_1
   3069                }
   3070                /* Enable the Peripheral */
   3071                __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_DMA_13: (+1)
   \      0x154   0x6838             LDR      R0,[R7, #+0]
   \      0x156   0x6800             LDR      R0,[R0, #+0]
   \      0x158   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x15C   0x6839             LDR      R1,[R7, #+0]
   \      0x15E   0x6008             STR      R0,[R1, #+0]
   3072          
   3073                /* Enable the Capture compare channel */
   3074                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \      0x160   0x2201             MOVS     R2,#+1
   \      0x162   0x2100             MOVS     R1,#+0
   \      0x164   0x6838             LDR      R0,[R7, #+0]
   \      0x166   0x.... 0x....      BL       TIM_CCxChannelCmd
   3075                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \      0x16A   0x2201             MOVS     R2,#+1
   \      0x16C   0x2104             MOVS     R1,#+4
   \      0x16E   0x6838             LDR      R0,[R7, #+0]
   \      0x170   0x.... 0x....      BL       TIM_CCxChannelCmd
   3076          
   3077                /* Enable the TIM Input Capture  DMA request */
   3078                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \      0x174   0x6838             LDR      R0,[R7, #+0]
   \      0x176   0x68C0             LDR      R0,[R0, #+12]
   \      0x178   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x17C   0x6839             LDR      R1,[R7, #+0]
   \      0x17E   0x60C8             STR      R0,[R1, #+12]
   3079                /* Enable the TIM Input Capture  DMA request */
   3080                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \      0x180   0x6838             LDR      R0,[R7, #+0]
   \      0x182   0x68C0             LDR      R0,[R0, #+12]
   \      0x184   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x188   0x6839             LDR      R1,[R7, #+0]
   \      0x18A   0x60C8             STR      R0,[R1, #+12]
   3081                break;
   \      0x18C   0xE7FF             B.N      ??HAL_TIM_Encoder_Start_DMA_10
   3082              }
   3083          
   3084              default:
   3085                break;
   3086            }
   3087            /* Return function status */
   3088            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Start_DMA_8: (+1)
   \                     ??HAL_TIM_Encoder_Start_DMA_10: (+1)
   \      0x18E   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Encoder_Start_DMA_1: (+1)
   \      0x190   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   3089          }
   3090          
   3091          /**
   3092            * @brief  Stops the TIM Encoder Interface in DMA mode.
   3093            * @param  htim TIM Encoder Interface handle
   3094            * @param  Channel TIM Channels to be enabled
   3095            *          This parameter can be one of the following values:
   3096            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3097            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3098            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   3099            * @retval HAL status
   3100            */

   \                                 In section .text, align 2, keep-with-next
   3101          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   3102          {
   \                     HAL_TIM_Encoder_Stop_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   3103            /* Check the parameters */
   3104            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   3105          
   3106            /* Disable the Input Capture channels 1 and 2
   3107              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   3108            if (Channel == TIM_CHANNEL_1)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD10E             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_0
   3109            {
   3110              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x.... 0x....      BL       TIM_CCxChannelCmd
   3111          
   3112              /* Disable the capture compare DMA Request 1 */
   3113              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x68C0             LDR      R0,[R0, #+12]
   \       0x18   0xF430 0x7000      BICS     R0,R0,#0x200
   \       0x1C   0x6829             LDR      R1,[R5, #+0]
   \       0x1E   0x60C8             STR      R0,[R1, #+12]
   3114              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x20   0x6A68             LDR      R0,[R5, #+36]
   \       0x22   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x26   0xE02C             B.N      ??HAL_TIM_Encoder_Stop_DMA_1
   3115            }
   3116            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_DMA_0: (+1)
   \       0x28   0x2C04             CMP      R4,#+4
   \       0x2A   0xD10E             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_2
   3117            {
   3118              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x2C   0x2200             MOVS     R2,#+0
   \       0x2E   0x2104             MOVS     R1,#+4
   \       0x30   0x6828             LDR      R0,[R5, #+0]
   \       0x32   0x.... 0x....      BL       TIM_CCxChannelCmd
   3119          
   3120              /* Disable the capture compare DMA Request 2 */
   3121              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \       0x36   0x6828             LDR      R0,[R5, #+0]
   \       0x38   0x68C0             LDR      R0,[R0, #+12]
   \       0x3A   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x3E   0x6829             LDR      R1,[R5, #+0]
   \       0x40   0x60C8             STR      R0,[R1, #+12]
   3122              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \       0x42   0x6AA8             LDR      R0,[R5, #+40]
   \       0x44   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x48   0xE01B             B.N      ??HAL_TIM_Encoder_Stop_DMA_1
   3123            }
   3124            else
   3125            {
   3126              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_DMA_2: (+1)
   \       0x4A   0x2200             MOVS     R2,#+0
   \       0x4C   0x2100             MOVS     R1,#+0
   \       0x4E   0x6828             LDR      R0,[R5, #+0]
   \       0x50   0x.... 0x....      BL       TIM_CCxChannelCmd
   3127              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x54   0x2200             MOVS     R2,#+0
   \       0x56   0x2104             MOVS     R1,#+4
   \       0x58   0x6828             LDR      R0,[R5, #+0]
   \       0x5A   0x.... 0x....      BL       TIM_CCxChannelCmd
   3128          
   3129              /* Disable the capture compare DMA Request 1 and 2 */
   3130              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \       0x5E   0x6828             LDR      R0,[R5, #+0]
   \       0x60   0x68C0             LDR      R0,[R0, #+12]
   \       0x62   0xF430 0x7000      BICS     R0,R0,#0x200
   \       0x66   0x6829             LDR      R1,[R5, #+0]
   \       0x68   0x60C8             STR      R0,[R1, #+12]
   3131              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \       0x6A   0x6828             LDR      R0,[R5, #+0]
   \       0x6C   0x68C0             LDR      R0,[R0, #+12]
   \       0x6E   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x72   0x6829             LDR      R1,[R5, #+0]
   \       0x74   0x60C8             STR      R0,[R1, #+12]
   3132              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x76   0x6A68             LDR      R0,[R5, #+36]
   \       0x78   0x.... 0x....      BL       HAL_DMA_Abort_IT
   3133              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \       0x7C   0x6AA8             LDR      R0,[R5, #+40]
   \       0x7E   0x.... 0x....      BL       HAL_DMA_Abort_IT
   3134            }
   3135          
   3136            /* Disable the Peripheral */
   3137            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_DMA_1: (+1)
   \       0x82   0x6828             LDR      R0,[R5, #+0]
   \       0x84   0x6A00             LDR      R0,[R0, #+32]
   \       0x86   0xF241 0x1111      MOVW     R1,#+4369
   \       0x8A   0x4208             TST      R0,R1
   \       0x8C   0xD10B             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_3
   \       0x8E   0x6828             LDR      R0,[R5, #+0]
   \       0x90   0x6A00             LDR      R0,[R0, #+32]
   \       0x92   0xF240 0x4144      MOVW     R1,#+1092
   \       0x96   0x4208             TST      R0,R1
   \       0x98   0xD105             BNE.N    ??HAL_TIM_Encoder_Stop_DMA_3
   \       0x9A   0x6828             LDR      R0,[R5, #+0]
   \       0x9C   0x6800             LDR      R0,[R0, #+0]
   \       0x9E   0x0840             LSRS     R0,R0,#+1
   \       0xA0   0x0040             LSLS     R0,R0,#+1
   \       0xA2   0x6829             LDR      R1,[R5, #+0]
   \       0xA4   0x6008             STR      R0,[R1, #+0]
   3138          
   3139            /* Change the htim state */
   3140            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_DMA_3: (+1)
   \       0xA6   0x2001             MOVS     R0,#+1
   \       0xA8   0xF885 0x003D      STRB     R0,[R5, #+61]
   3141          
   3142            /* Return function status */
   3143            return HAL_OK;
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0xBD32             POP      {R1,R4,R5,PC}
   3144          }
   3145          
   3146          /**
   3147            * @}
   3148            */
   3149          /** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management
   3150            *  @brief    TIM IRQ handler management
   3151            *
   3152          @verbatim
   3153            ==============================================================================
   3154                                  ##### IRQ handler management #####
   3155            ==============================================================================
   3156            [..]
   3157              This section provides Timer IRQ handler function.
   3158          
   3159          @endverbatim
   3160            * @{
   3161            */
   3162          /**
   3163            * @brief  This function handles TIM interrupts requests.
   3164            * @param  htim TIM  handle
   3165            * @retval None
   3166            */

   \                                 In section .text, align 2, keep-with-next
   3167          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   3168          {
   \                     HAL_TIM_IRQHandler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3169            /* Capture compare 1 event */
   3170            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6900             LDR      R0,[R0, #+16]
   \        0x8   0x0780             LSLS     R0,R0,#+30
   \        0xA   0xD51A             BPL.N    ??HAL_TIM_IRQHandler_0
   3171            {
   3172              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x68C0             LDR      R0,[R0, #+12]
   \       0x10   0x0780             LSLS     R0,R0,#+30
   \       0x12   0xD516             BPL.N    ??HAL_TIM_IRQHandler_0
   3173              {
   3174                {
   3175                  __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
   \       0x14   0xF07F 0x0002      MVNS     R0,#+2
   \       0x18   0x6821             LDR      R1,[R4, #+0]
   \       0x1A   0x6108             STR      R0,[R1, #+16]
   3176                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0x7720             STRB     R0,[R4, #+28]
   3177          
   3178                  /* Input capture event */
   3179                  if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x6980             LDR      R0,[R0, #+24]
   \       0x24   0xF010 0x0F03      TST      R0,#0x3
   \       0x28   0xD003             BEQ.N    ??HAL_TIM_IRQHandler_1
   3180                  {
   3181          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3182                    htim->IC_CaptureCallback(htim);
   3183          #else
   3184                    HAL_TIM_IC_CaptureCallback(htim);
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \       0x30   0xE005             B.N      ??HAL_TIM_IRQHandler_2
   3185          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3186                  }
   3187                  /* Output compare event */
   3188                  else
   3189                  {
   3190          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3191                    htim->OC_DelayElapsedCallback(htim);
   3192                    htim->PWM_PulseFinishedCallback(htim);
   3193          #else
   3194                    HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_1: (+1)
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   3195                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   \       0x38   0x0020             MOVS     R0,R4
   \       0x3A   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   3196          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3197                  }
   3198                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_2: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x7720             STRB     R0,[R4, #+28]
   3199                }
   3200              }
   3201            }
   3202            /* Capture compare 2 event */
   3203            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
   \                     ??HAL_TIM_IRQHandler_0: (+1)
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x6900             LDR      R0,[R0, #+16]
   \       0x46   0x0740             LSLS     R0,R0,#+29
   \       0x48   0xD51A             BPL.N    ??HAL_TIM_IRQHandler_3
   3204            {
   3205              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x68C0             LDR      R0,[R0, #+12]
   \       0x4E   0x0740             LSLS     R0,R0,#+29
   \       0x50   0xD516             BPL.N    ??HAL_TIM_IRQHandler_3
   3206              {
   3207                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
   \       0x52   0xF07F 0x0004      MVNS     R0,#+4
   \       0x56   0x6821             LDR      R1,[R4, #+0]
   \       0x58   0x6108             STR      R0,[R1, #+16]
   3208                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x5A   0x2002             MOVS     R0,#+2
   \       0x5C   0x7720             STRB     R0,[R4, #+28]
   3209                /* Input capture event */
   3210                if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6980             LDR      R0,[R0, #+24]
   \       0x62   0xF410 0x7F40      TST      R0,#0x300
   \       0x66   0xD003             BEQ.N    ??HAL_TIM_IRQHandler_4
   3211                {
   3212          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3213                  htim->IC_CaptureCallback(htim);
   3214          #else
   3215                  HAL_TIM_IC_CaptureCallback(htim);
   \       0x68   0x0020             MOVS     R0,R4
   \       0x6A   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \       0x6E   0xE005             B.N      ??HAL_TIM_IRQHandler_5
   3216          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3217                }
   3218                /* Output compare event */
   3219                else
   3220                {
   3221          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3222                  htim->OC_DelayElapsedCallback(htim);
   3223                  htim->PWM_PulseFinishedCallback(htim);
   3224          #else
   3225                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_4: (+1)
   \       0x70   0x0020             MOVS     R0,R4
   \       0x72   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   3226                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \       0x76   0x0020             MOVS     R0,R4
   \       0x78   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   3227          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3228                }
   3229                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_5: (+1)
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0x7720             STRB     R0,[R4, #+28]
   3230              }
   3231            }
   3232            /* Capture compare 3 event */
   3233            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
   \                     ??HAL_TIM_IRQHandler_3: (+1)
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x6900             LDR      R0,[R0, #+16]
   \       0x84   0x0700             LSLS     R0,R0,#+28
   \       0x86   0xD51A             BPL.N    ??HAL_TIM_IRQHandler_6
   3234            {
   3235              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x68C0             LDR      R0,[R0, #+12]
   \       0x8C   0x0700             LSLS     R0,R0,#+28
   \       0x8E   0xD516             BPL.N    ??HAL_TIM_IRQHandler_6
   3236              {
   3237                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
   \       0x90   0xF07F 0x0008      MVNS     R0,#+8
   \       0x94   0x6821             LDR      R1,[R4, #+0]
   \       0x96   0x6108             STR      R0,[R1, #+16]
   3238                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x98   0x2004             MOVS     R0,#+4
   \       0x9A   0x7720             STRB     R0,[R4, #+28]
   3239                /* Input capture event */
   3240                if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
   \       0x9C   0x6820             LDR      R0,[R4, #+0]
   \       0x9E   0x69C0             LDR      R0,[R0, #+28]
   \       0xA0   0xF010 0x0F03      TST      R0,#0x3
   \       0xA4   0xD003             BEQ.N    ??HAL_TIM_IRQHandler_7
   3241                {
   3242          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3243                  htim->IC_CaptureCallback(htim);
   3244          #else
   3245                  HAL_TIM_IC_CaptureCallback(htim);
   \       0xA6   0x0020             MOVS     R0,R4
   \       0xA8   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \       0xAC   0xE005             B.N      ??HAL_TIM_IRQHandler_8
   3246          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3247                }
   3248                /* Output compare event */
   3249                else
   3250                {
   3251          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3252                  htim->OC_DelayElapsedCallback(htim);
   3253                  htim->PWM_PulseFinishedCallback(htim);
   3254          #else
   3255                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_7: (+1)
   \       0xAE   0x0020             MOVS     R0,R4
   \       0xB0   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   3256                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \       0xB4   0x0020             MOVS     R0,R4
   \       0xB6   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   3257          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3258                }
   3259                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_8: (+1)
   \       0xBA   0x2000             MOVS     R0,#+0
   \       0xBC   0x7720             STRB     R0,[R4, #+28]
   3260              }
   3261            }
   3262            /* Capture compare 4 event */
   3263            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
   \                     ??HAL_TIM_IRQHandler_6: (+1)
   \       0xBE   0x6820             LDR      R0,[R4, #+0]
   \       0xC0   0x6900             LDR      R0,[R0, #+16]
   \       0xC2   0x06C0             LSLS     R0,R0,#+27
   \       0xC4   0xD51A             BPL.N    ??HAL_TIM_IRQHandler_9
   3264            {
   3265              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
   \       0xC6   0x6820             LDR      R0,[R4, #+0]
   \       0xC8   0x68C0             LDR      R0,[R0, #+12]
   \       0xCA   0x06C0             LSLS     R0,R0,#+27
   \       0xCC   0xD516             BPL.N    ??HAL_TIM_IRQHandler_9
   3266              {
   3267                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
   \       0xCE   0xF07F 0x0010      MVNS     R0,#+16
   \       0xD2   0x6821             LDR      R1,[R4, #+0]
   \       0xD4   0x6108             STR      R0,[R1, #+16]
   3268                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0xD6   0x2008             MOVS     R0,#+8
   \       0xD8   0x7720             STRB     R0,[R4, #+28]
   3269                /* Input capture event */
   3270                if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
   \       0xDA   0x6820             LDR      R0,[R4, #+0]
   \       0xDC   0x69C0             LDR      R0,[R0, #+28]
   \       0xDE   0xF410 0x7F40      TST      R0,#0x300
   \       0xE2   0xD003             BEQ.N    ??HAL_TIM_IRQHandler_10
   3271                {
   3272          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3273                  htim->IC_CaptureCallback(htim);
   3274          #else
   3275                  HAL_TIM_IC_CaptureCallback(htim);
   \       0xE4   0x0020             MOVS     R0,R4
   \       0xE6   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   \       0xEA   0xE005             B.N      ??HAL_TIM_IRQHandler_11
   3276          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3277                }
   3278                /* Output compare event */
   3279                else
   3280                {
   3281          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3282                  htim->OC_DelayElapsedCallback(htim);
   3283                  htim->PWM_PulseFinishedCallback(htim);
   3284          #else
   3285                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_10: (+1)
   \       0xEC   0x0020             MOVS     R0,R4
   \       0xEE   0x.... 0x....      BL       HAL_TIM_OC_DelayElapsedCallback
   3286                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \       0xF2   0x0020             MOVS     R0,R4
   \       0xF4   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   3287          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3288                }
   3289                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_11: (+1)
   \       0xF8   0x2000             MOVS     R0,#+0
   \       0xFA   0x7720             STRB     R0,[R4, #+28]
   3290              }
   3291            }
   3292            /* TIM Update event */
   3293            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
   \                     ??HAL_TIM_IRQHandler_9: (+1)
   \       0xFC   0x6820             LDR      R0,[R4, #+0]
   \       0xFE   0x6900             LDR      R0,[R0, #+16]
   \      0x100   0x07C0             LSLS     R0,R0,#+31
   \      0x102   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_12
   3294            {
   3295              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
   \      0x104   0x6820             LDR      R0,[R4, #+0]
   \      0x106   0x68C0             LDR      R0,[R0, #+12]
   \      0x108   0x07C0             LSLS     R0,R0,#+31
   \      0x10A   0xD506             BPL.N    ??HAL_TIM_IRQHandler_12
   3296              {
   3297                __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
   \      0x10C   0xF07F 0x0001      MVNS     R0,#+1
   \      0x110   0x6821             LDR      R1,[R4, #+0]
   \      0x112   0x6108             STR      R0,[R1, #+16]
   3298          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3299                htim->PeriodElapsedCallback(htim);
   3300          #else
   3301                HAL_TIM_PeriodElapsedCallback(htim);
   \      0x114   0x0020             MOVS     R0,R4
   \      0x116   0x.... 0x....      BL       HAL_TIM_PeriodElapsedCallback
   3302          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3303              }
   3304            }
   3305            /* TIM Break input event */
   3306            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
   \                     ??HAL_TIM_IRQHandler_12: (+1)
   \      0x11A   0x6820             LDR      R0,[R4, #+0]
   \      0x11C   0x6900             LDR      R0,[R0, #+16]
   \      0x11E   0x0600             LSLS     R0,R0,#+24
   \      0x120   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_13
   3307            {
   3308              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
   \      0x122   0x6820             LDR      R0,[R4, #+0]
   \      0x124   0x68C0             LDR      R0,[R0, #+12]
   \      0x126   0x0600             LSLS     R0,R0,#+24
   \      0x128   0xD506             BPL.N    ??HAL_TIM_IRQHandler_13
   3309              {
   3310                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   \      0x12A   0xF07F 0x0080      MVNS     R0,#+128
   \      0x12E   0x6821             LDR      R1,[R4, #+0]
   \      0x130   0x6108             STR      R0,[R1, #+16]
   3311          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3312                htim->BreakCallback(htim);
   3313          #else
   3314                HAL_TIMEx_BreakCallback(htim);
   \      0x132   0x0020             MOVS     R0,R4
   \      0x134   0x.... 0x....      BL       HAL_TIMEx_BreakCallback
   3315          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3316              }
   3317            }
   3318            /* TIM Trigger detection event */
   3319            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
   \                     ??HAL_TIM_IRQHandler_13: (+1)
   \      0x138   0x6820             LDR      R0,[R4, #+0]
   \      0x13A   0x6900             LDR      R0,[R0, #+16]
   \      0x13C   0x0640             LSLS     R0,R0,#+25
   \      0x13E   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_14
   3320            {
   3321              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
   \      0x140   0x6820             LDR      R0,[R4, #+0]
   \      0x142   0x68C0             LDR      R0,[R0, #+12]
   \      0x144   0x0640             LSLS     R0,R0,#+25
   \      0x146   0xD506             BPL.N    ??HAL_TIM_IRQHandler_14
   3322              {
   3323                __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
   \      0x148   0xF07F 0x0040      MVNS     R0,#+64
   \      0x14C   0x6821             LDR      R1,[R4, #+0]
   \      0x14E   0x6108             STR      R0,[R1, #+16]
   3324          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3325                htim->TriggerCallback(htim);
   3326          #else
   3327                HAL_TIM_TriggerCallback(htim);
   \      0x150   0x0020             MOVS     R0,R4
   \      0x152   0x.... 0x....      BL       HAL_TIM_TriggerCallback
   3328          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3329              }
   3330            }
   3331            /* TIM commutation event */
   3332            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
   \                     ??HAL_TIM_IRQHandler_14: (+1)
   \      0x156   0x6820             LDR      R0,[R4, #+0]
   \      0x158   0x6900             LDR      R0,[R0, #+16]
   \      0x15A   0x0680             LSLS     R0,R0,#+26
   \      0x15C   0xD50A             BPL.N    ??HAL_TIM_IRQHandler_15
   3333            {
   3334              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
   \      0x15E   0x6820             LDR      R0,[R4, #+0]
   \      0x160   0x68C0             LDR      R0,[R0, #+12]
   \      0x162   0x0680             LSLS     R0,R0,#+26
   \      0x164   0xD506             BPL.N    ??HAL_TIM_IRQHandler_15
   3335              {
   3336                __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
   \      0x166   0xF07F 0x0020      MVNS     R0,#+32
   \      0x16A   0x6821             LDR      R1,[R4, #+0]
   \      0x16C   0x6108             STR      R0,[R1, #+16]
   3337          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3338                htim->CommutationCallback(htim);
   3339          #else
   3340                HAL_TIMEx_CommutCallback(htim);
   \      0x16E   0x0020             MOVS     R0,R4
   \      0x170   0x.... 0x....      BL       HAL_TIMEx_CommutCallback
   3341          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3342              }
   3343            }
   3344          }
   \                     ??HAL_TIM_IRQHandler_15: (+1)
   \      0x174   0xBD10             POP      {R4,PC}
   3345          
   3346          /**
   3347            * @}
   3348            */
   3349          
   3350          /** @defgroup TIM_Exported_Functions_Group8 TIM Peripheral Control functions
   3351            *  @brief    TIM Peripheral Control functions
   3352            *
   3353          @verbatim
   3354            ==============================================================================
   3355                             ##### Peripheral Control functions #####
   3356            ==============================================================================
   3357           [..]
   3358             This section provides functions allowing to:
   3359                (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode.
   3360                (+) Configure External Clock source.
   3361                (+) Configure Complementary channels, break features and dead time.
   3362                (+) Configure Master and the Slave synchronization.
   3363                (+) Configure the DMA Burst Mode.
   3364          
   3365          @endverbatim
   3366            * @{
   3367            */
   3368          
   3369          /**
   3370            * @brief  Initializes the TIM Output Compare Channels according to the specified
   3371            *         parameters in the TIM_OC_InitTypeDef.
   3372            * @param  htim TIM Output Compare handle
   3373            * @param  sConfig TIM Output Compare configuration structure
   3374            * @param  Channel TIM Channels to configure
   3375            *          This parameter can be one of the following values:
   3376            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3377            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3378            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3379            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3380            * @retval HAL status
   3381            */

   \                                 In section .text, align 2, keep-with-next
   3382          HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,
   3383                                                     TIM_OC_InitTypeDef *sConfig,
   3384                                                     uint32_t Channel)
   3385          {
   \                     HAL_TIM_OC_ConfigChannel: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   3386            /* Check the parameters */
   3387            assert_param(IS_TIM_CHANNELS(Channel));
   3388            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   3389            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3390          
   3391            /* Process Locked */
   3392            __HAL_LOCK(htim);
   \        0x8   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE.N    ??HAL_TIM_OC_ConfigChannel_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE02A             B.N      ??HAL_TIM_OC_ConfigChannel_1
   \                     ??HAL_TIM_OC_ConfigChannel_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xF884 0x003C      STRB     R0,[R4, #+60]
   3393          
   3394            htim->State = HAL_TIM_STATE_BUSY;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0xF884 0x003D      STRB     R0,[R4, #+61]
   3395          
   3396            switch (Channel)
   \       0x20   0x0030             MOVS     R0,R6
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD006             BEQ.N    ??HAL_TIM_OC_ConfigChannel_2
   \       0x26   0x2804             CMP      R0,#+4
   \       0x28   0xD009             BEQ.N    ??HAL_TIM_OC_ConfigChannel_3
   \       0x2A   0x2808             CMP      R0,#+8
   \       0x2C   0xD00C             BEQ.N    ??HAL_TIM_OC_ConfigChannel_4
   \       0x2E   0x280C             CMP      R0,#+12
   \       0x30   0xD00F             BEQ.N    ??HAL_TIM_OC_ConfigChannel_5
   \       0x32   0xE013             B.N      ??HAL_TIM_OC_ConfigChannel_6
   3397            {
   3398              case TIM_CHANNEL_1:
   3399              {
   3400                /* Check the parameters */
   3401                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3402          
   3403                /* Configure the TIM Channel 1 in Output Compare */
   3404                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_2: (+1)
   \       0x34   0x0029             MOVS     R1,R5
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x.... 0x....      BL       TIM_OC1_SetConfig
   3405                break;
   \       0x3C   0xE00E             B.N      ??HAL_TIM_OC_ConfigChannel_7
   3406              }
   3407          
   3408              case TIM_CHANNEL_2:
   3409              {
   3410                /* Check the parameters */
   3411                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3412          
   3413                /* Configure the TIM Channel 2 in Output Compare */
   3414                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_3: (+1)
   \       0x3E   0x0029             MOVS     R1,R5
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x.... 0x....      BL       TIM_OC2_SetConfig
   3415                break;
   \       0x46   0xE009             B.N      ??HAL_TIM_OC_ConfigChannel_7
   3416              }
   3417          
   3418              case TIM_CHANNEL_3:
   3419              {
   3420                /* Check the parameters */
   3421                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3422          
   3423                /* Configure the TIM Channel 3 in Output Compare */
   3424                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_4: (+1)
   \       0x48   0x0029             MOVS     R1,R5
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x.... 0x....      BL       TIM_OC3_SetConfig
   3425                break;
   \       0x50   0xE004             B.N      ??HAL_TIM_OC_ConfigChannel_7
   3426              }
   3427          
   3428              case TIM_CHANNEL_4:
   3429              {
   3430                /* Check the parameters */
   3431                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3432          
   3433                /* Configure the TIM Channel 4 in Output Compare */
   3434                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_5: (+1)
   \       0x52   0x0029             MOVS     R1,R5
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x.... 0x....      BL       TIM_OC4_SetConfig
   3435                break;
   \       0x5A   0xE7FF             B.N      ??HAL_TIM_OC_ConfigChannel_7
   3436              }
   3437          
   3438              default:
   3439                break;
   3440            }
   3441          
   3442            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_ConfigChannel_6: (+1)
   \                     ??HAL_TIM_OC_ConfigChannel_7: (+1)
   \       0x5C   0x2001             MOVS     R0,#+1
   \       0x5E   0xF884 0x003D      STRB     R0,[R4, #+61]
   3443          
   3444            __HAL_UNLOCK(htim);
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xF884 0x003C      STRB     R0,[R4, #+60]
   3445          
   3446            return HAL_OK;
   \       0x68   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_ConfigChannel_1: (+1)
   \       0x6A   0xBD70             POP      {R4-R6,PC}
   3447          }
   3448          
   3449          /**
   3450            * @brief  Initializes the TIM Input Capture Channels according to the specified
   3451            *         parameters in the TIM_IC_InitTypeDef.
   3452            * @param  htim TIM IC handle
   3453            * @param  sConfig TIM Input Capture configuration structure
   3454            * @param  Channel TIM Channel to configure
   3455            *          This parameter can be one of the following values:
   3456            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3457            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3458            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3459            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3460            * @retval HAL status
   3461            */

   \                                 In section .text, align 2, keep-with-next
   3462          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef *sConfig, uint32_t Channel)
   3463          {
   \                     HAL_TIM_IC_ConfigChannel: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0014             MOVS     R4,R2
   3464            /* Check the parameters */
   3465            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3466            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   3467            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   3468            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   3469            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   3470          
   3471            /* Process Locked */
   3472            __HAL_LOCK(htim);
   \        0x8   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE.N    ??HAL_TIM_IC_ConfigChannel_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE05F             B.N      ??HAL_TIM_IC_ConfigChannel_1
   \                     ??HAL_TIM_IC_ConfigChannel_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xF885 0x003C      STRB     R0,[R5, #+60]
   3473          
   3474            htim->State = HAL_TIM_STATE_BUSY;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0xF885 0x003D      STRB     R0,[R5, #+61]
   3475          
   3476            if (Channel == TIM_CHANNEL_1)
   \       0x20   0x2C00             CMP      R4,#+0
   \       0x22   0xD112             BNE.N    ??HAL_TIM_IC_ConfigChannel_2
   3477            {
   3478              /* TI1 Configuration */
   3479              TIM_TI1_SetConfig(htim->Instance,
   3480                                sConfig->ICPolarity,
   3481                                sConfig->ICSelection,
   3482                                sConfig->ICFilter);
   \       0x24   0x68F3             LDR      R3,[R6, #+12]
   \       0x26   0x6872             LDR      R2,[R6, #+4]
   \       0x28   0x6831             LDR      R1,[R6, #+0]
   \       0x2A   0x6828             LDR      R0,[R5, #+0]
   \       0x2C   0x.... 0x....      BL       TIM_TI1_SetConfig
   3483          
   3484              /* Reset the IC1PSC Bits */
   3485              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \       0x30   0x6828             LDR      R0,[R5, #+0]
   \       0x32   0x6980             LDR      R0,[R0, #+24]
   \       0x34   0xF030 0x000C      BICS     R0,R0,#0xC
   \       0x38   0x6829             LDR      R1,[R5, #+0]
   \       0x3A   0x6188             STR      R0,[R1, #+24]
   3486          
   3487              /* Set the IC1PSC value */
   3488              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   \       0x3C   0x6828             LDR      R0,[R5, #+0]
   \       0x3E   0x6981             LDR      R1,[R0, #+24]
   \       0x40   0x68B0             LDR      R0,[R6, #+8]
   \       0x42   0x4301             ORRS     R1,R0,R1
   \       0x44   0x6828             LDR      R0,[R5, #+0]
   \       0x46   0x6181             STR      R1,[R0, #+24]
   \       0x48   0xE03D             B.N      ??HAL_TIM_IC_ConfigChannel_3
   3489            }
   3490            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_IC_ConfigChannel_2: (+1)
   \       0x4A   0x2C04             CMP      R4,#+4
   \       0x4C   0xD113             BNE.N    ??HAL_TIM_IC_ConfigChannel_4
   3491            {
   3492              /* TI2 Configuration */
   3493              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3494          
   3495              TIM_TI2_SetConfig(htim->Instance,
   3496                                sConfig->ICPolarity,
   3497                                sConfig->ICSelection,
   3498                                sConfig->ICFilter);
   \       0x4E   0x68F3             LDR      R3,[R6, #+12]
   \       0x50   0x6872             LDR      R2,[R6, #+4]
   \       0x52   0x6831             LDR      R1,[R6, #+0]
   \       0x54   0x6828             LDR      R0,[R5, #+0]
   \       0x56   0x.... 0x....      BL       TIM_TI2_SetConfig
   3499          
   3500              /* Reset the IC2PSC Bits */
   3501              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \       0x5A   0x6828             LDR      R0,[R5, #+0]
   \       0x5C   0x6980             LDR      R0,[R0, #+24]
   \       0x5E   0xF430 0x6040      BICS     R0,R0,#0xC00
   \       0x62   0x6829             LDR      R1,[R5, #+0]
   \       0x64   0x6188             STR      R0,[R1, #+24]
   3502          
   3503              /* Set the IC2PSC value */
   3504              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
   \       0x66   0x6828             LDR      R0,[R5, #+0]
   \       0x68   0x6980             LDR      R0,[R0, #+24]
   \       0x6A   0x68B1             LDR      R1,[R6, #+8]
   \       0x6C   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \       0x70   0x6829             LDR      R1,[R5, #+0]
   \       0x72   0x6188             STR      R0,[R1, #+24]
   \       0x74   0xE027             B.N      ??HAL_TIM_IC_ConfigChannel_3
   3505            }
   3506            else if (Channel == TIM_CHANNEL_3)
   \                     ??HAL_TIM_IC_ConfigChannel_4: (+1)
   \       0x76   0x2C08             CMP      R4,#+8
   \       0x78   0xD112             BNE.N    ??HAL_TIM_IC_ConfigChannel_5
   3507            {
   3508              /* TI3 Configuration */
   3509              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3510          
   3511              TIM_TI3_SetConfig(htim->Instance,
   3512                                sConfig->ICPolarity,
   3513                                sConfig->ICSelection,
   3514                                sConfig->ICFilter);
   \       0x7A   0x68F3             LDR      R3,[R6, #+12]
   \       0x7C   0x6872             LDR      R2,[R6, #+4]
   \       0x7E   0x6831             LDR      R1,[R6, #+0]
   \       0x80   0x6828             LDR      R0,[R5, #+0]
   \       0x82   0x.... 0x....      BL       TIM_TI3_SetConfig
   3515          
   3516              /* Reset the IC3PSC Bits */
   3517              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   \       0x86   0x6828             LDR      R0,[R5, #+0]
   \       0x88   0x69C0             LDR      R0,[R0, #+28]
   \       0x8A   0xF030 0x000C      BICS     R0,R0,#0xC
   \       0x8E   0x6829             LDR      R1,[R5, #+0]
   \       0x90   0x61C8             STR      R0,[R1, #+28]
   3518          
   3519              /* Set the IC3PSC value */
   3520              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   \       0x92   0x6828             LDR      R0,[R5, #+0]
   \       0x94   0x69C1             LDR      R1,[R0, #+28]
   \       0x96   0x68B0             LDR      R0,[R6, #+8]
   \       0x98   0x4301             ORRS     R1,R0,R1
   \       0x9A   0x6828             LDR      R0,[R5, #+0]
   \       0x9C   0x61C1             STR      R1,[R0, #+28]
   \       0x9E   0xE012             B.N      ??HAL_TIM_IC_ConfigChannel_3
   3521            }
   3522            else
   3523            {
   3524              /* TI4 Configuration */
   3525              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3526          
   3527              TIM_TI4_SetConfig(htim->Instance,
   3528                                sConfig->ICPolarity,
   3529                                sConfig->ICSelection,
   3530                                sConfig->ICFilter);
   \                     ??HAL_TIM_IC_ConfigChannel_5: (+1)
   \       0xA0   0x68F3             LDR      R3,[R6, #+12]
   \       0xA2   0x6872             LDR      R2,[R6, #+4]
   \       0xA4   0x6831             LDR      R1,[R6, #+0]
   \       0xA6   0x6828             LDR      R0,[R5, #+0]
   \       0xA8   0x.... 0x....      BL       TIM_TI4_SetConfig
   3531          
   3532              /* Reset the IC4PSC Bits */
   3533              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   \       0xAC   0x6828             LDR      R0,[R5, #+0]
   \       0xAE   0x69C0             LDR      R0,[R0, #+28]
   \       0xB0   0xF430 0x6040      BICS     R0,R0,#0xC00
   \       0xB4   0x6829             LDR      R1,[R5, #+0]
   \       0xB6   0x61C8             STR      R0,[R1, #+28]
   3534          
   3535              /* Set the IC4PSC value */
   3536              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
   \       0xB8   0x6828             LDR      R0,[R5, #+0]
   \       0xBA   0x69C0             LDR      R0,[R0, #+28]
   \       0xBC   0x68B1             LDR      R1,[R6, #+8]
   \       0xBE   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \       0xC2   0x6829             LDR      R1,[R5, #+0]
   \       0xC4   0x61C8             STR      R0,[R1, #+28]
   3537            }
   3538          
   3539            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_ConfigChannel_3: (+1)
   \       0xC6   0x2001             MOVS     R0,#+1
   \       0xC8   0xF885 0x003D      STRB     R0,[R5, #+61]
   3540          
   3541            __HAL_UNLOCK(htim);
   \       0xCC   0x2000             MOVS     R0,#+0
   \       0xCE   0xF885 0x003C      STRB     R0,[R5, #+60]
   3542          
   3543            return HAL_OK;
   \       0xD2   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_ConfigChannel_1: (+1)
   \       0xD4   0xBD70             POP      {R4-R6,PC}
   3544          }
   3545          
   3546          /**
   3547            * @brief  Initializes the TIM PWM  channels according to the specified
   3548            *         parameters in the TIM_OC_InitTypeDef.
   3549            * @param  htim TIM PWM handle
   3550            * @param  sConfig TIM PWM configuration structure
   3551            * @param  Channel TIM Channels to be configured
   3552            *          This parameter can be one of the following values:
   3553            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3554            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3555            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3556            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3557            * @retval HAL status
   3558            */

   \                                 In section .text, align 2, keep-with-next
   3559          HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
   3560                                                      TIM_OC_InitTypeDef *sConfig,
   3561                                                      uint32_t Channel)
   3562          {
   \                     HAL_TIM_PWM_ConfigChannel: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   3563            /* Check the parameters */
   3564            assert_param(IS_TIM_CHANNELS(Channel));
   3565            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   3566            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3567            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   3568          
   3569            /* Process Locked */
   3570            __HAL_LOCK(htim);
   \        0x8   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE.N    ??HAL_TIM_PWM_ConfigChannel_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE074             B.N      ??HAL_TIM_PWM_ConfigChannel_1
   \                     ??HAL_TIM_PWM_ConfigChannel_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xF884 0x003C      STRB     R0,[R4, #+60]
   3571          
   3572            htim->State = HAL_TIM_STATE_BUSY;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0xF884 0x003D      STRB     R0,[R4, #+61]
   3573          
   3574            switch (Channel)
   \       0x20   0x0030             MOVS     R0,R6
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD006             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_2
   \       0x26   0x2804             CMP      R0,#+4
   \       0x28   0xD01B             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_3
   \       0x2A   0x2808             CMP      R0,#+8
   \       0x2C   0xD031             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_4
   \       0x2E   0x280C             CMP      R0,#+12
   \       0x30   0xD046             BEQ.N    ??HAL_TIM_PWM_ConfigChannel_5
   \       0x32   0xE05D             B.N      ??HAL_TIM_PWM_ConfigChannel_6
   3575            {
   3576              case TIM_CHANNEL_1:
   3577              {
   3578                /* Check the parameters */
   3579                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3580          
   3581                /* Configure the Channel 1 in PWM mode */
   3582                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_2: (+1)
   \       0x34   0x0029             MOVS     R1,R5
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x.... 0x....      BL       TIM_OC1_SetConfig
   3583          
   3584                /* Set the Preload enable bit for channel1 */
   3585                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x6980             LDR      R0,[R0, #+24]
   \       0x40   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0x44   0x6821             LDR      R1,[R4, #+0]
   \       0x46   0x6188             STR      R0,[R1, #+24]
   3586          
   3587                /* Configure the Output Fast mode */
   3588                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x6980             LDR      R0,[R0, #+24]
   \       0x4C   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0x50   0x6821             LDR      R1,[R4, #+0]
   \       0x52   0x6188             STR      R0,[R1, #+24]
   3589                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x6981             LDR      R1,[R0, #+24]
   \       0x58   0x6928             LDR      R0,[R5, #+16]
   \       0x5A   0x4301             ORRS     R1,R0,R1
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x6181             STR      R1,[R0, #+24]
   3590                break;
   \       0x60   0xE046             B.N      ??HAL_TIM_PWM_ConfigChannel_7
   3591              }
   3592          
   3593              case TIM_CHANNEL_2:
   3594              {
   3595                /* Check the parameters */
   3596                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3597          
   3598                /* Configure the Channel 2 in PWM mode */
   3599                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_3: (+1)
   \       0x62   0x0029             MOVS     R1,R5
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x.... 0x....      BL       TIM_OC2_SetConfig
   3600          
   3601                /* Set the Preload enable bit for channel2 */
   3602                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x6980             LDR      R0,[R0, #+24]
   \       0x6E   0xF450 0x6000      ORRS     R0,R0,#0x800
   \       0x72   0x6821             LDR      R1,[R4, #+0]
   \       0x74   0x6188             STR      R0,[R1, #+24]
   3603          
   3604                /* Configure the Output Fast mode */
   3605                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x6980             LDR      R0,[R0, #+24]
   \       0x7A   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x7E   0x6821             LDR      R1,[R4, #+0]
   \       0x80   0x6188             STR      R0,[R1, #+24]
   3606                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
   \       0x82   0x6820             LDR      R0,[R4, #+0]
   \       0x84   0x6980             LDR      R0,[R0, #+24]
   \       0x86   0x6929             LDR      R1,[R5, #+16]
   \       0x88   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \       0x8C   0x6821             LDR      R1,[R4, #+0]
   \       0x8E   0x6188             STR      R0,[R1, #+24]
   3607                break;
   \       0x90   0xE02E             B.N      ??HAL_TIM_PWM_ConfigChannel_7
   3608              }
   3609          
   3610              case TIM_CHANNEL_3:
   3611              {
   3612                /* Check the parameters */
   3613                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3614          
   3615                /* Configure the Channel 3 in PWM mode */
   3616                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_4: (+1)
   \       0x92   0x0029             MOVS     R1,R5
   \       0x94   0x6820             LDR      R0,[R4, #+0]
   \       0x96   0x.... 0x....      BL       TIM_OC3_SetConfig
   3617          
   3618                /* Set the Preload enable bit for channel3 */
   3619                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0x69C0             LDR      R0,[R0, #+28]
   \       0x9E   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0xA2   0x6821             LDR      R1,[R4, #+0]
   \       0xA4   0x61C8             STR      R0,[R1, #+28]
   3620          
   3621                /* Configure the Output Fast mode */
   3622                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   \       0xA6   0x6820             LDR      R0,[R4, #+0]
   \       0xA8   0x69C0             LDR      R0,[R0, #+28]
   \       0xAA   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0xAE   0x6821             LDR      R1,[R4, #+0]
   \       0xB0   0x61C8             STR      R0,[R1, #+28]
   3623                htim->Instance->CCMR2 |= sConfig->OCFastMode;
   \       0xB2   0x6820             LDR      R0,[R4, #+0]
   \       0xB4   0x69C1             LDR      R1,[R0, #+28]
   \       0xB6   0x6928             LDR      R0,[R5, #+16]
   \       0xB8   0x4301             ORRS     R1,R0,R1
   \       0xBA   0x6820             LDR      R0,[R4, #+0]
   \       0xBC   0x61C1             STR      R1,[R0, #+28]
   3624                break;
   \       0xBE   0xE017             B.N      ??HAL_TIM_PWM_ConfigChannel_7
   3625              }
   3626          
   3627              case TIM_CHANNEL_4:
   3628              {
   3629                /* Check the parameters */
   3630                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3631          
   3632                /* Configure the Channel 4 in PWM mode */
   3633                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_5: (+1)
   \       0xC0   0x0029             MOVS     R1,R5
   \       0xC2   0x6820             LDR      R0,[R4, #+0]
   \       0xC4   0x.... 0x....      BL       TIM_OC4_SetConfig
   3634          
   3635                /* Set the Preload enable bit for channel4 */
   3636                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   \       0xC8   0x6820             LDR      R0,[R4, #+0]
   \       0xCA   0x69C0             LDR      R0,[R0, #+28]
   \       0xCC   0xF450 0x6000      ORRS     R0,R0,#0x800
   \       0xD0   0x6821             LDR      R1,[R4, #+0]
   \       0xD2   0x61C8             STR      R0,[R1, #+28]
   3637          
   3638                /* Configure the Output Fast mode */
   3639                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   \       0xD4   0x6820             LDR      R0,[R4, #+0]
   \       0xD6   0x69C0             LDR      R0,[R0, #+28]
   \       0xD8   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0xDC   0x6821             LDR      R1,[R4, #+0]
   \       0xDE   0x61C8             STR      R0,[R1, #+28]
   3640                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
   \       0xE0   0x6820             LDR      R0,[R4, #+0]
   \       0xE2   0x69C0             LDR      R0,[R0, #+28]
   \       0xE4   0x6929             LDR      R1,[R5, #+16]
   \       0xE6   0xEA50 0x2001      ORRS     R0,R0,R1, LSL #+8
   \       0xEA   0x6821             LDR      R1,[R4, #+0]
   \       0xEC   0x61C8             STR      R0,[R1, #+28]
   3641                break;
   \       0xEE   0xE7FF             B.N      ??HAL_TIM_PWM_ConfigChannel_7
   3642              }
   3643          
   3644              default:
   3645                break;
   3646            }
   3647          
   3648            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_ConfigChannel_6: (+1)
   \                     ??HAL_TIM_PWM_ConfigChannel_7: (+1)
   \       0xF0   0x2001             MOVS     R0,#+1
   \       0xF2   0xF884 0x003D      STRB     R0,[R4, #+61]
   3649          
   3650            __HAL_UNLOCK(htim);
   \       0xF6   0x2000             MOVS     R0,#+0
   \       0xF8   0xF884 0x003C      STRB     R0,[R4, #+60]
   3651          
   3652            return HAL_OK;
   \       0xFC   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_ConfigChannel_1: (+1)
   \       0xFE   0xBD70             POP      {R4-R6,PC}
   3653          }
   3654          
   3655          /**
   3656            * @brief  Initializes the TIM One Pulse Channels according to the specified
   3657            *         parameters in the TIM_OnePulse_InitTypeDef.
   3658            * @param  htim TIM One Pulse handle
   3659            * @param  sConfig TIM One Pulse configuration structure
   3660            * @param  OutputChannel TIM output channel to configure
   3661            *          This parameter can be one of the following values:
   3662            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3663            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3664            * @param  InputChannel TIM input Channel to configure
   3665            *          This parameter can be one of the following values:
   3666            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3667            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3668            * @note  To output a waveform with a minimum delay user can enable the fast
   3669            *        mode by calling the @ref __HAL_TIM_ENABLE_OCxFAST macro. Then CCx
   3670            *        output is forced in response to the edge detection on TIx input,
   3671            *        without taking in account the comparison.
   3672            * @retval HAL status
   3673            */

   \                                 In section .text, align 2, keep-with-next
   3674          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef *sConfig,
   3675                                                           uint32_t OutputChannel,  uint32_t InputChannel)
   3676          {
   \                     HAL_TIM_OnePulse_ConfigChannel: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   3677            TIM_OC_InitTypeDef temp1;
   3678          
   3679            /* Check the parameters */
   3680            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   3681            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   3682          
   3683            if (OutputChannel != InputChannel)
   \        0xC   0x42BE             CMP      R6,R7
   \        0xE   0xF000 0x8080      BEQ.W    ??HAL_TIM_OnePulse_ConfigChannel_0
   3684            {
   3685              /* Process Locked */
   3686              __HAL_LOCK(htim);
   \       0x12   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD101             BNE.N    ??HAL_TIM_OnePulse_ConfigChannel_1
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0xE07A             B.N      ??HAL_TIM_OnePulse_ConfigChannel_2
   \                     ??HAL_TIM_OnePulse_ConfigChannel_1: (+1)
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xF884 0x003C      STRB     R0,[R4, #+60]
   3687          
   3688              htim->State = HAL_TIM_STATE_BUSY;
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0xF884 0x003D      STRB     R0,[R4, #+61]
   3689          
   3690              /* Extract the Output compare configuration from sConfig structure */
   3691              temp1.OCMode = sConfig->OCMode;
   \       0x2A   0x6828             LDR      R0,[R5, #+0]
   \       0x2C   0x9000             STR      R0,[SP, #+0]
   3692              temp1.Pulse = sConfig->Pulse;
   \       0x2E   0x6868             LDR      R0,[R5, #+4]
   \       0x30   0x9001             STR      R0,[SP, #+4]
   3693              temp1.OCPolarity = sConfig->OCPolarity;
   \       0x32   0x68A8             LDR      R0,[R5, #+8]
   \       0x34   0x9002             STR      R0,[SP, #+8]
   3694              temp1.OCNPolarity = sConfig->OCNPolarity;
   \       0x36   0x68E8             LDR      R0,[R5, #+12]
   \       0x38   0x9003             STR      R0,[SP, #+12]
   3695              temp1.OCIdleState = sConfig->OCIdleState;
   \       0x3A   0x6928             LDR      R0,[R5, #+16]
   \       0x3C   0x9005             STR      R0,[SP, #+20]
   3696              temp1.OCNIdleState = sConfig->OCNIdleState;
   \       0x3E   0x6968             LDR      R0,[R5, #+20]
   \       0x40   0x9006             STR      R0,[SP, #+24]
   3697          
   3698              switch (OutputChannel)
   \       0x42   0x0030             MOVS     R0,R6
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD002             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_3
   \       0x48   0x2804             CMP      R0,#+4
   \       0x4A   0xD005             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_4
   \       0x4C   0xE009             B.N      ??HAL_TIM_OnePulse_ConfigChannel_5
   3699              {
   3700                case TIM_CHANNEL_1:
   3701                {
   3702                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3703          
   3704                  TIM_OC1_SetConfig(htim->Instance, &temp1);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_3: (+1)
   \       0x4E   0x4669             MOV      R1,SP
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x.... 0x....      BL       TIM_OC1_SetConfig
   3705                  break;
   \       0x56   0xE004             B.N      ??HAL_TIM_OnePulse_ConfigChannel_6
   3706                }
   3707                case TIM_CHANNEL_2:
   3708                {
   3709                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3710          
   3711                  TIM_OC2_SetConfig(htim->Instance, &temp1);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_4: (+1)
   \       0x58   0x4669             MOV      R1,SP
   \       0x5A   0x6820             LDR      R0,[R4, #+0]
   \       0x5C   0x.... 0x....      BL       TIM_OC2_SetConfig
   3712                  break;
   \       0x60   0xE7FF             B.N      ??HAL_TIM_OnePulse_ConfigChannel_6
   3713                }
   3714                default:
   3715                  break;
   3716              }
   3717          
   3718              switch (InputChannel)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_5: (+1)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_6: (+1)
   \       0x62   0x0038             MOVS     R0,R7
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD002             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_7
   \       0x68   0x2804             CMP      R0,#+4
   \       0x6A   0xD025             BEQ.N    ??HAL_TIM_OnePulse_ConfigChannel_8
   \       0x6C   0xE049             B.N      ??HAL_TIM_OnePulse_ConfigChannel_9
   3719              {
   3720                case TIM_CHANNEL_1:
   3721                {
   3722                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3723          
   3724                  TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   3725                                    sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_7: (+1)
   \       0x6E   0x6A2B             LDR      R3,[R5, #+32]
   \       0x70   0x69EA             LDR      R2,[R5, #+28]
   \       0x72   0x69A9             LDR      R1,[R5, #+24]
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x.... 0x....      BL       TIM_TI1_SetConfig
   3726          
   3727                  /* Reset the IC1PSC Bits */
   3728                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x6980             LDR      R0,[R0, #+24]
   \       0x7E   0xF030 0x000C      BICS     R0,R0,#0xC
   \       0x82   0x6821             LDR      R1,[R4, #+0]
   \       0x84   0x6188             STR      R0,[R1, #+24]
   3729          
   3730                  /* Select the Trigger source */
   3731                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x6880             LDR      R0,[R0, #+8]
   \       0x8A   0xF030 0x0070      BICS     R0,R0,#0x70
   \       0x8E   0x6821             LDR      R1,[R4, #+0]
   \       0x90   0x6088             STR      R0,[R1, #+8]
   3732                  htim->Instance->SMCR |= TIM_TS_TI1FP1;
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x6880             LDR      R0,[R0, #+8]
   \       0x96   0xF050 0x0050      ORRS     R0,R0,#0x50
   \       0x9A   0x6821             LDR      R1,[R4, #+0]
   \       0x9C   0x6088             STR      R0,[R1, #+8]
   3733          
   3734                  /* Select the Slave Mode */
   3735                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \       0x9E   0x6820             LDR      R0,[R4, #+0]
   \       0xA0   0x6880             LDR      R0,[R0, #+8]
   \       0xA2   0x08C0             LSRS     R0,R0,#+3
   \       0xA4   0x00C0             LSLS     R0,R0,#+3
   \       0xA6   0x6821             LDR      R1,[R4, #+0]
   \       0xA8   0x6088             STR      R0,[R1, #+8]
   3736                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \       0xAA   0x6820             LDR      R0,[R4, #+0]
   \       0xAC   0x6880             LDR      R0,[R0, #+8]
   \       0xAE   0xF050 0x0006      ORRS     R0,R0,#0x6
   \       0xB2   0x6821             LDR      R1,[R4, #+0]
   \       0xB4   0x6088             STR      R0,[R1, #+8]
   3737                  break;
   \       0xB6   0xE024             B.N      ??HAL_TIM_OnePulse_ConfigChannel_10
   3738                }
   3739                case TIM_CHANNEL_2:
   3740                {
   3741                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3742          
   3743                  TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   3744                                    sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_8: (+1)
   \       0xB8   0x6A2B             LDR      R3,[R5, #+32]
   \       0xBA   0x69EA             LDR      R2,[R5, #+28]
   \       0xBC   0x69A9             LDR      R1,[R5, #+24]
   \       0xBE   0x6820             LDR      R0,[R4, #+0]
   \       0xC0   0x.... 0x....      BL       TIM_TI2_SetConfig
   3745          
   3746                  /* Reset the IC2PSC Bits */
   3747                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \       0xC4   0x6820             LDR      R0,[R4, #+0]
   \       0xC6   0x6980             LDR      R0,[R0, #+24]
   \       0xC8   0xF430 0x6040      BICS     R0,R0,#0xC00
   \       0xCC   0x6821             LDR      R1,[R4, #+0]
   \       0xCE   0x6188             STR      R0,[R1, #+24]
   3748          
   3749                  /* Select the Trigger source */
   3750                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \       0xD0   0x6820             LDR      R0,[R4, #+0]
   \       0xD2   0x6880             LDR      R0,[R0, #+8]
   \       0xD4   0xF030 0x0070      BICS     R0,R0,#0x70
   \       0xD8   0x6821             LDR      R1,[R4, #+0]
   \       0xDA   0x6088             STR      R0,[R1, #+8]
   3751                  htim->Instance->SMCR |= TIM_TS_TI2FP2;
   \       0xDC   0x6820             LDR      R0,[R4, #+0]
   \       0xDE   0x6880             LDR      R0,[R0, #+8]
   \       0xE0   0xF050 0x0060      ORRS     R0,R0,#0x60
   \       0xE4   0x6821             LDR      R1,[R4, #+0]
   \       0xE6   0x6088             STR      R0,[R1, #+8]
   3752          
   3753                  /* Select the Slave Mode */
   3754                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \       0xE8   0x6820             LDR      R0,[R4, #+0]
   \       0xEA   0x6880             LDR      R0,[R0, #+8]
   \       0xEC   0x08C0             LSRS     R0,R0,#+3
   \       0xEE   0x00C0             LSLS     R0,R0,#+3
   \       0xF0   0x6821             LDR      R1,[R4, #+0]
   \       0xF2   0x6088             STR      R0,[R1, #+8]
   3755                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \       0xF4   0x6820             LDR      R0,[R4, #+0]
   \       0xF6   0x6880             LDR      R0,[R0, #+8]
   \       0xF8   0xF050 0x0006      ORRS     R0,R0,#0x6
   \       0xFC   0x6821             LDR      R1,[R4, #+0]
   \       0xFE   0x6088             STR      R0,[R1, #+8]
   3756                  break;
   \      0x100   0xE7FF             B.N      ??HAL_TIM_OnePulse_ConfigChannel_10
   3757                }
   3758          
   3759                default:
   3760                  break;
   3761              }
   3762          
   3763              htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_9: (+1)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_10: (+1)
   \      0x102   0x2001             MOVS     R0,#+1
   \      0x104   0xF884 0x003D      STRB     R0,[R4, #+61]
   3764          
   3765              __HAL_UNLOCK(htim);
   \      0x108   0x2000             MOVS     R0,#+0
   \      0x10A   0xF884 0x003C      STRB     R0,[R4, #+60]
   3766          
   3767              return HAL_OK;
   \      0x10E   0x2000             MOVS     R0,#+0
   \      0x110   0xE000             B.N      ??HAL_TIM_OnePulse_ConfigChannel_2
   3768            }
   3769            else
   3770            {
   3771              return HAL_ERROR;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_0: (+1)
   \      0x112   0x2001             MOVS     R0,#+1
   \                     ??HAL_TIM_OnePulse_ConfigChannel_2: (+1)
   \      0x114   0xB007             ADD      SP,SP,#+28
   \      0x116   0xBDF0             POP      {R4-R7,PC}
   3772            }
   3773          }
   3774          
   3775          /**
   3776            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral
   3777            * @param  htim TIM handle
   3778            * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data write
   3779            *         This parameter can be one of the following values:
   3780            *            @arg TIM_DMABASE_CR1
   3781            *            @arg TIM_DMABASE_CR2
   3782            *            @arg TIM_DMABASE_SMCR
   3783            *            @arg TIM_DMABASE_DIER
   3784            *            @arg TIM_DMABASE_SR
   3785            *            @arg TIM_DMABASE_EGR
   3786            *            @arg TIM_DMABASE_CCMR1
   3787            *            @arg TIM_DMABASE_CCMR2
   3788            *            @arg TIM_DMABASE_CCER
   3789            *            @arg TIM_DMABASE_CNT
   3790            *            @arg TIM_DMABASE_PSC
   3791            *            @arg TIM_DMABASE_ARR
   3792            *            @arg TIM_DMABASE_RCR
   3793            *            @arg TIM_DMABASE_CCR1
   3794            *            @arg TIM_DMABASE_CCR2
   3795            *            @arg TIM_DMABASE_CCR3
   3796            *            @arg TIM_DMABASE_CCR4
   3797            *            @arg TIM_DMABASE_BDTR
   3798            * @param  BurstRequestSrc TIM DMA Request sources
   3799            *         This parameter can be one of the following values:
   3800            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3801            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3802            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3803            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3804            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3805            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3806            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3807            * @param  BurstBuffer The Buffer address.
   3808            * @param  BurstLength DMA Burst length. This parameter can be one value
   3809            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3810            * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
   3811            * @retval HAL status
   3812            */

   \                                 In section .text, align 2, keep-with-next
   3813          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3814                                                        uint32_t *BurstBuffer, uint32_t  BurstLength)
   3815          {
   \                     HAL_TIM_DMABurst_WriteStart: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x001C             MOVS     R4,R3
   \        0xC   0x9D06             LDR      R5,[SP, #+24]
   3816            /* Check the parameters */
   3817            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3818            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3819            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3820            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3821          
   3822            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0xE   0xF896 0x003D      LDRB     R0,[R6, #+61]
   \       0x12   0x2802             CMP      R0,#+2
   \       0x14   0xD101             BNE.N    ??HAL_TIM_DMABurst_WriteStart_0
   3823            {
   3824              return HAL_BUSY;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0xE0F0             B.N      ??HAL_TIM_DMABurst_WriteStart_1
   3825            }
   3826            else if (htim->State == HAL_TIM_STATE_READY)
   \                     ??HAL_TIM_DMABurst_WriteStart_0: (+1)
   \       0x1A   0xF896 0x003D      LDRB     R0,[R6, #+61]
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xD108             BNE.N    ??HAL_TIM_DMABurst_WriteStart_2
   3827            {
   3828              if ((BurstBuffer == NULL) && (BurstLength > 0U))
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD103             BNE.N    ??HAL_TIM_DMABurst_WriteStart_3
   \       0x26   0x2D00             CMP      R5,#+0
   \       0x28   0xD001             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_3
   3829              {
   3830                return HAL_ERROR;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE0E6             B.N      ??HAL_TIM_DMABurst_WriteStart_1
   3831              }
   3832              else
   3833              {
   3834                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_WriteStart_3: (+1)
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0xF886 0x003D      STRB     R0,[R6, #+61]
   3835              }
   3836            }
   3837            else
   3838            {
   3839              /* nothing to do */
   3840            }
   3841            switch (BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_WriteStart_2: (+1)
   \       0x34   0x4640             MOV      R0,R8
   \       0x36   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x3A   0xD014             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_4
   \       0x3C   0xF5B0 0x7F00      CMP      R0,#+512
   \       0x40   0xD02C             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_5
   \       0x42   0xF5B0 0x6F80      CMP      R0,#+1024
   \       0x46   0xD044             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_6
   \       0x48   0xF5B0 0x6F00      CMP      R0,#+2048
   \       0x4C   0xD05C             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_7
   \       0x4E   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x52   0xD074             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_8
   \       0x54   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x58   0xF000 0x808C      BEQ.W    ??HAL_TIM_DMABurst_WriteStart_9
   \       0x5C   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x60   0xF000 0x80A3      BEQ.W    ??HAL_TIM_DMABurst_WriteStart_10
   \       0x64   0xE0BC             B.N      ??HAL_TIM_DMABurst_WriteStart_11
   3842            {
   3843              case TIM_DMA_UPDATE:
   3844              {
   3845                /* Set the DMA Period elapsed callbacks */
   3846                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_4: (+1)
   \       0x66   0x.... 0x....      ADR.W    R0,TIM_DMAPeriodElapsedCplt
   \       0x6A   0x6A31             LDR      R1,[R6, #+32]
   \       0x6C   0x63C8             STR      R0,[R1, #+60]
   3847                htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   \       0x6E   0x.... 0x....      ADR.W    R0,TIM_DMAPeriodElapsedHalfCplt
   \       0x72   0x6A31             LDR      R1,[R6, #+32]
   \       0x74   0x6408             STR      R0,[R1, #+64]
   3848          
   3849                /* Set the DMA error callback */
   3850                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \       0x76   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \       0x7A   0x6A31             LDR      R1,[R6, #+32]
   \       0x7C   0x64C8             STR      R0,[R1, #+76]
   3851          
   3852                /* Enable the DMA stream */
   3853                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \       0x7E   0x002B             MOVS     R3,R5
   \       0x80   0x0A1B             LSRS     R3,R3,#+8
   \       0x82   0x1C5B             ADDS     R3,R3,#+1
   \       0x84   0x6830             LDR      R0,[R6, #+0]
   \       0x86   0xF110 0x024C      ADDS     R2,R0,#+76
   \       0x8A   0x0021             MOVS     R1,R4
   \       0x8C   0x6A30             LDR      R0,[R6, #+32]
   \       0x8E   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD001             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_12
   3854                {
   3855                  return HAL_ERROR;
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0xE0B0             B.N      ??HAL_TIM_DMABurst_WriteStart_1
   3856                }
   3857                break;
   \                     ??HAL_TIM_DMABurst_WriteStart_12: (+1)
   \       0x9A   0xE0A1             B.N      ??HAL_TIM_DMABurst_WriteStart_13
   3858              }
   3859              case TIM_DMA_CC1:
   3860              {
   3861                /* Set the DMA compare callbacks */
   3862                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_5: (+1)
   \       0x9C   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \       0xA0   0x6A71             LDR      R1,[R6, #+36]
   \       0xA2   0x63C8             STR      R0,[R1, #+60]
   3863                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0xA4   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseHalfCplt
   \       0xA8   0x6A71             LDR      R1,[R6, #+36]
   \       0xAA   0x6408             STR      R0,[R1, #+64]
   3864          
   3865                /* Set the DMA error callback */
   3866                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0xAC   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \       0xB0   0x6A71             LDR      R1,[R6, #+36]
   \       0xB2   0x64C8             STR      R0,[R1, #+76]
   3867          
   3868                /* Enable the DMA stream */
   3869                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer,
   3870                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \       0xB4   0x002B             MOVS     R3,R5
   \       0xB6   0x0A1B             LSRS     R3,R3,#+8
   \       0xB8   0x1C5B             ADDS     R3,R3,#+1
   \       0xBA   0x6830             LDR      R0,[R6, #+0]
   \       0xBC   0xF110 0x024C      ADDS     R2,R0,#+76
   \       0xC0   0x0021             MOVS     R1,R4
   \       0xC2   0x6A70             LDR      R0,[R6, #+36]
   \       0xC4   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xD001             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_14
   3871                {
   3872                  return HAL_ERROR;
   \       0xCC   0x2001             MOVS     R0,#+1
   \       0xCE   0xE095             B.N      ??HAL_TIM_DMABurst_WriteStart_1
   3873                }
   3874                break;
   \                     ??HAL_TIM_DMABurst_WriteStart_14: (+1)
   \       0xD0   0xE086             B.N      ??HAL_TIM_DMABurst_WriteStart_13
   3875              }
   3876              case TIM_DMA_CC2:
   3877              {
   3878                /* Set the DMA compare callbacks */
   3879                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_6: (+1)
   \       0xD2   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \       0xD6   0x6AB1             LDR      R1,[R6, #+40]
   \       0xD8   0x63C8             STR      R0,[R1, #+60]
   3880                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0xDA   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseHalfCplt
   \       0xDE   0x6AB1             LDR      R1,[R6, #+40]
   \       0xE0   0x6408             STR      R0,[R1, #+64]
   3881          
   3882                /* Set the DMA error callback */
   3883                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \       0xE2   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \       0xE6   0x6AB1             LDR      R1,[R6, #+40]
   \       0xE8   0x64C8             STR      R0,[R1, #+76]
   3884          
   3885                /* Enable the DMA stream */
   3886                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer,
   3887                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \       0xEA   0x002B             MOVS     R3,R5
   \       0xEC   0x0A1B             LSRS     R3,R3,#+8
   \       0xEE   0x1C5B             ADDS     R3,R3,#+1
   \       0xF0   0x6830             LDR      R0,[R6, #+0]
   \       0xF2   0xF110 0x024C      ADDS     R2,R0,#+76
   \       0xF6   0x0021             MOVS     R1,R4
   \       0xF8   0x6AB0             LDR      R0,[R6, #+40]
   \       0xFA   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xD001             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_15
   3888                {
   3889                  return HAL_ERROR;
   \      0x102   0x2001             MOVS     R0,#+1
   \      0x104   0xE07A             B.N      ??HAL_TIM_DMABurst_WriteStart_1
   3890                }
   3891                break;
   \                     ??HAL_TIM_DMABurst_WriteStart_15: (+1)
   \      0x106   0xE06B             B.N      ??HAL_TIM_DMABurst_WriteStart_13
   3892              }
   3893              case TIM_DMA_CC3:
   3894              {
   3895                /* Set the DMA compare callbacks */
   3896                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_7: (+1)
   \      0x108   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \      0x10C   0x6AF1             LDR      R1,[R6, #+44]
   \      0x10E   0x63C8             STR      R0,[R1, #+60]
   3897                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \      0x110   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseHalfCplt
   \      0x114   0x6AF1             LDR      R1,[R6, #+44]
   \      0x116   0x6408             STR      R0,[R1, #+64]
   3898          
   3899                /* Set the DMA error callback */
   3900                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \      0x118   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \      0x11C   0x6AF1             LDR      R1,[R6, #+44]
   \      0x11E   0x64C8             STR      R0,[R1, #+76]
   3901          
   3902                /* Enable the DMA stream */
   3903                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer,
   3904                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \      0x120   0x002B             MOVS     R3,R5
   \      0x122   0x0A1B             LSRS     R3,R3,#+8
   \      0x124   0x1C5B             ADDS     R3,R3,#+1
   \      0x126   0x6830             LDR      R0,[R6, #+0]
   \      0x128   0xF110 0x024C      ADDS     R2,R0,#+76
   \      0x12C   0x0021             MOVS     R1,R4
   \      0x12E   0x6AF0             LDR      R0,[R6, #+44]
   \      0x130   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x134   0x2800             CMP      R0,#+0
   \      0x136   0xD001             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_16
   3905                {
   3906                  return HAL_ERROR;
   \      0x138   0x2001             MOVS     R0,#+1
   \      0x13A   0xE05F             B.N      ??HAL_TIM_DMABurst_WriteStart_1
   3907                }
   3908                break;
   \                     ??HAL_TIM_DMABurst_WriteStart_16: (+1)
   \      0x13C   0xE050             B.N      ??HAL_TIM_DMABurst_WriteStart_13
   3909              }
   3910              case TIM_DMA_CC4:
   3911              {
   3912                /* Set the DMA compare callbacks */
   3913                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_8: (+1)
   \      0x13E   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseCplt
   \      0x142   0x6B31             LDR      R1,[R6, #+48]
   \      0x144   0x63C8             STR      R0,[R1, #+60]
   3914                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \      0x146   0x.... 0x....      ADR.W    R0,TIM_DMADelayPulseHalfCplt
   \      0x14A   0x6B31             LDR      R1,[R6, #+48]
   \      0x14C   0x6408             STR      R0,[R1, #+64]
   3915          
   3916                /* Set the DMA error callback */
   3917                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \      0x14E   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \      0x152   0x6B31             LDR      R1,[R6, #+48]
   \      0x154   0x64C8             STR      R0,[R1, #+76]
   3918          
   3919                /* Enable the DMA stream */
   3920                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer,
   3921                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \      0x156   0x002B             MOVS     R3,R5
   \      0x158   0x0A1B             LSRS     R3,R3,#+8
   \      0x15A   0x1C5B             ADDS     R3,R3,#+1
   \      0x15C   0x6830             LDR      R0,[R6, #+0]
   \      0x15E   0xF110 0x024C      ADDS     R2,R0,#+76
   \      0x162   0x0021             MOVS     R1,R4
   \      0x164   0x6B30             LDR      R0,[R6, #+48]
   \      0x166   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x16A   0x2800             CMP      R0,#+0
   \      0x16C   0xD001             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_17
   3922                {
   3923                  return HAL_ERROR;
   \      0x16E   0x2001             MOVS     R0,#+1
   \      0x170   0xE044             B.N      ??HAL_TIM_DMABurst_WriteStart_1
   3924                }
   3925                break;
   \                     ??HAL_TIM_DMABurst_WriteStart_17: (+1)
   \      0x172   0xE035             B.N      ??HAL_TIM_DMABurst_WriteStart_13
   3926              }
   3927              case TIM_DMA_COM:
   3928              {
   3929                /* Set the DMA commutation callbacks */
   3930                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_9: (+1)
   \      0x174   0x.... 0x....      LDR.W    R0,??DataTable27
   \      0x178   0x6B71             LDR      R1,[R6, #+52]
   \      0x17A   0x63C8             STR      R0,[R1, #+60]
   3931                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
   \      0x17C   0x.... 0x....      LDR.W    R0,??DataTable28
   \      0x180   0x6B71             LDR      R1,[R6, #+52]
   \      0x182   0x6408             STR      R0,[R1, #+64]
   3932          
   3933                /* Set the DMA error callback */
   3934                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   \      0x184   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \      0x188   0x6B71             LDR      R1,[R6, #+52]
   \      0x18A   0x64C8             STR      R0,[R1, #+76]
   3935          
   3936                /* Enable the DMA stream */
   3937                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer,
   3938                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \      0x18C   0x002B             MOVS     R3,R5
   \      0x18E   0x0A1B             LSRS     R3,R3,#+8
   \      0x190   0x1C5B             ADDS     R3,R3,#+1
   \      0x192   0x6830             LDR      R0,[R6, #+0]
   \      0x194   0xF110 0x024C      ADDS     R2,R0,#+76
   \      0x198   0x0021             MOVS     R1,R4
   \      0x19A   0x6B70             LDR      R0,[R6, #+52]
   \      0x19C   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x1A0   0x2800             CMP      R0,#+0
   \      0x1A2   0xD001             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_18
   3939                {
   3940                  return HAL_ERROR;
   \      0x1A4   0x2001             MOVS     R0,#+1
   \      0x1A6   0xE029             B.N      ??HAL_TIM_DMABurst_WriteStart_1
   3941                }
   3942                break;
   \                     ??HAL_TIM_DMABurst_WriteStart_18: (+1)
   \      0x1A8   0xE01A             B.N      ??HAL_TIM_DMABurst_WriteStart_13
   3943              }
   3944              case TIM_DMA_TRIGGER:
   3945              {
   3946                /* Set the DMA trigger callbacks */
   3947                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_10: (+1)
   \      0x1AA   0x.... 0x....      ADR.W    R0,TIM_DMATriggerCplt
   \      0x1AE   0x6BB1             LDR      R1,[R6, #+56]
   \      0x1B0   0x63C8             STR      R0,[R1, #+60]
   3948                htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
   \      0x1B2   0x.... 0x....      ADR.W    R0,TIM_DMATriggerHalfCplt
   \      0x1B6   0x6BB1             LDR      R1,[R6, #+56]
   \      0x1B8   0x6408             STR      R0,[R1, #+64]
   3949          
   3950                /* Set the DMA error callback */
   3951                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   \      0x1BA   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \      0x1BE   0x6BB1             LDR      R1,[R6, #+56]
   \      0x1C0   0x64C8             STR      R0,[R1, #+76]
   3952          
   3953                /* Enable the DMA stream */
   3954                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer,
   3955                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \      0x1C2   0x002B             MOVS     R3,R5
   \      0x1C4   0x0A1B             LSRS     R3,R3,#+8
   \      0x1C6   0x1C5B             ADDS     R3,R3,#+1
   \      0x1C8   0x6830             LDR      R0,[R6, #+0]
   \      0x1CA   0xF110 0x024C      ADDS     R2,R0,#+76
   \      0x1CE   0x0021             MOVS     R1,R4
   \      0x1D0   0x6BB0             LDR      R0,[R6, #+56]
   \      0x1D2   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x1D6   0x2800             CMP      R0,#+0
   \      0x1D8   0xD001             BEQ.N    ??HAL_TIM_DMABurst_WriteStart_19
   3956                {
   3957                  return HAL_ERROR;
   \      0x1DA   0x2001             MOVS     R0,#+1
   \      0x1DC   0xE00E             B.N      ??HAL_TIM_DMABurst_WriteStart_1
   3958                }
   3959                break;
   \                     ??HAL_TIM_DMABurst_WriteStart_19: (+1)
   \      0x1DE   0xE7FF             B.N      ??HAL_TIM_DMABurst_WriteStart_13
   3960              }
   3961              default:
   3962                break;
   3963            }
   3964            /* configure the DMA Burst Mode */
   3965            htim->Instance->DCR = (BurstBaseAddress | BurstLength);
   \                     ??HAL_TIM_DMABurst_WriteStart_11: (+1)
   \                     ??HAL_TIM_DMABurst_WriteStart_13: (+1)
   \      0x1E0   0xEA55 0x0007      ORRS     R0,R5,R7
   \      0x1E4   0x6831             LDR      R1,[R6, #+0]
   \      0x1E6   0x6488             STR      R0,[R1, #+72]
   3966          
   3967            /* Enable the TIM DMA Request */
   3968            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   \      0x1E8   0x6830             LDR      R0,[R6, #+0]
   \      0x1EA   0x68C0             LDR      R0,[R0, #+12]
   \      0x1EC   0xEA58 0x0000      ORRS     R0,R8,R0
   \      0x1F0   0x6831             LDR      R1,[R6, #+0]
   \      0x1F2   0x60C8             STR      R0,[R1, #+12]
   3969          
   3970            htim->State = HAL_TIM_STATE_READY;
   \      0x1F4   0x2001             MOVS     R0,#+1
   \      0x1F6   0xF886 0x003D      STRB     R0,[R6, #+61]
   3971          
   3972            /* Return function status */
   3973            return HAL_OK;
   \      0x1FA   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_DMABurst_WriteStart_1: (+1)
   \      0x1FC   0xE8BD 0x81F0      POP      {R4-R8,PC}
   3974          }
   3975          
   3976          /**
   3977            * @brief  Stops the TIM DMA Burst mode
   3978            * @param  htim TIM handle
   3979            * @param  BurstRequestSrc TIM DMA Request sources to disable
   3980            * @retval HAL status
   3981            */

   \                                 In section .text, align 2, keep-with-next
   3982          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3983          {
   \                     HAL_TIM_DMABurst_WriteStop: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   3984            HAL_StatusTypeDef status = HAL_OK;
   \        0x6   0x2600             MOVS     R6,#+0
   3985            /* Check the parameters */
   3986            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3987          
   3988            /* Abort the DMA transfer (at least disable the DMA stream) */
   3989            switch (BurstRequestSrc)
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0xF5B0 0x7F80      CMP      R0,#+256
   \        0xE   0xD012             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_0
   \       0x10   0xF5B0 0x7F00      CMP      R0,#+512
   \       0x14   0xD014             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_1
   \       0x16   0xF5B0 0x6F80      CMP      R0,#+1024
   \       0x1A   0xD016             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_2
   \       0x1C   0xF5B0 0x6F00      CMP      R0,#+2048
   \       0x20   0xD018             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_3
   \       0x22   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x26   0xD01A             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_4
   \       0x28   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x2C   0xD01C             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_5
   \       0x2E   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x32   0xD01E             BEQ.N    ??HAL_TIM_DMABurst_WriteStop_6
   \       0x34   0xE022             B.N      ??HAL_TIM_DMABurst_WriteStop_7
   3990            {
   3991              case TIM_DMA_UPDATE:
   3992              {
   3993                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_WriteStop_0: (+1)
   \       0x36   0x6A20             LDR      R0,[R4, #+32]
   \       0x38   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x3C   0x0006             MOVS     R6,R0
   3994                break;
   \       0x3E   0xE01D             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   3995              }
   3996              case TIM_DMA_CC1:
   3997              {
   3998                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_WriteStop_1: (+1)
   \       0x40   0x6A60             LDR      R0,[R4, #+36]
   \       0x42   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x46   0x0006             MOVS     R6,R0
   3999                break;
   \       0x48   0xE018             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   4000              }
   4001              case TIM_DMA_CC2:
   4002              {
   4003                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_WriteStop_2: (+1)
   \       0x4A   0x6AA0             LDR      R0,[R4, #+40]
   \       0x4C   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x50   0x0006             MOVS     R6,R0
   4004                break;
   \       0x52   0xE013             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   4005              }
   4006              case TIM_DMA_CC3:
   4007              {
   4008                status =  HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_WriteStop_3: (+1)
   \       0x54   0x6AE0             LDR      R0,[R4, #+44]
   \       0x56   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x5A   0x0006             MOVS     R6,R0
   4009                break;
   \       0x5C   0xE00E             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   4010              }
   4011              case TIM_DMA_CC4:
   4012              {
   4013                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_WriteStop_4: (+1)
   \       0x5E   0x6B20             LDR      R0,[R4, #+48]
   \       0x60   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x64   0x0006             MOVS     R6,R0
   4014                break;
   \       0x66   0xE009             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   4015              }
   4016              case TIM_DMA_COM:
   4017              {
   4018                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??HAL_TIM_DMABurst_WriteStop_5: (+1)
   \       0x68   0x6B60             LDR      R0,[R4, #+52]
   \       0x6A   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x6E   0x0006             MOVS     R6,R0
   4019                break;
   \       0x70   0xE004             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   4020              }
   4021              case TIM_DMA_TRIGGER:
   4022              {
   4023                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_WriteStop_6: (+1)
   \       0x72   0x6BA0             LDR      R0,[R4, #+56]
   \       0x74   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x78   0x0006             MOVS     R6,R0
   4024                break;
   \       0x7A   0xE7FF             B.N      ??HAL_TIM_DMABurst_WriteStop_8
   4025              }
   4026              default:
   4027                break;
   4028            }
   4029          
   4030            if (HAL_OK == status)
   \                     ??HAL_TIM_DMABurst_WriteStop_7: (+1)
   \                     ??HAL_TIM_DMABurst_WriteStop_8: (+1)
   \       0x7C   0x0030             MOVS     R0,R6
   \       0x7E   0xB2C0             UXTB     R0,R0
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD104             BNE.N    ??HAL_TIM_DMABurst_WriteStop_9
   4031            {
   4032              /* Disable the TIM Update DMA request */
   4033              __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \       0x84   0x6820             LDR      R0,[R4, #+0]
   \       0x86   0x68C0             LDR      R0,[R0, #+12]
   \       0x88   0x43A8             BICS     R0,R0,R5
   \       0x8A   0x6821             LDR      R1,[R4, #+0]
   \       0x8C   0x60C8             STR      R0,[R1, #+12]
   4034            }
   4035          
   4036            /* Return function status */
   4037            return status;
   \                     ??HAL_TIM_DMABurst_WriteStop_9: (+1)
   \       0x8E   0x0030             MOVS     R0,R6
   \       0x90   0xB2C0             UXTB     R0,R0
   \       0x92   0xBD70             POP      {R4-R6,PC}
   4038          }
   4039          
   4040          /**
   4041            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory
   4042            * @param  htim TIM handle
   4043            * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read
   4044            *         This parameter can be one of the following values:
   4045            *            @arg TIM_DMABASE_CR1
   4046            *            @arg TIM_DMABASE_CR2
   4047            *            @arg TIM_DMABASE_SMCR
   4048            *            @arg TIM_DMABASE_DIER
   4049            *            @arg TIM_DMABASE_SR
   4050            *            @arg TIM_DMABASE_EGR
   4051            *            @arg TIM_DMABASE_CCMR1
   4052            *            @arg TIM_DMABASE_CCMR2
   4053            *            @arg TIM_DMABASE_CCER
   4054            *            @arg TIM_DMABASE_CNT
   4055            *            @arg TIM_DMABASE_PSC
   4056            *            @arg TIM_DMABASE_ARR
   4057            *            @arg TIM_DMABASE_RCR
   4058            *            @arg TIM_DMABASE_CCR1
   4059            *            @arg TIM_DMABASE_CCR2
   4060            *            @arg TIM_DMABASE_CCR3
   4061            *            @arg TIM_DMABASE_CCR4
   4062            *            @arg TIM_DMABASE_BDTR
   4063            * @param  BurstRequestSrc TIM DMA Request sources
   4064            *         This parameter can be one of the following values:
   4065            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   4066            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   4067            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   4068            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   4069            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   4070            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   4071            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   4072            * @param  BurstBuffer The Buffer address.
   4073            * @param  BurstLength DMA Burst length. This parameter can be one value
   4074            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   4075            * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
   4076            * @retval HAL status
   4077            */

   \                                 In section .text, align 2, keep-with-next
   4078          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
   4079                                                       uint32_t BurstRequestSrc, uint32_t  *BurstBuffer, uint32_t  BurstLength)
   4080          {
   \                     HAL_TIM_DMABurst_ReadStart: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x001C             MOVS     R4,R3
   \        0xC   0x9D06             LDR      R5,[SP, #+24]
   4081            /* Check the parameters */
   4082            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   4083            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   4084            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   4085            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   4086          
   4087            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0xE   0xF896 0x003D      LDRB     R0,[R6, #+61]
   \       0x12   0x2802             CMP      R0,#+2
   \       0x14   0xD101             BNE.N    ??HAL_TIM_DMABurst_ReadStart_0
   4088            {
   4089              return HAL_BUSY;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0xE0F0             B.N      ??HAL_TIM_DMABurst_ReadStart_1
   4090            }
   4091            else if (htim->State == HAL_TIM_STATE_READY)
   \                     ??HAL_TIM_DMABurst_ReadStart_0: (+1)
   \       0x1A   0xF896 0x003D      LDRB     R0,[R6, #+61]
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xD108             BNE.N    ??HAL_TIM_DMABurst_ReadStart_2
   4092            {
   4093              if ((BurstBuffer == NULL) && (BurstLength > 0U))
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD103             BNE.N    ??HAL_TIM_DMABurst_ReadStart_3
   \       0x26   0x2D00             CMP      R5,#+0
   \       0x28   0xD001             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_3
   4094              {
   4095                return HAL_ERROR;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE0E6             B.N      ??HAL_TIM_DMABurst_ReadStart_1
   4096              }
   4097              else
   4098              {
   4099                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_ReadStart_3: (+1)
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0xF886 0x003D      STRB     R0,[R6, #+61]
   4100              }
   4101            }
   4102            else
   4103            {
   4104              /* nothing to do */
   4105            }
   4106            switch (BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_ReadStart_2: (+1)
   \       0x34   0x4640             MOV      R0,R8
   \       0x36   0xF5B0 0x7F80      CMP      R0,#+256
   \       0x3A   0xD014             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_4
   \       0x3C   0xF5B0 0x7F00      CMP      R0,#+512
   \       0x40   0xD02C             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_5
   \       0x42   0xF5B0 0x6F80      CMP      R0,#+1024
   \       0x46   0xD044             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_6
   \       0x48   0xF5B0 0x6F00      CMP      R0,#+2048
   \       0x4C   0xD05C             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_7
   \       0x4E   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x52   0xD074             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_8
   \       0x54   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x58   0xF000 0x808C      BEQ.W    ??HAL_TIM_DMABurst_ReadStart_9
   \       0x5C   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x60   0xF000 0x80A3      BEQ.W    ??HAL_TIM_DMABurst_ReadStart_10
   \       0x64   0xE0BC             B.N      ??HAL_TIM_DMABurst_ReadStart_11
   4107            {
   4108              case TIM_DMA_UPDATE:
   4109              {
   4110                /* Set the DMA Period elapsed callbacks */
   4111                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_4: (+1)
   \       0x66   0x.... 0x....      ADR.W    R0,TIM_DMAPeriodElapsedCplt
   \       0x6A   0x6A31             LDR      R1,[R6, #+32]
   \       0x6C   0x63C8             STR      R0,[R1, #+60]
   4112                htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   \       0x6E   0x.... 0x....      ADR.W    R0,TIM_DMAPeriodElapsedHalfCplt
   \       0x72   0x6A31             LDR      R1,[R6, #+32]
   \       0x74   0x6408             STR      R0,[R1, #+64]
   4113          
   4114                /* Set the DMA error callback */
   4115                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \       0x76   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \       0x7A   0x6A31             LDR      R1,[R6, #+32]
   \       0x7C   0x64C8             STR      R0,[R1, #+76]
   4116          
   4117                /* Enable the DMA stream */
   4118                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \       0x7E   0x002B             MOVS     R3,R5
   \       0x80   0x0A1B             LSRS     R3,R3,#+8
   \       0x82   0x1C5B             ADDS     R3,R3,#+1
   \       0x84   0x0022             MOVS     R2,R4
   \       0x86   0x6830             LDR      R0,[R6, #+0]
   \       0x88   0xF110 0x014C      ADDS     R1,R0,#+76
   \       0x8C   0x6A30             LDR      R0,[R6, #+32]
   \       0x8E   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD001             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_12
   4119                {
   4120                  return HAL_ERROR;
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0xE0B0             B.N      ??HAL_TIM_DMABurst_ReadStart_1
   4121                }
   4122                break;
   \                     ??HAL_TIM_DMABurst_ReadStart_12: (+1)
   \       0x9A   0xE0A1             B.N      ??HAL_TIM_DMABurst_ReadStart_13
   4123              }
   4124              case TIM_DMA_CC1:
   4125              {
   4126                /* Set the DMA capture callbacks */
   4127                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_5: (+1)
   \       0x9C   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \       0xA0   0x6A71             LDR      R1,[R6, #+36]
   \       0xA2   0x63C8             STR      R0,[R1, #+60]
   4128                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0xA4   0x.... 0x....      ADR.W    R0,TIM_DMACaptureHalfCplt
   \       0xA8   0x6A71             LDR      R1,[R6, #+36]
   \       0xAA   0x6408             STR      R0,[R1, #+64]
   4129          
   4130                /* Set the DMA error callback */
   4131                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0xAC   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \       0xB0   0x6A71             LDR      R1,[R6, #+36]
   \       0xB2   0x64C8             STR      R0,[R1, #+76]
   4132          
   4133                /* Enable the DMA stream */
   4134                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \       0xB4   0x002B             MOVS     R3,R5
   \       0xB6   0x0A1B             LSRS     R3,R3,#+8
   \       0xB8   0x1C5B             ADDS     R3,R3,#+1
   \       0xBA   0x0022             MOVS     R2,R4
   \       0xBC   0x6830             LDR      R0,[R6, #+0]
   \       0xBE   0xF110 0x014C      ADDS     R1,R0,#+76
   \       0xC2   0x6A70             LDR      R0,[R6, #+36]
   \       0xC4   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xD001             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_14
   4135                {
   4136                  return HAL_ERROR;
   \       0xCC   0x2001             MOVS     R0,#+1
   \       0xCE   0xE095             B.N      ??HAL_TIM_DMABurst_ReadStart_1
   4137                }
   4138                break;
   \                     ??HAL_TIM_DMABurst_ReadStart_14: (+1)
   \       0xD0   0xE086             B.N      ??HAL_TIM_DMABurst_ReadStart_13
   4139              }
   4140              case TIM_DMA_CC2:
   4141              {
   4142                /* Set the DMA capture/compare callbacks */
   4143                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_6: (+1)
   \       0xD2   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \       0xD6   0x6AB1             LDR      R1,[R6, #+40]
   \       0xD8   0x63C8             STR      R0,[R1, #+60]
   4144                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0xDA   0x.... 0x....      ADR.W    R0,TIM_DMACaptureHalfCplt
   \       0xDE   0x6AB1             LDR      R1,[R6, #+40]
   \       0xE0   0x6408             STR      R0,[R1, #+64]
   4145          
   4146                /* Set the DMA error callback */
   4147                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \       0xE2   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \       0xE6   0x6AB1             LDR      R1,[R6, #+40]
   \       0xE8   0x64C8             STR      R0,[R1, #+76]
   4148          
   4149                /* Enable the DMA stream */
   4150                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \       0xEA   0x002B             MOVS     R3,R5
   \       0xEC   0x0A1B             LSRS     R3,R3,#+8
   \       0xEE   0x1C5B             ADDS     R3,R3,#+1
   \       0xF0   0x0022             MOVS     R2,R4
   \       0xF2   0x6830             LDR      R0,[R6, #+0]
   \       0xF4   0xF110 0x014C      ADDS     R1,R0,#+76
   \       0xF8   0x6AB0             LDR      R0,[R6, #+40]
   \       0xFA   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xD001             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_15
   4151                {
   4152                  return HAL_ERROR;
   \      0x102   0x2001             MOVS     R0,#+1
   \      0x104   0xE07A             B.N      ??HAL_TIM_DMABurst_ReadStart_1
   4153                }
   4154                break;
   \                     ??HAL_TIM_DMABurst_ReadStart_15: (+1)
   \      0x106   0xE06B             B.N      ??HAL_TIM_DMABurst_ReadStart_13
   4155              }
   4156              case TIM_DMA_CC3:
   4157              {
   4158                /* Set the DMA capture callbacks */
   4159                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_7: (+1)
   \      0x108   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \      0x10C   0x6AF1             LDR      R1,[R6, #+44]
   \      0x10E   0x63C8             STR      R0,[R1, #+60]
   4160                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \      0x110   0x.... 0x....      ADR.W    R0,TIM_DMACaptureHalfCplt
   \      0x114   0x6AF1             LDR      R1,[R6, #+44]
   \      0x116   0x6408             STR      R0,[R1, #+64]
   4161          
   4162                /* Set the DMA error callback */
   4163                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \      0x118   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \      0x11C   0x6AF1             LDR      R1,[R6, #+44]
   \      0x11E   0x64C8             STR      R0,[R1, #+76]
   4164          
   4165                /* Enable the DMA stream */
   4166                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \      0x120   0x002B             MOVS     R3,R5
   \      0x122   0x0A1B             LSRS     R3,R3,#+8
   \      0x124   0x1C5B             ADDS     R3,R3,#+1
   \      0x126   0x0022             MOVS     R2,R4
   \      0x128   0x6830             LDR      R0,[R6, #+0]
   \      0x12A   0xF110 0x014C      ADDS     R1,R0,#+76
   \      0x12E   0x6AF0             LDR      R0,[R6, #+44]
   \      0x130   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x134   0x2800             CMP      R0,#+0
   \      0x136   0xD001             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_16
   4167                {
   4168                  return HAL_ERROR;
   \      0x138   0x2001             MOVS     R0,#+1
   \      0x13A   0xE05F             B.N      ??HAL_TIM_DMABurst_ReadStart_1
   4169                }
   4170                break;
   \                     ??HAL_TIM_DMABurst_ReadStart_16: (+1)
   \      0x13C   0xE050             B.N      ??HAL_TIM_DMABurst_ReadStart_13
   4171              }
   4172              case TIM_DMA_CC4:
   4173              {
   4174                /* Set the DMA capture callbacks */
   4175                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_8: (+1)
   \      0x13E   0x.... 0x....      ADR.W    R0,TIM_DMACaptureCplt
   \      0x142   0x6B31             LDR      R1,[R6, #+48]
   \      0x144   0x63C8             STR      R0,[R1, #+60]
   4176                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \      0x146   0x.... 0x....      ADR.W    R0,TIM_DMACaptureHalfCplt
   \      0x14A   0x6B31             LDR      R1,[R6, #+48]
   \      0x14C   0x6408             STR      R0,[R1, #+64]
   4177          
   4178                /* Set the DMA error callback */
   4179                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \      0x14E   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \      0x152   0x6B31             LDR      R1,[R6, #+48]
   \      0x154   0x64C8             STR      R0,[R1, #+76]
   4180          
   4181                /* Enable the DMA stream */
   4182                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \      0x156   0x002B             MOVS     R3,R5
   \      0x158   0x0A1B             LSRS     R3,R3,#+8
   \      0x15A   0x1C5B             ADDS     R3,R3,#+1
   \      0x15C   0x0022             MOVS     R2,R4
   \      0x15E   0x6830             LDR      R0,[R6, #+0]
   \      0x160   0xF110 0x014C      ADDS     R1,R0,#+76
   \      0x164   0x6B30             LDR      R0,[R6, #+48]
   \      0x166   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x16A   0x2800             CMP      R0,#+0
   \      0x16C   0xD001             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_17
   4183                {
   4184                  return HAL_ERROR;
   \      0x16E   0x2001             MOVS     R0,#+1
   \      0x170   0xE044             B.N      ??HAL_TIM_DMABurst_ReadStart_1
   4185                }
   4186                break;
   \                     ??HAL_TIM_DMABurst_ReadStart_17: (+1)
   \      0x172   0xE035             B.N      ??HAL_TIM_DMABurst_ReadStart_13
   4187              }
   4188              case TIM_DMA_COM:
   4189              {
   4190                /* Set the DMA commutation callbacks */
   4191                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_9: (+1)
   \      0x174   0x.... 0x....      LDR.W    R0,??DataTable27
   \      0x178   0x6B71             LDR      R1,[R6, #+52]
   \      0x17A   0x63C8             STR      R0,[R1, #+60]
   4192                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
   \      0x17C   0x.... 0x....      LDR.W    R0,??DataTable28
   \      0x180   0x6B71             LDR      R1,[R6, #+52]
   \      0x182   0x6408             STR      R0,[R1, #+64]
   4193          
   4194                /* Set the DMA error callback */
   4195                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   \      0x184   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \      0x188   0x6B71             LDR      R1,[R6, #+52]
   \      0x18A   0x64C8             STR      R0,[R1, #+76]
   4196          
   4197                /* Enable the DMA stream */
   4198                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \      0x18C   0x002B             MOVS     R3,R5
   \      0x18E   0x0A1B             LSRS     R3,R3,#+8
   \      0x190   0x1C5B             ADDS     R3,R3,#+1
   \      0x192   0x0022             MOVS     R2,R4
   \      0x194   0x6830             LDR      R0,[R6, #+0]
   \      0x196   0xF110 0x014C      ADDS     R1,R0,#+76
   \      0x19A   0x6B70             LDR      R0,[R6, #+52]
   \      0x19C   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x1A0   0x2800             CMP      R0,#+0
   \      0x1A2   0xD001             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_18
   4199                {
   4200                  return HAL_ERROR;
   \      0x1A4   0x2001             MOVS     R0,#+1
   \      0x1A6   0xE029             B.N      ??HAL_TIM_DMABurst_ReadStart_1
   4201                }
   4202                break;
   \                     ??HAL_TIM_DMABurst_ReadStart_18: (+1)
   \      0x1A8   0xE01A             B.N      ??HAL_TIM_DMABurst_ReadStart_13
   4203              }
   4204              case TIM_DMA_TRIGGER:
   4205              {
   4206                /* Set the DMA trigger callbacks */
   4207                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_10: (+1)
   \      0x1AA   0x.... 0x....      ADR.W    R0,TIM_DMATriggerCplt
   \      0x1AE   0x6BB1             LDR      R1,[R6, #+56]
   \      0x1B0   0x63C8             STR      R0,[R1, #+60]
   4208                htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
   \      0x1B2   0x.... 0x....      ADR.W    R0,TIM_DMATriggerHalfCplt
   \      0x1B6   0x6BB1             LDR      R1,[R6, #+56]
   \      0x1B8   0x6408             STR      R0,[R1, #+64]
   4209          
   4210                /* Set the DMA error callback */
   4211                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   \      0x1BA   0x.... 0x....      ADR.W    R0,TIM_DMAError
   \      0x1BE   0x6BB1             LDR      R1,[R6, #+56]
   \      0x1C0   0x64C8             STR      R0,[R1, #+76]
   4212          
   4213                /* Enable the DMA stream */
   4214                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \      0x1C2   0x002B             MOVS     R3,R5
   \      0x1C4   0x0A1B             LSRS     R3,R3,#+8
   \      0x1C6   0x1C5B             ADDS     R3,R3,#+1
   \      0x1C8   0x0022             MOVS     R2,R4
   \      0x1CA   0x6830             LDR      R0,[R6, #+0]
   \      0x1CC   0xF110 0x014C      ADDS     R1,R0,#+76
   \      0x1D0   0x6BB0             LDR      R0,[R6, #+56]
   \      0x1D2   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x1D6   0x2800             CMP      R0,#+0
   \      0x1D8   0xD001             BEQ.N    ??HAL_TIM_DMABurst_ReadStart_19
   4215                {
   4216                  return HAL_ERROR;
   \      0x1DA   0x2001             MOVS     R0,#+1
   \      0x1DC   0xE00E             B.N      ??HAL_TIM_DMABurst_ReadStart_1
   4217                }
   4218                break;
   \                     ??HAL_TIM_DMABurst_ReadStart_19: (+1)
   \      0x1DE   0xE7FF             B.N      ??HAL_TIM_DMABurst_ReadStart_13
   4219              }
   4220              default:
   4221                break;
   4222            }
   4223          
   4224            /* configure the DMA Burst Mode */
   4225            htim->Instance->DCR = (BurstBaseAddress | BurstLength);
   \                     ??HAL_TIM_DMABurst_ReadStart_11: (+1)
   \                     ??HAL_TIM_DMABurst_ReadStart_13: (+1)
   \      0x1E0   0xEA55 0x0007      ORRS     R0,R5,R7
   \      0x1E4   0x6831             LDR      R1,[R6, #+0]
   \      0x1E6   0x6488             STR      R0,[R1, #+72]
   4226          
   4227            /* Enable the TIM DMA Request */
   4228            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   \      0x1E8   0x6830             LDR      R0,[R6, #+0]
   \      0x1EA   0x68C0             LDR      R0,[R0, #+12]
   \      0x1EC   0xEA58 0x0000      ORRS     R0,R8,R0
   \      0x1F0   0x6831             LDR      R1,[R6, #+0]
   \      0x1F2   0x60C8             STR      R0,[R1, #+12]
   4229          
   4230            htim->State = HAL_TIM_STATE_READY;
   \      0x1F4   0x2001             MOVS     R0,#+1
   \      0x1F6   0xF886 0x003D      STRB     R0,[R6, #+61]
   4231          
   4232            /* Return function status */
   4233            return HAL_OK;
   \      0x1FA   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_DMABurst_ReadStart_1: (+1)
   \      0x1FC   0xE8BD 0x81F0      POP      {R4-R8,PC}
   4234          }
   4235          
   4236          /**
   4237            * @brief  Stop the DMA burst reading
   4238            * @param  htim TIM handle
   4239            * @param  BurstRequestSrc TIM DMA Request sources to disable.
   4240            * @retval HAL status
   4241            */

   \                                 In section .text, align 2, keep-with-next
   4242          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   4243          {
   \                     HAL_TIM_DMABurst_ReadStop: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   4244            HAL_StatusTypeDef status = HAL_OK;
   \        0x6   0x2600             MOVS     R6,#+0
   4245            /* Check the parameters */
   4246            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   4247          
   4248            /* Abort the DMA transfer (at least disable the DMA stream) */
   4249            switch (BurstRequestSrc)
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0xF5B0 0x7F80      CMP      R0,#+256
   \        0xE   0xD012             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_0
   \       0x10   0xF5B0 0x7F00      CMP      R0,#+512
   \       0x14   0xD014             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_1
   \       0x16   0xF5B0 0x6F80      CMP      R0,#+1024
   \       0x1A   0xD016             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_2
   \       0x1C   0xF5B0 0x6F00      CMP      R0,#+2048
   \       0x20   0xD018             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_3
   \       0x22   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x26   0xD01A             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_4
   \       0x28   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x2C   0xD01C             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_5
   \       0x2E   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x32   0xD01E             BEQ.N    ??HAL_TIM_DMABurst_ReadStop_6
   \       0x34   0xE022             B.N      ??HAL_TIM_DMABurst_ReadStop_7
   4250            {
   4251              case TIM_DMA_UPDATE:
   4252              {
   4253                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_ReadStop_0: (+1)
   \       0x36   0x6A20             LDR      R0,[R4, #+32]
   \       0x38   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x3C   0x0006             MOVS     R6,R0
   4254                break;
   \       0x3E   0xE01D             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   4255              }
   4256              case TIM_DMA_CC1:
   4257              {
   4258                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_ReadStop_1: (+1)
   \       0x40   0x6A60             LDR      R0,[R4, #+36]
   \       0x42   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x46   0x0006             MOVS     R6,R0
   4259                break;
   \       0x48   0xE018             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   4260              }
   4261              case TIM_DMA_CC2:
   4262              {
   4263                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_ReadStop_2: (+1)
   \       0x4A   0x6AA0             LDR      R0,[R4, #+40]
   \       0x4C   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x50   0x0006             MOVS     R6,R0
   4264                break;
   \       0x52   0xE013             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   4265              }
   4266              case TIM_DMA_CC3:
   4267              {
   4268                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_ReadStop_3: (+1)
   \       0x54   0x6AE0             LDR      R0,[R4, #+44]
   \       0x56   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x5A   0x0006             MOVS     R6,R0
   4269                break;
   \       0x5C   0xE00E             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   4270              }
   4271              case TIM_DMA_CC4:
   4272              {
   4273                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_ReadStop_4: (+1)
   \       0x5E   0x6B20             LDR      R0,[R4, #+48]
   \       0x60   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x64   0x0006             MOVS     R6,R0
   4274                break;
   \       0x66   0xE009             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   4275              }
   4276              case TIM_DMA_COM:
   4277              {
   4278                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??HAL_TIM_DMABurst_ReadStop_5: (+1)
   \       0x68   0x6B60             LDR      R0,[R4, #+52]
   \       0x6A   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x6E   0x0006             MOVS     R6,R0
   4279                break;
   \       0x70   0xE004             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   4280              }
   4281              case TIM_DMA_TRIGGER:
   4282              {
   4283                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_ReadStop_6: (+1)
   \       0x72   0x6BA0             LDR      R0,[R4, #+56]
   \       0x74   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x78   0x0006             MOVS     R6,R0
   4284                break;
   \       0x7A   0xE7FF             B.N      ??HAL_TIM_DMABurst_ReadStop_8
   4285              }
   4286              default:
   4287                break;
   4288            }
   4289          
   4290            if (HAL_OK == status)
   \                     ??HAL_TIM_DMABurst_ReadStop_7: (+1)
   \                     ??HAL_TIM_DMABurst_ReadStop_8: (+1)
   \       0x7C   0x0030             MOVS     R0,R6
   \       0x7E   0xB2C0             UXTB     R0,R0
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD104             BNE.N    ??HAL_TIM_DMABurst_ReadStop_9
   4291            {
   4292              /* Disable the TIM Update DMA request */
   4293              __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \       0x84   0x6820             LDR      R0,[R4, #+0]
   \       0x86   0x68C0             LDR      R0,[R0, #+12]
   \       0x88   0x43A8             BICS     R0,R0,R5
   \       0x8A   0x6821             LDR      R1,[R4, #+0]
   \       0x8C   0x60C8             STR      R0,[R1, #+12]
   4294            }
   4295          
   4296            /* Return function status */
   4297            return status;
   \                     ??HAL_TIM_DMABurst_ReadStop_9: (+1)
   \       0x8E   0x0030             MOVS     R0,R6
   \       0x90   0xB2C0             UXTB     R0,R0
   \       0x92   0xBD70             POP      {R4-R6,PC}
   4298          }
   4299          
   4300          /**
   4301            * @brief  Generate a software event
   4302            * @param  htim TIM handle
   4303            * @param  EventSource specifies the event source.
   4304            *          This parameter can be one of the following values:
   4305            *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
   4306            *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
   4307            *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
   4308            *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
   4309            *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
   4310            *            @arg TIM_EVENTSOURCE_COM: Timer COM event source
   4311            *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
   4312            *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source
   4313            * @note   Basic timers can only generate an update event.
   4314            * @note   TIM_EVENTSOURCE_COM is relevant only with advanced timer instances.
   4315            * @note   TIM_EVENTSOURCE_BREAK are relevant only for timer instances
   4316            *         supporting a break input.
   4317            * @retval HAL status
   4318            */
   4319          

   \                                 In section .text, align 2, keep-with-next
   4320          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   4321          {
   \                     HAL_TIM_GenerateEvent: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   4322            /* Check the parameters */
   4323            assert_param(IS_TIM_INSTANCE(htim->Instance));
   4324            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   4325          
   4326            /* Process Locked */
   4327            __HAL_LOCK(htim);
   \        0x2   0xF892 0x003C      LDRB     R0,[R2, #+60]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD101             BNE.N    ??HAL_TIM_GenerateEvent_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xE00E             B.N      ??HAL_TIM_GenerateEvent_1
   \                     ??HAL_TIM_GenerateEvent_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF882 0x003C      STRB     R0,[R2, #+60]
   4328          
   4329            /* Change the TIM state */
   4330            htim->State = HAL_TIM_STATE_BUSY;
   \       0x14   0x2002             MOVS     R0,#+2
   \       0x16   0xF882 0x003D      STRB     R0,[R2, #+61]
   4331          
   4332            /* Set the event sources */
   4333            htim->Instance->EGR = EventSource;
   \       0x1A   0x6810             LDR      R0,[R2, #+0]
   \       0x1C   0x6141             STR      R1,[R0, #+20]
   4334          
   4335            /* Change the TIM state */
   4336            htim->State = HAL_TIM_STATE_READY;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xF882 0x003D      STRB     R0,[R2, #+61]
   4337          
   4338            __HAL_UNLOCK(htim);
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xF882 0x003C      STRB     R0,[R2, #+60]
   4339          
   4340            /* Return function status */
   4341            return HAL_OK;
   \       0x2A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_GenerateEvent_1: (+1)
   \       0x2C   0x4770             BX       LR
   4342          }
   4343          
   4344          /**
   4345            * @brief  Configures the OCRef clear feature
   4346            * @param  htim TIM handle
   4347            * @param  sClearInputConfig pointer to a TIM_ClearInputConfigTypeDef structure that
   4348            *         contains the OCREF clear feature and parameters for the TIM peripheral.
   4349            * @param  Channel specifies the TIM Channel
   4350            *          This parameter can be one of the following values:
   4351            *            @arg TIM_CHANNEL_1: TIM Channel 1
   4352            *            @arg TIM_CHANNEL_2: TIM Channel 2
   4353            *            @arg TIM_CHANNEL_3: TIM Channel 3
   4354            *            @arg TIM_CHANNEL_4: TIM Channel 4
   4355            * @retval HAL status
   4356            */

   \                                 In section .text, align 2, keep-with-next
   4357          HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim,
   4358                                                     TIM_ClearInputConfigTypeDef *sClearInputConfig,
   4359                                                     uint32_t Channel)
   4360          {
   \                     HAL_TIM_ConfigOCrefClear: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   4361            /* Check the parameters */
   4362            assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
   4363            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   4364          
   4365            /* Process Locked */
   4366            __HAL_LOCK(htim);
   \        0x8   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE.N    ??HAL_TIM_ConfigOCrefClear_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE079             B.N      ??HAL_TIM_ConfigOCrefClear_1
   \                     ??HAL_TIM_ConfigOCrefClear_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xF884 0x003C      STRB     R0,[R4, #+60]
   4367          
   4368            htim->State = HAL_TIM_STATE_BUSY;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0xF884 0x003D      STRB     R0,[R4, #+61]
   4369          
   4370            switch (sClearInputConfig->ClearInputSource)
   \       0x20   0x6868             LDR      R0,[R5, #+4]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD002             BEQ.N    ??HAL_TIM_ConfigOCrefClear_2
   \       0x26   0x2801             CMP      R0,#+1
   \       0x28   0xD007             BEQ.N    ??HAL_TIM_ConfigOCrefClear_3
   \       0x2A   0xE018             B.N      ??HAL_TIM_ConfigOCrefClear_4
   4371            {
   4372              case TIM_CLEARINPUTSOURCE_NONE:
   4373              {
   4374                /* Clear the OCREF clear selection bit and the the ETR Bits */
   4375                CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
   \                     ??HAL_TIM_ConfigOCrefClear_2: (+1)
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6880             LDR      R0,[R0, #+8]
   \       0x30   0xF430 0x407F      BICS     R0,R0,#0xFF00
   \       0x34   0x6821             LDR      R1,[R4, #+0]
   \       0x36   0x6088             STR      R0,[R1, #+8]
   4376                break;
   \       0x38   0xE011             B.N      ??HAL_TIM_ConfigOCrefClear_5
   4377              }
   4378          
   4379              case TIM_CLEARINPUTSOURCE_ETR:
   4380              {
   4381                /* Check the parameters */
   4382                assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   4383                assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   4384                assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   4385          
   4386                /* When OCRef clear feature is used with ETR source, ETR prescaler must be off */
   4387                if (sClearInputConfig->ClearInputPrescaler != TIM_CLEARINPUTPRESCALER_DIV1)
   \                     ??HAL_TIM_ConfigOCrefClear_3: (+1)
   \       0x3A   0x68E8             LDR      R0,[R5, #+12]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD007             BEQ.N    ??HAL_TIM_ConfigOCrefClear_6
   4388                {
   4389                  htim->State = HAL_TIM_STATE_READY;
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0xF884 0x003D      STRB     R0,[R4, #+61]
   4390                  __HAL_UNLOCK(htim);
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0xF884 0x003C      STRB     R0,[R4, #+60]
   4391                  return HAL_ERROR;
   \       0x4C   0x2001             MOVS     R0,#+1
   \       0x4E   0xE05B             B.N      ??HAL_TIM_ConfigOCrefClear_1
   4392                }
   4393          
   4394                TIM_ETR_SetConfig(htim->Instance,
   4395                                  sClearInputConfig->ClearInputPrescaler,
   4396                                  sClearInputConfig->ClearInputPolarity,
   4397                                  sClearInputConfig->ClearInputFilter);
   \                     ??HAL_TIM_ConfigOCrefClear_6: (+1)
   \       0x50   0x692B             LDR      R3,[R5, #+16]
   \       0x52   0x68AA             LDR      R2,[R5, #+8]
   \       0x54   0x68E9             LDR      R1,[R5, #+12]
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x.... 0x....      BL       TIM_ETR_SetConfig
   4398                break;
   \       0x5C   0xE7FF             B.N      ??HAL_TIM_ConfigOCrefClear_5
   4399              }
   4400          
   4401              default:
   4402                break;
   4403            }
   4404          
   4405            switch (Channel)
   \                     ??HAL_TIM_ConfigOCrefClear_4: (+1)
   \                     ??HAL_TIM_ConfigOCrefClear_5: (+1)
   \       0x5E   0x0030             MOVS     R0,R6
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_7
   \       0x64   0x2804             CMP      R0,#+4
   \       0x66   0xD015             BEQ.N    ??HAL_TIM_ConfigOCrefClear_8
   \       0x68   0x2808             CMP      R0,#+8
   \       0x6A   0xD024             BEQ.N    ??HAL_TIM_ConfigOCrefClear_9
   \       0x6C   0x280C             CMP      R0,#+12
   \       0x6E   0xD033             BEQ.N    ??HAL_TIM_ConfigOCrefClear_10
   \       0x70   0xE043             B.N      ??HAL_TIM_ConfigOCrefClear_11
   4406            {
   4407              case TIM_CHANNEL_1:
   4408              {
   4409                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_7: (+1)
   \       0x72   0x6828             LDR      R0,[R5, #+0]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_12
   4410                {
   4411                  /* Enable the OCREF clear feature for Channel 1 */
   4412                  SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
   \       0x78   0x6820             LDR      R0,[R4, #+0]
   \       0x7A   0x6980             LDR      R0,[R0, #+24]
   \       0x7C   0xF050 0x0080      ORRS     R0,R0,#0x80
   \       0x80   0x6821             LDR      R1,[R4, #+0]
   \       0x82   0x6188             STR      R0,[R1, #+24]
   \       0x84   0xE005             B.N      ??HAL_TIM_ConfigOCrefClear_13
   4413                }
   4414                else
   4415                {
   4416                  /* Disable the OCREF clear feature for Channel 1 */
   4417                  CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
   \                     ??HAL_TIM_ConfigOCrefClear_12: (+1)
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x6980             LDR      R0,[R0, #+24]
   \       0x8A   0xF030 0x0080      BICS     R0,R0,#0x80
   \       0x8E   0x6821             LDR      R1,[R4, #+0]
   \       0x90   0x6188             STR      R0,[R1, #+24]
   4418                }
   4419                break;
   \                     ??HAL_TIM_ConfigOCrefClear_13: (+1)
   \       0x92   0xE032             B.N      ??HAL_TIM_ConfigOCrefClear_14
   4420              }
   4421              case TIM_CHANNEL_2:
   4422              {
   4423                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_8: (+1)
   \       0x94   0x6828             LDR      R0,[R5, #+0]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_15
   4424                {
   4425                  /* Enable the OCREF clear feature for Channel 2 */
   4426                  SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0x6980             LDR      R0,[R0, #+24]
   \       0x9E   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0xA2   0x6821             LDR      R1,[R4, #+0]
   \       0xA4   0x6188             STR      R0,[R1, #+24]
   \       0xA6   0xE005             B.N      ??HAL_TIM_ConfigOCrefClear_16
   4427                }
   4428                else
   4429                {
   4430                  /* Disable the OCREF clear feature for Channel 2 */
   4431                  CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
   \                     ??HAL_TIM_ConfigOCrefClear_15: (+1)
   \       0xA8   0x6820             LDR      R0,[R4, #+0]
   \       0xAA   0x6980             LDR      R0,[R0, #+24]
   \       0xAC   0xF430 0x4000      BICS     R0,R0,#0x8000
   \       0xB0   0x6821             LDR      R1,[R4, #+0]
   \       0xB2   0x6188             STR      R0,[R1, #+24]
   4432                }
   4433                break;
   \                     ??HAL_TIM_ConfigOCrefClear_16: (+1)
   \       0xB4   0xE021             B.N      ??HAL_TIM_ConfigOCrefClear_14
   4434              }
   4435              case TIM_CHANNEL_3:
   4436              {
   4437                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_9: (+1)
   \       0xB6   0x6828             LDR      R0,[R5, #+0]
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_17
   4438                {
   4439                  /* Enable the OCREF clear feature for Channel 3 */
   4440                  SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
   \       0xBC   0x6820             LDR      R0,[R4, #+0]
   \       0xBE   0x69C0             LDR      R0,[R0, #+28]
   \       0xC0   0xF050 0x0080      ORRS     R0,R0,#0x80
   \       0xC4   0x6821             LDR      R1,[R4, #+0]
   \       0xC6   0x61C8             STR      R0,[R1, #+28]
   \       0xC8   0xE005             B.N      ??HAL_TIM_ConfigOCrefClear_18
   4441                }
   4442                else
   4443                {
   4444                  /* Disable the OCREF clear feature for Channel 3 */
   4445                  CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
   \                     ??HAL_TIM_ConfigOCrefClear_17: (+1)
   \       0xCA   0x6820             LDR      R0,[R4, #+0]
   \       0xCC   0x69C0             LDR      R0,[R0, #+28]
   \       0xCE   0xF030 0x0080      BICS     R0,R0,#0x80
   \       0xD2   0x6821             LDR      R1,[R4, #+0]
   \       0xD4   0x61C8             STR      R0,[R1, #+28]
   4446                }
   4447                break;
   \                     ??HAL_TIM_ConfigOCrefClear_18: (+1)
   \       0xD6   0xE010             B.N      ??HAL_TIM_ConfigOCrefClear_14
   4448              }
   4449              case TIM_CHANNEL_4:
   4450              {
   4451                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_10: (+1)
   \       0xD8   0x6828             LDR      R0,[R5, #+0]
   \       0xDA   0x2800             CMP      R0,#+0
   \       0xDC   0xD006             BEQ.N    ??HAL_TIM_ConfigOCrefClear_19
   4452                {
   4453                  /* Enable the OCREF clear feature for Channel 4 */
   4454                  SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
   \       0xDE   0x6820             LDR      R0,[R4, #+0]
   \       0xE0   0x69C0             LDR      R0,[R0, #+28]
   \       0xE2   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0xE6   0x6821             LDR      R1,[R4, #+0]
   \       0xE8   0x61C8             STR      R0,[R1, #+28]
   \       0xEA   0xE005             B.N      ??HAL_TIM_ConfigOCrefClear_20
   4455                }
   4456                else
   4457                {
   4458                  /* Disable the OCREF clear feature for Channel 4 */
   4459                  CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
   \                     ??HAL_TIM_ConfigOCrefClear_19: (+1)
   \       0xEC   0x6820             LDR      R0,[R4, #+0]
   \       0xEE   0x69C0             LDR      R0,[R0, #+28]
   \       0xF0   0xF430 0x4000      BICS     R0,R0,#0x8000
   \       0xF4   0x6821             LDR      R1,[R4, #+0]
   \       0xF6   0x61C8             STR      R0,[R1, #+28]
   4460                }
   4461                break;
   \                     ??HAL_TIM_ConfigOCrefClear_20: (+1)
   \       0xF8   0xE7FF             B.N      ??HAL_TIM_ConfigOCrefClear_14
   4462              }
   4463              default:
   4464                break;
   4465            }
   4466          
   4467            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigOCrefClear_11: (+1)
   \                     ??HAL_TIM_ConfigOCrefClear_14: (+1)
   \       0xFA   0x2001             MOVS     R0,#+1
   \       0xFC   0xF884 0x003D      STRB     R0,[R4, #+61]
   4468          
   4469            __HAL_UNLOCK(htim);
   \      0x100   0x2000             MOVS     R0,#+0
   \      0x102   0xF884 0x003C      STRB     R0,[R4, #+60]
   4470          
   4471            return HAL_OK;
   \      0x106   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_ConfigOCrefClear_1: (+1)
   \      0x108   0xBD70             POP      {R4-R6,PC}
   4472          }
   4473          
   4474          /**
   4475            * @brief   Configures the clock source to be used
   4476            * @param  htim TIM handle
   4477            * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
   4478            *         contains the clock source information for the TIM peripheral.
   4479            * @retval HAL status
   4480            */

   \                                 In section .text, align 2, keep-with-next
   4481          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
   4482          {
   \                     HAL_TIM_ConfigClockSource: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   4483            uint32_t tmpsmcr;
   4484          
   4485            /* Process Locked */
   4486            __HAL_LOCK(htim);
   \        0x6   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE.N    ??HAL_TIM_ConfigClockSource_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE06B             B.N      ??HAL_TIM_ConfigClockSource_1
   \                     ??HAL_TIM_ConfigClockSource_0: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xF884 0x003C      STRB     R0,[R4, #+60]
   4487          
   4488            htim->State = HAL_TIM_STATE_BUSY;
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0xF884 0x003D      STRB     R0,[R4, #+61]
   4489          
   4490            /* Check the parameters */
   4491            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   4492          
   4493            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   4494            tmpsmcr = htim->Instance->SMCR;
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6886             LDR      R6,[R0, #+8]
   4495            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   \       0x22   0xF036 0x0677      BICS     R6,R6,#0x77
   4496            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   \       0x26   0xF436 0x467F      BICS     R6,R6,#0xFF00
   4497            htim->Instance->SMCR = tmpsmcr;
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x6086             STR      R6,[R0, #+8]
   4498          
   4499            switch (sClockSourceConfig->ClockSource)
   \       0x2E   0x6828             LDR      R0,[R5, #+0]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD04E             BEQ.N    ??HAL_TIM_ConfigClockSource_2
   \       0x34   0x2810             CMP      R0,#+16
   \       0x36   0xD04C             BEQ.N    ??HAL_TIM_ConfigClockSource_2
   \       0x38   0x2820             CMP      R0,#+32
   \       0x3A   0xD04A             BEQ.N    ??HAL_TIM_ConfigClockSource_2
   \       0x3C   0x2830             CMP      R0,#+48
   \       0x3E   0xD048             BEQ.N    ??HAL_TIM_ConfigClockSource_2
   \       0x40   0x2840             CMP      R0,#+64
   \       0x42   0xD03C             BEQ.N    ??HAL_TIM_ConfigClockSource_3
   \       0x44   0x2850             CMP      R0,#+80
   \       0x46   0xD026             BEQ.N    ??HAL_TIM_ConfigClockSource_4
   \       0x48   0x2860             CMP      R0,#+96
   \       0x4A   0xD02E             BEQ.N    ??HAL_TIM_ConfigClockSource_5
   \       0x4C   0x2870             CMP      R0,#+112
   \       0x4E   0xD007             BEQ.N    ??HAL_TIM_ConfigClockSource_6
   \       0x50   0xF5B0 0x5F80      CMP      R0,#+4096
   \       0x54   0xD003             BEQ.N    ??HAL_TIM_ConfigClockSource_7
   \       0x56   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x5A   0xD00F             BEQ.N    ??HAL_TIM_ConfigClockSource_8
   \       0x5C   0xE03E             B.N      ??HAL_TIM_ConfigClockSource_9
   4500            {
   4501              case TIM_CLOCKSOURCE_INTERNAL:
   4502              {
   4503                assert_param(IS_TIM_INSTANCE(htim->Instance));
   4504                break;
   \                     ??HAL_TIM_ConfigClockSource_7: (+1)
   \       0x5E   0xE03D             B.N      ??HAL_TIM_ConfigClockSource_10
   4505              }
   4506          
   4507              case TIM_CLOCKSOURCE_ETRMODE1:
   4508              {
   4509                /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
   4510                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   4511          
   4512                /* Check ETR input conditioning related parameters */
   4513                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   4514                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4515                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4516          
   4517                /* Configure the ETR Clock source */
   4518                TIM_ETR_SetConfig(htim->Instance,
   4519                                  sClockSourceConfig->ClockPrescaler,
   4520                                  sClockSourceConfig->ClockPolarity,
   4521                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_6: (+1)
   \       0x60   0x68EB             LDR      R3,[R5, #+12]
   \       0x62   0x686A             LDR      R2,[R5, #+4]
   \       0x64   0x68A9             LDR      R1,[R5, #+8]
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x.... 0x....      BL       TIM_ETR_SetConfig
   4522          
   4523                /* Select the External clock mode1 and the ETRF trigger */
   4524                tmpsmcr = htim->Instance->SMCR;
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x6880             LDR      R0,[R0, #+8]
   4525                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   \       0x70   0xF050 0x0077      ORRS     R0,R0,#0x77
   \       0x74   0x0006             MOVS     R6,R0
   4526                /* Write to TIMx SMCR */
   4527                htim->Instance->SMCR = tmpsmcr;
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x6086             STR      R6,[R0, #+8]
   4528                break;
   \       0x7A   0xE02F             B.N      ??HAL_TIM_ConfigClockSource_10
   4529              }
   4530          
   4531              case TIM_CLOCKSOURCE_ETRMODE2:
   4532              {
   4533                /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
   4534                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
   4535          
   4536                /* Check ETR input conditioning related parameters */
   4537                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   4538                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4539                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4540          
   4541                /* Configure the ETR Clock source */
   4542                TIM_ETR_SetConfig(htim->Instance,
   4543                                  sClockSourceConfig->ClockPrescaler,
   4544                                  sClockSourceConfig->ClockPolarity,
   4545                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_8: (+1)
   \       0x7C   0x68EB             LDR      R3,[R5, #+12]
   \       0x7E   0x686A             LDR      R2,[R5, #+4]
   \       0x80   0x68A9             LDR      R1,[R5, #+8]
   \       0x82   0x6820             LDR      R0,[R4, #+0]
   \       0x84   0x.... 0x....      BL       TIM_ETR_SetConfig
   4546                /* Enable the External clock mode2 */
   4547                htim->Instance->SMCR |= TIM_SMCR_ECE;
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6880             LDR      R0,[R0, #+8]
   \       0x8C   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \       0x90   0x6821             LDR      R1,[R4, #+0]
   \       0x92   0x6088             STR      R0,[R1, #+8]
   4548                break;
   \       0x94   0xE022             B.N      ??HAL_TIM_ConfigClockSource_10
   4549              }
   4550          
   4551              case TIM_CLOCKSOURCE_TI1:
   4552              {
   4553                /* Check whether or not the timer instance supports external clock mode 1 */
   4554                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4555          
   4556                /* Check TI1 input conditioning related parameters */
   4557                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4558                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4559          
   4560                TIM_TI1_ConfigInputStage(htim->Instance,
   4561                                         sClockSourceConfig->ClockPolarity,
   4562                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_4: (+1)
   \       0x96   0x68EA             LDR      R2,[R5, #+12]
   \       0x98   0x6869             LDR      R1,[R5, #+4]
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   4563                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   \       0xA0   0x2150             MOVS     R1,#+80
   \       0xA2   0x6820             LDR      R0,[R4, #+0]
   \       0xA4   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4564                break;
   \       0xA8   0xE018             B.N      ??HAL_TIM_ConfigClockSource_10
   4565              }
   4566          
   4567              case TIM_CLOCKSOURCE_TI2:
   4568              {
   4569                /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
   4570                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4571          
   4572                /* Check TI2 input conditioning related parameters */
   4573                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4574                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4575          
   4576                TIM_TI2_ConfigInputStage(htim->Instance,
   4577                                         sClockSourceConfig->ClockPolarity,
   4578                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_5: (+1)
   \       0xAA   0x68EA             LDR      R2,[R5, #+12]
   \       0xAC   0x6869             LDR      R1,[R5, #+4]
   \       0xAE   0x6820             LDR      R0,[R4, #+0]
   \       0xB0   0x.... 0x....      BL       TIM_TI2_ConfigInputStage
   4579                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   \       0xB4   0x2160             MOVS     R1,#+96
   \       0xB6   0x6820             LDR      R0,[R4, #+0]
   \       0xB8   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4580                break;
   \       0xBC   0xE00E             B.N      ??HAL_TIM_ConfigClockSource_10
   4581              }
   4582          
   4583              case TIM_CLOCKSOURCE_TI1ED:
   4584              {
   4585                /* Check whether or not the timer instance supports external clock mode 1 */
   4586                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4587          
   4588                /* Check TI1 input conditioning related parameters */
   4589                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4590                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4591          
   4592                TIM_TI1_ConfigInputStage(htim->Instance,
   4593                                         sClockSourceConfig->ClockPolarity,
   4594                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_3: (+1)
   \       0xBE   0x68EA             LDR      R2,[R5, #+12]
   \       0xC0   0x6869             LDR      R1,[R5, #+4]
   \       0xC2   0x6820             LDR      R0,[R4, #+0]
   \       0xC4   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   4595                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   \       0xC8   0x2140             MOVS     R1,#+64
   \       0xCA   0x6820             LDR      R0,[R4, #+0]
   \       0xCC   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4596                break;
   \       0xD0   0xE004             B.N      ??HAL_TIM_ConfigClockSource_10
   4597              }
   4598          
   4599              case TIM_CLOCKSOURCE_ITR0:
   4600              case TIM_CLOCKSOURCE_ITR1:
   4601              case TIM_CLOCKSOURCE_ITR2:
   4602              case TIM_CLOCKSOURCE_ITR3:
   4603              {
   4604                /* Check whether or not the timer instance supports internal trigger input */
   4605                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4606          
   4607                TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
   \                     ??HAL_TIM_ConfigClockSource_2: (+1)
   \       0xD2   0x6829             LDR      R1,[R5, #+0]
   \       0xD4   0x6820             LDR      R0,[R4, #+0]
   \       0xD6   0x.... 0x....      BL       TIM_ITRx_SetConfig
   4608                break;
   \       0xDA   0xE7FF             B.N      ??HAL_TIM_ConfigClockSource_10
   4609              }
   4610          
   4611              default:
   4612                break;
   4613            }
   4614            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigClockSource_9: (+1)
   \                     ??HAL_TIM_ConfigClockSource_10: (+1)
   \       0xDC   0x2001             MOVS     R0,#+1
   \       0xDE   0xF884 0x003D      STRB     R0,[R4, #+61]
   4615          
   4616            __HAL_UNLOCK(htim);
   \       0xE2   0x2000             MOVS     R0,#+0
   \       0xE4   0xF884 0x003C      STRB     R0,[R4, #+60]
   4617          
   4618            return HAL_OK;
   \       0xE8   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_ConfigClockSource_1: (+1)
   \       0xEA   0xBD70             POP      {R4-R6,PC}
   4619          }
   4620          
   4621          /**
   4622            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   4623            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   4624            * @param  htim TIM handle.
   4625            * @param  TI1_Selection Indicate whether or not channel 1 is connected to the
   4626            *         output of a XOR gate.
   4627            *          This parameter can be one of the following values:
   4628            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   4629            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   4630            *            pins are connected to the TI1 input (XOR combination)
   4631            * @retval HAL status
   4632            */

   \                                 In section .text, align 2, keep-with-next
   4633          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   4634          {
   \                     HAL_TIM_ConfigTI1Input: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   4635            uint32_t tmpcr2;
   4636          
   4637            /* Check the parameters */
   4638            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
   4639            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   4640          
   4641            /* Get the TIMx CR2 register value */
   4642            tmpcr2 = htim->Instance->CR2;
   \        0x2   0x6810             LDR      R0,[R2, #+0]
   \        0x4   0x6843             LDR      R3,[R0, #+4]
   4643          
   4644            /* Reset the TI1 selection */
   4645            tmpcr2 &= ~TIM_CR2_TI1S;
   \        0x6   0xF033 0x0380      BICS     R3,R3,#0x80
   4646          
   4647            /* Set the TI1 selection */
   4648            tmpcr2 |= TI1_Selection;
   \        0xA   0x430B             ORRS     R3,R1,R3
   4649          
   4650            /* Write to TIMxCR2 */
   4651            htim->Instance->CR2 = tmpcr2;
   \        0xC   0x6810             LDR      R0,[R2, #+0]
   \        0xE   0x6043             STR      R3,[R0, #+4]
   4652          
   4653            return HAL_OK;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x4770             BX       LR
   4654          }
   4655          
   4656          /**
   4657            * @brief  Configures the TIM in Slave mode
   4658            * @param  htim TIM handle.
   4659            * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
   4660            *         contains the selected trigger (internal trigger input, filtered
   4661            *         timer input or external trigger input) and the Slave mode
   4662            *         (Disable, Reset, Gated, Trigger, External clock mode 1).
   4663            * @retval HAL status
   4664            */

   \                                 In section .text, align 2, keep-with-next
   4665          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef *sSlaveConfig)
   4666          {
   \                     HAL_TIM_SlaveConfigSynchro: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   4667            /* Check the parameters */
   4668            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4669            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4670            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4671          
   4672            __HAL_LOCK(htim);
   \        0x6   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE.N    ??HAL_TIM_SlaveConfigSynchro_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE026             B.N      ??HAL_TIM_SlaveConfigSynchro_1
   \                     ??HAL_TIM_SlaveConfigSynchro_0: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xF884 0x003C      STRB     R0,[R4, #+60]
   4673          
   4674            htim->State = HAL_TIM_STATE_BUSY;
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0xF884 0x003D      STRB     R0,[R4, #+61]
   4675          
   4676            if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
   \       0x1E   0x0029             MOVS     R1,R5
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       TIM_SlaveTimer_SetConfig
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD007             BEQ.N    ??HAL_TIM_SlaveConfigSynchro_2
   4677            {
   4678              htim->State = HAL_TIM_STATE_READY;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xF884 0x003D      STRB     R0,[R4, #+61]
   4679              __HAL_UNLOCK(htim);
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xF884 0x003C      STRB     R0,[R4, #+60]
   4680              return HAL_ERROR;
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0xE012             B.N      ??HAL_TIM_SlaveConfigSynchro_1
   4681            }
   4682          
   4683            /* Disable Trigger Interrupt */
   4684            __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
   \                     ??HAL_TIM_SlaveConfigSynchro_2: (+1)
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x68C0             LDR      R0,[R0, #+12]
   \       0x3E   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x42   0x6821             LDR      R1,[R4, #+0]
   \       0x44   0x60C8             STR      R0,[R1, #+12]
   4685          
   4686            /* Disable Trigger DMA request */
   4687            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x68C0             LDR      R0,[R0, #+12]
   \       0x4A   0xF430 0x4080      BICS     R0,R0,#0x4000
   \       0x4E   0x6821             LDR      R1,[R4, #+0]
   \       0x50   0x60C8             STR      R0,[R1, #+12]
   4688          
   4689            htim->State = HAL_TIM_STATE_READY;
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0xF884 0x003D      STRB     R0,[R4, #+61]
   4690          
   4691            __HAL_UNLOCK(htim);
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xF884 0x003C      STRB     R0,[R4, #+60]
   4692          
   4693            return HAL_OK;
   \       0x5E   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_SlaveConfigSynchro_1: (+1)
   \       0x60   0xBD32             POP      {R1,R4,R5,PC}
   4694          }
   4695          
   4696          /**
   4697            * @brief  Configures the TIM in Slave mode in interrupt mode
   4698            * @param  htim TIM handle.
   4699            * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
   4700            *         contains the selected trigger (internal trigger input, filtered
   4701            *         timer input or external trigger input) and the Slave mode
   4702            *         (Disable, Reset, Gated, Trigger, External clock mode 1).
   4703            * @retval HAL status
   4704            */

   \                                 In section .text, align 2, keep-with-next
   4705          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro_IT(TIM_HandleTypeDef *htim,
   4706                                                          TIM_SlaveConfigTypeDef *sSlaveConfig)
   4707          {
   \                     HAL_TIM_SlaveConfigSynchro_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   4708            /* Check the parameters */
   4709            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4710            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4711            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4712          
   4713            __HAL_LOCK(htim);
   \        0x6   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE.N    ??HAL_TIM_SlaveConfigSynchro_IT_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE026             B.N      ??HAL_TIM_SlaveConfigSynchro_IT_1
   \                     ??HAL_TIM_SlaveConfigSynchro_IT_0: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xF884 0x003C      STRB     R0,[R4, #+60]
   4714          
   4715            htim->State = HAL_TIM_STATE_BUSY;
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0xF884 0x003D      STRB     R0,[R4, #+61]
   4716          
   4717            if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
   \       0x1E   0x0029             MOVS     R1,R5
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       TIM_SlaveTimer_SetConfig
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD007             BEQ.N    ??HAL_TIM_SlaveConfigSynchro_IT_2
   4718            {
   4719              htim->State = HAL_TIM_STATE_READY;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xF884 0x003D      STRB     R0,[R4, #+61]
   4720              __HAL_UNLOCK(htim);
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xF884 0x003C      STRB     R0,[R4, #+60]
   4721              return HAL_ERROR;
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0xE012             B.N      ??HAL_TIM_SlaveConfigSynchro_IT_1
   4722            }
   4723          
   4724            /* Enable Trigger Interrupt */
   4725            __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
   \                     ??HAL_TIM_SlaveConfigSynchro_IT_2: (+1)
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x68C0             LDR      R0,[R0, #+12]
   \       0x3E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x42   0x6821             LDR      R1,[R4, #+0]
   \       0x44   0x60C8             STR      R0,[R1, #+12]
   4726          
   4727            /* Disable Trigger DMA request */
   4728            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x68C0             LDR      R0,[R0, #+12]
   \       0x4A   0xF430 0x4080      BICS     R0,R0,#0x4000
   \       0x4E   0x6821             LDR      R1,[R4, #+0]
   \       0x50   0x60C8             STR      R0,[R1, #+12]
   4729          
   4730            htim->State = HAL_TIM_STATE_READY;
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0xF884 0x003D      STRB     R0,[R4, #+61]
   4731          
   4732            __HAL_UNLOCK(htim);
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xF884 0x003C      STRB     R0,[R4, #+60]
   4733          
   4734            return HAL_OK;
   \       0x5E   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_SlaveConfigSynchro_IT_1: (+1)
   \       0x60   0xBD32             POP      {R1,R4,R5,PC}
   4735          }
   4736          
   4737          /**
   4738            * @brief  Read the captured value from Capture Compare unit
   4739            * @param  htim TIM handle.
   4740            * @param  Channel TIM Channels to be enabled
   4741            *          This parameter can be one of the following values:
   4742            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   4743            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   4744            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   4745            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   4746            * @retval Captured value
   4747            */

   \                                 In section .text, align 2, keep-with-next
   4748          uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
   4749          {
   \                     HAL_TIM_ReadCapturedValue: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   4750            uint32_t tmpreg = 0U;
   \        0x2   0x2000             MOVS     R0,#+0
   4751          
   4752            switch (Channel)
   \        0x4   0x000B             MOVS     R3,R1
   \        0x6   0x2B00             CMP      R3,#+0
   \        0x8   0xD006             BEQ.N    ??HAL_TIM_ReadCapturedValue_0
   \        0xA   0x2B04             CMP      R3,#+4
   \        0xC   0xD008             BEQ.N    ??HAL_TIM_ReadCapturedValue_1
   \        0xE   0x2B08             CMP      R3,#+8
   \       0x10   0xD00A             BEQ.N    ??HAL_TIM_ReadCapturedValue_2
   \       0x12   0x2B0C             CMP      R3,#+12
   \       0x14   0xD00C             BEQ.N    ??HAL_TIM_ReadCapturedValue_3
   \       0x16   0xE00F             B.N      ??HAL_TIM_ReadCapturedValue_4
   4753            {
   4754              case TIM_CHANNEL_1:
   4755              {
   4756                /* Check the parameters */
   4757                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4758          
   4759                /* Return the capture 1 value */
   4760                tmpreg =  htim->Instance->CCR1;
   \                     ??HAL_TIM_ReadCapturedValue_0: (+1)
   \       0x18   0x6813             LDR      R3,[R2, #+0]
   \       0x1A   0x6B5B             LDR      R3,[R3, #+52]
   \       0x1C   0x0018             MOVS     R0,R3
   4761          
   4762                break;
   \       0x1E   0xE00B             B.N      ??HAL_TIM_ReadCapturedValue_5
   4763              }
   4764              case TIM_CHANNEL_2:
   4765              {
   4766                /* Check the parameters */
   4767                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4768          
   4769                /* Return the capture 2 value */
   4770                tmpreg =   htim->Instance->CCR2;
   \                     ??HAL_TIM_ReadCapturedValue_1: (+1)
   \       0x20   0x6813             LDR      R3,[R2, #+0]
   \       0x22   0x6B9B             LDR      R3,[R3, #+56]
   \       0x24   0x0018             MOVS     R0,R3
   4771          
   4772                break;
   \       0x26   0xE007             B.N      ??HAL_TIM_ReadCapturedValue_5
   4773              }
   4774          
   4775              case TIM_CHANNEL_3:
   4776              {
   4777                /* Check the parameters */
   4778                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4779          
   4780                /* Return the capture 3 value */
   4781                tmpreg =   htim->Instance->CCR3;
   \                     ??HAL_TIM_ReadCapturedValue_2: (+1)
   \       0x28   0x6813             LDR      R3,[R2, #+0]
   \       0x2A   0x6BDB             LDR      R3,[R3, #+60]
   \       0x2C   0x0018             MOVS     R0,R3
   4782          
   4783                break;
   \       0x2E   0xE003             B.N      ??HAL_TIM_ReadCapturedValue_5
   4784              }
   4785          
   4786              case TIM_CHANNEL_4:
   4787              {
   4788                /* Check the parameters */
   4789                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4790          
   4791                /* Return the capture 4 value */
   4792                tmpreg =   htim->Instance->CCR4;
   \                     ??HAL_TIM_ReadCapturedValue_3: (+1)
   \       0x30   0x6813             LDR      R3,[R2, #+0]
   \       0x32   0x6C1B             LDR      R3,[R3, #+64]
   \       0x34   0x0018             MOVS     R0,R3
   4793          
   4794                break;
   \       0x36   0xE7FF             B.N      ??HAL_TIM_ReadCapturedValue_5
   4795              }
   4796          
   4797              default:
   4798                break;
   4799            }
   4800          
   4801            return tmpreg;
   \                     ??HAL_TIM_ReadCapturedValue_4: (+1)
   \                     ??HAL_TIM_ReadCapturedValue_5: (+1)
   \       0x38   0x4770             BX       LR
   4802          }
   4803          
   4804          /**
   4805            * @}
   4806            */
   4807          
   4808          /** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
   4809            *  @brief    TIM Callbacks functions
   4810            *
   4811          @verbatim
   4812            ==============================================================================
   4813                                  ##### TIM Callbacks functions #####
   4814            ==============================================================================
   4815           [..]
   4816             This section provides TIM callback functions:
   4817             (+) TIM Period elapsed callback
   4818             (+) TIM Output Compare callback
   4819             (+) TIM Input capture callback
   4820             (+) TIM Trigger callback
   4821             (+) TIM Error callback
   4822          
   4823          @endverbatim
   4824            * @{
   4825            */
   4826          
   4827          /**
   4828            * @brief  Period elapsed callback in non-blocking mode
   4829            * @param  htim TIM handle
   4830            * @retval None
   4831            */

   \                                 In section .text, align 2
   4832          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   4833          {
   4834            /* Prevent unused argument(s) compilation warning */
   4835            UNUSED(htim);
   4836          
   4837            /* NOTE : This function should not be modified, when the callback is needed,
   4838                      the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   4839             */
   4840          }
   \                     HAL_TIM_PeriodElapsedCallback: (+1)
   \        0x0   0x4770             BX       LR
   4841          
   4842          /**
   4843            * @brief  Period elapsed half complete callback in non-blocking mode
   4844            * @param  htim TIM handle
   4845            * @retval None
   4846            */

   \                                 In section .text, align 2
   4847          __weak void HAL_TIM_PeriodElapsedHalfCpltCallback(TIM_HandleTypeDef *htim)
   4848          {
   4849            /* Prevent unused argument(s) compilation warning */
   4850            UNUSED(htim);
   4851          
   4852            /* NOTE : This function should not be modified, when the callback is needed,
   4853                      the HAL_TIM_PeriodElapsedHalfCpltCallback could be implemented in the user file
   4854             */
   4855          }
   \                     HAL_TIM_PeriodElapsedHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   4856          
   4857          /**
   4858            * @brief  Output Compare callback in non-blocking mode
   4859            * @param  htim TIM OC handle
   4860            * @retval None
   4861            */

   \                                 In section .text, align 2
   4862          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   4863          {
   4864            /* Prevent unused argument(s) compilation warning */
   4865            UNUSED(htim);
   4866          
   4867            /* NOTE : This function should not be modified, when the callback is needed,
   4868                      the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   4869             */
   4870          }
   \                     HAL_TIM_OC_DelayElapsedCallback: (+1)
   \        0x0   0x4770             BX       LR
   4871          
   4872          /**
   4873            * @brief  Input Capture callback in non-blocking mode
   4874            * @param  htim TIM IC handle
   4875            * @retval None
   4876            */

   \                                 In section .text, align 2
   4877          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   4878          {
   4879            /* Prevent unused argument(s) compilation warning */
   4880            UNUSED(htim);
   4881          
   4882            /* NOTE : This function should not be modified, when the callback is needed,
   4883                      the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   4884             */
   4885          }
   \                     HAL_TIM_IC_CaptureCallback: (+1)
   \        0x0   0x4770             BX       LR
   4886          
   4887          /**
   4888            * @brief  Input Capture half complete callback in non-blocking mode
   4889            * @param  htim TIM IC handle
   4890            * @retval None
   4891            */

   \                                 In section .text, align 2
   4892          __weak void HAL_TIM_IC_CaptureHalfCpltCallback(TIM_HandleTypeDef *htim)
   4893          {
   4894            /* Prevent unused argument(s) compilation warning */
   4895            UNUSED(htim);
   4896          
   4897            /* NOTE : This function should not be modified, when the callback is needed,
   4898                      the HAL_TIM_IC_CaptureHalfCpltCallback could be implemented in the user file
   4899             */
   4900          }
   \                     HAL_TIM_IC_CaptureHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   4901          
   4902          /**
   4903            * @brief  PWM Pulse finished callback in non-blocking mode
   4904            * @param  htim TIM handle
   4905            * @retval None
   4906            */

   \                                 In section .text, align 2
   4907          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   4908          {
   4909            /* Prevent unused argument(s) compilation warning */
   4910            UNUSED(htim);
   4911          
   4912            /* NOTE : This function should not be modified, when the callback is needed,
   4913                      the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   4914             */
   4915          }
   \                     HAL_TIM_PWM_PulseFinishedCallback: (+1)
   \        0x0   0x4770             BX       LR
   4916          
   4917          /**
   4918            * @brief  PWM Pulse finished half complete callback in non-blocking mode
   4919            * @param  htim TIM handle
   4920            * @retval None
   4921            */

   \                                 In section .text, align 2
   4922          __weak void HAL_TIM_PWM_PulseFinishedHalfCpltCallback(TIM_HandleTypeDef *htim)
   4923          {
   4924            /* Prevent unused argument(s) compilation warning */
   4925            UNUSED(htim);
   4926          
   4927            /* NOTE : This function should not be modified, when the callback is needed,
   4928                      the HAL_TIM_PWM_PulseFinishedHalfCpltCallback could be implemented in the user file
   4929             */
   4930          }
   \                     HAL_TIM_PWM_PulseFinishedHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   4931          
   4932          /**
   4933            * @brief  Hall Trigger detection callback in non-blocking mode
   4934            * @param  htim TIM handle
   4935            * @retval None
   4936            */

   \                                 In section .text, align 2
   4937          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   4938          {
   4939            /* Prevent unused argument(s) compilation warning */
   4940            UNUSED(htim);
   4941          
   4942            /* NOTE : This function should not be modified, when the callback is needed,
   4943                      the HAL_TIM_TriggerCallback could be implemented in the user file
   4944             */
   4945          }
   \                     HAL_TIM_TriggerCallback: (+1)
   \        0x0   0x4770             BX       LR
   4946          
   4947          /**
   4948            * @brief  Hall Trigger detection half complete callback in non-blocking mode
   4949            * @param  htim TIM handle
   4950            * @retval None
   4951            */

   \                                 In section .text, align 2
   4952          __weak void HAL_TIM_TriggerHalfCpltCallback(TIM_HandleTypeDef *htim)
   4953          {
   4954            /* Prevent unused argument(s) compilation warning */
   4955            UNUSED(htim);
   4956          
   4957            /* NOTE : This function should not be modified, when the callback is needed,
   4958                      the HAL_TIM_TriggerHalfCpltCallback could be implemented in the user file
   4959             */
   4960          }
   \                     HAL_TIM_TriggerHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   4961          
   4962          /**
   4963            * @brief  Timer error callback in non-blocking mode
   4964            * @param  htim TIM handle
   4965            * @retval None
   4966            */

   \                                 In section .text, align 2
   4967          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   4968          {
   4969            /* Prevent unused argument(s) compilation warning */
   4970            UNUSED(htim);
   4971          
   4972            /* NOTE : This function should not be modified, when the callback is needed,
   4973                      the HAL_TIM_ErrorCallback could be implemented in the user file
   4974             */
   4975          }
   \                     HAL_TIM_ErrorCallback: (+1)
   \        0x0   0x4770             BX       LR
   4976          
   4977          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   4978          /**
   4979            * @brief  Register a User TIM callback to be used instead of the weak predefined callback
   4980            * @param htim tim handle
   4981            * @param CallbackID ID of the callback to be registered
   4982            *        This parameter can be one of the following values:
   4983            *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
   4984            *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
   4985            *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
   4986            *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
   4987            *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
   4988            *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
   4989            *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
   4990            *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
   4991            *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
   4992            *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
   4993            *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
   4994            *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
   4995            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID
   4996            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID
   4997            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
   4998            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
   4999            *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
   5000            *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
   5001            *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
   5002            *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
   5003            *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
   5004            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
   5005            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
   5006            *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
   5007            *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID
   5008            *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID
   5009            *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID
   5010            *          @param pCallback pointer to the callback function
   5011            *          @retval status
   5012            */
   5013          HAL_StatusTypeDef HAL_TIM_RegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID,
   5014                                                     pTIM_CallbackTypeDef pCallback)
   5015          {
   5016            HAL_StatusTypeDef status = HAL_OK;
   5017          
   5018            if (pCallback == NULL)
   5019            {
   5020              return HAL_ERROR;
   5021            }
   5022            /* Process locked */
   5023            __HAL_LOCK(htim);
   5024          
   5025            if (htim->State == HAL_TIM_STATE_READY)
   5026            {
   5027              switch (CallbackID)
   5028              {
   5029                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5030                  htim->Base_MspInitCallback                 = pCallback;
   5031                  break;
   5032          
   5033                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5034                  htim->Base_MspDeInitCallback               = pCallback;
   5035                  break;
   5036          
   5037                case HAL_TIM_IC_MSPINIT_CB_ID :
   5038                  htim->IC_MspInitCallback                   = pCallback;
   5039                  break;
   5040          
   5041                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5042                  htim->IC_MspDeInitCallback                 = pCallback;
   5043                  break;
   5044          
   5045                case HAL_TIM_OC_MSPINIT_CB_ID :
   5046                  htim->OC_MspInitCallback                   = pCallback;
   5047                  break;
   5048          
   5049                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5050                  htim->OC_MspDeInitCallback                 = pCallback;
   5051                  break;
   5052          
   5053                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5054                  htim->PWM_MspInitCallback                  = pCallback;
   5055                  break;
   5056          
   5057                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5058                  htim->PWM_MspDeInitCallback                = pCallback;
   5059                  break;
   5060          
   5061                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5062                  htim->OnePulse_MspInitCallback             = pCallback;
   5063                  break;
   5064          
   5065                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5066                  htim->OnePulse_MspDeInitCallback           = pCallback;
   5067                  break;
   5068          
   5069                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5070                  htim->Encoder_MspInitCallback              = pCallback;
   5071                  break;
   5072          
   5073                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5074                  htim->Encoder_MspDeInitCallback            = pCallback;
   5075                  break;
   5076          
   5077                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5078                  htim->HallSensor_MspInitCallback           = pCallback;
   5079                  break;
   5080          
   5081                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5082                  htim->HallSensor_MspDeInitCallback         = pCallback;
   5083                  break;
   5084          
   5085                case HAL_TIM_PERIOD_ELAPSED_CB_ID :
   5086                  htim->PeriodElapsedCallback                = pCallback;
   5087                  break;
   5088          
   5089                case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :
   5090                  htim->PeriodElapsedHalfCpltCallback        = pCallback;
   5091                  break;
   5092          
   5093                case HAL_TIM_TRIGGER_CB_ID :
   5094                  htim->TriggerCallback                      = pCallback;
   5095                  break;
   5096          
   5097                case HAL_TIM_TRIGGER_HALF_CB_ID :
   5098                  htim->TriggerHalfCpltCallback              = pCallback;
   5099                  break;
   5100          
   5101                case HAL_TIM_IC_CAPTURE_CB_ID :
   5102                  htim->IC_CaptureCallback                   = pCallback;
   5103                  break;
   5104          
   5105                case HAL_TIM_IC_CAPTURE_HALF_CB_ID :
   5106                  htim->IC_CaptureHalfCpltCallback           = pCallback;
   5107                  break;
   5108          
   5109                case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :
   5110                  htim->OC_DelayElapsedCallback              = pCallback;
   5111                  break;
   5112          
   5113                case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :
   5114                  htim->PWM_PulseFinishedCallback            = pCallback;
   5115                  break;
   5116          
   5117                case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :
   5118                  htim->PWM_PulseFinishedHalfCpltCallback    = pCallback;
   5119                  break;
   5120          
   5121                case HAL_TIM_ERROR_CB_ID :
   5122                  htim->ErrorCallback                        = pCallback;
   5123                  break;
   5124          
   5125                case HAL_TIM_COMMUTATION_CB_ID :
   5126                  htim->CommutationCallback                  = pCallback;
   5127                  break;
   5128          
   5129                case HAL_TIM_COMMUTATION_HALF_CB_ID :
   5130                  htim->CommutationHalfCpltCallback          = pCallback;
   5131                  break;
   5132          
   5133                case HAL_TIM_BREAK_CB_ID :
   5134                  htim->BreakCallback                        = pCallback;
   5135                  break;
   5136          
   5137                default :
   5138                  /* Return error status */
   5139                  status =  HAL_ERROR;
   5140                  break;
   5141              }
   5142            }
   5143            else if (htim->State == HAL_TIM_STATE_RESET)
   5144            {
   5145              switch (CallbackID)
   5146              {
   5147                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5148                  htim->Base_MspInitCallback         = pCallback;
   5149                  break;
   5150          
   5151                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5152                  htim->Base_MspDeInitCallback       = pCallback;
   5153                  break;
   5154          
   5155                case HAL_TIM_IC_MSPINIT_CB_ID :
   5156                  htim->IC_MspInitCallback           = pCallback;
   5157                  break;
   5158          
   5159                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5160                  htim->IC_MspDeInitCallback         = pCallback;
   5161                  break;
   5162          
   5163                case HAL_TIM_OC_MSPINIT_CB_ID :
   5164                  htim->OC_MspInitCallback           = pCallback;
   5165                  break;
   5166          
   5167                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5168                  htim->OC_MspDeInitCallback         = pCallback;
   5169                  break;
   5170          
   5171                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5172                  htim->PWM_MspInitCallback          = pCallback;
   5173                  break;
   5174          
   5175                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5176                  htim->PWM_MspDeInitCallback        = pCallback;
   5177                  break;
   5178          
   5179                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5180                  htim->OnePulse_MspInitCallback     = pCallback;
   5181                  break;
   5182          
   5183                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5184                  htim->OnePulse_MspDeInitCallback   = pCallback;
   5185                  break;
   5186          
   5187                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5188                  htim->Encoder_MspInitCallback      = pCallback;
   5189                  break;
   5190          
   5191                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5192                  htim->Encoder_MspDeInitCallback    = pCallback;
   5193                  break;
   5194          
   5195                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5196                  htim->HallSensor_MspInitCallback   = pCallback;
   5197                  break;
   5198          
   5199                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5200                  htim->HallSensor_MspDeInitCallback = pCallback;
   5201                  break;
   5202          
   5203                default :
   5204                  /* Return error status */
   5205                  status =  HAL_ERROR;
   5206                  break;
   5207              }
   5208            }
   5209            else
   5210            {
   5211              /* Return error status */
   5212              status =  HAL_ERROR;
   5213            }
   5214          
   5215            /* Release Lock */
   5216            __HAL_UNLOCK(htim);
   5217          
   5218            return status;
   5219          }
   5220          
   5221          /**
   5222            * @brief  Unregister a TIM callback
   5223            *         TIM callback is redirected to the weak predefined callback
   5224            * @param htim tim handle
   5225            * @param CallbackID ID of the callback to be unregistered
   5226            *        This parameter can be one of the following values:
   5227            *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
   5228            *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
   5229            *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
   5230            *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
   5231            *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
   5232            *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
   5233            *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
   5234            *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
   5235            *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
   5236            *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
   5237            *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
   5238            *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
   5239            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID
   5240            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID
   5241            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
   5242            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
   5243            *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
   5244            *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
   5245            *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
   5246            *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
   5247            *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
   5248            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
   5249            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
   5250            *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
   5251            *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID
   5252            *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID
   5253            *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID
   5254            *          @retval status
   5255            */
   5256          HAL_StatusTypeDef HAL_TIM_UnRegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID)
   5257          {
   5258            HAL_StatusTypeDef status = HAL_OK;
   5259          
   5260            /* Process locked */
   5261            __HAL_LOCK(htim);
   5262          
   5263            if (htim->State == HAL_TIM_STATE_READY)
   5264            {
   5265              switch (CallbackID)
   5266              {
   5267                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5268                  htim->Base_MspInitCallback              = HAL_TIM_Base_MspInit;                      /* Legacy weak Base MspInit Callback */
   5269                  break;
   5270          
   5271                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5272                  htim->Base_MspDeInitCallback            = HAL_TIM_Base_MspDeInit;                    /* Legacy weak Base Msp DeInit Callback */
   5273                  break;
   5274          
   5275                case HAL_TIM_IC_MSPINIT_CB_ID :
   5276                  htim->IC_MspInitCallback                = HAL_TIM_IC_MspInit;                        /* Legacy weak IC Msp Init Callback */
   5277                  break;
   5278          
   5279                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5280                  htim->IC_MspDeInitCallback              = HAL_TIM_IC_MspDeInit;                      /* Legacy weak IC Msp DeInit Callback */
   5281                  break;
   5282          
   5283                case HAL_TIM_OC_MSPINIT_CB_ID :
   5284                  htim->OC_MspInitCallback                = HAL_TIM_OC_MspInit;                        /* Legacy weak OC Msp Init Callback */
   5285                  break;
   5286          
   5287                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5288                  htim->OC_MspDeInitCallback              = HAL_TIM_OC_MspDeInit;                      /* Legacy weak OC Msp DeInit Callback */
   5289                  break;
   5290          
   5291                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5292                  htim->PWM_MspInitCallback               = HAL_TIM_PWM_MspInit;                       /* Legacy weak PWM Msp Init Callback */
   5293                  break;
   5294          
   5295                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5296                  htim->PWM_MspDeInitCallback             = HAL_TIM_PWM_MspDeInit;                     /* Legacy weak PWM Msp DeInit Callback */
   5297                  break;
   5298          
   5299                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5300                  htim->OnePulse_MspInitCallback          = HAL_TIM_OnePulse_MspInit;                  /* Legacy weak One Pulse Msp Init Callback */
   5301                  break;
   5302          
   5303                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5304                  htim->OnePulse_MspDeInitCallback        = HAL_TIM_OnePulse_MspDeInit;                /* Legacy weak One Pulse Msp DeInit Callback */
   5305                  break;
   5306          
   5307                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5308                  htim->Encoder_MspInitCallback           = HAL_TIM_Encoder_MspInit;                   /* Legacy weak Encoder Msp Init Callback */
   5309                  break;
   5310          
   5311                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5312                  htim->Encoder_MspDeInitCallback         = HAL_TIM_Encoder_MspDeInit;                 /* Legacy weak Encoder Msp DeInit Callback */
   5313                  break;
   5314          
   5315                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5316                  htim->HallSensor_MspInitCallback        = HAL_TIMEx_HallSensor_MspInit;              /* Legacy weak Hall Sensor Msp Init Callback */
   5317                  break;
   5318          
   5319                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5320                  htim->HallSensor_MspDeInitCallback      = HAL_TIMEx_HallSensor_MspDeInit;            /* Legacy weak Hall Sensor Msp DeInit Callback */
   5321                  break;
   5322          
   5323                case HAL_TIM_PERIOD_ELAPSED_CB_ID :
   5324                  htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;             /* Legacy weak Period Elapsed Callback */
   5325                  break;
   5326          
   5327                case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :
   5328                  htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;     /* Legacy weak Period Elapsed half complete Callback */
   5329                  break;
   5330          
   5331                case HAL_TIM_TRIGGER_CB_ID :
   5332                  htim->TriggerCallback                   = HAL_TIM_TriggerCallback;                   /* Legacy weak Trigger Callback */
   5333                  break;
   5334          
   5335                case HAL_TIM_TRIGGER_HALF_CB_ID :
   5336                  htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;           /* Legacy weak Trigger half complete Callback */
   5337                  break;
   5338          
   5339                case HAL_TIM_IC_CAPTURE_CB_ID :
   5340                  htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;                /* Legacy weak IC Capture Callback */
   5341                  break;
   5342          
   5343                case HAL_TIM_IC_CAPTURE_HALF_CB_ID :
   5344                  htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;        /* Legacy weak IC Capture half complete Callback */
   5345                  break;
   5346          
   5347                case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :
   5348                  htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;           /* Legacy weak OC Delay Elapsed Callback */
   5349                  break;
   5350          
   5351                case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :
   5352                  htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;         /* Legacy weak PWM Pulse Finished Callback */
   5353                  break;
   5354          
   5355                case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :
   5356                  htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback; /* Legacy weak PWM Pulse Finished half complete Callback */
   5357                  break;
   5358          
   5359                case HAL_TIM_ERROR_CB_ID :
   5360                  htim->ErrorCallback                     = HAL_TIM_ErrorCallback;                     /* Legacy weak Error Callback */
   5361                  break;
   5362          
   5363                case HAL_TIM_COMMUTATION_CB_ID :
   5364                  htim->CommutationCallback               = HAL_TIMEx_CommutCallback;                  /* Legacy weak Commutation Callback */
   5365                  break;
   5366          
   5367                case HAL_TIM_COMMUTATION_HALF_CB_ID :
   5368                  htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;          /* Legacy weak Commutation half complete Callback */
   5369                  break;
   5370          
   5371                case HAL_TIM_BREAK_CB_ID :
   5372                  htim->BreakCallback                     = HAL_TIMEx_BreakCallback;                   /* Legacy weak Break Callback */
   5373                  break;
   5374          
   5375                default :
   5376                  /* Return error status */
   5377                  status =  HAL_ERROR;
   5378                  break;
   5379              }
   5380            }
   5381            else if (htim->State == HAL_TIM_STATE_RESET)
   5382            {
   5383              switch (CallbackID)
   5384              {
   5385                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5386                  htim->Base_MspInitCallback         = HAL_TIM_Base_MspInit;              /* Legacy weak Base MspInit Callback */
   5387                  break;
   5388          
   5389                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5390                  htim->Base_MspDeInitCallback       = HAL_TIM_Base_MspDeInit;            /* Legacy weak Base Msp DeInit Callback */
   5391                  break;
   5392          
   5393                case HAL_TIM_IC_MSPINIT_CB_ID :
   5394                  htim->IC_MspInitCallback           = HAL_TIM_IC_MspInit;                /* Legacy weak IC Msp Init Callback */
   5395                  break;
   5396          
   5397                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5398                  htim->IC_MspDeInitCallback         = HAL_TIM_IC_MspDeInit;              /* Legacy weak IC Msp DeInit Callback */
   5399                  break;
   5400          
   5401                case HAL_TIM_OC_MSPINIT_CB_ID :
   5402                  htim->OC_MspInitCallback           = HAL_TIM_OC_MspInit;                /* Legacy weak OC Msp Init Callback */
   5403                  break;
   5404          
   5405                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5406                  htim->OC_MspDeInitCallback         = HAL_TIM_OC_MspDeInit;              /* Legacy weak OC Msp DeInit Callback */
   5407                  break;
   5408          
   5409                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5410                  htim->PWM_MspInitCallback          = HAL_TIM_PWM_MspInit;               /* Legacy weak PWM Msp Init Callback */
   5411                  break;
   5412          
   5413                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5414                  htim->PWM_MspDeInitCallback        = HAL_TIM_PWM_MspDeInit;             /* Legacy weak PWM Msp DeInit Callback */
   5415                  break;
   5416          
   5417                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5418                  htim->OnePulse_MspInitCallback     = HAL_TIM_OnePulse_MspInit;          /* Legacy weak One Pulse Msp Init Callback */
   5419                  break;
   5420          
   5421                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5422                  htim->OnePulse_MspDeInitCallback   = HAL_TIM_OnePulse_MspDeInit;        /* Legacy weak One Pulse Msp DeInit Callback */
   5423                  break;
   5424          
   5425                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5426                  htim->Encoder_MspInitCallback      = HAL_TIM_Encoder_MspInit;           /* Legacy weak Encoder Msp Init Callback */
   5427                  break;
   5428          
   5429                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5430                  htim->Encoder_MspDeInitCallback    = HAL_TIM_Encoder_MspDeInit;         /* Legacy weak Encoder Msp DeInit Callback */
   5431                  break;
   5432          
   5433                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5434                  htim->HallSensor_MspInitCallback   = HAL_TIMEx_HallSensor_MspInit;      /* Legacy weak Hall Sensor Msp Init Callback */
   5435                  break;
   5436          
   5437                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5438                  htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;    /* Legacy weak Hall Sensor Msp DeInit Callback */
   5439                  break;
   5440          
   5441                default :
   5442                  /* Return error status */
   5443                  status =  HAL_ERROR;
   5444                  break;
   5445              }
   5446            }
   5447            else
   5448            {
   5449              /* Return error status */
   5450              status =  HAL_ERROR;
   5451            }
   5452          
   5453            /* Release Lock */
   5454            __HAL_UNLOCK(htim);
   5455          
   5456            return status;
   5457          }
   5458          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5459          
   5460          /**
   5461            * @}
   5462            */
   5463          
   5464          /** @defgroup TIM_Exported_Functions_Group10 TIM Peripheral State functions
   5465            *  @brief   TIM Peripheral State functions
   5466            *
   5467          @verbatim
   5468            ==============================================================================
   5469                                  ##### Peripheral State functions #####
   5470            ==============================================================================
   5471              [..]
   5472              This subsection permits to get in run-time the status of the peripheral
   5473              and the data flow.
   5474          
   5475          @endverbatim
   5476            * @{
   5477            */
   5478          
   5479          /**
   5480            * @brief  Return the TIM Base handle state.
   5481            * @param  htim TIM Base handle
   5482            * @retval HAL state
   5483            */

   \                                 In section .text, align 2, keep-with-next
   5484          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
   5485          {
   5486            return htim->State;
   \                     HAL_TIM_Base_GetState: (+1)
   \        0x0   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \        0x4   0x4770             BX       LR
   5487          }
   5488          
   5489          /**
   5490            * @brief  Return the TIM OC handle state.
   5491            * @param  htim TIM Output Compare handle
   5492            * @retval HAL state
   5493            */

   \                                 In section .text, align 2, keep-with-next
   5494          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
   5495          {
   5496            return htim->State;
   \                     HAL_TIM_OC_GetState: (+1)
   \        0x0   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \        0x4   0x4770             BX       LR
   5497          }
   5498          
   5499          /**
   5500            * @brief  Return the TIM PWM handle state.
   5501            * @param  htim TIM handle
   5502            * @retval HAL state
   5503            */

   \                                 In section .text, align 2, keep-with-next
   5504          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
   5505          {
   5506            return htim->State;
   \                     HAL_TIM_PWM_GetState: (+1)
   \        0x0   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \        0x4   0x4770             BX       LR
   5507          }
   5508          
   5509          /**
   5510            * @brief  Return the TIM Input Capture handle state.
   5511            * @param  htim TIM IC handle
   5512            * @retval HAL state
   5513            */

   \                                 In section .text, align 2, keep-with-next
   5514          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
   5515          {
   5516            return htim->State;
   \                     HAL_TIM_IC_GetState: (+1)
   \        0x0   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \        0x4   0x4770             BX       LR
   5517          }
   5518          
   5519          /**
   5520            * @brief  Return the TIM One Pulse Mode handle state.
   5521            * @param  htim TIM OPM handle
   5522            * @retval HAL state
   5523            */

   \                                 In section .text, align 2, keep-with-next
   5524          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
   5525          {
   5526            return htim->State;
   \                     HAL_TIM_OnePulse_GetState: (+1)
   \        0x0   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \        0x4   0x4770             BX       LR
   5527          }
   5528          
   5529          /**
   5530            * @brief  Return the TIM Encoder Mode handle state.
   5531            * @param  htim TIM Encoder Interface handle
   5532            * @retval HAL state
   5533            */

   \                                 In section .text, align 2, keep-with-next
   5534          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
   5535          {
   5536            return htim->State;
   \                     HAL_TIM_Encoder_GetState: (+1)
   \        0x0   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \        0x4   0x4770             BX       LR
   5537          }
   5538          
   5539          /**
   5540            * @}
   5541            */
   5542          
   5543          /**
   5544            * @}
   5545            */
   5546          
   5547          /** @defgroup TIM_Private_Functions TIM Private Functions
   5548            * @{
   5549            */
   5550          
   5551          /**
   5552            * @brief  TIM DMA error callback
   5553            * @param  hdma pointer to DMA handle.
   5554            * @retval None
   5555            */

   \                                 In section .text, align 4, keep-with-next
   5556          void TIM_DMAError(DMA_HandleTypeDef *hdma)
   5557          {
   \                     TIM_DMAError: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5558            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   5559          
   5560            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xF885 0x003D      STRB     R0,[R5, #+61]
   5561          
   5562          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5563            htim->ErrorCallback(htim);
   5564          #else
   5565            HAL_TIM_ErrorCallback(htim);
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x.... 0x....      BL       HAL_TIM_ErrorCallback
   5566          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5567          }
   \       0x12   0xBD31             POP      {R0,R4,R5,PC}
   5568          
   5569          /**
   5570            * @brief  TIM DMA Delay Pulse complete callback.
   5571            * @param  hdma pointer to DMA handle.
   5572            * @retval None
   5573            */

   \                                 In section .text, align 4, keep-with-next
   5574          void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   5575          {
   \                     TIM_DMADelayPulseCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5576            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   5577          
   5578            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xF885 0x003D      STRB     R0,[R5, #+61]
   5579          
   5580            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \        0xC   0x6A68             LDR      R0,[R5, #+36]
   \        0xE   0x4284             CMP      R4,R0
   \       0x10   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_0
   5581            {
   5582              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x7728             STRB     R0,[R5, #+28]
   \       0x16   0xE010             B.N      ??TIM_DMADelayPulseCplt_1
   5583            }
   5584            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMADelayPulseCplt_0: (+1)
   \       0x18   0x6AA8             LDR      R0,[R5, #+40]
   \       0x1A   0x4284             CMP      R4,R0
   \       0x1C   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_2
   5585            {
   5586              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0x7728             STRB     R0,[R5, #+28]
   \       0x22   0xE00A             B.N      ??TIM_DMADelayPulseCplt_1
   5587            }
   5588            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMADelayPulseCplt_2: (+1)
   \       0x24   0x6AE8             LDR      R0,[R5, #+44]
   \       0x26   0x4284             CMP      R4,R0
   \       0x28   0xD102             BNE.N    ??TIM_DMADelayPulseCplt_3
   5589            {
   5590              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x2A   0x2004             MOVS     R0,#+4
   \       0x2C   0x7728             STRB     R0,[R5, #+28]
   \       0x2E   0xE004             B.N      ??TIM_DMADelayPulseCplt_1
   5591            }
   5592            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMADelayPulseCplt_3: (+1)
   \       0x30   0x6B28             LDR      R0,[R5, #+48]
   \       0x32   0x4284             CMP      R4,R0
   \       0x34   0xD101             BNE.N    ??TIM_DMADelayPulseCplt_1
   5593            {
   5594              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0x36   0x2008             MOVS     R0,#+8
   \       0x38   0x7728             STRB     R0,[R5, #+28]
   5595            }
   5596            else
   5597            {
   5598              /* nothing to do */
   5599            }
   5600          
   5601          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5602            htim->PWM_PulseFinishedCallback(htim);
   5603          #else
   5604            HAL_TIM_PWM_PulseFinishedCallback(htim);
   \                     ??TIM_DMADelayPulseCplt_1: (+1)
   \       0x3A   0x0028             MOVS     R0,R5
   \       0x3C   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedCallback
   5605          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5606          
   5607            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x7728             STRB     R0,[R5, #+28]
   5608          }
   \       0x44   0xBD31             POP      {R0,R4,R5,PC}
   5609          
   5610          /**
   5611            * @brief  TIM DMA Delay Pulse half complete callback.
   5612            * @param  hdma pointer to DMA handle.
   5613            * @retval None
   5614            */

   \                                 In section .text, align 4, keep-with-next
   5615          void TIM_DMADelayPulseHalfCplt(DMA_HandleTypeDef *hdma)
   5616          {
   \                     TIM_DMADelayPulseHalfCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5617            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   5618          
   5619            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xF885 0x003D      STRB     R0,[R5, #+61]
   5620          
   5621            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \        0xC   0x6A68             LDR      R0,[R5, #+36]
   \        0xE   0x4284             CMP      R4,R0
   \       0x10   0xD102             BNE.N    ??TIM_DMADelayPulseHalfCplt_0
   5622            {
   5623              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x7728             STRB     R0,[R5, #+28]
   \       0x16   0xE010             B.N      ??TIM_DMADelayPulseHalfCplt_1
   5624            }
   5625            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMADelayPulseHalfCplt_0: (+1)
   \       0x18   0x6AA8             LDR      R0,[R5, #+40]
   \       0x1A   0x4284             CMP      R4,R0
   \       0x1C   0xD102             BNE.N    ??TIM_DMADelayPulseHalfCplt_2
   5626            {
   5627              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0x7728             STRB     R0,[R5, #+28]
   \       0x22   0xE00A             B.N      ??TIM_DMADelayPulseHalfCplt_1
   5628            }
   5629            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMADelayPulseHalfCplt_2: (+1)
   \       0x24   0x6AE8             LDR      R0,[R5, #+44]
   \       0x26   0x4284             CMP      R4,R0
   \       0x28   0xD102             BNE.N    ??TIM_DMADelayPulseHalfCplt_3
   5630            {
   5631              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x2A   0x2004             MOVS     R0,#+4
   \       0x2C   0x7728             STRB     R0,[R5, #+28]
   \       0x2E   0xE004             B.N      ??TIM_DMADelayPulseHalfCplt_1
   5632            }
   5633            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMADelayPulseHalfCplt_3: (+1)
   \       0x30   0x6B28             LDR      R0,[R5, #+48]
   \       0x32   0x4284             CMP      R4,R0
   \       0x34   0xD101             BNE.N    ??TIM_DMADelayPulseHalfCplt_1
   5634            {
   5635              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0x36   0x2008             MOVS     R0,#+8
   \       0x38   0x7728             STRB     R0,[R5, #+28]
   5636            }
   5637            else
   5638            {
   5639              /* nothing to do */
   5640            }
   5641          
   5642          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5643            htim->PWM_PulseFinishedHalfCpltCallback(htim);
   5644          #else
   5645            HAL_TIM_PWM_PulseFinishedHalfCpltCallback(htim);
   \                     ??TIM_DMADelayPulseHalfCplt_1: (+1)
   \       0x3A   0x0028             MOVS     R0,R5
   \       0x3C   0x.... 0x....      BL       HAL_TIM_PWM_PulseFinishedHalfCpltCallback
   5646          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5647          
   5648            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x7728             STRB     R0,[R5, #+28]
   5649          }
   \       0x44   0xBD31             POP      {R0,R4,R5,PC}
   5650          
   5651          /**
   5652            * @brief  TIM DMA Capture complete callback.
   5653            * @param  hdma pointer to DMA handle.
   5654            * @retval None
   5655            */

   \                                 In section .text, align 4, keep-with-next
   5656          void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   5657          {
   \                     TIM_DMACaptureCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5658            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   5659          
   5660            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xF885 0x003D      STRB     R0,[R5, #+61]
   5661          
   5662            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \        0xC   0x6A68             LDR      R0,[R5, #+36]
   \        0xE   0x4284             CMP      R4,R0
   \       0x10   0xD102             BNE.N    ??TIM_DMACaptureCplt_0
   5663            {
   5664              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x7728             STRB     R0,[R5, #+28]
   \       0x16   0xE010             B.N      ??TIM_DMACaptureCplt_1
   5665            }
   5666            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMACaptureCplt_0: (+1)
   \       0x18   0x6AA8             LDR      R0,[R5, #+40]
   \       0x1A   0x4284             CMP      R4,R0
   \       0x1C   0xD102             BNE.N    ??TIM_DMACaptureCplt_2
   5667            {
   5668              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0x7728             STRB     R0,[R5, #+28]
   \       0x22   0xE00A             B.N      ??TIM_DMACaptureCplt_1
   5669            }
   5670            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMACaptureCplt_2: (+1)
   \       0x24   0x6AE8             LDR      R0,[R5, #+44]
   \       0x26   0x4284             CMP      R4,R0
   \       0x28   0xD102             BNE.N    ??TIM_DMACaptureCplt_3
   5671            {
   5672              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x2A   0x2004             MOVS     R0,#+4
   \       0x2C   0x7728             STRB     R0,[R5, #+28]
   \       0x2E   0xE004             B.N      ??TIM_DMACaptureCplt_1
   5673            }
   5674            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMACaptureCplt_3: (+1)
   \       0x30   0x6B28             LDR      R0,[R5, #+48]
   \       0x32   0x4284             CMP      R4,R0
   \       0x34   0xD101             BNE.N    ??TIM_DMACaptureCplt_1
   5675            {
   5676              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0x36   0x2008             MOVS     R0,#+8
   \       0x38   0x7728             STRB     R0,[R5, #+28]
   5677            }
   5678            else
   5679            {
   5680              /* nothing to do */
   5681            }
   5682          
   5683          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5684            htim->IC_CaptureCallback(htim);
   5685          #else
   5686            HAL_TIM_IC_CaptureCallback(htim);
   \                     ??TIM_DMACaptureCplt_1: (+1)
   \       0x3A   0x0028             MOVS     R0,R5
   \       0x3C   0x.... 0x....      BL       HAL_TIM_IC_CaptureCallback
   5687          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5688          
   5689            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x7728             STRB     R0,[R5, #+28]
   5690          }
   \       0x44   0xBD31             POP      {R0,R4,R5,PC}
   5691          
   5692          /**
   5693            * @brief  TIM DMA Capture half complete callback.
   5694            * @param  hdma pointer to DMA handle.
   5695            * @retval None
   5696            */

   \                                 In section .text, align 4, keep-with-next
   5697          void TIM_DMACaptureHalfCplt(DMA_HandleTypeDef *hdma)
   5698          {
   \                     TIM_DMACaptureHalfCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5699            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   5700          
   5701            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xF885 0x003D      STRB     R0,[R5, #+61]
   5702          
   5703            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \        0xC   0x6A68             LDR      R0,[R5, #+36]
   \        0xE   0x4284             CMP      R4,R0
   \       0x10   0xD102             BNE.N    ??TIM_DMACaptureHalfCplt_0
   5704            {
   5705              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x7728             STRB     R0,[R5, #+28]
   \       0x16   0xE010             B.N      ??TIM_DMACaptureHalfCplt_1
   5706            }
   5707            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMACaptureHalfCplt_0: (+1)
   \       0x18   0x6AA8             LDR      R0,[R5, #+40]
   \       0x1A   0x4284             CMP      R4,R0
   \       0x1C   0xD102             BNE.N    ??TIM_DMACaptureHalfCplt_2
   5708            {
   5709              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0x7728             STRB     R0,[R5, #+28]
   \       0x22   0xE00A             B.N      ??TIM_DMACaptureHalfCplt_1
   5710            }
   5711            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMACaptureHalfCplt_2: (+1)
   \       0x24   0x6AE8             LDR      R0,[R5, #+44]
   \       0x26   0x4284             CMP      R4,R0
   \       0x28   0xD102             BNE.N    ??TIM_DMACaptureHalfCplt_3
   5712            {
   5713              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x2A   0x2004             MOVS     R0,#+4
   \       0x2C   0x7728             STRB     R0,[R5, #+28]
   \       0x2E   0xE004             B.N      ??TIM_DMACaptureHalfCplt_1
   5714            }
   5715            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMACaptureHalfCplt_3: (+1)
   \       0x30   0x6B28             LDR      R0,[R5, #+48]
   \       0x32   0x4284             CMP      R4,R0
   \       0x34   0xD101             BNE.N    ??TIM_DMACaptureHalfCplt_1
   5716            {
   5717              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0x36   0x2008             MOVS     R0,#+8
   \       0x38   0x7728             STRB     R0,[R5, #+28]
   5718            }
   5719            else
   5720            {
   5721              /* nothing to do */
   5722            }
   5723          
   5724          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5725            htim->IC_CaptureHalfCpltCallback(htim);
   5726          #else
   5727            HAL_TIM_IC_CaptureHalfCpltCallback(htim);
   \                     ??TIM_DMACaptureHalfCplt_1: (+1)
   \       0x3A   0x0028             MOVS     R0,R5
   \       0x3C   0x.... 0x....      BL       HAL_TIM_IC_CaptureHalfCpltCallback
   5728          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5729          
   5730            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x7728             STRB     R0,[R5, #+28]
   5731          }
   \       0x44   0xBD31             POP      {R0,R4,R5,PC}
   5732          
   5733          /**
   5734            * @brief  TIM DMA Period Elapse complete callback.
   5735            * @param  hdma pointer to DMA handle.
   5736            * @retval None
   5737            */

   \                                 In section .text, align 4, keep-with-next
   5738          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   5739          {
   \                     TIM_DMAPeriodElapsedCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5740            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   5741          
   5742            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xF885 0x003D      STRB     R0,[R5, #+61]
   5743          
   5744          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5745            htim->PeriodElapsedCallback(htim);
   5746          #else
   5747            HAL_TIM_PeriodElapsedCallback(htim);
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x.... 0x....      BL       HAL_TIM_PeriodElapsedCallback
   5748          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5749          }
   \       0x12   0xBD31             POP      {R0,R4,R5,PC}
   5750          
   5751          /**
   5752            * @brief  TIM DMA Period Elapse half complete callback.
   5753            * @param  hdma pointer to DMA handle.
   5754            * @retval None
   5755            */

   \                                 In section .text, align 4, keep-with-next
   5756          static void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma)
   5757          {
   \                     TIM_DMAPeriodElapsedHalfCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5758            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   5759          
   5760            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xF885 0x003D      STRB     R0,[R5, #+61]
   5761          
   5762          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5763            htim->PeriodElapsedHalfCpltCallback(htim);
   5764          #else
   5765            HAL_TIM_PeriodElapsedHalfCpltCallback(htim);
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x.... 0x....      BL       HAL_TIM_PeriodElapsedHalfCpltCallback
   5766          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5767          }
   \       0x12   0xBD31             POP      {R0,R4,R5,PC}
   5768          
   5769          /**
   5770            * @brief  TIM DMA Trigger callback.
   5771            * @param  hdma pointer to DMA handle.
   5772            * @retval None
   5773            */

   \                                 In section .text, align 4, keep-with-next
   5774          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   5775          {
   \                     TIM_DMATriggerCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5776            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   5777          
   5778            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xF885 0x003D      STRB     R0,[R5, #+61]
   5779          
   5780          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5781            htim->TriggerCallback(htim);
   5782          #else
   5783            HAL_TIM_TriggerCallback(htim);
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x.... 0x....      BL       HAL_TIM_TriggerCallback
   5784          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5785          }
   \       0x12   0xBD31             POP      {R0,R4,R5,PC}
   5786          
   5787          /**
   5788            * @brief  TIM DMA Trigger half complete callback.
   5789            * @param  hdma pointer to DMA handle.
   5790            * @retval None
   5791            */

   \                                 In section .text, align 4, keep-with-next
   5792          static void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma)
   5793          {
   \                     TIM_DMATriggerHalfCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5794            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   5795          
   5796            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xF885 0x003D      STRB     R0,[R5, #+61]
   5797          
   5798          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5799            htim->TriggerHalfCpltCallback(htim);
   5800          #else
   5801            HAL_TIM_TriggerHalfCpltCallback(htim);
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x.... 0x....      BL       HAL_TIM_TriggerHalfCpltCallback
   5802          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5803          }
   \       0x12   0xBD31             POP      {R0,R4,R5,PC}
   5804          
   5805          /**
   5806            * @brief  Time Base configuration
   5807            * @param  TIMx TIM peripheral
   5808            * @param  Structure TIM Base configuration structure
   5809            * @retval None
   5810            */

   \                                 In section .text, align 2, keep-with-next
   5811          void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
   5812          {
   \                     TIM_Base_SetConfig: (+1)
   \        0x0   0xB410             PUSH     {R4}
   5813            uint32_t tmpcr1;
   5814            tmpcr1 = TIMx->CR1;
   \        0x2   0x6804             LDR      R4,[R0, #+0]
   5815          
   5816            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   5817            if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   \        0x4   0x.... 0x....      LDR.W    R3,??DataTable28_1
   \        0x8   0x4298             CMP      R0,R3
   \        0xA   0xD012             BEQ.N    ??TIM_Base_SetConfig_0
   \        0xC   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0x10   0xD00F             BEQ.N    ??TIM_Base_SetConfig_0
   \       0x12   0x.... 0x....      LDR.W    R2,??DataTable28_2
   \       0x16   0x4290             CMP      R0,R2
   \       0x18   0xD00B             BEQ.N    ??TIM_Base_SetConfig_0
   \       0x1A   0x.... 0x....      LDR.W    R2,??DataTable28_3
   \       0x1E   0x4290             CMP      R0,R2
   \       0x20   0xD007             BEQ.N    ??TIM_Base_SetConfig_0
   \       0x22   0x.... 0x....      LDR.W    R2,??DataTable28_4
   \       0x26   0x4290             CMP      R0,R2
   \       0x28   0xD003             BEQ.N    ??TIM_Base_SetConfig_0
   \       0x2A   0x.... 0x....      LDR.W    R2,??DataTable28_5
   \       0x2E   0x4290             CMP      R0,R2
   \       0x30   0xD103             BNE.N    ??TIM_Base_SetConfig_1
   5818            {
   5819              /* Select the Counter Mode */
   5820              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   \                     ??TIM_Base_SetConfig_0: (+1)
   \       0x32   0xF034 0x0470      BICS     R4,R4,#0x70
   5821              tmpcr1 |= Structure->CounterMode;
   \       0x36   0x684A             LDR      R2,[R1, #+4]
   \       0x38   0x4314             ORRS     R4,R2,R4
   5822            }
   5823          
   5824            if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   \                     ??TIM_Base_SetConfig_1: (+1)
   \       0x3A   0x4298             CMP      R0,R3
   \       0x3C   0xD028             BEQ.N    ??TIM_Base_SetConfig_2
   \       0x3E   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0x42   0xD025             BEQ.N    ??TIM_Base_SetConfig_2
   \       0x44   0x.... 0x....      LDR.W    R2,??DataTable28_2
   \       0x48   0x4290             CMP      R0,R2
   \       0x4A   0xD021             BEQ.N    ??TIM_Base_SetConfig_2
   \       0x4C   0x.... 0x....      LDR.W    R2,??DataTable28_3
   \       0x50   0x4290             CMP      R0,R2
   \       0x52   0xD01D             BEQ.N    ??TIM_Base_SetConfig_2
   \       0x54   0x.... 0x....      LDR.W    R2,??DataTable28_4
   \       0x58   0x4290             CMP      R0,R2
   \       0x5A   0xD019             BEQ.N    ??TIM_Base_SetConfig_2
   \       0x5C   0x.... 0x....      LDR.W    R2,??DataTable28_5
   \       0x60   0x4290             CMP      R0,R2
   \       0x62   0xD015             BEQ.N    ??TIM_Base_SetConfig_2
   \       0x64   0x.... 0x....      LDR.W    R2,??DataTable28_6
   \       0x68   0x4290             CMP      R0,R2
   \       0x6A   0xD011             BEQ.N    ??TIM_Base_SetConfig_2
   \       0x6C   0x.... 0x....      LDR.W    R2,??DataTable28_7
   \       0x70   0x4290             CMP      R0,R2
   \       0x72   0xD00D             BEQ.N    ??TIM_Base_SetConfig_2
   \       0x74   0x.... 0x....      LDR.W    R2,??DataTable28_8
   \       0x78   0x4290             CMP      R0,R2
   \       0x7A   0xD009             BEQ.N    ??TIM_Base_SetConfig_2
   \       0x7C   0x.... 0x....      LDR.W    R2,??DataTable28_9
   \       0x80   0x4290             CMP      R0,R2
   \       0x82   0xD005             BEQ.N    ??TIM_Base_SetConfig_2
   \       0x84   0x....             LDR.N    R2,??DataTable28_10
   \       0x86   0x4290             CMP      R0,R2
   \       0x88   0xD002             BEQ.N    ??TIM_Base_SetConfig_2
   \       0x8A   0x....             LDR.N    R2,??DataTable28_11
   \       0x8C   0x4290             CMP      R0,R2
   \       0x8E   0xD103             BNE.N    ??TIM_Base_SetConfig_3
   5825            {
   5826              /* Set the clock division */
   5827              tmpcr1 &= ~TIM_CR1_CKD;
   \                     ??TIM_Base_SetConfig_2: (+1)
   \       0x90   0xF434 0x7440      BICS     R4,R4,#0x300
   5828              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   \       0x94   0x68CA             LDR      R2,[R1, #+12]
   \       0x96   0x4314             ORRS     R4,R2,R4
   5829            }
   5830          
   5831            /* Set the auto-reload preload */
   5832            MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
   \                     ??TIM_Base_SetConfig_3: (+1)
   \       0x98   0xF034 0x0480      BICS     R4,R4,#0x80
   \       0x9C   0x694A             LDR      R2,[R1, #+20]
   \       0x9E   0x4314             ORRS     R4,R2,R4
   5833          
   5834            TIMx->CR1 = tmpcr1;
   \       0xA0   0x6004             STR      R4,[R0, #+0]
   5835          
   5836            /* Set the Autoreload value */
   5837            TIMx->ARR = (uint32_t)Structure->Period ;
   \       0xA2   0x688A             LDR      R2,[R1, #+8]
   \       0xA4   0x62C2             STR      R2,[R0, #+44]
   5838          
   5839            /* Set the Prescaler value */
   5840            TIMx->PSC = Structure->Prescaler;
   \       0xA6   0x680A             LDR      R2,[R1, #+0]
   \       0xA8   0x6282             STR      R2,[R0, #+40]
   5841          
   5842            if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
   \       0xAA   0x4298             CMP      R0,R3
   \       0xAC   0xD002             BEQ.N    ??TIM_Base_SetConfig_4
   \       0xAE   0x....             LDR.N    R2,??DataTable28_5
   \       0xB0   0x4290             CMP      R0,R2
   \       0xB2   0xD101             BNE.N    ??TIM_Base_SetConfig_5
   5843            {
   5844              /* Set the Repetition Counter value */
   5845              TIMx->RCR = Structure->RepetitionCounter;
   \                     ??TIM_Base_SetConfig_4: (+1)
   \       0xB4   0x690A             LDR      R2,[R1, #+16]
   \       0xB6   0x6302             STR      R2,[R0, #+48]
   5846            }
   5847          
   5848            /* Generate an update event to reload the Prescaler
   5849               and the repetition counter (only for advanced timer) value immediately */
   5850            TIMx->EGR = TIM_EGR_UG;
   \                     ??TIM_Base_SetConfig_5: (+1)
   \       0xB8   0x2201             MOVS     R2,#+1
   \       0xBA   0x6142             STR      R2,[R0, #+20]
   5851          }
   \       0xBC   0xBC10             POP      {R4}
   \       0xBE   0x4770             BX       LR
   5852          
   5853          /**
   5854            * @brief  Timer Output Compare 1 configuration
   5855            * @param  TIMx to select the TIM peripheral
   5856            * @param  OC_Config The ouput configuration structure
   5857            * @retval None
   5858            */

   \                                 In section .text, align 2, keep-with-next
   5859          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   5860          {
   \                     TIM_OC1_SetConfig: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   5861            uint32_t tmpccmrx;
   5862            uint32_t tmpccer;
   5863            uint32_t tmpcr2;
   5864          
   5865            /* Disable the Channel 1: Reset the CC1E Bit */
   5866            TIMx->CCER &= ~TIM_CCER_CC1E;
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   \        0x4   0x0852             LSRS     R2,R2,#+1
   \        0x6   0x0052             LSLS     R2,R2,#+1
   \        0x8   0x6202             STR      R2,[R0, #+32]
   5867          
   5868            /* Get the TIMx CCER register value */
   5869            tmpccer = TIMx->CCER;
   \        0xA   0x6A04             LDR      R4,[R0, #+32]
   5870            /* Get the TIMx CR2 register value */
   5871            tmpcr2 =  TIMx->CR2;
   \        0xC   0x6845             LDR      R5,[R0, #+4]
   5872          
   5873            /* Get the TIMx CCMR1 register value */
   5874            tmpccmrx = TIMx->CCMR1;
   \        0xE   0x6983             LDR      R3,[R0, #+24]
   5875          
   5876            /* Reset the Output Compare Mode Bits */
   5877            tmpccmrx &= ~TIM_CCMR1_OC1M;
   \       0x10   0xF033 0x0370      BICS     R3,R3,#0x70
   5878            tmpccmrx &= ~TIM_CCMR1_CC1S;
   \       0x14   0x089B             LSRS     R3,R3,#+2
   \       0x16   0x009B             LSLS     R3,R3,#+2
   5879            /* Select the Output Compare Mode */
   5880            tmpccmrx |= OC_Config->OCMode;
   \       0x18   0x680A             LDR      R2,[R1, #+0]
   \       0x1A   0x4313             ORRS     R3,R2,R3
   5881          
   5882            /* Reset the Output Polarity level */
   5883            tmpccer &= ~TIM_CCER_CC1P;
   \       0x1C   0xF034 0x0402      BICS     R4,R4,#0x2
   5884            /* Set the Output Compare Polarity */
   5885            tmpccer |= OC_Config->OCPolarity;
   \       0x20   0x688A             LDR      R2,[R1, #+8]
   \       0x22   0x4314             ORRS     R4,R2,R4
   5886          
   5887            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   \       0x24   0x....             LDR.N    R6,??DataTable28_1
   \       0x26   0x42B0             CMP      R0,R6
   \       0x28   0xD002             BEQ.N    ??TIM_OC1_SetConfig_0
   \       0x2A   0x....             LDR.N    R2,??DataTable28_5
   \       0x2C   0x4290             CMP      R0,R2
   \       0x2E   0xD105             BNE.N    ??TIM_OC1_SetConfig_1
   5888            {
   5889              /* Check parameters */
   5890              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   5891          
   5892              /* Reset the Output N Polarity level */
   5893              tmpccer &= ~TIM_CCER_CC1NP;
   \                     ??TIM_OC1_SetConfig_0: (+1)
   \       0x30   0xF034 0x0408      BICS     R4,R4,#0x8
   5894              /* Set the Output N Polarity */
   5895              tmpccer |= OC_Config->OCNPolarity;
   \       0x34   0x68CA             LDR      R2,[R1, #+12]
   \       0x36   0x4314             ORRS     R4,R2,R4
   5896              /* Reset the Output N State */
   5897              tmpccer &= ~TIM_CCER_CC1NE;
   \       0x38   0xF034 0x0404      BICS     R4,R4,#0x4
   5898            }
   5899          
   5900            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \                     ??TIM_OC1_SetConfig_1: (+1)
   \       0x3C   0x42B0             CMP      R0,R6
   \       0x3E   0xD002             BEQ.N    ??TIM_OC1_SetConfig_2
   \       0x40   0x....             LDR.N    R2,??DataTable28_5
   \       0x42   0x4290             CMP      R0,R2
   \       0x44   0xD107             BNE.N    ??TIM_OC1_SetConfig_3
   5901            {
   5902              /* Check parameters */
   5903              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   5904              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   5905          
   5906              /* Reset the Output Compare and Output Compare N IDLE State */
   5907              tmpcr2 &= ~TIM_CR2_OIS1;
   \                     ??TIM_OC1_SetConfig_2: (+1)
   \       0x46   0xF435 0x7580      BICS     R5,R5,#0x100
   5908              tmpcr2 &= ~TIM_CR2_OIS1N;
   \       0x4A   0xF435 0x7500      BICS     R5,R5,#0x200
   5909              /* Set the Output Idle state */
   5910              tmpcr2 |= OC_Config->OCIdleState;
   \       0x4E   0x694A             LDR      R2,[R1, #+20]
   \       0x50   0x4315             ORRS     R5,R2,R5
   5911              /* Set the Output N Idle state */
   5912              tmpcr2 |= OC_Config->OCNIdleState;
   \       0x52   0x698A             LDR      R2,[R1, #+24]
   \       0x54   0x4315             ORRS     R5,R2,R5
   5913            }
   5914          
   5915            /* Write to TIMx CR2 */
   5916            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC1_SetConfig_3: (+1)
   \       0x56   0x6045             STR      R5,[R0, #+4]
   5917          
   5918            /* Write to TIMx CCMR1 */
   5919            TIMx->CCMR1 = tmpccmrx;
   \       0x58   0x6183             STR      R3,[R0, #+24]
   5920          
   5921            /* Set the Capture Compare Register value */
   5922            TIMx->CCR1 = OC_Config->Pulse;
   \       0x5A   0x684A             LDR      R2,[R1, #+4]
   \       0x5C   0x6342             STR      R2,[R0, #+52]
   5923          
   5924            /* Write to TIMx CCER */
   5925            TIMx->CCER = tmpccer;
   \       0x5E   0x6204             STR      R4,[R0, #+32]
   5926          }
   \       0x60   0xBC70             POP      {R4-R6}
   \       0x62   0x4770             BX       LR
   5927          
   5928          /**
   5929            * @brief  Timer Output Compare 2 configuration
   5930            * @param  TIMx to select the TIM peripheral
   5931            * @param  OC_Config The ouput configuration structure
   5932            * @retval None
   5933            */

   \                                 In section .text, align 2, keep-with-next
   5934          void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   5935          {
   \                     TIM_OC2_SetConfig: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   5936            uint32_t tmpccmrx;
   5937            uint32_t tmpccer;
   5938            uint32_t tmpcr2;
   5939          
   5940            /* Disable the Channel 2: Reset the CC2E Bit */
   5941            TIMx->CCER &= ~TIM_CCER_CC2E;
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   \        0x4   0xF032 0x0210      BICS     R2,R2,#0x10
   \        0x8   0x6202             STR      R2,[R0, #+32]
   5942          
   5943            /* Get the TIMx CCER register value */
   5944            tmpccer = TIMx->CCER;
   \        0xA   0x6A03             LDR      R3,[R0, #+32]
   5945            /* Get the TIMx CR2 register value */
   5946            tmpcr2 =  TIMx->CR2;
   \        0xC   0x6844             LDR      R4,[R0, #+4]
   5947          
   5948            /* Get the TIMx CCMR1 register value */
   5949            tmpccmrx = TIMx->CCMR1;
   \        0xE   0x6982             LDR      R2,[R0, #+24]
   5950          
   5951            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   5952            tmpccmrx &= ~TIM_CCMR1_OC2M;
   \       0x10   0xF432 0x42E0      BICS     R2,R2,#0x7000
   5953            tmpccmrx &= ~TIM_CCMR1_CC2S;
   \       0x14   0xF432 0x7240      BICS     R2,R2,#0x300
   5954          
   5955            /* Select the Output Compare Mode */
   5956            tmpccmrx |= (OC_Config->OCMode << 8U);
   \       0x18   0x680D             LDR      R5,[R1, #+0]
   \       0x1A   0xEA52 0x2205      ORRS     R2,R2,R5, LSL #+8
   5957          
   5958            /* Reset the Output Polarity level */
   5959            tmpccer &= ~TIM_CCER_CC2P;
   \       0x1E   0xF033 0x0320      BICS     R3,R3,#0x20
   5960            /* Set the Output Compare Polarity */
   5961            tmpccer |= (OC_Config->OCPolarity << 4U);
   \       0x22   0x688D             LDR      R5,[R1, #+8]
   \       0x24   0xEA53 0x1305      ORRS     R3,R3,R5, LSL #+4
   5962          
   5963            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   \       0x28   0x....             LDR.N    R5,??DataTable28_1
   \       0x2A   0x42A8             CMP      R0,R5
   \       0x2C   0xD002             BEQ.N    ??TIM_OC2_SetConfig_0
   \       0x2E   0x....             LDR.N    R6,??DataTable28_5
   \       0x30   0x42B0             CMP      R0,R6
   \       0x32   0xD106             BNE.N    ??TIM_OC2_SetConfig_1
   5964            {
   5965              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   5966          
   5967              /* Reset the Output N Polarity level */
   5968              tmpccer &= ~TIM_CCER_CC2NP;
   \                     ??TIM_OC2_SetConfig_0: (+1)
   \       0x34   0xF033 0x0380      BICS     R3,R3,#0x80
   5969              /* Set the Output N Polarity */
   5970              tmpccer |= (OC_Config->OCNPolarity << 4U);
   \       0x38   0x68CE             LDR      R6,[R1, #+12]
   \       0x3A   0xEA53 0x1306      ORRS     R3,R3,R6, LSL #+4
   5971              /* Reset the Output N State */
   5972              tmpccer &= ~TIM_CCER_CC2NE;
   \       0x3E   0xF033 0x0340      BICS     R3,R3,#0x40
   5973          
   5974            }
   5975          
   5976            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \                     ??TIM_OC2_SetConfig_1: (+1)
   \       0x42   0x42A8             CMP      R0,R5
   \       0x44   0xD002             BEQ.N    ??TIM_OC2_SetConfig_2
   \       0x46   0x....             LDR.N    R5,??DataTable28_5
   \       0x48   0x42A8             CMP      R0,R5
   \       0x4A   0xD109             BNE.N    ??TIM_OC2_SetConfig_3
   5977            {
   5978              /* Check parameters */
   5979              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   5980              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   5981          
   5982              /* Reset the Output Compare and Output Compare N IDLE State */
   5983              tmpcr2 &= ~TIM_CR2_OIS2;
   \                     ??TIM_OC2_SetConfig_2: (+1)
   \       0x4C   0xF434 0x6480      BICS     R4,R4,#0x400
   5984              tmpcr2 &= ~TIM_CR2_OIS2N;
   \       0x50   0xF434 0x6400      BICS     R4,R4,#0x800
   5985              /* Set the Output Idle state */
   5986              tmpcr2 |= (OC_Config->OCIdleState << 2U);
   \       0x54   0x694D             LDR      R5,[R1, #+20]
   \       0x56   0xEA54 0x0485      ORRS     R4,R4,R5, LSL #+2
   5987              /* Set the Output N Idle state */
   5988              tmpcr2 |= (OC_Config->OCNIdleState << 2U);
   \       0x5A   0x698D             LDR      R5,[R1, #+24]
   \       0x5C   0xEA54 0x0485      ORRS     R4,R4,R5, LSL #+2
   5989            }
   5990          
   5991            /* Write to TIMx CR2 */
   5992            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC2_SetConfig_3: (+1)
   \       0x60   0x6044             STR      R4,[R0, #+4]
   5993          
   5994            /* Write to TIMx CCMR1 */
   5995            TIMx->CCMR1 = tmpccmrx;
   \       0x62   0x6182             STR      R2,[R0, #+24]
   5996          
   5997            /* Set the Capture Compare Register value */
   5998            TIMx->CCR2 = OC_Config->Pulse;
   \       0x64   0x684D             LDR      R5,[R1, #+4]
   \       0x66   0x6385             STR      R5,[R0, #+56]
   5999          
   6000            /* Write to TIMx CCER */
   6001            TIMx->CCER = tmpccer;
   \       0x68   0x6203             STR      R3,[R0, #+32]
   6002          }
   \       0x6A   0xBC70             POP      {R4-R6}
   \       0x6C   0x4770             BX       LR
   6003          
   6004          /**
   6005            * @brief  Timer Output Compare 3 configuration
   6006            * @param  TIMx to select the TIM peripheral
   6007            * @param  OC_Config The ouput configuration structure
   6008            * @retval None
   6009            */

   \                                 In section .text, align 2, keep-with-next
   6010          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   6011          {
   \                     TIM_OC3_SetConfig: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   6012            uint32_t tmpccmrx;
   6013            uint32_t tmpccer;
   6014            uint32_t tmpcr2;
   6015          
   6016            /* Disable the Channel 3: Reset the CC2E Bit */
   6017            TIMx->CCER &= ~TIM_CCER_CC3E;
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   \        0x4   0xF432 0x7280      BICS     R2,R2,#0x100
   \        0x8   0x6202             STR      R2,[R0, #+32]
   6018          
   6019            /* Get the TIMx CCER register value */
   6020            tmpccer = TIMx->CCER;
   \        0xA   0x6A04             LDR      R4,[R0, #+32]
   6021            /* Get the TIMx CR2 register value */
   6022            tmpcr2 =  TIMx->CR2;
   \        0xC   0x6845             LDR      R5,[R0, #+4]
   6023          
   6024            /* Get the TIMx CCMR2 register value */
   6025            tmpccmrx = TIMx->CCMR2;
   \        0xE   0x69C3             LDR      R3,[R0, #+28]
   6026          
   6027            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   6028            tmpccmrx &= ~TIM_CCMR2_OC3M;
   \       0x10   0xF033 0x0370      BICS     R3,R3,#0x70
   6029            tmpccmrx &= ~TIM_CCMR2_CC3S;
   \       0x14   0x089B             LSRS     R3,R3,#+2
   \       0x16   0x009B             LSLS     R3,R3,#+2
   6030            /* Select the Output Compare Mode */
   6031            tmpccmrx |= OC_Config->OCMode;
   \       0x18   0x680A             LDR      R2,[R1, #+0]
   \       0x1A   0x4313             ORRS     R3,R2,R3
   6032          
   6033            /* Reset the Output Polarity level */
   6034            tmpccer &= ~TIM_CCER_CC3P;
   \       0x1C   0xF434 0x7400      BICS     R4,R4,#0x200
   6035            /* Set the Output Compare Polarity */
   6036            tmpccer |= (OC_Config->OCPolarity << 8U);
   \       0x20   0x688A             LDR      R2,[R1, #+8]
   \       0x22   0xEA54 0x2402      ORRS     R4,R4,R2, LSL #+8
   6037          
   6038            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   \       0x26   0x....             LDR.N    R2,??DataTable28_1
   \       0x28   0x4290             CMP      R0,R2
   \       0x2A   0xD002             BEQ.N    ??TIM_OC3_SetConfig_0
   \       0x2C   0x....             LDR.N    R6,??DataTable28_5
   \       0x2E   0x42B0             CMP      R0,R6
   \       0x30   0xD106             BNE.N    ??TIM_OC3_SetConfig_1
   6039            {
   6040              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   6041          
   6042              /* Reset the Output N Polarity level */
   6043              tmpccer &= ~TIM_CCER_CC3NP;
   \                     ??TIM_OC3_SetConfig_0: (+1)
   \       0x32   0xF434 0x6400      BICS     R4,R4,#0x800
   6044              /* Set the Output N Polarity */
   6045              tmpccer |= (OC_Config->OCNPolarity << 8U);
   \       0x36   0x68CE             LDR      R6,[R1, #+12]
   \       0x38   0xEA54 0x2406      ORRS     R4,R4,R6, LSL #+8
   6046              /* Reset the Output N State */
   6047              tmpccer &= ~TIM_CCER_CC3NE;
   \       0x3C   0xF434 0x6480      BICS     R4,R4,#0x400
   6048            }
   6049          
   6050            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \                     ??TIM_OC3_SetConfig_1: (+1)
   \       0x40   0x4290             CMP      R0,R2
   \       0x42   0xD002             BEQ.N    ??TIM_OC3_SetConfig_2
   \       0x44   0x....             LDR.N    R2,??DataTable28_5
   \       0x46   0x4290             CMP      R0,R2
   \       0x48   0xD109             BNE.N    ??TIM_OC3_SetConfig_3
   6051            {
   6052              /* Check parameters */
   6053              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   6054              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   6055          
   6056              /* Reset the Output Compare and Output Compare N IDLE State */
   6057              tmpcr2 &= ~TIM_CR2_OIS3;
   \                     ??TIM_OC3_SetConfig_2: (+1)
   \       0x4A   0xF435 0x5580      BICS     R5,R5,#0x1000
   6058              tmpcr2 &= ~TIM_CR2_OIS3N;
   \       0x4E   0xF435 0x5500      BICS     R5,R5,#0x2000
   6059              /* Set the Output Idle state */
   6060              tmpcr2 |= (OC_Config->OCIdleState << 4U);
   \       0x52   0x694A             LDR      R2,[R1, #+20]
   \       0x54   0xEA55 0x1502      ORRS     R5,R5,R2, LSL #+4
   6061              /* Set the Output N Idle state */
   6062              tmpcr2 |= (OC_Config->OCNIdleState << 4U);
   \       0x58   0x698A             LDR      R2,[R1, #+24]
   \       0x5A   0xEA55 0x1502      ORRS     R5,R5,R2, LSL #+4
   6063            }
   6064          
   6065            /* Write to TIMx CR2 */
   6066            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC3_SetConfig_3: (+1)
   \       0x5E   0x6045             STR      R5,[R0, #+4]
   6067          
   6068            /* Write to TIMx CCMR2 */
   6069            TIMx->CCMR2 = tmpccmrx;
   \       0x60   0x61C3             STR      R3,[R0, #+28]
   6070          
   6071            /* Set the Capture Compare Register value */
   6072            TIMx->CCR3 = OC_Config->Pulse;
   \       0x62   0x684A             LDR      R2,[R1, #+4]
   \       0x64   0x63C2             STR      R2,[R0, #+60]
   6073          
   6074            /* Write to TIMx CCER */
   6075            TIMx->CCER = tmpccer;
   \       0x66   0x6204             STR      R4,[R0, #+32]
   6076          }
   \       0x68   0xBC70             POP      {R4-R6}
   \       0x6A   0x4770             BX       LR
   6077          
   6078          /**
   6079            * @brief  Timer Output Compare 4 configuration
   6080            * @param  TIMx to select the TIM peripheral
   6081            * @param  OC_Config The ouput configuration structure
   6082            * @retval None
   6083            */

   \                                 In section .text, align 2, keep-with-next
   6084          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   6085          {
   \                     TIM_OC4_SetConfig: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   6086            uint32_t tmpccmrx;
   6087            uint32_t tmpccer;
   6088            uint32_t tmpcr2;
   6089          
   6090            /* Disable the Channel 4: Reset the CC4E Bit */
   6091            TIMx->CCER &= ~TIM_CCER_CC4E;
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   \        0x4   0xF432 0x5280      BICS     R2,R2,#0x1000
   \        0x8   0x6202             STR      R2,[R0, #+32]
   6092          
   6093            /* Get the TIMx CCER register value */
   6094            tmpccer = TIMx->CCER;
   \        0xA   0x6A03             LDR      R3,[R0, #+32]
   6095            /* Get the TIMx CR2 register value */
   6096            tmpcr2 =  TIMx->CR2;
   \        0xC   0x6844             LDR      R4,[R0, #+4]
   6097          
   6098            /* Get the TIMx CCMR2 register value */
   6099            tmpccmrx = TIMx->CCMR2;
   \        0xE   0x69C2             LDR      R2,[R0, #+28]
   6100          
   6101            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   6102            tmpccmrx &= ~TIM_CCMR2_OC4M;
   \       0x10   0xF432 0x42E0      BICS     R2,R2,#0x7000
   6103            tmpccmrx &= ~TIM_CCMR2_CC4S;
   \       0x14   0xF432 0x7240      BICS     R2,R2,#0x300
   6104          
   6105            /* Select the Output Compare Mode */
   6106            tmpccmrx |= (OC_Config->OCMode << 8U);
   \       0x18   0x680D             LDR      R5,[R1, #+0]
   \       0x1A   0xEA52 0x2205      ORRS     R2,R2,R5, LSL #+8
   6107          
   6108            /* Reset the Output Polarity level */
   6109            tmpccer &= ~TIM_CCER_CC4P;
   \       0x1E   0xF433 0x5300      BICS     R3,R3,#0x2000
   6110            /* Set the Output Compare Polarity */
   6111            tmpccer |= (OC_Config->OCPolarity << 12U);
   \       0x22   0x688D             LDR      R5,[R1, #+8]
   \       0x24   0xEA53 0x3305      ORRS     R3,R3,R5, LSL #+12
   6112          
   6113            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \       0x28   0x....             LDR.N    R5,??DataTable28_1
   \       0x2A   0x42A8             CMP      R0,R5
   \       0x2C   0xD002             BEQ.N    ??TIM_OC4_SetConfig_0
   \       0x2E   0x....             LDR.N    R5,??DataTable28_5
   \       0x30   0x42A8             CMP      R0,R5
   \       0x32   0xD104             BNE.N    ??TIM_OC4_SetConfig_1
   6114            {
   6115              /* Check parameters */
   6116              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   6117          
   6118              /* Reset the Output Compare IDLE State */
   6119              tmpcr2 &= ~TIM_CR2_OIS4;
   \                     ??TIM_OC4_SetConfig_0: (+1)
   \       0x34   0xF434 0x4480      BICS     R4,R4,#0x4000
   6120          
   6121              /* Set the Output Idle state */
   6122              tmpcr2 |= (OC_Config->OCIdleState << 6U);
   \       0x38   0x694D             LDR      R5,[R1, #+20]
   \       0x3A   0xEA54 0x1485      ORRS     R4,R4,R5, LSL #+6
   6123            }
   6124          
   6125            /* Write to TIMx CR2 */
   6126            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC4_SetConfig_1: (+1)
   \       0x3E   0x6044             STR      R4,[R0, #+4]
   6127          
   6128            /* Write to TIMx CCMR2 */
   6129            TIMx->CCMR2 = tmpccmrx;
   \       0x40   0x61C2             STR      R2,[R0, #+28]
   6130          
   6131            /* Set the Capture Compare Register value */
   6132            TIMx->CCR4 = OC_Config->Pulse;
   \       0x42   0x684D             LDR      R5,[R1, #+4]
   \       0x44   0x6405             STR      R5,[R0, #+64]
   6133          
   6134            /* Write to TIMx CCER */
   6135            TIMx->CCER = tmpccer;
   \       0x46   0x6203             STR      R3,[R0, #+32]
   6136          }
   \       0x48   0xBC30             POP      {R4,R5}
   \       0x4A   0x4770             BX       LR
   6137          
   6138          /**
   6139            * @brief  Slave Timer configuration function
   6140            * @param  htim TIM handle
   6141            * @param  sSlaveConfig Slave timer configuration
   6142            * @retval None
   6143            */

   \                                 In section .text, align 2, keep-with-next
   6144          static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
   6145                                                            TIM_SlaveConfigTypeDef *sSlaveConfig)
   6146          {
   \                     TIM_SlaveTimer_SetConfig: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   6147            uint32_t tmpsmcr;
   6148            uint32_t tmpccmr1;
   6149            uint32_t tmpccer;
   6150          
   6151            /* Get the TIMx SMCR register value */
   6152            tmpsmcr = htim->Instance->SMCR;
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0xF8D0 0x8008      LDR      R8,[R0, #+8]
   6153          
   6154            /* Reset the Trigger Selection Bits */
   6155            tmpsmcr &= ~TIM_SMCR_TS;
   \        0xE   0xF038 0x0870      BICS     R8,R8,#0x70
   6156            /* Set the Input Trigger source */
   6157            tmpsmcr |= sSlaveConfig->InputTrigger;
   \       0x12   0x6868             LDR      R0,[R5, #+4]
   \       0x14   0xEA50 0x0808      ORRS     R8,R0,R8
   6158          
   6159            /* Reset the slave mode Bits */
   6160            tmpsmcr &= ~TIM_SMCR_SMS;
   \       0x18   0xEA5F 0x08D8      LSRS     R8,R8,#+3
   \       0x1C   0xEA5F 0x08C8      LSLS     R8,R8,#+3
   6161            /* Set the slave mode */
   6162            tmpsmcr |= sSlaveConfig->SlaveMode;
   \       0x20   0x6828             LDR      R0,[R5, #+0]
   \       0x22   0xEA50 0x0808      ORRS     R8,R0,R8
   6163          
   6164            /* Write to TIMx SMCR */
   6165            htim->Instance->SMCR = tmpsmcr;
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0xF8C0 0x8008      STR      R8,[R0, #+8]
   6166          
   6167            /* Configure the trigger prescaler, filter, and polarity */
   6168            switch (sSlaveConfig->InputTrigger)
   \       0x2C   0x6868             LDR      R0,[R5, #+4]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD03B             BEQ.N    ??TIM_SlaveTimer_SetConfig_0
   \       0x32   0x2810             CMP      R0,#+16
   \       0x34   0xD039             BEQ.N    ??TIM_SlaveTimer_SetConfig_0
   \       0x36   0x2820             CMP      R0,#+32
   \       0x38   0xD037             BEQ.N    ??TIM_SlaveTimer_SetConfig_0
   \       0x3A   0x2830             CMP      R0,#+48
   \       0x3C   0xD035             BEQ.N    ??TIM_SlaveTimer_SetConfig_0
   \       0x3E   0x2840             CMP      R0,#+64
   \       0x40   0xD00C             BEQ.N    ??TIM_SlaveTimer_SetConfig_1
   \       0x42   0x2850             CMP      R0,#+80
   \       0x44   0xD025             BEQ.N    ??TIM_SlaveTimer_SetConfig_2
   \       0x46   0x2860             CMP      R0,#+96
   \       0x48   0xD029             BEQ.N    ??TIM_SlaveTimer_SetConfig_3
   \       0x4A   0x2870             CMP      R0,#+112
   \       0x4C   0xD12E             BNE.N    ??TIM_SlaveTimer_SetConfig_4
   6169            {
   6170              case TIM_TS_ETRF:
   6171              {
   6172                /* Check the parameters */
   6173                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   6174                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   6175                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   6176                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6177                /* Configure the ETR Trigger source */
   6178                TIM_ETR_SetConfig(htim->Instance,
   6179                                  sSlaveConfig->TriggerPrescaler,
   6180                                  sSlaveConfig->TriggerPolarity,
   6181                                  sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_5: (+1)
   \       0x4E   0x692B             LDR      R3,[R5, #+16]
   \       0x50   0x68AA             LDR      R2,[R5, #+8]
   \       0x52   0x68E9             LDR      R1,[R5, #+12]
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x.... 0x....      BL       TIM_ETR_SetConfig
   6182                break;
   \       0x5A   0xE027             B.N      ??TIM_SlaveTimer_SetConfig_6
   6183              }
   6184          
   6185              case TIM_TS_TI1F_ED:
   6186              {
   6187                /* Check the parameters */
   6188                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   6189                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6190          
   6191                if(sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED)
   \                     ??TIM_SlaveTimer_SetConfig_1: (+1)
   \       0x5C   0x6828             LDR      R0,[R5, #+0]
   \       0x5E   0x2805             CMP      R0,#+5
   \       0x60   0xD101             BNE.N    ??TIM_SlaveTimer_SetConfig_7
   6192                {
   6193                  return HAL_ERROR;
   \       0x62   0x2001             MOVS     R0,#+1
   \       0x64   0xE023             B.N      ??TIM_SlaveTimer_SetConfig_8
   6194                }
   6195          
   6196                /* Disable the Channel 1: Reset the CC1E Bit */
   6197                tmpccer = htim->Instance->CCER;
   \                     ??TIM_SlaveTimer_SetConfig_7: (+1)
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x6A00             LDR      R0,[R0, #+32]
   \       0x6A   0x0007             MOVS     R7,R0
   6198                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x6A00             LDR      R0,[R0, #+32]
   \       0x70   0x0840             LSRS     R0,R0,#+1
   \       0x72   0x0040             LSLS     R0,R0,#+1
   \       0x74   0x6821             LDR      R1,[R4, #+0]
   \       0x76   0x6208             STR      R0,[R1, #+32]
   6199                tmpccmr1 = htim->Instance->CCMR1;
   \       0x78   0x6820             LDR      R0,[R4, #+0]
   \       0x7A   0x6980             LDR      R0,[R0, #+24]
   6200          
   6201                /* Set the filter */
   6202                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   \       0x7C   0xF030 0x00F0      BICS     R0,R0,#0xF0
   6203                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
   \       0x80   0x6929             LDR      R1,[R5, #+16]
   \       0x82   0xEA50 0x1001      ORRS     R0,R0,R1, LSL #+4
   \       0x86   0x0006             MOVS     R6,R0
   6204          
   6205                /* Write to TIMx CCMR1 and CCER registers */
   6206                htim->Instance->CCMR1 = tmpccmr1;
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6186             STR      R6,[R0, #+24]
   6207                htim->Instance->CCER = tmpccer;
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x6207             STR      R7,[R0, #+32]
   6208                break;
   \       0x90   0xE00C             B.N      ??TIM_SlaveTimer_SetConfig_6
   6209              }
   6210          
   6211              case TIM_TS_TI1FP1:
   6212              {
   6213                /* Check the parameters */
   6214                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   6215                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   6216                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6217          
   6218                /* Configure TI1 Filter and Polarity */
   6219                TIM_TI1_ConfigInputStage(htim->Instance,
   6220                                         sSlaveConfig->TriggerPolarity,
   6221                                         sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_2: (+1)
   \       0x92   0x692A             LDR      R2,[R5, #+16]
   \       0x94   0x68A9             LDR      R1,[R5, #+8]
   \       0x96   0x6820             LDR      R0,[R4, #+0]
   \       0x98   0x.... 0x....      BL       TIM_TI1_ConfigInputStage
   6222                break;
   \       0x9C   0xE006             B.N      ??TIM_SlaveTimer_SetConfig_6
   6223              }
   6224          
   6225              case TIM_TS_TI2FP2:
   6226              {
   6227                /* Check the parameters */
   6228                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   6229                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   6230                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6231          
   6232                /* Configure TI2 Filter and Polarity */
   6233                TIM_TI2_ConfigInputStage(htim->Instance,
   6234                                         sSlaveConfig->TriggerPolarity,
   6235                                         sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_3: (+1)
   \       0x9E   0x692A             LDR      R2,[R5, #+16]
   \       0xA0   0x68A9             LDR      R1,[R5, #+8]
   \       0xA2   0x6820             LDR      R0,[R4, #+0]
   \       0xA4   0x.... 0x....      BL       TIM_TI2_ConfigInputStage
   6236                break;
   \       0xA8   0xE000             B.N      ??TIM_SlaveTimer_SetConfig_6
   6237              }
   6238          
   6239              case TIM_TS_ITR0:
   6240              case TIM_TS_ITR1:
   6241              case TIM_TS_ITR2:
   6242              case TIM_TS_ITR3:
   6243              {
   6244                /* Check the parameter */
   6245                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   6246                break;
   \                     ??TIM_SlaveTimer_SetConfig_0: (+1)
   \       0xAA   0xE7FF             B.N      ??TIM_SlaveTimer_SetConfig_6
   6247              }
   6248          
   6249              default:
   6250                break;
   6251            }
   6252            return HAL_OK;
   \                     ??TIM_SlaveTimer_SetConfig_4: (+1)
   \                     ??TIM_SlaveTimer_SetConfig_6: (+1)
   \       0xAC   0x2000             MOVS     R0,#+0
   \                     ??TIM_SlaveTimer_SetConfig_8: (+1)
   \       0xAE   0xE8BD 0x81F0      POP      {R4-R8,PC}
   6253          }
   6254          
   6255          /**
   6256            * @brief  Configure the TI1 as Input.
   6257            * @param  TIMx to select the TIM peripheral.
   6258            * @param  TIM_ICPolarity The Input Polarity.
   6259            *          This parameter can be one of the following values:
   6260            *            @arg TIM_ICPOLARITY_RISING
   6261            *            @arg TIM_ICPOLARITY_FALLING
   6262            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6263            * @param  TIM_ICSelection specifies the input to be used.
   6264            *          This parameter can be one of the following values:
   6265            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 1 is selected to be connected to IC1.
   6266            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 1 is selected to be connected to IC2.
   6267            *            @arg TIM_ICSELECTION_TRC: TIM Input 1 is selected to be connected to TRC.
   6268            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6269            *          This parameter must be a value between 0x00 and 0x0F.
   6270            * @retval None
   6271            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1
   6272            *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be
   6273            *        protected against un-initialized filter and polarity values.
   6274            */

   \                                 In section .text, align 2, keep-with-next
   6275          void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6276                                 uint32_t TIM_ICFilter)
   6277          {
   \                     TIM_TI1_SetConfig: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   6278            uint32_t tmpccmr1;
   6279            uint32_t tmpccer;
   6280          
   6281            /* Disable the Channel 1: Reset the CC1E Bit */
   6282            TIMx->CCER &= ~TIM_CCER_CC1E;
   \        0x2   0x6A04             LDR      R4,[R0, #+32]
   \        0x4   0x0864             LSRS     R4,R4,#+1
   \        0x6   0x0064             LSLS     R4,R4,#+1
   \        0x8   0x6204             STR      R4,[R0, #+32]
   6283            tmpccmr1 = TIMx->CCMR1;
   \        0xA   0x6985             LDR      R5,[R0, #+24]
   6284            tmpccer = TIMx->CCER;
   \        0xC   0x6A06             LDR      R6,[R0, #+32]
   6285          
   6286            /* Select the Input */
   6287            if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   \        0xE   0x....             LDR.N    R4,??DataTable28_1
   \       0x10   0x42A0             CMP      R0,R4
   \       0x12   0xD014             BEQ.N    ??TIM_TI1_SetConfig_0
   \       0x14   0xF1B0 0x4F80      CMP      R0,#+1073741824
   \       0x18   0xD011             BEQ.N    ??TIM_TI1_SetConfig_0
   \       0x1A   0x....             LDR.N    R4,??DataTable28_2
   \       0x1C   0x42A0             CMP      R0,R4
   \       0x1E   0xD00E             BEQ.N    ??TIM_TI1_SetConfig_0
   \       0x20   0x....             LDR.N    R4,??DataTable28_3
   \       0x22   0x42A0             CMP      R0,R4
   \       0x24   0xD00B             BEQ.N    ??TIM_TI1_SetConfig_0
   \       0x26   0x....             LDR.N    R4,??DataTable28_4
   \       0x28   0x42A0             CMP      R0,R4
   \       0x2A   0xD008             BEQ.N    ??TIM_TI1_SetConfig_0
   \       0x2C   0x....             LDR.N    R4,??DataTable28_5
   \       0x2E   0x42A0             CMP      R0,R4
   \       0x30   0xD005             BEQ.N    ??TIM_TI1_SetConfig_0
   \       0x32   0x....             LDR.N    R4,??DataTable28_6
   \       0x34   0x42A0             CMP      R0,R4
   \       0x36   0xD002             BEQ.N    ??TIM_TI1_SetConfig_0
   \       0x38   0x....             LDR.N    R4,??DataTable28_9
   \       0x3A   0x42A0             CMP      R0,R4
   \       0x3C   0xD101             BNE.N    ??TIM_TI1_SetConfig_1
   \                     ??TIM_TI1_SetConfig_0: (+1)
   \       0x3E   0x2401             MOVS     R4,#+1
   \       0x40   0xE000             B.N      ??TIM_TI1_SetConfig_2
   \                     ??TIM_TI1_SetConfig_1: (+1)
   \       0x42   0x2400             MOVS     R4,#+0
   \                     ??TIM_TI1_SetConfig_2: (+1)
   \       0x44   0xB2E4             UXTB     R4,R4
   \       0x46   0x2C00             CMP      R4,#+0
   \       0x48   0xD003             BEQ.N    ??TIM_TI1_SetConfig_3
   6288            {
   6289              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   \       0x4A   0x08AD             LSRS     R5,R5,#+2
   \       0x4C   0x00AD             LSLS     R5,R5,#+2
   6290              tmpccmr1 |= TIM_ICSelection;
   \       0x4E   0x4315             ORRS     R5,R2,R5
   \       0x50   0xE001             B.N      ??TIM_TI1_SetConfig_4
   6291            }
   6292            else
   6293            {
   6294              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   \                     ??TIM_TI1_SetConfig_3: (+1)
   \       0x52   0xF055 0x0501      ORRS     R5,R5,#0x1
   6295            }
   6296          
   6297            /* Set the filter */
   6298            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   \                     ??TIM_TI1_SetConfig_4: (+1)
   \       0x56   0xF035 0x05F0      BICS     R5,R5,#0xF0
   6299            tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
   \       0x5A   0x011C             LSLS     R4,R3,#+4
   \       0x5C   0xF014 0x04F0      ANDS     R4,R4,#0xF0
   \       0x60   0x4325             ORRS     R5,R4,R5
   6300          
   6301            /* Select the Polarity and set the CC1E Bit */
   6302            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   \       0x62   0xF036 0x060A      BICS     R6,R6,#0xA
   6303            tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
   \       0x66   0xF011 0x040A      ANDS     R4,R1,#0xA
   \       0x6A   0x4326             ORRS     R6,R4,R6
   6304          
   6305            /* Write to TIMx CCMR1 and CCER registers */
   6306            TIMx->CCMR1 = tmpccmr1;
   \       0x6C   0x6185             STR      R5,[R0, #+24]
   6307            TIMx->CCER = tmpccer;
   \       0x6E   0x6206             STR      R6,[R0, #+32]
   6308          }
   \       0x70   0xBC70             POP      {R4-R6}
   \       0x72   0x4770             BX       LR
   6309          
   6310          /**
   6311            * @brief  Configure the Polarity and Filter for TI1.
   6312            * @param  TIMx to select the TIM peripheral.
   6313            * @param  TIM_ICPolarity The Input Polarity.
   6314            *          This parameter can be one of the following values:
   6315            *            @arg TIM_ICPOLARITY_RISING
   6316            *            @arg TIM_ICPOLARITY_FALLING
   6317            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6318            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6319            *          This parameter must be a value between 0x00 and 0x0F.
   6320            * @retval None
   6321            */

   \                                 In section .text, align 2, keep-with-next
   6322          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   6323          {
   \                     TIM_TI1_ConfigInputStage: (+1)
   \        0x0   0xB410             PUSH     {R4}
   6324            uint32_t tmpccmr1;
   6325            uint32_t tmpccer;
   6326          
   6327            /* Disable the Channel 1: Reset the CC1E Bit */
   6328            tmpccer = TIMx->CCER;
   \        0x2   0x6A04             LDR      R4,[R0, #+32]
   6329            TIMx->CCER &= ~TIM_CCER_CC1E;
   \        0x4   0x6A03             LDR      R3,[R0, #+32]
   \        0x6   0x085B             LSRS     R3,R3,#+1
   \        0x8   0x005B             LSLS     R3,R3,#+1
   \        0xA   0x6203             STR      R3,[R0, #+32]
   6330            tmpccmr1 = TIMx->CCMR1;
   \        0xC   0x6983             LDR      R3,[R0, #+24]
   6331          
   6332            /* Set the filter */
   6333            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   \        0xE   0xF033 0x03F0      BICS     R3,R3,#0xF0
   6334            tmpccmr1 |= (TIM_ICFilter << 4U);
   \       0x12   0xEA53 0x1302      ORRS     R3,R3,R2, LSL #+4
   6335          
   6336            /* Select the Polarity and set the CC1E Bit */
   6337            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   \       0x16   0xF034 0x040A      BICS     R4,R4,#0xA
   6338            tmpccer |= TIM_ICPolarity;
   \       0x1A   0x430C             ORRS     R4,R1,R4
   6339          
   6340            /* Write to TIMx CCMR1 and CCER registers */
   6341            TIMx->CCMR1 = tmpccmr1;
   \       0x1C   0x6183             STR      R3,[R0, #+24]
   6342            TIMx->CCER = tmpccer;
   \       0x1E   0x6204             STR      R4,[R0, #+32]
   6343          }
   \       0x20   0xBC10             POP      {R4}
   \       0x22   0x4770             BX       LR
   6344          
   6345          /**
   6346            * @brief  Configure the TI2 as Input.
   6347            * @param  TIMx to select the TIM peripheral
   6348            * @param  TIM_ICPolarity The Input Polarity.
   6349            *          This parameter can be one of the following values:
   6350            *            @arg TIM_ICPOLARITY_RISING
   6351            *            @arg TIM_ICPOLARITY_FALLING
   6352            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6353            * @param  TIM_ICSelection specifies the input to be used.
   6354            *          This parameter can be one of the following values:
   6355            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 2 is selected to be connected to IC2.
   6356            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 2 is selected to be connected to IC1.
   6357            *            @arg TIM_ICSELECTION_TRC: TIM Input 2 is selected to be connected to TRC.
   6358            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6359            *          This parameter must be a value between 0x00 and 0x0F.
   6360            * @retval None
   6361            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2
   6362            *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be
   6363            *        protected against un-initialized filter and polarity values.
   6364            */

   \                                 In section .text, align 2, keep-with-next
   6365          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6366                                        uint32_t TIM_ICFilter)
   6367          {
   \                     TIM_TI2_SetConfig: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   6368            uint32_t tmpccmr1;
   6369            uint32_t tmpccer;
   6370          
   6371            /* Disable the Channel 2: Reset the CC2E Bit */
   6372            TIMx->CCER &= ~TIM_CCER_CC2E;
   \        0x2   0x6A04             LDR      R4,[R0, #+32]
   \        0x4   0xF034 0x0410      BICS     R4,R4,#0x10
   \        0x8   0x6204             STR      R4,[R0, #+32]
   6373            tmpccmr1 = TIMx->CCMR1;
   \        0xA   0x6984             LDR      R4,[R0, #+24]
   6374            tmpccer = TIMx->CCER;
   \        0xC   0x6A05             LDR      R5,[R0, #+32]
   6375          
   6376            /* Select the Input */
   6377            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   \        0xE   0xF434 0x7440      BICS     R4,R4,#0x300
   6378            tmpccmr1 |= (TIM_ICSelection << 8U);
   \       0x12   0xEA54 0x2402      ORRS     R4,R4,R2, LSL #+8
   6379          
   6380            /* Set the filter */
   6381            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   \       0x16   0xF434 0x4470      BICS     R4,R4,#0xF000
   6382            tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
   \       0x1A   0x031E             LSLS     R6,R3,#+12
   \       0x1C   0xF416 0x4670      ANDS     R6,R6,#0xF000
   \       0x20   0x4334             ORRS     R4,R6,R4
   6383          
   6384            /* Select the Polarity and set the CC2E Bit */
   6385            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   \       0x22   0xF035 0x05A0      BICS     R5,R5,#0xA0
   6386            tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
   \       0x26   0x010E             LSLS     R6,R1,#+4
   \       0x28   0xF016 0x06A0      ANDS     R6,R6,#0xA0
   \       0x2C   0x4335             ORRS     R5,R6,R5
   6387          
   6388            /* Write to TIMx CCMR1 and CCER registers */
   6389            TIMx->CCMR1 = tmpccmr1 ;
   \       0x2E   0x6184             STR      R4,[R0, #+24]
   6390            TIMx->CCER = tmpccer;
   \       0x30   0x6205             STR      R5,[R0, #+32]
   6391          }
   \       0x32   0xBC70             POP      {R4-R6}
   \       0x34   0x4770             BX       LR
   6392          
   6393          /**
   6394            * @brief  Configure the Polarity and Filter for TI2.
   6395            * @param  TIMx to select the TIM peripheral.
   6396            * @param  TIM_ICPolarity The Input Polarity.
   6397            *          This parameter can be one of the following values:
   6398            *            @arg TIM_ICPOLARITY_RISING
   6399            *            @arg TIM_ICPOLARITY_FALLING
   6400            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6401            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6402            *          This parameter must be a value between 0x00 and 0x0F.
   6403            * @retval None
   6404            */

   \                                 In section .text, align 2, keep-with-next
   6405          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   6406          {
   \                     TIM_TI2_ConfigInputStage: (+1)
   \        0x0   0xB410             PUSH     {R4}
   6407            uint32_t tmpccmr1;
   6408            uint32_t tmpccer;
   6409          
   6410            /* Disable the Channel 2: Reset the CC2E Bit */
   6411            TIMx->CCER &= ~TIM_CCER_CC2E;
   \        0x2   0x6A03             LDR      R3,[R0, #+32]
   \        0x4   0xF033 0x0310      BICS     R3,R3,#0x10
   \        0x8   0x6203             STR      R3,[R0, #+32]
   6412            tmpccmr1 = TIMx->CCMR1;
   \        0xA   0x6983             LDR      R3,[R0, #+24]
   6413            tmpccer = TIMx->CCER;
   \        0xC   0x6A04             LDR      R4,[R0, #+32]
   6414          
   6415            /* Set the filter */
   6416            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   \        0xE   0xF433 0x4370      BICS     R3,R3,#0xF000
   6417            tmpccmr1 |= (TIM_ICFilter << 12U);
   \       0x12   0xEA53 0x3302      ORRS     R3,R3,R2, LSL #+12
   6418          
   6419            /* Select the Polarity and set the CC2E Bit */
   6420            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   \       0x16   0xF034 0x04A0      BICS     R4,R4,#0xA0
   6421            tmpccer |= (TIM_ICPolarity << 4U);
   \       0x1A   0xEA54 0x1401      ORRS     R4,R4,R1, LSL #+4
   6422          
   6423            /* Write to TIMx CCMR1 and CCER registers */
   6424            TIMx->CCMR1 = tmpccmr1 ;
   \       0x1E   0x6183             STR      R3,[R0, #+24]
   6425            TIMx->CCER = tmpccer;
   \       0x20   0x6204             STR      R4,[R0, #+32]
   6426          }
   \       0x22   0xBC10             POP      {R4}
   \       0x24   0x4770             BX       LR
   6427          
   6428          /**
   6429            * @brief  Configure the TI3 as Input.
   6430            * @param  TIMx to select the TIM peripheral
   6431            * @param  TIM_ICPolarity The Input Polarity.
   6432            *          This parameter can be one of the following values:
   6433            *            @arg TIM_ICPOLARITY_RISING
   6434            *            @arg TIM_ICPOLARITY_FALLING
   6435            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6436            * @param  TIM_ICSelection specifies the input to be used.
   6437            *          This parameter can be one of the following values:
   6438            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 3 is selected to be connected to IC3.
   6439            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 3 is selected to be connected to IC4.
   6440            *            @arg TIM_ICSELECTION_TRC: TIM Input 3 is selected to be connected to TRC.
   6441            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6442            *          This parameter must be a value between 0x00 and 0x0F.
   6443            * @retval None
   6444            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4
   6445            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
   6446            *        protected against un-initialized filter and polarity values.
   6447            */

   \                                 In section .text, align 2, keep-with-next
   6448          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6449                                        uint32_t TIM_ICFilter)
   6450          {
   \                     TIM_TI3_SetConfig: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   6451            uint32_t tmpccmr2;
   6452            uint32_t tmpccer;
   6453          
   6454            /* Disable the Channel 3: Reset the CC3E Bit */
   6455            TIMx->CCER &= ~TIM_CCER_CC3E;
   \        0x2   0x6A04             LDR      R4,[R0, #+32]
   \        0x4   0xF434 0x7480      BICS     R4,R4,#0x100
   \        0x8   0x6204             STR      R4,[R0, #+32]
   6456            tmpccmr2 = TIMx->CCMR2;
   \        0xA   0x69C4             LDR      R4,[R0, #+28]
   6457            tmpccer = TIMx->CCER;
   \        0xC   0x6A05             LDR      R5,[R0, #+32]
   6458          
   6459            /* Select the Input */
   6460            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   \        0xE   0x08A4             LSRS     R4,R4,#+2
   \       0x10   0x00A4             LSLS     R4,R4,#+2
   6461            tmpccmr2 |= TIM_ICSelection;
   \       0x12   0x4314             ORRS     R4,R2,R4
   6462          
   6463            /* Set the filter */
   6464            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   \       0x14   0xF034 0x04F0      BICS     R4,R4,#0xF0
   6465            tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
   \       0x18   0x011E             LSLS     R6,R3,#+4
   \       0x1A   0xF016 0x06F0      ANDS     R6,R6,#0xF0
   \       0x1E   0x4334             ORRS     R4,R6,R4
   6466          
   6467            /* Select the Polarity and set the CC3E Bit */
   6468            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   \       0x20   0xF435 0x6520      BICS     R5,R5,#0xA00
   6469            tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
   \       0x24   0x020E             LSLS     R6,R1,#+8
   \       0x26   0xF416 0x6620      ANDS     R6,R6,#0xA00
   \       0x2A   0x4335             ORRS     R5,R6,R5
   6470          
   6471            /* Write to TIMx CCMR2 and CCER registers */
   6472            TIMx->CCMR2 = tmpccmr2;
   \       0x2C   0x61C4             STR      R4,[R0, #+28]
   6473            TIMx->CCER = tmpccer;
   \       0x2E   0x6205             STR      R5,[R0, #+32]
   6474          }
   \       0x30   0xBC70             POP      {R4-R6}
   \       0x32   0x4770             BX       LR
   6475          
   6476          /**
   6477            * @brief  Configure the TI4 as Input.
   6478            * @param  TIMx to select the TIM peripheral
   6479            * @param  TIM_ICPolarity The Input Polarity.
   6480            *          This parameter can be one of the following values:
   6481            *            @arg TIM_ICPOLARITY_RISING
   6482            *            @arg TIM_ICPOLARITY_FALLING
   6483            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6484            * @param  TIM_ICSelection specifies the input to be used.
   6485            *          This parameter can be one of the following values:
   6486            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 4 is selected to be connected to IC4.
   6487            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 4 is selected to be connected to IC3.
   6488            *            @arg TIM_ICSELECTION_TRC: TIM Input 4 is selected to be connected to TRC.
   6489            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6490            *          This parameter must be a value between 0x00 and 0x0F.
   6491            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3
   6492            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
   6493            *        protected against un-initialized filter and polarity values.
   6494            * @retval None
   6495            */

   \                                 In section .text, align 2, keep-with-next
   6496          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6497                                        uint32_t TIM_ICFilter)
   6498          {
   \                     TIM_TI4_SetConfig: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   6499            uint32_t tmpccmr2;
   6500            uint32_t tmpccer;
   6501          
   6502            /* Disable the Channel 4: Reset the CC4E Bit */
   6503            TIMx->CCER &= ~TIM_CCER_CC4E;
   \        0x2   0x6A04             LDR      R4,[R0, #+32]
   \        0x4   0xF434 0x5480      BICS     R4,R4,#0x1000
   \        0x8   0x6204             STR      R4,[R0, #+32]
   6504            tmpccmr2 = TIMx->CCMR2;
   \        0xA   0x69C4             LDR      R4,[R0, #+28]
   6505            tmpccer = TIMx->CCER;
   \        0xC   0x6A05             LDR      R5,[R0, #+32]
   6506          
   6507            /* Select the Input */
   6508            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   \        0xE   0xF434 0x7440      BICS     R4,R4,#0x300
   6509            tmpccmr2 |= (TIM_ICSelection << 8U);
   \       0x12   0xEA54 0x2402      ORRS     R4,R4,R2, LSL #+8
   6510          
   6511            /* Set the filter */
   6512            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   \       0x16   0xF434 0x4470      BICS     R4,R4,#0xF000
   6513            tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
   \       0x1A   0x031E             LSLS     R6,R3,#+12
   \       0x1C   0xF416 0x4670      ANDS     R6,R6,#0xF000
   \       0x20   0x4334             ORRS     R4,R6,R4
   6514          
   6515            /* Select the Polarity and set the CC4E Bit */
   6516            tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   \       0x22   0xF435 0x4520      BICS     R5,R5,#0xA000
   6517            tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
   \       0x26   0x030E             LSLS     R6,R1,#+12
   \       0x28   0xF416 0x4620      ANDS     R6,R6,#0xA000
   \       0x2C   0x4335             ORRS     R5,R6,R5
   6518          
   6519            /* Write to TIMx CCMR2 and CCER registers */
   6520            TIMx->CCMR2 = tmpccmr2;
   \       0x2E   0x61C4             STR      R4,[R0, #+28]
   6521            TIMx->CCER = tmpccer ;
   \       0x30   0x6205             STR      R5,[R0, #+32]
   6522          }
   \       0x32   0xBC70             POP      {R4-R6}
   \       0x34   0x4770             BX       LR
   6523          
   6524          /**
   6525            * @brief  Selects the Input Trigger source
   6526            * @param  TIMx to select the TIM peripheral
   6527            * @param  InputTriggerSource The Input Trigger source.
   6528            *          This parameter can be one of the following values:
   6529            *            @arg TIM_TS_ITR0: Internal Trigger 0
   6530            *            @arg TIM_TS_ITR1: Internal Trigger 1
   6531            *            @arg TIM_TS_ITR2: Internal Trigger 2
   6532            *            @arg TIM_TS_ITR3: Internal Trigger 3
   6533            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   6534            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   6535            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   6536            *            @arg TIM_TS_ETRF: External Trigger input
   6537            * @retval None
   6538            */

   \                                 In section .text, align 2, keep-with-next
   6539          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
   6540          {
   6541            uint32_t tmpsmcr;
   6542          
   6543            /* Get the TIMx SMCR register value */
   6544            tmpsmcr = TIMx->SMCR;
   \                     TIM_ITRx_SetConfig: (+1)
   \        0x0   0x6882             LDR      R2,[R0, #+8]
   6545            /* Reset the TS Bits */
   6546            tmpsmcr &= ~TIM_SMCR_TS;
   \        0x2   0xF032 0x0270      BICS     R2,R2,#0x70
   6547            /* Set the Input Trigger source and the slave mode*/
   6548            tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   \        0x6   0x430A             ORRS     R2,R1,R2
   \        0x8   0xF052 0x0207      ORRS     R2,R2,#0x7
   6549            /* Write to TIMx SMCR */
   6550            TIMx->SMCR = tmpsmcr;
   \        0xC   0x6082             STR      R2,[R0, #+8]
   6551          }
   \        0xE   0x4770             BX       LR
   6552          /**
   6553            * @brief  Configures the TIMx External Trigger (ETR).
   6554            * @param  TIMx to select the TIM peripheral
   6555            * @param  TIM_ExtTRGPrescaler The external Trigger Prescaler.
   6556            *          This parameter can be one of the following values:
   6557            *            @arg TIM_ETRPRESCALER_DIV1: ETRP Prescaler OFF.
   6558            *            @arg TIM_ETRPRESCALER_DIV2: ETRP frequency divided by 2.
   6559            *            @arg TIM_ETRPRESCALER_DIV4: ETRP frequency divided by 4.
   6560            *            @arg TIM_ETRPRESCALER_DIV8: ETRP frequency divided by 8.
   6561            * @param  TIM_ExtTRGPolarity The external Trigger Polarity.
   6562            *          This parameter can be one of the following values:
   6563            *            @arg TIM_ETRPOLARITY_INVERTED: active low or falling edge active.
   6564            *            @arg TIM_ETRPOLARITY_NONINVERTED: active high or rising edge active.
   6565            * @param  ExtTRGFilter External Trigger Filter.
   6566            *          This parameter must be a value between 0x00 and 0x0F
   6567            * @retval None
   6568            */

   \                                 In section .text, align 2, keep-with-next
   6569          void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
   6570                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   6571          {
   \                     TIM_ETR_SetConfig: (+1)
   \        0x0   0xB410             PUSH     {R4}
   6572            uint32_t tmpsmcr;
   6573          
   6574            tmpsmcr = TIMx->SMCR;
   \        0x2   0x6884             LDR      R4,[R0, #+8]
   6575          
   6576            /* Reset the ETR Bits */
   6577            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   \        0x4   0xF434 0x447F      BICS     R4,R4,#0xFF00
   6578          
   6579            /* Set the Prescaler, the Filter value and the Polarity */
   6580            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
   \        0x8   0x430C             ORRS     R4,R1,R4
   \        0xA   0x4314             ORRS     R4,R2,R4
   \        0xC   0xEA54 0x2403      ORRS     R4,R4,R3, LSL #+8
   6581          
   6582            /* Write to TIMx SMCR */
   6583            TIMx->SMCR = tmpsmcr;
   \       0x10   0x6084             STR      R4,[R0, #+8]
   6584          }
   \       0x12   0xBC10             POP      {R4}
   \       0x14   0x4770             BX       LR
   6585          
   6586          /**
   6587            * @brief  Enables or disables the TIM Capture Compare Channel x.
   6588            * @param  TIMx to select the TIM peripheral
   6589            * @param  Channel specifies the TIM Channel
   6590            *          This parameter can be one of the following values:
   6591            *            @arg TIM_CHANNEL_1: TIM Channel 1
   6592            *            @arg TIM_CHANNEL_2: TIM Channel 2
   6593            *            @arg TIM_CHANNEL_3: TIM Channel 3
   6594            *            @arg TIM_CHANNEL_4: TIM Channel 4
   6595            * @param  ChannelState specifies the TIM Channel CCxE bit new state.
   6596            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
   6597            * @retval None
   6598            */

   \                                 In section .text, align 2, keep-with-next
   6599          void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
   6600          {
   \                     TIM_CCxChannelCmd: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   6601            uint32_t tmp;
   6602          
   6603            /* Check the parameters */
   6604            assert_param(IS_TIM_CC1_INSTANCE(TIMx));
   6605            assert_param(IS_TIM_CHANNELS(Channel));
   6606          
   6607            tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
   \        0x2   0x2401             MOVS     R4,#+1
   \        0x4   0xF011 0x031F      ANDS     R3,R1,#0x1F
   \        0x8   0xFA14 0xF303      LSLS     R3,R4,R3
   6608          
   6609            /* Reset the CCxE Bit */
   6610            TIMx->CCER &= ~tmp;
   \        0xC   0x6A04             LDR      R4,[R0, #+32]
   \        0xE   0x439C             BICS     R4,R4,R3
   \       0x10   0x6204             STR      R4,[R0, #+32]
   6611          
   6612            /* Set or reset the CCxE Bit */
   6613            TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
   \       0x12   0x6A04             LDR      R4,[R0, #+32]
   \       0x14   0xF011 0x051F      ANDS     R5,R1,#0x1F
   \       0x18   0xFA12 0xF505      LSLS     R5,R2,R5
   \       0x1C   0x432C             ORRS     R4,R5,R4
   \       0x1E   0x6204             STR      R4,[R0, #+32]
   6614          }
   \       0x20   0xBC30             POP      {R4,R5}
   \       0x22   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x....'....        DC32     TIM_DMAPeriodElapsedCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0x....'....        DC32     TIM_DMAPeriodElapsedHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \        0x0   0x4001'0000        DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \        0x0   0x4001'0400        DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0x....'....        DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \        0x0   0x....'....        DC32     TIM_DMACaptureHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \        0x0   0x4001'0000        DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \        0x0   0x4001'0400        DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \        0x0   0xFFFF'BFF8        DC32     0xffffbff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \        0x0   0xFFFF'FCFC        DC32     0xfffffcfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \        0x0   0xFFFF'F3F3        DC32     0xfffff3f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \        0x0   0xFFFF'0F0F        DC32     0xffff0f0f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \        0x0   0x....'....        DC32     TIMEx_DMACommutationCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \        0x0   0x....'....        DC32     TIMEx_DMACommutationHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \        0x0   0x4001'0000        DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \        0x0   0x4000'0400        DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \        0x0   0x4000'0800        DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \        0x0   0x4000'0C00        DC32     0x40000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_5:
   \        0x0   0x4001'0400        DC32     0x40010400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_6:
   \        0x0   0x4001'4000        DC32     0x40014000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_7:
   \        0x0   0x4001'4400        DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_8:
   \        0x0   0x4001'4800        DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_9:
   \        0x0   0x4000'1800        DC32     0x40001800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_10:
   \        0x0   0x4000'1C00        DC32     0x40001c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_11:
   \        0x0   0x4000'2000        DC32     0x40002000
   6615          
   6616          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6617          /**
   6618            * @brief  Reset interrupt callbacks to the legacy weak callbacks.
   6619            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   6620            *                the configuration information for TIM module.
   6621            * @retval None
   6622            */
   6623          void TIM_ResetCallback(TIM_HandleTypeDef *htim)
   6624          {
   6625            /* Reset the TIM callback to the legacy weak callbacks */
   6626            htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;             /* Legacy weak PeriodElapsedCallback             */
   6627            htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;     /* Legacy weak PeriodElapsedHalfCpltCallback     */
   6628            htim->TriggerCallback                   = HAL_TIM_TriggerCallback;                   /* Legacy weak TriggerCallback                   */
   6629            htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;           /* Legacy weak TriggerHalfCpltCallback           */
   6630            htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;                /* Legacy weak IC_CaptureCallback                */
   6631            htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;        /* Legacy weak IC_CaptureHalfCpltCallback        */
   6632            htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;           /* Legacy weak OC_DelayElapsedCallback           */
   6633            htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;         /* Legacy weak PWM_PulseFinishedCallback         */
   6634            htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback; /* Legacy weak PWM_PulseFinishedHalfCpltCallback */
   6635            htim->ErrorCallback                     = HAL_TIM_ErrorCallback;                     /* Legacy weak ErrorCallback                     */
   6636            htim->CommutationCallback               = HAL_TIMEx_CommutCallback;                  /* Legacy weak CommutationCallback               */
   6637            htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;          /* Legacy weak CommutationHalfCpltCallback       */
   6638            htim->BreakCallback                     = HAL_TIMEx_BreakCallback;                   /* Legacy weak BreakCallback                     */
   6639          }
   6640          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6641          
   6642          /**
   6643            * @}
   6644            */
   6645          
   6646          #endif /* HAL_TIM_MODULE_ENABLED */
   6647          /**
   6648            * @}
   6649            */
   6650          
   6651          /**
   6652            * @}
   6653            */
   6654          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_TIM_Base_DeInit
         8   -> HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_GetState
       8   HAL_TIM_Base_Init
         8   -> HAL_TIM_Base_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_MspInit
       0   HAL_TIM_Base_Start
      16   HAL_TIM_Base_Start_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_TIM_Base_Start_IT
       0   HAL_TIM_Base_Stop
       8   HAL_TIM_Base_Stop_DMA
         8   -> HAL_DMA_Abort_IT
       0   HAL_TIM_Base_Stop_IT
      16   HAL_TIM_ConfigClockSource
        16   -> TIM_ETR_SetConfig
        16   -> TIM_ITRx_SetConfig
        16   -> TIM_TI1_ConfigInputStage
        16   -> TIM_TI2_ConfigInputStage
      16   HAL_TIM_ConfigOCrefClear
        16   -> TIM_ETR_SetConfig
       0   HAL_TIM_ConfigTI1Input
      24   HAL_TIM_DMABurst_ReadStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_ReadStop
        16   -> HAL_DMA_Abort_IT
      24   HAL_TIM_DMABurst_WriteStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_WriteStop
        16   -> HAL_DMA_Abort_IT
       8   HAL_TIM_Encoder_DeInit
         8   -> HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_GetState
      16   HAL_TIM_Encoder_Init
        16   -> HAL_TIM_Encoder_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_MspInit
      16   HAL_TIM_Encoder_Start
        16   -> TIM_CCxChannelCmd
      40   HAL_TIM_Encoder_Start_DMA
        40   -> HAL_DMA_Start_IT
        40   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop_IT
        16   -> TIM_CCxChannelCmd
       0   HAL_TIM_ErrorCallback
       0   HAL_TIM_GenerateEvent
       0   HAL_TIM_IC_CaptureCallback
       0   HAL_TIM_IC_CaptureHalfCpltCallback
      16   HAL_TIM_IC_ConfigChannel
        16   -> TIM_TI1_SetConfig
        16   -> TIM_TI2_SetConfig
        16   -> TIM_TI3_SetConfig
        16   -> TIM_TI4_SetConfig
       8   HAL_TIM_IC_DeInit
         8   -> HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_GetState
       8   HAL_TIM_IC_Init
         8   -> HAL_TIM_IC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_MspInit
      16   HAL_TIM_IC_Start
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_IC_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_IRQHandler
         8   -> HAL_TIMEx_BreakCallback
         8   -> HAL_TIMEx_CommutCallback
         8   -> HAL_TIM_IC_CaptureCallback
         8   -> HAL_TIM_OC_DelayElapsedCallback
         8   -> HAL_TIM_PWM_PulseFinishedCallback
         8   -> HAL_TIM_PeriodElapsedCallback
         8   -> HAL_TIM_TriggerCallback
      16   HAL_TIM_OC_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
       8   HAL_TIM_OC_DeInit
         8   -> HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_DelayElapsedCallback
       0   HAL_TIM_OC_GetState
       8   HAL_TIM_OC_Init
         8   -> HAL_TIM_OC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_MspInit
      16   HAL_TIM_OC_Start
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_OC_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop_IT
        16   -> TIM_CCxChannelCmd
      48   HAL_TIM_OnePulse_ConfigChannel
        48   -> TIM_OC1_SetConfig
        48   -> TIM_OC2_SetConfig
        48   -> TIM_TI1_SetConfig
        48   -> TIM_TI2_SetConfig
       8   HAL_TIM_OnePulse_DeInit
         8   -> HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_GetState
      16   HAL_TIM_OnePulse_Init
        16   -> HAL_TIM_OnePulse_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_MspInit
      16   HAL_TIM_OnePulse_Start
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Stop_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
       8   HAL_TIM_PWM_DeInit
         8   -> HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_GetState
       8   HAL_TIM_PWM_Init
         8   -> HAL_TIM_PWM_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_MspInit
       0   HAL_TIM_PWM_PulseFinishedCallback
       0   HAL_TIM_PWM_PulseFinishedHalfCpltCallback
      16   HAL_TIM_PWM_Start
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_PWM_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop_IT
        16   -> TIM_CCxChannelCmd
       0   HAL_TIM_PeriodElapsedCallback
       0   HAL_TIM_PeriodElapsedHalfCpltCallback
       0   HAL_TIM_ReadCapturedValue
      16   HAL_TIM_SlaveConfigSynchro
        16   -> TIM_SlaveTimer_SetConfig
      16   HAL_TIM_SlaveConfigSynchro_IT
        16   -> TIM_SlaveTimer_SetConfig
       0   HAL_TIM_TriggerCallback
       0   HAL_TIM_TriggerHalfCpltCallback
       4   TIM_Base_SetConfig
       8   TIM_CCxChannelCmd
      16   TIM_DMACaptureCplt
        16   -> HAL_TIM_IC_CaptureCallback
      16   TIM_DMACaptureHalfCplt
        16   -> HAL_TIM_IC_CaptureHalfCpltCallback
      16   TIM_DMADelayPulseCplt
        16   -> HAL_TIM_PWM_PulseFinishedCallback
      16   TIM_DMADelayPulseHalfCplt
        16   -> HAL_TIM_PWM_PulseFinishedHalfCpltCallback
      16   TIM_DMAError
        16   -> HAL_TIM_ErrorCallback
      16   TIM_DMAPeriodElapsedCplt
        16   -> HAL_TIM_PeriodElapsedCallback
      16   TIM_DMAPeriodElapsedHalfCplt
        16   -> HAL_TIM_PeriodElapsedHalfCpltCallback
      16   TIM_DMATriggerCplt
        16   -> HAL_TIM_TriggerCallback
      16   TIM_DMATriggerHalfCplt
        16   -> HAL_TIM_TriggerHalfCpltCallback
       4   TIM_ETR_SetConfig
       0   TIM_ITRx_SetConfig
      12   TIM_OC1_SetConfig
      12   TIM_OC2_SetConfig
      12   TIM_OC3_SetConfig
       8   TIM_OC4_SetConfig
      24   TIM_SlaveTimer_SetConfig
        24   -> TIM_ETR_SetConfig
        24   -> TIM_TI1_ConfigInputStage
        24   -> TIM_TI2_ConfigInputStage
       4   TIM_TI1_ConfigInputStage
      12   TIM_TI1_SetConfig
       4   TIM_TI2_ConfigInputStage
      12   TIM_TI2_SetConfig
      12   TIM_TI3_SetConfig
      12   TIM_TI4_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable22
       4  ??DataTable27
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_10
       4  ??DataTable28_11
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable28_7
       4  ??DataTable28_8
       4  ??DataTable28_9
      68  HAL_TIM_Base_DeInit
       6  HAL_TIM_Base_GetState
      56  HAL_TIM_Base_Init
       2  HAL_TIM_Base_MspDeInit
       2  HAL_TIM_Base_MspInit
      42  HAL_TIM_Base_Start
     140  HAL_TIM_Base_Start_DMA
      42  HAL_TIM_Base_Start_IT
      54  HAL_TIM_Base_Stop
      68  HAL_TIM_Base_Stop_DMA
      54  HAL_TIM_Base_Stop_IT
     236  HAL_TIM_ConfigClockSource
     266  HAL_TIM_ConfigOCrefClear
      20  HAL_TIM_ConfigTI1Input
     512  HAL_TIM_DMABurst_ReadStart
     148  HAL_TIM_DMABurst_ReadStop
     512  HAL_TIM_DMABurst_WriteStart
     148  HAL_TIM_DMABurst_WriteStop
      68  HAL_TIM_Encoder_DeInit
       6  HAL_TIM_Encoder_GetState
     168  HAL_TIM_Encoder_Init
       2  HAL_TIM_Encoder_MspDeInit
       2  HAL_TIM_Encoder_MspInit
      78  HAL_TIM_Encoder_Start
     404  HAL_TIM_Encoder_Start_DMA
     126  HAL_TIM_Encoder_Start_IT
     102  HAL_TIM_Encoder_Stop
     176  HAL_TIM_Encoder_Stop_DMA
     152  HAL_TIM_Encoder_Stop_IT
       2  HAL_TIM_ErrorCallback
      46  HAL_TIM_GenerateEvent
       2  HAL_TIM_IC_CaptureCallback
       2  HAL_TIM_IC_CaptureHalfCpltCallback
     214  HAL_TIM_IC_ConfigChannel
      68  HAL_TIM_IC_DeInit
       6  HAL_TIM_IC_GetState
      56  HAL_TIM_IC_Init
       2  HAL_TIM_IC_MspDeInit
       2  HAL_TIM_IC_MspInit
      44  HAL_TIM_IC_Start
     358  HAL_TIM_IC_Start_DMA
     120  HAL_TIM_IC_Start_IT
      56  HAL_TIM_IC_Stop
     162  HAL_TIM_IC_Stop_DMA
     132  HAL_TIM_IC_Stop_IT
     374  HAL_TIM_IRQHandler
     108  HAL_TIM_OC_ConfigChannel
      68  HAL_TIM_OC_DeInit
       2  HAL_TIM_OC_DelayElapsedCallback
       6  HAL_TIM_OC_GetState
      56  HAL_TIM_OC_Init
       2  HAL_TIM_OC_MspDeInit
       2  HAL_TIM_OC_MspInit
      88  HAL_TIM_OC_Start
     410  HAL_TIM_OC_Start_DMA
     164  HAL_TIM_OC_Start_IT
     124  HAL_TIM_OC_Stop
     230  HAL_TIM_OC_Stop_DMA
     200  HAL_TIM_OC_Stop_IT
     280  HAL_TIM_OnePulse_ConfigChannel
      68  HAL_TIM_OnePulse_DeInit
       6  HAL_TIM_OnePulse_GetState
      80  HAL_TIM_OnePulse_Init
       2  HAL_TIM_OnePulse_MspDeInit
       2  HAL_TIM_OnePulse_MspInit
      74  HAL_TIM_OnePulse_Start
      98  HAL_TIM_OnePulse_Start_IT
     134  HAL_TIM_OnePulse_Stop
     158  HAL_TIM_OnePulse_Stop_IT
     256  HAL_TIM_PWM_ConfigChannel
      68  HAL_TIM_PWM_DeInit
       6  HAL_TIM_PWM_GetState
      56  HAL_TIM_PWM_Init
       2  HAL_TIM_PWM_MspDeInit
       2  HAL_TIM_PWM_MspInit
       2  HAL_TIM_PWM_PulseFinishedCallback
       2  HAL_TIM_PWM_PulseFinishedHalfCpltCallback
      88  HAL_TIM_PWM_Start
     398  HAL_TIM_PWM_Start_DMA
     164  HAL_TIM_PWM_Start_IT
     130  HAL_TIM_PWM_Stop
     226  HAL_TIM_PWM_Stop_DMA
     196  HAL_TIM_PWM_Stop_IT
       2  HAL_TIM_PeriodElapsedCallback
       2  HAL_TIM_PeriodElapsedHalfCpltCallback
      58  HAL_TIM_ReadCapturedValue
      98  HAL_TIM_SlaveConfigSynchro
      98  HAL_TIM_SlaveConfigSynchro_IT
       2  HAL_TIM_TriggerCallback
       2  HAL_TIM_TriggerHalfCpltCallback
     192  TIM_Base_SetConfig
      36  TIM_CCxChannelCmd
      70  TIM_DMACaptureCplt
      70  TIM_DMACaptureHalfCplt
      70  TIM_DMADelayPulseCplt
      70  TIM_DMADelayPulseHalfCplt
      20  TIM_DMAError
      20  TIM_DMAPeriodElapsedCplt
      20  TIM_DMAPeriodElapsedHalfCplt
      20  TIM_DMATriggerCplt
      20  TIM_DMATriggerHalfCplt
      22  TIM_ETR_SetConfig
      16  TIM_ITRx_SetConfig
     100  TIM_OC1_SetConfig
     110  TIM_OC2_SetConfig
     108  TIM_OC3_SetConfig
      76  TIM_OC4_SetConfig
     178  TIM_SlaveTimer_SetConfig
      36  TIM_TI1_ConfigInputStage
     116  TIM_TI1_SetConfig
      38  TIM_TI2_ConfigInputStage
      54  TIM_TI2_SetConfig
      52  TIM_TI3_SetConfig
      54  TIM_TI4_SetConfig

 
 11'214 bytes in section .text
 
 11'170 bytes of CODE memory (+ 44 bytes shared)

Errors: none
Warnings: none
