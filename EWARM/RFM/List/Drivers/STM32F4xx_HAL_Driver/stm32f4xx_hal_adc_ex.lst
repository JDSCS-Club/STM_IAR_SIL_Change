###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         20/Sep/2022  11:09:51
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_adc_ex.c
#    Command line      =
#        -f
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_adc_ex.o.rsp
#        (C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_adc_ex.c
#        -D USE_HAL_DRIVER -D STM32F407xx -lC
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver
#        -o
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/App\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Core/Inc\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Include\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/display\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Library\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_adc_ex.o.d
#    Locale            =  C
#    List file         =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_adc_ex.lst
#    Object file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_adc_ex.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_adc_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_adc_ex.c
      4            * @author  MCD Application Team
      5            * @brief   This file provides firmware functions to manage the following
      6            *          functionalities of the ADC extension peripheral:
      7            *           + Extended features functions
      8            *
      9            @verbatim
     10            ==============================================================================
     11                              ##### How to use this driver #####
     12            ==============================================================================
     13              [..]
     14              (#)Initialize the ADC low level resources by implementing the HAL_ADC_MspInit():
     15                 (##) Enable the ADC interface clock using __HAL_RCC_ADC_CLK_ENABLE()
     16                 (##) ADC pins configuration
     17                       (+++) Enable the clock for the ADC GPIOs using the following function:
     18                             __HAL_RCC_GPIOx_CLK_ENABLE()
     19                       (+++) Configure these ADC pins in analog mode using HAL_GPIO_Init()
     20                 (##) In case of using interrupts (e.g. HAL_ADC_Start_IT())
     21                       (+++) Configure the ADC interrupt priority using HAL_NVIC_SetPriority()
     22                       (+++) Enable the ADC IRQ handler using HAL_NVIC_EnableIRQ()
     23                       (+++) In ADC IRQ handler, call HAL_ADC_IRQHandler()
     24                (##) In case of using DMA to control data transfer (e.g. HAL_ADC_Start_DMA())
     25                       (+++) Enable the DMAx interface clock using __HAL_RCC_DMAx_CLK_ENABLE()
     26                       (+++) Configure and enable two DMA streams stream for managing data
     27                           transfer from peripheral to memory (output stream)
     28                       (+++) Associate the initialized DMA handle to the ADC DMA handle
     29                           using  __HAL_LINKDMA()
     30                       (+++) Configure the priority and enable the NVIC for the transfer complete
     31                           interrupt on the two DMA Streams. The output stream should have higher
     32                           priority than the input stream.
     33               (#) Configure the ADC Prescaler, conversion resolution and data alignment
     34                   using the HAL_ADC_Init() function.
     35          
     36               (#) Configure the ADC Injected channels group features, use HAL_ADC_Init()
     37                   and HAL_ADC_ConfigChannel() functions.
     38          
     39               (#) Three operation modes are available within this driver:
     40          
     41               *** Polling mode IO operation ***
     42               =================================
     43               [..]
     44                 (+) Start the ADC peripheral using HAL_ADCEx_InjectedStart()
     45                 (+) Wait for end of conversion using HAL_ADC_PollForConversion(), at this stage
     46                     user can specify the value of timeout according to his end application
     47                 (+) To read the ADC converted values, use the HAL_ADCEx_InjectedGetValue() function.
     48                 (+) Stop the ADC peripheral using HAL_ADCEx_InjectedStop()
     49          
     50               *** Interrupt mode IO operation ***
     51               ===================================
     52               [..]
     53                 (+) Start the ADC peripheral using HAL_ADCEx_InjectedStart_IT()
     54                 (+) Use HAL_ADC_IRQHandler() called under ADC_IRQHandler() Interrupt subroutine
     55                 (+) At ADC end of conversion HAL_ADCEx_InjectedConvCpltCallback() function is executed and user can
     56                      add his own code by customization of function pointer HAL_ADCEx_InjectedConvCpltCallback 
     57                 (+) In case of ADC Error, HAL_ADCEx_InjectedErrorCallback() function is executed and user can 
     58                      add his own code by customization of function pointer HAL_ADCEx_InjectedErrorCallback
     59                 (+) Stop the ADC peripheral using HAL_ADCEx_InjectedStop_IT()
     60          
     61               *** Multi mode ADCs Regular channels configuration ***
     62               ======================================================
     63               [..]
     64                 (+) Select the Multi mode ADC regular channels features (dual or triple mode)
     65                    and configure the DMA mode using HAL_ADCEx_MultiModeConfigChannel() functions.
     66                 (+) Start the ADC peripheral using HAL_ADCEx_MultiModeStart_DMA(), at this stage the user specify the length
     67                     of data to be transferred at each end of conversion
     68                 (+) Read the ADCs converted values using the HAL_ADCEx_MultiModeGetValue() function.
     69          
     70          
     71              @endverbatim
     72            ******************************************************************************
     73            * @attention
     74            *
     75            * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
     76            * All rights reserved.</center></h2>
     77            *
     78            * This software component is licensed by ST under BSD 3-Clause license,
     79            * the "License"; You may not use this file except in compliance with the
     80            * License. You may obtain a copy of the License at:
     81            *                        opensource.org/licenses/BSD-3-Clause
     82            *
     83            ******************************************************************************
     84            */
     85          
     86          /* Includes ------------------------------------------------------------------*/
     87          #include "stm32f4xx_hal.h"
     88          
     89          /** @addtogroup STM32F4xx_HAL_Driver
     90            * @{
     91            */
     92          
     93          /** @defgroup ADCEx ADCEx
     94            * @brief ADC Extended driver modules
     95            * @{
     96            */ 
     97          
     98          #ifdef HAL_ADC_MODULE_ENABLED
     99              
    100          /* Private typedef -----------------------------------------------------------*/
    101          /* Private define ------------------------------------------------------------*/ 
    102          /* Private macro -------------------------------------------------------------*/
    103          /* Private variables ---------------------------------------------------------*/
    104          /** @addtogroup ADCEx_Private_Functions
    105            * @{
    106            */
    107          /* Private function prototypes -----------------------------------------------*/
    108          static void ADC_MultiModeDMAConvCplt(DMA_HandleTypeDef *hdma);
    109          static void ADC_MultiModeDMAError(DMA_HandleTypeDef *hdma);
    110          static void ADC_MultiModeDMAHalfConvCplt(DMA_HandleTypeDef *hdma); 
    111          /**
    112            * @}
    113            */
    114          
    115          /* Exported functions --------------------------------------------------------*/
    116          /** @defgroup ADCEx_Exported_Functions ADC Exported Functions
    117            * @{
    118            */
    119          
    120          /** @defgroup ADCEx_Exported_Functions_Group1  Extended features functions 
    121            *  @brief    Extended features functions  
    122            *
    123          @verbatim   
    124           ===============================================================================
    125                           ##### Extended features functions #####
    126           ===============================================================================  
    127              [..]  This section provides functions allowing to:
    128                (+) Start conversion of injected channel.
    129                (+) Stop conversion of injected channel.
    130                (+) Start multimode and enable DMA transfer.
    131                (+) Stop multimode and disable DMA transfer.
    132                (+) Get result of injected channel conversion.
    133                (+) Get result of multimode conversion.
    134                (+) Configure injected channels.
    135                (+) Configure multimode.
    136                         
    137          @endverbatim
    138            * @{
    139            */
    140          
    141          /**
    142            * @brief  Enables the selected ADC software start conversion of the injected channels.
    143            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
    144            *         the configuration information for the specified ADC.
    145            * @retval HAL status
    146            */

   \                                 In section .text, align 2, keep-with-next
    147          HAL_StatusTypeDef HAL_ADCEx_InjectedStart(ADC_HandleTypeDef* hadc)
    148          {
   \                     HAL_ADCEx_InjectedStart: (+1)
   \        0x0   0xB438             PUSH     {R3-R5}
   \        0x2   0x0004             MOVS     R4,R0
    149            __IO uint32_t counter = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
    150            uint32_t tmp1 = 0U, tmp2 = 0U;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x2200             MOVS     R2,#+0
    151            ADC_Common_TypeDef *tmpADC_Common;
    152            
    153            /* Process locked */
    154            __HAL_LOCK(hadc);
   \        0xC   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD101             BNE.N    ??HAL_ADCEx_InjectedStart_0
   \       0x14   0x2002             MOVS     R0,#+2
   \       0x16   0xE076             B.N      ??HAL_ADCEx_InjectedStart_1
   \                     ??HAL_ADCEx_InjectedStart_0: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xF884 0x003C      STRB     R0,[R4, #+60]
    155            
    156            /* Enable the ADC peripheral */
    157            
    158            /* Check if ADC peripheral is disabled in order to enable it and wait during 
    159               Tstab time the ADC's stabilization */
    160            if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6880             LDR      R0,[R0, #+8]
   \       0x22   0x07C0             LSLS     R0,R0,#+31
   \       0x24   0xD416             BMI.N    ??HAL_ADCEx_InjectedStart_2
    161            {  
    162              /* Enable the Peripheral */
    163              __HAL_ADC_ENABLE(hadc);
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6880             LDR      R0,[R0, #+8]
   \       0x2A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x2E   0x6825             LDR      R5,[R4, #+0]
   \       0x30   0x60A8             STR      R0,[R5, #+8]
    164              
    165              /* Delay for ADC stabilization time */
    166              /* Compute number of CPU cycles to wait for */
    167              counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x36   0x6800             LDR      R0,[R0, #+0]
   \       0x38   0x.... 0x....      LDR.W    R5,??DataTable6_1
   \       0x3C   0xFBB0 0xF5F5      UDIV     R5,R0,R5
   \       0x40   0x2003             MOVS     R0,#+3
   \       0x42   0x4345             MULS     R5,R0,R5
   \       0x44   0x9500             STR      R5,[SP, #+0]
    168              while(counter != 0U)
   \                     ??HAL_ADCEx_InjectedStart_3: (+1)
   \       0x46   0x9800             LDR      R0,[SP, #+0]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD003             BEQ.N    ??HAL_ADCEx_InjectedStart_2
    169              {
    170                counter--;
   \       0x4C   0x9800             LDR      R0,[SP, #+0]
   \       0x4E   0x1E40             SUBS     R0,R0,#+1
   \       0x50   0x9000             STR      R0,[SP, #+0]
   \       0x52   0xE7F8             B.N      ??HAL_ADCEx_InjectedStart_3
    171              }
    172            }
    173            
    174            /* Start conversion if ADC is effectively enabled */
    175            if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
   \                     ??HAL_ADCEx_InjectedStart_2: (+1)
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x6880             LDR      R0,[R0, #+8]
   \       0x58   0x07C0             LSLS     R0,R0,#+31
   \       0x5A   0xD553             BPL.N    ??HAL_ADCEx_InjectedStart_4
    176            {
    177              /* Set ADC state                                                          */
    178              /* - Clear state bitfield related to injected group conversion results    */
    179              /* - Set state bitfield related to injected operation                     */
    180              ADC_STATE_CLR_SET(hadc->State,
    181                                HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
    182                                HAL_ADC_STATE_INJ_BUSY);
   \       0x5C   0x6C25             LDR      R5,[R4, #+64]
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \       0x62   0x4005             ANDS     R5,R0,R5
   \       0x64   0xF455 0x5580      ORRS     R5,R5,#0x1000
   \       0x68   0x6425             STR      R5,[R4, #+64]
    183              
    184              /* Check if a regular conversion is ongoing */
    185              /* Note: On this device, there is no ADC error code fields related to     */
    186              /*       conversions on group injected only. In case of conversion on     */
    187              /*       going on group regular, no error code is reset.                  */
    188              if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
   \       0x6A   0x6C20             LDR      R0,[R4, #+64]
   \       0x6C   0x05C0             LSLS     R0,R0,#+23
   \       0x6E   0xD401             BMI.N    ??HAL_ADCEx_InjectedStart_5
    189              {
    190                /* Reset ADC all error code fields */
    191                ADC_CLEAR_ERRORCODE(hadc);
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x6460             STR      R0,[R4, #+68]
    192              }
    193              
    194              /* Process unlocked */
    195              /* Unlock before starting ADC conversions: in case of potential           */
    196              /* interruption, to let the process to ADC IRQ Handler.                   */
    197              __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_InjectedStart_5: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xF884 0x003C      STRB     R0,[R4, #+60]
    198              
    199              /* Clear injected group conversion flag */
    200              /* (To ensure of no unknown state from potential previous ADC operations) */
    201              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
   \       0x7A   0xF07F 0x0004      MVNS     R0,#+4
   \       0x7E   0x6825             LDR      R5,[R4, #+0]
   \       0x80   0x6028             STR      R0,[R5, #+0]
    202          
    203              /* Pointer to the common control register to which is belonging hadc    */
    204              /* (Depending on STM32F4 product, there may be up to 3 ADC and 1 common */
    205              /* control register)                                                    */
    206              tmpADC_Common = ADC_COMMON_REGISTER(hadc);
   \       0x82   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \       0x86   0x0003             MOVS     R3,R0
    207          
    208              /* Check if Multimode enabled */
    209              if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
   \       0x88   0x6858             LDR      R0,[R3, #+4]
   \       0x8A   0xF010 0x0F1F      TST      R0,#0x1F
   \       0x8E   0xD11A             BNE.N    ??HAL_ADCEx_InjectedStart_6
    210              {
    211                tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
   \       0x90   0x6820             LDR      R0,[R4, #+0]
   \       0x92   0x6880             LDR      R0,[R0, #+8]
   \       0x94   0xF410 0x1F40      TST      R0,#0x300000
   \       0x98   0xD101             BNE.N    ??HAL_ADCEx_InjectedStart_7
   \       0x9A   0x2101             MOVS     R1,#+1
   \       0x9C   0xE000             B.N      ??HAL_ADCEx_InjectedStart_8
   \                     ??HAL_ADCEx_InjectedStart_7: (+1)
   \       0x9E   0x2100             MOVS     R1,#+0
    212                tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
   \                     ??HAL_ADCEx_InjectedStart_8: (+1)
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x6840             LDR      R0,[R0, #+4]
   \       0xA4   0x0A80             LSRS     R0,R0,#+10
   \       0xA6   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0xAA   0xF090 0x0001      EORS     R0,R0,#0x1
   \       0xAE   0x0002             MOVS     R2,R0
    213                if(tmp1 && tmp2)
   \       0xB0   0x2900             CMP      R1,#+0
   \       0xB2   0xD027             BEQ.N    ??HAL_ADCEx_InjectedStart_4
   \       0xB4   0x2A00             CMP      R2,#+0
   \       0xB6   0xD025             BEQ.N    ??HAL_ADCEx_InjectedStart_4
    214                {
    215                  /* Enable the selected ADC software conversion for injected group */
    216                  hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
   \       0xB8   0x6820             LDR      R0,[R4, #+0]
   \       0xBA   0x6880             LDR      R0,[R0, #+8]
   \       0xBC   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \       0xC0   0x6825             LDR      R5,[R4, #+0]
   \       0xC2   0x60A8             STR      R0,[R5, #+8]
   \       0xC4   0xE01E             B.N      ??HAL_ADCEx_InjectedStart_4
    217                }
    218              }
    219              else
    220              {
    221                tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
   \                     ??HAL_ADCEx_InjectedStart_6: (+1)
   \       0xC6   0x6820             LDR      R0,[R4, #+0]
   \       0xC8   0x6880             LDR      R0,[R0, #+8]
   \       0xCA   0xF410 0x1F40      TST      R0,#0x300000
   \       0xCE   0xD101             BNE.N    ??HAL_ADCEx_InjectedStart_9
   \       0xD0   0x2101             MOVS     R1,#+1
   \       0xD2   0xE000             B.N      ??HAL_ADCEx_InjectedStart_10
   \                     ??HAL_ADCEx_InjectedStart_9: (+1)
   \       0xD4   0x2100             MOVS     R1,#+0
    222                tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
   \                     ??HAL_ADCEx_InjectedStart_10: (+1)
   \       0xD6   0x6820             LDR      R0,[R4, #+0]
   \       0xD8   0x6840             LDR      R0,[R0, #+4]
   \       0xDA   0x0A80             LSRS     R0,R0,#+10
   \       0xDC   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0xE0   0xF090 0x0001      EORS     R0,R0,#0x1
   \       0xE4   0x0002             MOVS     R2,R0
    223                if((hadc->Instance == ADC1) && tmp1 && tmp2)  
   \       0xE6   0x6820             LDR      R0,[R4, #+0]
   \       0xE8   0x.... 0x....      LDR.W    R5,??DataTable6_4
   \       0xEC   0x42A8             CMP      R0,R5
   \       0xEE   0xD109             BNE.N    ??HAL_ADCEx_InjectedStart_4
   \       0xF0   0x2900             CMP      R1,#+0
   \       0xF2   0xD007             BEQ.N    ??HAL_ADCEx_InjectedStart_4
   \       0xF4   0x2A00             CMP      R2,#+0
   \       0xF6   0xD005             BEQ.N    ??HAL_ADCEx_InjectedStart_4
    224                {
    225                  /* Enable the selected ADC software conversion for injected group */
    226                  hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
   \       0xF8   0x6820             LDR      R0,[R4, #+0]
   \       0xFA   0x6880             LDR      R0,[R0, #+8]
   \       0xFC   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \      0x100   0x6825             LDR      R5,[R4, #+0]
   \      0x102   0x60A8             STR      R0,[R5, #+8]
    227                }
    228              }
    229            }
    230            
    231            /* Return function status */
    232            return HAL_OK;
   \                     ??HAL_ADCEx_InjectedStart_4: (+1)
   \      0x104   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADCEx_InjectedStart_1: (+1)
   \      0x106   0xBC32             POP      {R1,R4,R5}
   \      0x108   0x4770             BX       LR
    233          }
    234          
    235          /**
    236            * @brief  Enables the interrupt and starts ADC conversion of injected channels.
    237            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
    238            *         the configuration information for the specified ADC.
    239            *
    240            * @retval HAL status.
    241            */

   \                                 In section .text, align 2, keep-with-next
    242          HAL_StatusTypeDef HAL_ADCEx_InjectedStart_IT(ADC_HandleTypeDef* hadc)
    243          {
   \                     HAL_ADCEx_InjectedStart_IT: (+1)
   \        0x0   0xB438             PUSH     {R3-R5}
   \        0x2   0x0004             MOVS     R4,R0
    244            __IO uint32_t counter = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
    245            uint32_t tmp1 = 0U, tmp2 = 0U;
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x2200             MOVS     R2,#+0
    246            ADC_Common_TypeDef *tmpADC_Common;
    247            
    248            /* Process locked */
    249            __HAL_LOCK(hadc);
   \        0xC   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD101             BNE.N    ??HAL_ADCEx_InjectedStart_IT_0
   \       0x14   0x2002             MOVS     R0,#+2
   \       0x16   0xE07C             B.N      ??HAL_ADCEx_InjectedStart_IT_1
   \                     ??HAL_ADCEx_InjectedStart_IT_0: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xF884 0x003C      STRB     R0,[R4, #+60]
    250            
    251            /* Enable the ADC peripheral */
    252            
    253            /* Check if ADC peripheral is disabled in order to enable it and wait during 
    254               Tstab time the ADC's stabilization */
    255            if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6880             LDR      R0,[R0, #+8]
   \       0x22   0x07C0             LSLS     R0,R0,#+31
   \       0x24   0xD416             BMI.N    ??HAL_ADCEx_InjectedStart_IT_2
    256            {  
    257              /* Enable the Peripheral */
    258              __HAL_ADC_ENABLE(hadc);
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6880             LDR      R0,[R0, #+8]
   \       0x2A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x2E   0x6825             LDR      R5,[R4, #+0]
   \       0x30   0x60A8             STR      R0,[R5, #+8]
    259              
    260              /* Delay for ADC stabilization time */
    261              /* Compute number of CPU cycles to wait for */
    262              counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x36   0x6800             LDR      R0,[R0, #+0]
   \       0x38   0x.... 0x....      LDR.W    R5,??DataTable6_1
   \       0x3C   0xFBB0 0xF5F5      UDIV     R5,R0,R5
   \       0x40   0x2003             MOVS     R0,#+3
   \       0x42   0x4345             MULS     R5,R0,R5
   \       0x44   0x9500             STR      R5,[SP, #+0]
    263              while(counter != 0U)
   \                     ??HAL_ADCEx_InjectedStart_IT_3: (+1)
   \       0x46   0x9800             LDR      R0,[SP, #+0]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD003             BEQ.N    ??HAL_ADCEx_InjectedStart_IT_2
    264              {
    265                counter--;
   \       0x4C   0x9800             LDR      R0,[SP, #+0]
   \       0x4E   0x1E40             SUBS     R0,R0,#+1
   \       0x50   0x9000             STR      R0,[SP, #+0]
   \       0x52   0xE7F8             B.N      ??HAL_ADCEx_InjectedStart_IT_3
    266              }
    267            }
    268            
    269            /* Start conversion if ADC is effectively enabled */
    270            if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
   \                     ??HAL_ADCEx_InjectedStart_IT_2: (+1)
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x6880             LDR      R0,[R0, #+8]
   \       0x58   0x07C0             LSLS     R0,R0,#+31
   \       0x5A   0xD559             BPL.N    ??HAL_ADCEx_InjectedStart_IT_4
    271            {
    272              /* Set ADC state                                                          */
    273              /* - Clear state bitfield related to injected group conversion results    */
    274              /* - Set state bitfield related to injected operation                     */
    275              ADC_STATE_CLR_SET(hadc->State,
    276                                HAL_ADC_STATE_READY | HAL_ADC_STATE_INJ_EOC,
    277                                HAL_ADC_STATE_INJ_BUSY);
   \       0x5C   0x6C25             LDR      R5,[R4, #+64]
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \       0x62   0x4005             ANDS     R5,R0,R5
   \       0x64   0xF455 0x5580      ORRS     R5,R5,#0x1000
   \       0x68   0x6425             STR      R5,[R4, #+64]
    278              
    279              /* Check if a regular conversion is ongoing */
    280              /* Note: On this device, there is no ADC error code fields related to     */
    281              /*       conversions on group injected only. In case of conversion on     */
    282              /*       going on group regular, no error code is reset.                  */
    283              if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
   \       0x6A   0x6C20             LDR      R0,[R4, #+64]
   \       0x6C   0x05C0             LSLS     R0,R0,#+23
   \       0x6E   0xD401             BMI.N    ??HAL_ADCEx_InjectedStart_IT_5
    284              {
    285                /* Reset ADC all error code fields */
    286                ADC_CLEAR_ERRORCODE(hadc);
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x6460             STR      R0,[R4, #+68]
    287              }
    288              
    289              /* Process unlocked */
    290              /* Unlock before starting ADC conversions: in case of potential           */
    291              /* interruption, to let the process to ADC IRQ Handler.                   */
    292              __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_InjectedStart_IT_5: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xF884 0x003C      STRB     R0,[R4, #+60]
    293              
    294              /* Clear injected group conversion flag */
    295              /* (To ensure of no unknown state from potential previous ADC operations) */
    296              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
   \       0x7A   0xF07F 0x0004      MVNS     R0,#+4
   \       0x7E   0x6825             LDR      R5,[R4, #+0]
   \       0x80   0x6028             STR      R0,[R5, #+0]
    297              
    298              /* Enable end of conversion interrupt for injected channels */
    299              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_JEOC);
   \       0x82   0x6820             LDR      R0,[R4, #+0]
   \       0x84   0x6840             LDR      R0,[R0, #+4]
   \       0x86   0xF050 0x0080      ORRS     R0,R0,#0x80
   \       0x8A   0x6825             LDR      R5,[R4, #+0]
   \       0x8C   0x6068             STR      R0,[R5, #+4]
    300          
    301              /* Pointer to the common control register to which is belonging hadc    */
    302              /* (Depending on STM32F4 product, there may be up to 3 ADC and 1 common */
    303              /* control register)                                                    */
    304              tmpADC_Common = ADC_COMMON_REGISTER(hadc);
   \       0x8E   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \       0x92   0x0003             MOVS     R3,R0
    305              
    306              /* Check if Multimode enabled */
    307              if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
   \       0x94   0x6858             LDR      R0,[R3, #+4]
   \       0x96   0xF010 0x0F1F      TST      R0,#0x1F
   \       0x9A   0xD11A             BNE.N    ??HAL_ADCEx_InjectedStart_IT_6
    308              {
    309                tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
   \       0x9C   0x6820             LDR      R0,[R4, #+0]
   \       0x9E   0x6880             LDR      R0,[R0, #+8]
   \       0xA0   0xF410 0x1F40      TST      R0,#0x300000
   \       0xA4   0xD101             BNE.N    ??HAL_ADCEx_InjectedStart_IT_7
   \       0xA6   0x2101             MOVS     R1,#+1
   \       0xA8   0xE000             B.N      ??HAL_ADCEx_InjectedStart_IT_8
   \                     ??HAL_ADCEx_InjectedStart_IT_7: (+1)
   \       0xAA   0x2100             MOVS     R1,#+0
    310                tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
   \                     ??HAL_ADCEx_InjectedStart_IT_8: (+1)
   \       0xAC   0x6820             LDR      R0,[R4, #+0]
   \       0xAE   0x6840             LDR      R0,[R0, #+4]
   \       0xB0   0x0A80             LSRS     R0,R0,#+10
   \       0xB2   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0xB6   0xF090 0x0001      EORS     R0,R0,#0x1
   \       0xBA   0x0002             MOVS     R2,R0
    311                if(tmp1 && tmp2)
   \       0xBC   0x2900             CMP      R1,#+0
   \       0xBE   0xD027             BEQ.N    ??HAL_ADCEx_InjectedStart_IT_4
   \       0xC0   0x2A00             CMP      R2,#+0
   \       0xC2   0xD025             BEQ.N    ??HAL_ADCEx_InjectedStart_IT_4
    312                {
    313                  /* Enable the selected ADC software conversion for injected group */
    314                  hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
   \       0xC4   0x6820             LDR      R0,[R4, #+0]
   \       0xC6   0x6880             LDR      R0,[R0, #+8]
   \       0xC8   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \       0xCC   0x6825             LDR      R5,[R4, #+0]
   \       0xCE   0x60A8             STR      R0,[R5, #+8]
   \       0xD0   0xE01E             B.N      ??HAL_ADCEx_InjectedStart_IT_4
    315                }
    316              }
    317              else
    318              {
    319                tmp1 = HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_JEXTEN);
   \                     ??HAL_ADCEx_InjectedStart_IT_6: (+1)
   \       0xD2   0x6820             LDR      R0,[R4, #+0]
   \       0xD4   0x6880             LDR      R0,[R0, #+8]
   \       0xD6   0xF410 0x1F40      TST      R0,#0x300000
   \       0xDA   0xD101             BNE.N    ??HAL_ADCEx_InjectedStart_IT_9
   \       0xDC   0x2101             MOVS     R1,#+1
   \       0xDE   0xE000             B.N      ??HAL_ADCEx_InjectedStart_IT_10
   \                     ??HAL_ADCEx_InjectedStart_IT_9: (+1)
   \       0xE0   0x2100             MOVS     R1,#+0
    320                tmp2 = HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO);
   \                     ??HAL_ADCEx_InjectedStart_IT_10: (+1)
   \       0xE2   0x6820             LDR      R0,[R4, #+0]
   \       0xE4   0x6840             LDR      R0,[R0, #+4]
   \       0xE6   0x0A80             LSRS     R0,R0,#+10
   \       0xE8   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0xEC   0xF090 0x0001      EORS     R0,R0,#0x1
   \       0xF0   0x0002             MOVS     R2,R0
    321                if((hadc->Instance == ADC1) && tmp1 && tmp2)  
   \       0xF2   0x6820             LDR      R0,[R4, #+0]
   \       0xF4   0x.... 0x....      LDR.W    R5,??DataTable6_4
   \       0xF8   0x42A8             CMP      R0,R5
   \       0xFA   0xD109             BNE.N    ??HAL_ADCEx_InjectedStart_IT_4
   \       0xFC   0x2900             CMP      R1,#+0
   \       0xFE   0xD007             BEQ.N    ??HAL_ADCEx_InjectedStart_IT_4
   \      0x100   0x2A00             CMP      R2,#+0
   \      0x102   0xD005             BEQ.N    ??HAL_ADCEx_InjectedStart_IT_4
    322                {
    323                  /* Enable the selected ADC software conversion for injected group */
    324                  hadc->Instance->CR2 |= ADC_CR2_JSWSTART;
   \      0x104   0x6820             LDR      R0,[R4, #+0]
   \      0x106   0x6880             LDR      R0,[R0, #+8]
   \      0x108   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \      0x10C   0x6825             LDR      R5,[R4, #+0]
   \      0x10E   0x60A8             STR      R0,[R5, #+8]
    325                }
    326              }
    327            }
    328            
    329            /* Return function status */
    330            return HAL_OK;
   \                     ??HAL_ADCEx_InjectedStart_IT_4: (+1)
   \      0x110   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADCEx_InjectedStart_IT_1: (+1)
   \      0x112   0xBC32             POP      {R1,R4,R5}
   \      0x114   0x4770             BX       LR
    331          }
    332          
    333          /**
    334            * @brief  Stop conversion of injected channels. Disable ADC peripheral if
    335            *         no regular conversion is on going.
    336            * @note   If ADC must be disabled and if conversion is on going on 
    337            *         regular group, function HAL_ADC_Stop must be used to stop both
    338            *         injected and regular groups, and disable the ADC.
    339            * @note   If injected group mode auto-injection is enabled,
    340            *         function HAL_ADC_Stop must be used.
    341            * @note   In case of auto-injection mode, HAL_ADC_Stop must be used.
    342            * @param  hadc ADC handle
    343            * @retval None
    344            */

   \                                 In section .text, align 2, keep-with-next
    345          HAL_StatusTypeDef HAL_ADCEx_InjectedStop(ADC_HandleTypeDef* hadc)
    346          {
   \                     HAL_ADCEx_InjectedStop: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    347            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \        0x2   0x2200             MOVS     R2,#+0
    348            
    349            /* Check the parameters */
    350            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    351          
    352            /* Process locked */
    353            __HAL_LOCK(hadc);
   \        0x4   0xF891 0x003C      LDRB     R0,[R1, #+60]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE.N    ??HAL_ADCEx_InjectedStop_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE025             B.N      ??HAL_ADCEx_InjectedStop_1
   \                     ??HAL_ADCEx_InjectedStop_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xF881 0x003C      STRB     R0,[R1, #+60]
    354              
    355            /* Stop potential conversion and disable ADC peripheral                     */
    356            /* Conditioned to:                                                          */
    357            /* - No conversion on the other group (regular group) is intended to        */
    358            /*   continue (injected and regular groups stop conversion and ADC disable  */
    359            /*   are common)                                                            */
    360            /* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */
    361            if(((hadc->State & HAL_ADC_STATE_REG_BUSY) == RESET)  &&
    362               HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)   )
   \       0x16   0x6C08             LDR      R0,[R1, #+64]
   \       0x18   0x05C0             LSLS     R0,R0,#+23
   \       0x1A   0xD414             BMI.N    ??HAL_ADCEx_InjectedStop_2
   \       0x1C   0x6808             LDR      R0,[R1, #+0]
   \       0x1E   0x6840             LDR      R0,[R0, #+4]
   \       0x20   0x0540             LSLS     R0,R0,#+21
   \       0x22   0xD410             BMI.N    ??HAL_ADCEx_InjectedStop_2
    363            {
    364              /* Stop potential conversion on going, on regular and injected groups */
    365              /* Disable ADC peripheral */
    366              __HAL_ADC_DISABLE(hadc);
   \       0x24   0x6808             LDR      R0,[R1, #+0]
   \       0x26   0x6880             LDR      R0,[R0, #+8]
   \       0x28   0x0840             LSRS     R0,R0,#+1
   \       0x2A   0x0040             LSLS     R0,R0,#+1
   \       0x2C   0x680B             LDR      R3,[R1, #+0]
   \       0x2E   0x6098             STR      R0,[R3, #+8]
    367              
    368              /* Check if ADC is effectively disabled */
    369              if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
   \       0x30   0x6808             LDR      R0,[R1, #+0]
   \       0x32   0x6880             LDR      R0,[R0, #+8]
   \       0x34   0x07C0             LSLS     R0,R0,#+31
   \       0x36   0xD40C             BMI.N    ??HAL_ADCEx_InjectedStop_3
    370              {
    371                /* Set ADC state */
    372                ADC_STATE_CLR_SET(hadc->State,
    373                                  HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
    374                                  HAL_ADC_STATE_READY);
   \       0x38   0x6C08             LDR      R0,[R1, #+64]
   \       0x3A   0xF430 0x5088      BICS     R0,R0,#0x1100
   \       0x3E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x42   0x6408             STR      R0,[R1, #+64]
   \       0x44   0xE005             B.N      ??HAL_ADCEx_InjectedStop_3
    375              }
    376            }
    377            else
    378            {
    379              /* Update ADC state machine to error */
    380              SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
   \                     ??HAL_ADCEx_InjectedStop_2: (+1)
   \       0x46   0x6C08             LDR      R0,[R1, #+64]
   \       0x48   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x4C   0x6408             STR      R0,[R1, #+64]
    381                
    382              tmp_hal_status = HAL_ERROR;
   \       0x4E   0x2001             MOVS     R0,#+1
   \       0x50   0x0002             MOVS     R2,R0
    383            }
    384            
    385            /* Process unlocked */
    386            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_InjectedStop_3: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xF881 0x003C      STRB     R0,[R1, #+60]
    387            
    388            /* Return function status */
    389            return tmp_hal_status;
   \       0x58   0x0010             MOVS     R0,R2
   \       0x5A   0xB2C0             UXTB     R0,R0
   \                     ??HAL_ADCEx_InjectedStop_1: (+1)
   \       0x5C   0x4770             BX       LR
    390          }
    391          
    392          /**
    393            * @brief  Poll for injected conversion complete
    394            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
    395            *         the configuration information for the specified ADC.
    396            * @param  Timeout Timeout value in millisecond.  
    397            * @retval HAL status
    398            */

   \                                 In section .text, align 2, keep-with-next
    399          HAL_StatusTypeDef HAL_ADCEx_InjectedPollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
    400          {
   \                     HAL_ADCEx_InjectedPollForConversion: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    401            uint32_t tickstart = 0U;
   \        0x6   0x2700             MOVS     R7,#+0
    402          
    403            /* Get tick */ 
    404            tickstart = HAL_GetTick();
   \        0x8   0x.... 0x....      BL       HAL_GetTick
   \        0xC   0x0006             MOVS     R6,R0
    405          
    406            /* Check End of conversion flag */
    407            while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC)))
   \                     ??HAL_ADCEx_InjectedPollForConversion_0: (+1)
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x0740             LSLS     R0,R0,#+29
   \       0x14   0xD410             BMI.N    ??HAL_ADCEx_InjectedPollForConversion_1
    408            {
    409              /* Check for the Timeout */
    410              if(Timeout != HAL_MAX_DELAY)
   \       0x16   0xF114 0x0F01      CMN      R4,#+1
   \       0x1A   0xD0F8             BEQ.N    ??HAL_ADCEx_InjectedPollForConversion_0
    411              {
    412                if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD004             BEQ.N    ??HAL_ADCEx_InjectedPollForConversion_2
   \       0x20   0x.... 0x....      BL       HAL_GetTick
   \       0x24   0x1B80             SUBS     R0,R0,R6
   \       0x26   0x4284             CMP      R4,R0
   \       0x28   0xD2F1             BCS.N    ??HAL_ADCEx_InjectedPollForConversion_0
    413                {
    414                  hadc->State= HAL_ADC_STATE_TIMEOUT;
   \                     ??HAL_ADCEx_InjectedPollForConversion_2: (+1)
   \       0x2A   0x2004             MOVS     R0,#+4
   \       0x2C   0x6428             STR      R0,[R5, #+64]
    415                  /* Process unlocked */
    416                  __HAL_UNLOCK(hadc);
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xF885 0x003C      STRB     R0,[R5, #+60]
    417                  return HAL_TIMEOUT;
   \       0x34   0x2003             MOVS     R0,#+3
   \       0x36   0xE02D             B.N      ??HAL_ADCEx_InjectedPollForConversion_3
    418                }
    419              }
    420            }
    421            
    422            /* Clear injected group conversion flag */
    423            __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JSTRT | ADC_FLAG_JEOC);
   \                     ??HAL_ADCEx_InjectedPollForConversion_1: (+1)
   \       0x38   0xF07F 0x000C      MVNS     R0,#+12
   \       0x3C   0x6829             LDR      R1,[R5, #+0]
   \       0x3E   0x6008             STR      R0,[R1, #+0]
    424              
    425            /* Update ADC state machine */
    426            SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
   \       0x40   0x6C28             LDR      R0,[R5, #+64]
   \       0x42   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \       0x46   0x6428             STR      R0,[R5, #+64]
    427            
    428            /* Determine whether any further conversion upcoming on group injected      */
    429            /* by external trigger, continuous mode or scan sequence on going.          */
    430            /* Note: On STM32F4, there is no independent flag of end of sequence.       */
    431            /*       The test of scan sequence on going is done either with scan        */
    432            /*       sequence disabled or with end of conversion flag set to            */
    433            /*       of end of sequence.                                                */
    434            if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                    &&
    435               (HAL_IS_BIT_CLR(hadc->Instance->JSQR, ADC_JSQR_JL)  ||
    436                HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)    ) &&
    437               (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&
    438                (ADC_IS_SOFTWARE_START_REGULAR(hadc)       &&
    439                (hadc->Init.ContinuousConvMode == DISABLE)   )       )   )
   \       0x48   0x6828             LDR      R0,[R5, #+0]
   \       0x4A   0x6880             LDR      R0,[R0, #+8]
   \       0x4C   0xF410 0x1F40      TST      R0,#0x300000
   \       0x50   0xD11F             BNE.N    ??HAL_ADCEx_InjectedPollForConversion_4
   \       0x52   0x6828             LDR      R0,[R5, #+0]
   \       0x54   0x6B80             LDR      R0,[R0, #+56]
   \       0x56   0xF410 0x1F40      TST      R0,#0x300000
   \       0x5A   0xD003             BEQ.N    ??HAL_ADCEx_InjectedPollForConversion_5
   \       0x5C   0x6828             LDR      R0,[R5, #+0]
   \       0x5E   0x6880             LDR      R0,[R0, #+8]
   \       0x60   0x0540             LSLS     R0,R0,#+21
   \       0x62   0xD416             BMI.N    ??HAL_ADCEx_InjectedPollForConversion_4
   \                     ??HAL_ADCEx_InjectedPollForConversion_5: (+1)
   \       0x64   0x6828             LDR      R0,[R5, #+0]
   \       0x66   0x6840             LDR      R0,[R0, #+4]
   \       0x68   0x0540             LSLS     R0,R0,#+21
   \       0x6A   0xD412             BMI.N    ??HAL_ADCEx_InjectedPollForConversion_4
   \       0x6C   0x6828             LDR      R0,[R5, #+0]
   \       0x6E   0x6880             LDR      R0,[R0, #+8]
   \       0x70   0xF010 0x5F40      TST      R0,#0x30000000
   \       0x74   0xD10D             BNE.N    ??HAL_ADCEx_InjectedPollForConversion_4
   \       0x76   0x7E28             LDRB     R0,[R5, #+24]
   \       0x78   0x2800             CMP      R0,#+0
   \       0x7A   0xD10A             BNE.N    ??HAL_ADCEx_InjectedPollForConversion_4
    440            {
    441              /* Set ADC state */
    442              CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
   \       0x7C   0x6C28             LDR      R0,[R5, #+64]
   \       0x7E   0xF430 0x5080      BICS     R0,R0,#0x1000
   \       0x82   0x6428             STR      R0,[R5, #+64]
    443              
    444              if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
   \       0x84   0x6C28             LDR      R0,[R5, #+64]
   \       0x86   0x05C0             LSLS     R0,R0,#+23
   \       0x88   0xD403             BMI.N    ??HAL_ADCEx_InjectedPollForConversion_4
    445              { 
    446                SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   \       0x8A   0x6C28             LDR      R0,[R5, #+64]
   \       0x8C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x90   0x6428             STR      R0,[R5, #+64]
    447              }
    448            }
    449            
    450            /* Return ADC state */
    451            return HAL_OK;
   \                     ??HAL_ADCEx_InjectedPollForConversion_4: (+1)
   \       0x92   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADCEx_InjectedPollForConversion_3: (+1)
   \       0x94   0xBDF2             POP      {R1,R4-R7,PC}
    452          }      
    453            
    454          /**
    455            * @brief  Stop conversion of injected channels, disable interruption of 
    456            *         end-of-conversion. Disable ADC peripheral if no regular conversion
    457            *         is on going.
    458            * @note   If ADC must be disabled and if conversion is on going on 
    459            *         regular group, function HAL_ADC_Stop must be used to stop both
    460            *         injected and regular groups, and disable the ADC.
    461            * @note   If injected group mode auto-injection is enabled,
    462            *         function HAL_ADC_Stop must be used.
    463            * @param  hadc ADC handle
    464            * @retval None
    465            */

   \                                 In section .text, align 2, keep-with-next
    466          HAL_StatusTypeDef HAL_ADCEx_InjectedStop_IT(ADC_HandleTypeDef* hadc)
    467          {
   \                     HAL_ADCEx_InjectedStop_IT: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    468            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \        0x2   0x2200             MOVS     R2,#+0
    469            
    470            /* Check the parameters */
    471            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    472          
    473            /* Process locked */
    474            __HAL_LOCK(hadc);
   \        0x4   0xF891 0x003C      LDRB     R0,[R1, #+60]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE.N    ??HAL_ADCEx_InjectedStop_IT_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE02B             B.N      ??HAL_ADCEx_InjectedStop_IT_1
   \                     ??HAL_ADCEx_InjectedStop_IT_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xF881 0x003C      STRB     R0,[R1, #+60]
    475              
    476            /* Stop potential conversion and disable ADC peripheral                     */
    477            /* Conditioned to:                                                          */
    478            /* - No conversion on the other group (regular group) is intended to        */
    479            /*   continue (injected and regular groups stop conversion and ADC disable  */
    480            /*   are common)                                                            */
    481            /* - In case of auto-injection mode, HAL_ADC_Stop must be used.             */ 
    482            if(((hadc->State & HAL_ADC_STATE_REG_BUSY) == RESET)  &&
    483               HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO)   )
   \       0x16   0x6C08             LDR      R0,[R1, #+64]
   \       0x18   0x05C0             LSLS     R0,R0,#+23
   \       0x1A   0xD41A             BMI.N    ??HAL_ADCEx_InjectedStop_IT_2
   \       0x1C   0x6808             LDR      R0,[R1, #+0]
   \       0x1E   0x6840             LDR      R0,[R0, #+4]
   \       0x20   0x0540             LSLS     R0,R0,#+21
   \       0x22   0xD416             BMI.N    ??HAL_ADCEx_InjectedStop_IT_2
    484            {
    485              /* Stop potential conversion on going, on regular and injected groups */
    486              /* Disable ADC peripheral */
    487              __HAL_ADC_DISABLE(hadc);
   \       0x24   0x6808             LDR      R0,[R1, #+0]
   \       0x26   0x6880             LDR      R0,[R0, #+8]
   \       0x28   0x0840             LSRS     R0,R0,#+1
   \       0x2A   0x0040             LSLS     R0,R0,#+1
   \       0x2C   0x680B             LDR      R3,[R1, #+0]
   \       0x2E   0x6098             STR      R0,[R3, #+8]
    488              
    489              /* Check if ADC is effectively disabled */
    490              if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
   \       0x30   0x6808             LDR      R0,[R1, #+0]
   \       0x32   0x6880             LDR      R0,[R0, #+8]
   \       0x34   0x07C0             LSLS     R0,R0,#+31
   \       0x36   0xD412             BMI.N    ??HAL_ADCEx_InjectedStop_IT_3
    491              {
    492                /* Disable ADC end of conversion interrupt for injected channels */
    493                __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
   \       0x38   0x6808             LDR      R0,[R1, #+0]
   \       0x3A   0x6840             LDR      R0,[R0, #+4]
   \       0x3C   0xF030 0x0080      BICS     R0,R0,#0x80
   \       0x40   0x680B             LDR      R3,[R1, #+0]
   \       0x42   0x6058             STR      R0,[R3, #+4]
    494                
    495                /* Set ADC state */
    496                ADC_STATE_CLR_SET(hadc->State,
    497                                  HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
    498                                  HAL_ADC_STATE_READY);
   \       0x44   0x6C08             LDR      R0,[R1, #+64]
   \       0x46   0xF430 0x5088      BICS     R0,R0,#0x1100
   \       0x4A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x4E   0x6408             STR      R0,[R1, #+64]
   \       0x50   0xE005             B.N      ??HAL_ADCEx_InjectedStop_IT_3
    499              }
    500            }
    501            else
    502            {
    503              /* Update ADC state machine to error */
    504              SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
   \                     ??HAL_ADCEx_InjectedStop_IT_2: (+1)
   \       0x52   0x6C08             LDR      R0,[R1, #+64]
   \       0x54   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x58   0x6408             STR      R0,[R1, #+64]
    505                
    506              tmp_hal_status = HAL_ERROR;
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0x0002             MOVS     R2,R0
    507            }
    508            
    509            /* Process unlocked */
    510            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_InjectedStop_IT_3: (+1)
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xF881 0x003C      STRB     R0,[R1, #+60]
    511            
    512            /* Return function status */
    513            return tmp_hal_status;
   \       0x64   0x0010             MOVS     R0,R2
   \       0x66   0xB2C0             UXTB     R0,R0
   \                     ??HAL_ADCEx_InjectedStop_IT_1: (+1)
   \       0x68   0x4770             BX       LR
    514          }
    515          
    516          /**
    517            * @brief  Gets the converted value from data register of injected channel.
    518            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
    519            *         the configuration information for the specified ADC.
    520            * @param  InjectedRank the ADC injected rank.
    521            *          This parameter can be one of the following values:
    522            *            @arg ADC_INJECTED_RANK_1: Injected Channel1 selected
    523            *            @arg ADC_INJECTED_RANK_2: Injected Channel2 selected
    524            *            @arg ADC_INJECTED_RANK_3: Injected Channel3 selected
    525            *            @arg ADC_INJECTED_RANK_4: Injected Channel4 selected
    526            * @retval None
    527            */

   \                                 In section .text, align 2, keep-with-next
    528          uint32_t HAL_ADCEx_InjectedGetValue(ADC_HandleTypeDef* hadc, uint32_t InjectedRank)
    529          {
   \                     HAL_ADCEx_InjectedGetValue: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x0002             MOVS     R2,R0
    530            __IO uint32_t tmp = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
    531            
    532            /* Check the parameters */
    533            assert_param(IS_ADC_INJECTED_RANK(InjectedRank));
    534            
    535            /* Clear injected group conversion flag to have similar behaviour as        */
    536            /* regular group: reading data register also clears end of conversion flag. */
    537            __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC);
   \        0x8   0xF07F 0x0004      MVNS     R0,#+4
   \        0xC   0x6813             LDR      R3,[R2, #+0]
   \        0xE   0x6018             STR      R0,[R3, #+0]
    538            
    539            /* Return the selected ADC converted value */ 
    540            switch(InjectedRank)
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD011             BEQ.N    ??HAL_ADCEx_InjectedGetValue_0
   \       0x14   0xD314             BCC.N    ??HAL_ADCEx_InjectedGetValue_1
   \       0x16   0x2903             CMP      R1,#+3
   \       0x18   0xD006             BEQ.N    ??HAL_ADCEx_InjectedGetValue_2
   \       0x1A   0xD309             BCC.N    ??HAL_ADCEx_InjectedGetValue_3
   \       0x1C   0x2904             CMP      R1,#+4
   \       0x1E   0xD10F             BNE.N    ??HAL_ADCEx_InjectedGetValue_1
    541            {  
    542              case ADC_INJECTED_RANK_4:
    543              {
    544                tmp =  hadc->Instance->JDR4;
   \                     ??HAL_ADCEx_InjectedGetValue_4: (+1)
   \       0x20   0x6810             LDR      R0,[R2, #+0]
   \       0x22   0x6C80             LDR      R0,[R0, #+72]
   \       0x24   0x9000             STR      R0,[SP, #+0]
    545              }  
    546              break;
   \       0x26   0xE00B             B.N      ??HAL_ADCEx_InjectedGetValue_5
    547              case ADC_INJECTED_RANK_3: 
    548              {  
    549                tmp =  hadc->Instance->JDR3;
   \                     ??HAL_ADCEx_InjectedGetValue_2: (+1)
   \       0x28   0x6810             LDR      R0,[R2, #+0]
   \       0x2A   0x6C40             LDR      R0,[R0, #+68]
   \       0x2C   0x9000             STR      R0,[SP, #+0]
    550              }  
    551              break;
   \       0x2E   0xE007             B.N      ??HAL_ADCEx_InjectedGetValue_5
    552              case ADC_INJECTED_RANK_2: 
    553              {  
    554                tmp =  hadc->Instance->JDR2;
   \                     ??HAL_ADCEx_InjectedGetValue_3: (+1)
   \       0x30   0x6810             LDR      R0,[R2, #+0]
   \       0x32   0x6C00             LDR      R0,[R0, #+64]
   \       0x34   0x9000             STR      R0,[SP, #+0]
    555              }
    556              break;
   \       0x36   0xE003             B.N      ??HAL_ADCEx_InjectedGetValue_5
    557              case ADC_INJECTED_RANK_1:
    558              {
    559                tmp =  hadc->Instance->JDR1;
   \                     ??HAL_ADCEx_InjectedGetValue_0: (+1)
   \       0x38   0x6810             LDR      R0,[R2, #+0]
   \       0x3A   0x6BC0             LDR      R0,[R0, #+60]
   \       0x3C   0x9000             STR      R0,[SP, #+0]
    560              }
    561              break;
   \       0x3E   0xE7FF             B.N      ??HAL_ADCEx_InjectedGetValue_5
    562              default:
    563              break;  
    564            }
    565            return tmp;
   \                     ??HAL_ADCEx_InjectedGetValue_1: (+1)
   \                     ??HAL_ADCEx_InjectedGetValue_5: (+1)
   \       0x40   0x9800             LDR      R0,[SP, #+0]
   \       0x42   0xB001             ADD      SP,SP,#+4
   \       0x44   0x4770             BX       LR
    566          }
    567          
    568          /**
    569            * @brief  Enables ADC DMA request after last transfer (Multi-ADC mode) and enables ADC peripheral
    570            * 
    571            * @note   Caution: This function must be used only with the ADC master.  
    572            *
    573            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
    574            *         the configuration information for the specified ADC.
    575            * @param  pData   Pointer to buffer in which transferred from ADC peripheral to memory will be stored. 
    576            * @param  Length  The length of data to be transferred from ADC peripheral to memory.  
    577            * @retval HAL status
    578            */

   \                                 In section .text, align 2, keep-with-next
    579          HAL_StatusTypeDef HAL_ADCEx_MultiModeStart_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
    580          {
   \                     HAL_ADCEx_MultiModeStart_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0017             MOVS     R7,R2
    581            __IO uint32_t counter = 0U;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9000             STR      R0,[SP, #+0]
    582            ADC_Common_TypeDef *tmpADC_Common;
    583            
    584            /* Check the parameters */
    585            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
    586            assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
    587            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DMAContinuousRequests));
    588            
    589            /* Process locked */
    590            __HAL_LOCK(hadc);
   \        0xC   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD101             BNE.N    ??HAL_ADCEx_MultiModeStart_DMA_0
   \       0x14   0x2002             MOVS     R0,#+2
   \       0x16   0xE076             B.N      ??HAL_ADCEx_MultiModeStart_DMA_1
   \                     ??HAL_ADCEx_MultiModeStart_DMA_0: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xF885 0x003C      STRB     R0,[R5, #+60]
    591            
    592            /* Check if ADC peripheral is disabled in order to enable it and wait during 
    593               Tstab time the ADC's stabilization */
    594            if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
   \       0x1E   0x6828             LDR      R0,[R5, #+0]
   \       0x20   0x6880             LDR      R0,[R0, #+8]
   \       0x22   0x07C0             LSLS     R0,R0,#+31
   \       0x24   0xD416             BMI.N    ??HAL_ADCEx_MultiModeStart_DMA_2
    595            {  
    596              /* Enable the Peripheral */
    597              __HAL_ADC_ENABLE(hadc);
   \       0x26   0x6828             LDR      R0,[R5, #+0]
   \       0x28   0x6880             LDR      R0,[R0, #+8]
   \       0x2A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x2E   0x6829             LDR      R1,[R5, #+0]
   \       0x30   0x6088             STR      R0,[R1, #+8]
    598              
    599              /* Delay for temperature sensor stabilization time */
    600              /* Compute number of CPU cycles to wait for */
    601              counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable6
   \       0x36   0x6800             LDR      R0,[R0, #+0]
   \       0x38   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \       0x3C   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x40   0x2003             MOVS     R0,#+3
   \       0x42   0x4341             MULS     R1,R0,R1
   \       0x44   0x9100             STR      R1,[SP, #+0]
    602              while(counter != 0U)
   \                     ??HAL_ADCEx_MultiModeStart_DMA_3: (+1)
   \       0x46   0x9800             LDR      R0,[SP, #+0]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD003             BEQ.N    ??HAL_ADCEx_MultiModeStart_DMA_2
    603              {
    604                counter--;
   \       0x4C   0x9800             LDR      R0,[SP, #+0]
   \       0x4E   0x1E40             SUBS     R0,R0,#+1
   \       0x50   0x9000             STR      R0,[SP, #+0]
   \       0x52   0xE7F8             B.N      ??HAL_ADCEx_MultiModeStart_DMA_3
    605              }
    606            }
    607            
    608            /* Start conversion if ADC is effectively enabled */
    609            if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
   \                     ??HAL_ADCEx_MultiModeStart_DMA_2: (+1)
   \       0x54   0x6828             LDR      R0,[R5, #+0]
   \       0x56   0x6880             LDR      R0,[R0, #+8]
   \       0x58   0x07C0             LSLS     R0,R0,#+31
   \       0x5A   0xD553             BPL.N    ??HAL_ADCEx_MultiModeStart_DMA_4
    610            {
    611              /* Set ADC state                                                          */
    612              /* - Clear state bitfield related to regular group conversion results     */
    613              /* - Set state bitfield related to regular group operation                */
    614              ADC_STATE_CLR_SET(hadc->State,
    615                                HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR,
    616                                HAL_ADC_STATE_REG_BUSY);
   \       0x5C   0x6C29             LDR      R1,[R5, #+64]
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \       0x62   0x4001             ANDS     R1,R0,R1
   \       0x64   0xF451 0x7180      ORRS     R1,R1,#0x100
   \       0x68   0x6429             STR      R1,[R5, #+64]
    617              
    618              /* If conversions on group regular are also triggering group injected,    */
    619              /* update ADC state.                                                      */
    620              if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
   \       0x6A   0x6828             LDR      R0,[R5, #+0]
   \       0x6C   0x6840             LDR      R0,[R0, #+4]
   \       0x6E   0x0540             LSLS     R0,R0,#+21
   \       0x70   0xD504             BPL.N    ??HAL_ADCEx_MultiModeStart_DMA_5
    621              {
    622                ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0x6C29             LDR      R1,[R5, #+64]
   \       0x76   0xF360 0x310D      BFI      R1,R0,#+12,#+2
   \       0x7A   0x6429             STR      R1,[R5, #+64]
    623              }
    624              
    625              /* State machine update: Check if an injected conversion is ongoing */
    626              if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \                     ??HAL_ADCEx_MultiModeStart_DMA_5: (+1)
   \       0x7C   0x6C28             LDR      R0,[R5, #+64]
   \       0x7E   0x04C0             LSLS     R0,R0,#+19
   \       0x80   0xD504             BPL.N    ??HAL_ADCEx_MultiModeStart_DMA_6
    627              {
    628                /* Reset ADC error code fields related to conversions on group regular */
    629                CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
   \       0x82   0x6C68             LDR      R0,[R5, #+68]
   \       0x84   0xF030 0x0006      BICS     R0,R0,#0x6
   \       0x88   0x6468             STR      R0,[R5, #+68]
   \       0x8A   0xE001             B.N      ??HAL_ADCEx_MultiModeStart_DMA_7
    630              }
    631              else
    632              {
    633                /* Reset ADC all error code fields */
    634                ADC_CLEAR_ERRORCODE(hadc);
   \                     ??HAL_ADCEx_MultiModeStart_DMA_6: (+1)
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0x6468             STR      R0,[R5, #+68]
    635              }
    636              
    637              /* Process unlocked */
    638              /* Unlock before starting ADC conversions: in case of potential           */
    639              /* interruption, to let the process to ADC IRQ Handler.                   */
    640              __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_MultiModeStart_DMA_7: (+1)
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0xF885 0x003C      STRB     R0,[R5, #+60]
    641              
    642              /* Set the DMA transfer complete callback */
    643              hadc->DMA_Handle->XferCpltCallback = ADC_MultiModeDMAConvCplt;
   \       0x96   0x.... 0x....      ADR.W    R0,ADC_MultiModeDMAConvCplt
   \       0x9A   0x6BA9             LDR      R1,[R5, #+56]
   \       0x9C   0x63C8             STR      R0,[R1, #+60]
    644              
    645              /* Set the DMA half transfer complete callback */
    646              hadc->DMA_Handle->XferHalfCpltCallback = ADC_MultiModeDMAHalfConvCplt;
   \       0x9E   0x.... 0x....      ADR.W    R0,ADC_MultiModeDMAHalfConvCplt
   \       0xA2   0x6BA9             LDR      R1,[R5, #+56]
   \       0xA4   0x6408             STR      R0,[R1, #+64]
    647              
    648              /* Set the DMA error callback */
    649              hadc->DMA_Handle->XferErrorCallback = ADC_MultiModeDMAError ;
   \       0xA6   0x.... 0x....      ADR.W    R0,ADC_MultiModeDMAError
   \       0xAA   0x6BA9             LDR      R1,[R5, #+56]
   \       0xAC   0x64C8             STR      R0,[R1, #+76]
    650              
    651              /* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC     */
    652              /* start (in case of SW start):                                           */
    653              
    654              /* Clear regular group conversion flag and overrun flag */
    655              /* (To ensure of no unknown state from potential previous ADC operations) */
    656              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
   \       0xAE   0xF07F 0x0002      MVNS     R0,#+2
   \       0xB2   0x6829             LDR      R1,[R5, #+0]
   \       0xB4   0x6008             STR      R0,[R1, #+0]
    657          
    658              /* Enable ADC overrun interrupt */
    659              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
   \       0xB6   0x6828             LDR      R0,[R5, #+0]
   \       0xB8   0x6840             LDR      R0,[R0, #+4]
   \       0xBA   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \       0xBE   0x6829             LDR      R1,[R5, #+0]
   \       0xC0   0x6048             STR      R0,[R1, #+4]
    660          
    661              /* Pointer to the common control register to which is belonging hadc    */
    662              /* (Depending on STM32F4 product, there may be up to 3 ADC and 1 common */
    663              /* control register)                                                    */
    664              tmpADC_Common = ADC_COMMON_REGISTER(hadc);
   \       0xC2   0x....             LDR.N    R0,??DataTable6_3
   \       0xC4   0x0004             MOVS     R4,R0
    665          
    666              if (hadc->Init.DMAContinuousRequests != DISABLE)
   \       0xC6   0xF895 0x0030      LDRB     R0,[R5, #+48]
   \       0xCA   0x2800             CMP      R0,#+0
   \       0xCC   0xD004             BEQ.N    ??HAL_ADCEx_MultiModeStart_DMA_8
    667              {
    668                /* Enable the selected ADC DMA request after last transfer */
    669                tmpADC_Common->CCR |= ADC_CCR_DDS;
   \       0xCE   0x6860             LDR      R0,[R4, #+4]
   \       0xD0   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \       0xD4   0x6060             STR      R0,[R4, #+4]
   \       0xD6   0xE003             B.N      ??HAL_ADCEx_MultiModeStart_DMA_9
    670              }
    671              else
    672              {
    673                /* Disable the selected ADC EOC rising on each regular channel conversion */
    674                tmpADC_Common->CCR &= ~ADC_CCR_DDS;
   \                     ??HAL_ADCEx_MultiModeStart_DMA_8: (+1)
   \       0xD8   0x6860             LDR      R0,[R4, #+4]
   \       0xDA   0xF430 0x5000      BICS     R0,R0,#0x2000
   \       0xDE   0x6060             STR      R0,[R4, #+4]
    675              }
    676              
    677              /* Enable the DMA Stream */
    678              HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&tmpADC_Common->CDR, (uint32_t)pData, Length);
   \                     ??HAL_ADCEx_MultiModeStart_DMA_9: (+1)
   \       0xE0   0x003B             MOVS     R3,R7
   \       0xE2   0x0032             MOVS     R2,R6
   \       0xE4   0xF114 0x0108      ADDS     R1,R4,#+8
   \       0xE8   0x6BA8             LDR      R0,[R5, #+56]
   \       0xEA   0x.... 0x....      BL       HAL_DMA_Start_IT
    679              
    680              /* if no external trigger present enable software conversion of regular channels */
    681              if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
   \       0xEE   0x6828             LDR      R0,[R5, #+0]
   \       0xF0   0x6880             LDR      R0,[R0, #+8]
   \       0xF2   0xF010 0x5F40      TST      R0,#0x30000000
   \       0xF6   0xD105             BNE.N    ??HAL_ADCEx_MultiModeStart_DMA_4
    682              {
    683                /* Enable the selected ADC software conversion for regular group */
    684                hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
   \       0xF8   0x6828             LDR      R0,[R5, #+0]
   \       0xFA   0x6880             LDR      R0,[R0, #+8]
   \       0xFC   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \      0x100   0x6829             LDR      R1,[R5, #+0]
   \      0x102   0x6088             STR      R0,[R1, #+8]
    685              }
    686            }
    687            
    688            /* Return function status */
    689            return HAL_OK;
   \                     ??HAL_ADCEx_MultiModeStart_DMA_4: (+1)
   \      0x104   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADCEx_MultiModeStart_DMA_1: (+1)
   \      0x106   0xBDF2             POP      {R1,R4-R7,PC}
    690          }
    691          
    692          /**
    693            * @brief  Disables ADC DMA (multi-ADC mode) and disables ADC peripheral    
    694            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
    695            *         the configuration information for the specified ADC.
    696            * @retval HAL status
    697            */

   \                                 In section .text, align 2, keep-with-next
    698          HAL_StatusTypeDef HAL_ADCEx_MultiModeStop_DMA(ADC_HandleTypeDef* hadc)
    699          {
   \                     HAL_ADCEx_MultiModeStop_DMA: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    700            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
    701            ADC_Common_TypeDef *tmpADC_Common;
    702            
    703            /* Check the parameters */
    704            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    705            
    706            /* Process locked */
    707            __HAL_LOCK(hadc);
   \        0x6   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE.N    ??HAL_ADCEx_MultiModeStop_DMA_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE026             B.N      ??HAL_ADCEx_MultiModeStop_DMA_1
   \                     ??HAL_ADCEx_MultiModeStop_DMA_0: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xF884 0x003C      STRB     R0,[R4, #+60]
    708            
    709            /* Stop potential conversion on going, on regular and injected groups */
    710            /* Disable ADC peripheral */
    711            __HAL_ADC_DISABLE(hadc);
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x6880             LDR      R0,[R0, #+8]
   \       0x1C   0x0840             LSRS     R0,R0,#+1
   \       0x1E   0x0040             LSLS     R0,R0,#+1
   \       0x20   0x6821             LDR      R1,[R4, #+0]
   \       0x22   0x6088             STR      R0,[R1, #+8]
    712          
    713            /* Pointer to the common control register to which is belonging hadc    */
    714            /* (Depending on STM32F4 product, there may be up to 3 ADC and 1 common */
    715            /* control register)                                                    */
    716            tmpADC_Common = ADC_COMMON_REGISTER(hadc);
   \       0x24   0x....             LDR.N    R6,??DataTable6_3
    717          
    718            /* Check if ADC is effectively disabled */
    719            if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6880             LDR      R0,[R0, #+8]
   \       0x2A   0x07C0             LSLS     R0,R0,#+31
   \       0x2C   0xD413             BMI.N    ??HAL_ADCEx_MultiModeStop_DMA_2
    720            {
    721              /* Disable the selected ADC DMA mode for multimode */
    722              tmpADC_Common->CCR &= ~ADC_CCR_DDS;
   \       0x2E   0x6870             LDR      R0,[R6, #+4]
   \       0x30   0xF430 0x5000      BICS     R0,R0,#0x2000
   \       0x34   0x6070             STR      R0,[R6, #+4]
    723              
    724              /* Disable the DMA channel (in case of DMA in circular mode or stop while */
    725              /* DMA transfer is on going)                                              */
    726              tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
   \       0x36   0x6BA0             LDR      R0,[R4, #+56]
   \       0x38   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x3C   0x0005             MOVS     R5,R0
    727              
    728              /* Disable ADC overrun interrupt */
    729              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6840             LDR      R0,[R0, #+4]
   \       0x42   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \       0x46   0x6821             LDR      R1,[R4, #+0]
   \       0x48   0x6048             STR      R0,[R1, #+4]
    730              
    731              /* Set ADC state */
    732              ADC_STATE_CLR_SET(hadc->State,
    733                                HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
    734                                HAL_ADC_STATE_READY);
   \       0x4A   0x6C20             LDR      R0,[R4, #+64]
   \       0x4C   0xF430 0x5088      BICS     R0,R0,#0x1100
   \       0x50   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x54   0x6420             STR      R0,[R4, #+64]
    735            }
    736            
    737            /* Process unlocked */
    738            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_MultiModeStop_DMA_2: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xF884 0x003C      STRB     R0,[R4, #+60]
    739            
    740            /* Return function status */
    741            return tmp_hal_status;
   \       0x5C   0x0028             MOVS     R0,R5
   \       0x5E   0xB2C0             UXTB     R0,R0
   \                     ??HAL_ADCEx_MultiModeStop_DMA_1: (+1)
   \       0x60   0xBD70             POP      {R4-R6,PC}
    742          }
    743          
    744          /**
    745            * @brief  Returns the last ADC1, ADC2 and ADC3 regular conversions results 
    746            *         data in the selected multi mode.
    747            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
    748            *         the configuration information for the specified ADC.
    749            * @retval The converted data value.
    750            */

   \                                 In section .text, align 2, keep-with-next
    751          uint32_t HAL_ADCEx_MultiModeGetValue(ADC_HandleTypeDef* hadc)
    752          {
   \                     HAL_ADCEx_MultiModeGetValue: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    753            ADC_Common_TypeDef *tmpADC_Common;
    754          
    755            /* Pointer to the common control register to which is belonging hadc    */
    756            /* (Depending on STM32F4 product, there may be up to 3 ADC and 1 common */
    757            /* control register)                                                    */
    758            tmpADC_Common = ADC_COMMON_REGISTER(hadc);
   \        0x2   0x....             LDR.N    R0,??DataTable6_3
    759          
    760            /* Return the multi mode conversion value */
    761            return tmpADC_Common->CDR;
   \        0x4   0x6880             LDR      R0,[R0, #+8]
   \        0x6   0x4770             BX       LR
    762          }
    763          
    764          /**
    765            * @brief  Injected conversion complete callback in non blocking mode 
    766            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
    767            *         the configuration information for the specified ADC.
    768            * @retval None
    769            */

   \                                 In section .text, align 2
    770          __weak void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef* hadc)
    771          {
    772            /* Prevent unused argument(s) compilation warning */
    773            UNUSED(hadc);
    774            /* NOTE : This function Should not be modified, when the callback is needed,
    775                      the HAL_ADC_InjectedConvCpltCallback could be implemented in the user file
    776             */
    777          }
   \                     HAL_ADCEx_InjectedConvCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
    778          
    779          /**
    780            * @brief  Configures for the selected ADC injected channel its corresponding
    781            *         rank in the sequencer and its sample time.
    782            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
    783            *         the configuration information for the specified ADC.
    784            * @param  sConfigInjected ADC configuration structure for injected channel. 
    785            * @retval None
    786            */

   \                                 In section .text, align 2, keep-with-next
    787          HAL_StatusTypeDef HAL_ADCEx_InjectedConfigChannel(ADC_HandleTypeDef* hadc, ADC_InjectionConfTypeDef* sConfigInjected)
    788          {
   \                     HAL_ADCEx_InjectedConfigChannel: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x0002             MOVS     R2,R0
    789            
    790          #ifdef USE_FULL_ASSERT  
    791            uint32_t tmp = 0U;
    792            
    793          #endif /* USE_FULL_ASSERT  */
    794          
    795            ADC_Common_TypeDef *tmpADC_Common;
    796          
    797            /* Check the parameters */
    798            assert_param(IS_ADC_CHANNEL(sConfigInjected->InjectedChannel));
    799            assert_param(IS_ADC_INJECTED_RANK(sConfigInjected->InjectedRank));
    800            assert_param(IS_ADC_SAMPLE_TIME(sConfigInjected->InjectedSamplingTime));
    801            assert_param(IS_ADC_EXT_INJEC_TRIG(sConfigInjected->ExternalTrigInjecConv));
    802            assert_param(IS_ADC_INJECTED_LENGTH(sConfigInjected->InjectedNbrOfConversion));
    803            assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->AutoInjectedConv));
    804            assert_param(IS_FUNCTIONAL_STATE(sConfigInjected->InjectedDiscontinuousConvMode));
    805          
    806          #ifdef USE_FULL_ASSERT
    807            tmp = ADC_GET_RESOLUTION(hadc);
    808            assert_param(IS_ADC_RANGE(tmp, sConfigInjected->InjectedOffset));
    809          #endif /* USE_FULL_ASSERT  */
    810          
    811            if(sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
   \        0x4   0x....             LDR.N    R3,??DataTable6_6
   \        0x6   0x6988             LDR      R0,[R1, #+24]
   \        0x8   0x4298             CMP      R0,R3
    812            {
    813              assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(sConfigInjected->ExternalTrigInjecConvEdge));
    814            }
    815          
    816            /* Process locked */
    817            __HAL_LOCK(hadc);
   \                     ??HAL_ADCEx_InjectedConfigChannel_0: (+1)
   \        0xA   0xF892 0x003C      LDRB     R0,[R2, #+60]
   \        0xE   0x2801             CMP      R0,#+1
   \       0x10   0xD101             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_1
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xE0FC             B.N      ??HAL_ADCEx_InjectedConfigChannel_2
   \                     ??HAL_ADCEx_InjectedConfigChannel_1: (+1)
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xF882 0x003C      STRB     R0,[R2, #+60]
    818            
    819            /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
    820            if (sConfigInjected->InjectedChannel > ADC_CHANNEL_9)
   \       0x1C   0x6808             LDR      R0,[R1, #+0]
   \       0x1E   0x280A             CMP      R0,#+10
   \       0x20   0xD318             BCC.N    ??HAL_ADCEx_InjectedConfigChannel_3
    821            {
    822              /* Clear the old sample time */
    823              hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfigInjected->InjectedChannel);
   \       0x22   0x6810             LDR      R0,[R2, #+0]
   \       0x24   0x68C4             LDR      R4,[R0, #+12]
   \       0x26   0x2507             MOVS     R5,#+7
   \       0x28   0x6808             LDR      R0,[R1, #+0]
   \       0x2A   0x380A             SUBS     R0,R0,#+10
   \       0x2C   0x2603             MOVS     R6,#+3
   \       0x2E   0xFB10 0xF006      SMULBB   R0,R0,R6
   \       0x32   0x4085             LSLS     R5,R5,R0
   \       0x34   0x43AC             BICS     R4,R4,R5
   \       0x36   0x6810             LDR      R0,[R2, #+0]
   \       0x38   0x60C4             STR      R4,[R0, #+12]
    824              
    825              /* Set the new sample time */
    826              hadc->Instance->SMPR1 |= ADC_SMPR1(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
   \       0x3A   0x6810             LDR      R0,[R2, #+0]
   \       0x3C   0x68C4             LDR      R4,[R0, #+12]
   \       0x3E   0x688D             LDR      R5,[R1, #+8]
   \       0x40   0x6808             LDR      R0,[R1, #+0]
   \       0x42   0x380A             SUBS     R0,R0,#+10
   \       0x44   0x2603             MOVS     R6,#+3
   \       0x46   0xFB10 0xF006      SMULBB   R0,R0,R6
   \       0x4A   0x4085             LSLS     R5,R5,R0
   \       0x4C   0x432C             ORRS     R4,R5,R4
   \       0x4E   0x6810             LDR      R0,[R2, #+0]
   \       0x50   0x60C4             STR      R4,[R0, #+12]
   \       0x52   0xE013             B.N      ??HAL_ADCEx_InjectedConfigChannel_4
    827            }
    828            else /* ADC_Channel include in ADC_Channel_[0..9] */
    829            {
    830              /* Clear the old sample time */
    831              hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfigInjected->InjectedChannel);
   \                     ??HAL_ADCEx_InjectedConfigChannel_3: (+1)
   \       0x54   0x6810             LDR      R0,[R2, #+0]
   \       0x56   0x6904             LDR      R4,[R0, #+16]
   \       0x58   0x2507             MOVS     R5,#+7
   \       0x5A   0x680E             LDR      R6,[R1, #+0]
   \       0x5C   0x2003             MOVS     R0,#+3
   \       0x5E   0x4346             MULS     R6,R0,R6
   \       0x60   0x40B5             LSLS     R5,R5,R6
   \       0x62   0x43AC             BICS     R4,R4,R5
   \       0x64   0x6810             LDR      R0,[R2, #+0]
   \       0x66   0x6104             STR      R4,[R0, #+16]
    832              
    833              /* Set the new sample time */
    834              hadc->Instance->SMPR2 |= ADC_SMPR2(sConfigInjected->InjectedSamplingTime, sConfigInjected->InjectedChannel);
   \       0x68   0x6810             LDR      R0,[R2, #+0]
   \       0x6A   0x6904             LDR      R4,[R0, #+16]
   \       0x6C   0x688D             LDR      R5,[R1, #+8]
   \       0x6E   0x680E             LDR      R6,[R1, #+0]
   \       0x70   0x2003             MOVS     R0,#+3
   \       0x72   0x4346             MULS     R6,R0,R6
   \       0x74   0x40B5             LSLS     R5,R5,R6
   \       0x76   0x432C             ORRS     R4,R5,R4
   \       0x78   0x6810             LDR      R0,[R2, #+0]
   \       0x7A   0x6104             STR      R4,[R0, #+16]
    835            }
    836            
    837            /*---------------------------- ADCx JSQR Configuration -----------------*/
    838            hadc->Instance->JSQR &= ~(ADC_JSQR_JL);
   \                     ??HAL_ADCEx_InjectedConfigChannel_4: (+1)
   \       0x7C   0x6810             LDR      R0,[R2, #+0]
   \       0x7E   0x6B80             LDR      R0,[R0, #+56]
   \       0x80   0xF430 0x1040      BICS     R0,R0,#0x300000
   \       0x84   0x6814             LDR      R4,[R2, #+0]
   \       0x86   0x63A0             STR      R0,[R4, #+56]
    839            hadc->Instance->JSQR |=  ADC_SQR1(sConfigInjected->InjectedNbrOfConversion);
   \       0x88   0x6810             LDR      R0,[R2, #+0]
   \       0x8A   0x6B80             LDR      R0,[R0, #+56]
   \       0x8C   0x690C             LDR      R4,[R1, #+16]
   \       0x8E   0x1E64             SUBS     R4,R4,#+1
   \       0x90   0xEA50 0x5004      ORRS     R0,R0,R4, LSL #+20
   \       0x94   0x6814             LDR      R4,[R2, #+0]
   \       0x96   0x63A0             STR      R0,[R4, #+56]
    840            
    841            /* Rank configuration */
    842            
    843            /* Clear the old SQx bits for the selected rank */
    844            hadc->Instance->JSQR &= ~ADC_JSQR(ADC_JSQR_JSQ1, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
   \       0x98   0x6810             LDR      R0,[R2, #+0]
   \       0x9A   0x6B84             LDR      R4,[R0, #+56]
   \       0x9C   0x251F             MOVS     R5,#+31
   \       0x9E   0x684E             LDR      R6,[R1, #+4]
   \       0xA0   0x1CF6             ADDS     R6,R6,#+3
   \       0xA2   0x6908             LDR      R0,[R1, #+16]
   \       0xA4   0x1A36             SUBS     R6,R6,R0
   \       0xA6   0x2005             MOVS     R0,#+5
   \       0xA8   0xFB16 0xF000      SMULBB   R0,R6,R0
   \       0xAC   0x4085             LSLS     R5,R5,R0
   \       0xAE   0x43AC             BICS     R4,R4,R5
   \       0xB0   0x6810             LDR      R0,[R2, #+0]
   \       0xB2   0x6384             STR      R4,[R0, #+56]
    845             
    846            /* Set the SQx bits for the selected rank */
    847            hadc->Instance->JSQR |= ADC_JSQR(sConfigInjected->InjectedChannel, sConfigInjected->InjectedRank,sConfigInjected->InjectedNbrOfConversion);
   \       0xB4   0x6810             LDR      R0,[R2, #+0]
   \       0xB6   0x6B84             LDR      R4,[R0, #+56]
   \       0xB8   0x880D             LDRH     R5,[R1, #+0]
   \       0xBA   0x684E             LDR      R6,[R1, #+4]
   \       0xBC   0x1CF6             ADDS     R6,R6,#+3
   \       0xBE   0x6908             LDR      R0,[R1, #+16]
   \       0xC0   0x1A36             SUBS     R6,R6,R0
   \       0xC2   0x2005             MOVS     R0,#+5
   \       0xC4   0xFB16 0xF000      SMULBB   R0,R6,R0
   \       0xC8   0x4085             LSLS     R5,R5,R0
   \       0xCA   0x432C             ORRS     R4,R5,R4
   \       0xCC   0x6810             LDR      R0,[R2, #+0]
   \       0xCE   0x6384             STR      R4,[R0, #+56]
    848          
    849            /* Enable external trigger if trigger selection is different of software  */
    850            /* start.                                                                 */
    851            /* Note: This configuration keeps the hardware feature of parameter       */
    852            /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    853            /*       software start.                                                  */ 
    854            if(sConfigInjected->ExternalTrigInjecConv != ADC_INJECTED_SOFTWARE_START)
   \       0xD0   0x6988             LDR      R0,[R1, #+24]
   \       0xD2   0x4298             CMP      R0,R3
   \       0xD4   0xD018             BEQ.N    ??HAL_ADCEx_InjectedConfigChannel_5
    855            {  
    856              /* Select external trigger to start conversion */
    857              hadc->Instance->CR2 &= ~(ADC_CR2_JEXTSEL);
   \       0xD6   0x6810             LDR      R0,[R2, #+0]
   \       0xD8   0x6880             LDR      R0,[R0, #+8]
   \       0xDA   0xF430 0x2070      BICS     R0,R0,#0xF0000
   \       0xDE   0x6813             LDR      R3,[R2, #+0]
   \       0xE0   0x6098             STR      R0,[R3, #+8]
    858              hadc->Instance->CR2 |=  sConfigInjected->ExternalTrigInjecConv;
   \       0xE2   0x6810             LDR      R0,[R2, #+0]
   \       0xE4   0x6883             LDR      R3,[R0, #+8]
   \       0xE6   0x6988             LDR      R0,[R1, #+24]
   \       0xE8   0x4303             ORRS     R3,R0,R3
   \       0xEA   0x6810             LDR      R0,[R2, #+0]
   \       0xEC   0x6083             STR      R3,[R0, #+8]
    859              
    860              /* Select external trigger polarity */
    861              hadc->Instance->CR2 &= ~(ADC_CR2_JEXTEN);
   \       0xEE   0x6810             LDR      R0,[R2, #+0]
   \       0xF0   0x6880             LDR      R0,[R0, #+8]
   \       0xF2   0xF430 0x1040      BICS     R0,R0,#0x300000
   \       0xF6   0x6813             LDR      R3,[R2, #+0]
   \       0xF8   0x6098             STR      R0,[R3, #+8]
    862              hadc->Instance->CR2 |= sConfigInjected->ExternalTrigInjecConvEdge;
   \       0xFA   0x6810             LDR      R0,[R2, #+0]
   \       0xFC   0x6883             LDR      R3,[R0, #+8]
   \       0xFE   0x69C8             LDR      R0,[R1, #+28]
   \      0x100   0x4303             ORRS     R3,R0,R3
   \      0x102   0x6810             LDR      R0,[R2, #+0]
   \      0x104   0x6083             STR      R3,[R0, #+8]
   \      0x106   0xE00B             B.N      ??HAL_ADCEx_InjectedConfigChannel_6
    863            }
    864            else
    865            {
    866              /* Reset the external trigger */
    867              hadc->Instance->CR2 &= ~(ADC_CR2_JEXTSEL);
   \                     ??HAL_ADCEx_InjectedConfigChannel_5: (+1)
   \      0x108   0x6810             LDR      R0,[R2, #+0]
   \      0x10A   0x6880             LDR      R0,[R0, #+8]
   \      0x10C   0xF430 0x2070      BICS     R0,R0,#0xF0000
   \      0x110   0x6813             LDR      R3,[R2, #+0]
   \      0x112   0x6098             STR      R0,[R3, #+8]
    868              hadc->Instance->CR2 &= ~(ADC_CR2_JEXTEN);  
   \      0x114   0x6810             LDR      R0,[R2, #+0]
   \      0x116   0x6880             LDR      R0,[R0, #+8]
   \      0x118   0xF430 0x1040      BICS     R0,R0,#0x300000
   \      0x11C   0x6813             LDR      R3,[R2, #+0]
   \      0x11E   0x6098             STR      R0,[R3, #+8]
    869            }
    870            
    871            if (sConfigInjected->AutoInjectedConv != DISABLE)
   \                     ??HAL_ADCEx_InjectedConfigChannel_6: (+1)
   \      0x120   0x7D48             LDRB     R0,[R1, #+21]
   \      0x122   0x2800             CMP      R0,#+0
   \      0x124   0xD006             BEQ.N    ??HAL_ADCEx_InjectedConfigChannel_7
    872            {
    873              /* Enable the selected ADC automatic injected group conversion */
    874              hadc->Instance->CR1 |= ADC_CR1_JAUTO;
   \      0x126   0x6810             LDR      R0,[R2, #+0]
   \      0x128   0x6840             LDR      R0,[R0, #+4]
   \      0x12A   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x12E   0x6813             LDR      R3,[R2, #+0]
   \      0x130   0x6058             STR      R0,[R3, #+4]
   \      0x132   0xE005             B.N      ??HAL_ADCEx_InjectedConfigChannel_8
    875            }
    876            else
    877            {
    878              /* Disable the selected ADC automatic injected group conversion */
    879              hadc->Instance->CR1 &= ~(ADC_CR1_JAUTO);
   \                     ??HAL_ADCEx_InjectedConfigChannel_7: (+1)
   \      0x134   0x6810             LDR      R0,[R2, #+0]
   \      0x136   0x6840             LDR      R0,[R0, #+4]
   \      0x138   0xF430 0x6080      BICS     R0,R0,#0x400
   \      0x13C   0x6813             LDR      R3,[R2, #+0]
   \      0x13E   0x6058             STR      R0,[R3, #+4]
    880            }
    881            
    882            if (sConfigInjected->InjectedDiscontinuousConvMode != DISABLE)
   \                     ??HAL_ADCEx_InjectedConfigChannel_8: (+1)
   \      0x140   0x7D08             LDRB     R0,[R1, #+20]
   \      0x142   0x2800             CMP      R0,#+0
   \      0x144   0xD006             BEQ.N    ??HAL_ADCEx_InjectedConfigChannel_9
    883            {
    884              /* Enable the selected ADC injected discontinuous mode */
    885              hadc->Instance->CR1 |= ADC_CR1_JDISCEN;
   \      0x146   0x6810             LDR      R0,[R2, #+0]
   \      0x148   0x6840             LDR      R0,[R0, #+4]
   \      0x14A   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \      0x14E   0x6813             LDR      R3,[R2, #+0]
   \      0x150   0x6058             STR      R0,[R3, #+4]
   \      0x152   0xE005             B.N      ??HAL_ADCEx_InjectedConfigChannel_10
    886            }
    887            else
    888            {
    889              /* Disable the selected ADC injected discontinuous mode */
    890              hadc->Instance->CR1 &= ~(ADC_CR1_JDISCEN);
   \                     ??HAL_ADCEx_InjectedConfigChannel_9: (+1)
   \      0x154   0x6810             LDR      R0,[R2, #+0]
   \      0x156   0x6840             LDR      R0,[R0, #+4]
   \      0x158   0xF430 0x5080      BICS     R0,R0,#0x1000
   \      0x15C   0x6813             LDR      R3,[R2, #+0]
   \      0x15E   0x6058             STR      R0,[R3, #+4]
    891            }
    892            
    893            switch(sConfigInjected->InjectedRank)
   \                     ??HAL_ADCEx_InjectedConfigChannel_10: (+1)
   \      0x160   0x6848             LDR      R0,[R1, #+4]
   \      0x162   0x2801             CMP      R0,#+1
   \      0x164   0xD004             BEQ.N    ??HAL_ADCEx_InjectedConfigChannel_11
   \      0x166   0xD32A             BCC.N    ??HAL_ADCEx_InjectedConfigChannel_12
   \      0x168   0x2803             CMP      R0,#+3
   \      0x16A   0xD01B             BEQ.N    ??HAL_ADCEx_InjectedConfigChannel_13
   \      0x16C   0xD30D             BCC.N    ??HAL_ADCEx_InjectedConfigChannel_14
   \      0x16E   0xE026             B.N      ??HAL_ADCEx_InjectedConfigChannel_12
    894            {
    895              case 1U:
    896                /* Set injected channel 1 offset */
    897                hadc->Instance->JOFR1 &= ~(ADC_JOFR1_JOFFSET1);
   \                     ??HAL_ADCEx_InjectedConfigChannel_11: (+1)
   \      0x170   0x6810             LDR      R0,[R2, #+0]
   \      0x172   0x6940             LDR      R0,[R0, #+20]
   \      0x174   0x0B00             LSRS     R0,R0,#+12
   \      0x176   0x0300             LSLS     R0,R0,#+12
   \      0x178   0x6813             LDR      R3,[R2, #+0]
   \      0x17A   0x6158             STR      R0,[R3, #+20]
    898                hadc->Instance->JOFR1 |= sConfigInjected->InjectedOffset;
   \      0x17C   0x6810             LDR      R0,[R2, #+0]
   \      0x17E   0x6943             LDR      R3,[R0, #+20]
   \      0x180   0x68C8             LDR      R0,[R1, #+12]
   \      0x182   0x4303             ORRS     R3,R0,R3
   \      0x184   0x6810             LDR      R0,[R2, #+0]
   \      0x186   0x6143             STR      R3,[R0, #+20]
    899                break;
   \      0x188   0xE025             B.N      ??HAL_ADCEx_InjectedConfigChannel_15
    900              case 2U:
    901                /* Set injected channel 2 offset */
    902                hadc->Instance->JOFR2 &= ~(ADC_JOFR2_JOFFSET2);
   \                     ??HAL_ADCEx_InjectedConfigChannel_14: (+1)
   \      0x18A   0x6810             LDR      R0,[R2, #+0]
   \      0x18C   0x6980             LDR      R0,[R0, #+24]
   \      0x18E   0x0B00             LSRS     R0,R0,#+12
   \      0x190   0x0300             LSLS     R0,R0,#+12
   \      0x192   0x6813             LDR      R3,[R2, #+0]
   \      0x194   0x6198             STR      R0,[R3, #+24]
    903                hadc->Instance->JOFR2 |= sConfigInjected->InjectedOffset;
   \      0x196   0x6810             LDR      R0,[R2, #+0]
   \      0x198   0x6983             LDR      R3,[R0, #+24]
   \      0x19A   0x68C8             LDR      R0,[R1, #+12]
   \      0x19C   0x4303             ORRS     R3,R0,R3
   \      0x19E   0x6810             LDR      R0,[R2, #+0]
   \      0x1A0   0x6183             STR      R3,[R0, #+24]
    904                break;
   \      0x1A2   0xE018             B.N      ??HAL_ADCEx_InjectedConfigChannel_15
    905              case 3U:
    906                /* Set injected channel 3 offset */
    907                hadc->Instance->JOFR3 &= ~(ADC_JOFR3_JOFFSET3);
   \                     ??HAL_ADCEx_InjectedConfigChannel_13: (+1)
   \      0x1A4   0x6810             LDR      R0,[R2, #+0]
   \      0x1A6   0x69C0             LDR      R0,[R0, #+28]
   \      0x1A8   0x0B00             LSRS     R0,R0,#+12
   \      0x1AA   0x0300             LSLS     R0,R0,#+12
   \      0x1AC   0x6813             LDR      R3,[R2, #+0]
   \      0x1AE   0x61D8             STR      R0,[R3, #+28]
    908                hadc->Instance->JOFR3 |= sConfigInjected->InjectedOffset;
   \      0x1B0   0x6810             LDR      R0,[R2, #+0]
   \      0x1B2   0x69C3             LDR      R3,[R0, #+28]
   \      0x1B4   0x68C8             LDR      R0,[R1, #+12]
   \      0x1B6   0x4303             ORRS     R3,R0,R3
   \      0x1B8   0x6810             LDR      R0,[R2, #+0]
   \      0x1BA   0x61C3             STR      R3,[R0, #+28]
    909                break;
   \      0x1BC   0xE00B             B.N      ??HAL_ADCEx_InjectedConfigChannel_15
    910              default:
    911                /* Set injected channel 4 offset */
    912                hadc->Instance->JOFR4 &= ~(ADC_JOFR4_JOFFSET4);
   \                     ??HAL_ADCEx_InjectedConfigChannel_12: (+1)
   \      0x1BE   0x6810             LDR      R0,[R2, #+0]
   \      0x1C0   0x6A00             LDR      R0,[R0, #+32]
   \      0x1C2   0x0B00             LSRS     R0,R0,#+12
   \      0x1C4   0x0300             LSLS     R0,R0,#+12
   \      0x1C6   0x6813             LDR      R3,[R2, #+0]
   \      0x1C8   0x6218             STR      R0,[R3, #+32]
    913                hadc->Instance->JOFR4 |= sConfigInjected->InjectedOffset;
   \      0x1CA   0x6810             LDR      R0,[R2, #+0]
   \      0x1CC   0x6A03             LDR      R3,[R0, #+32]
   \      0x1CE   0x68C8             LDR      R0,[R1, #+12]
   \      0x1D0   0x4303             ORRS     R3,R0,R3
   \      0x1D2   0x6810             LDR      R0,[R2, #+0]
   \      0x1D4   0x6203             STR      R3,[R0, #+32]
    914                break;
    915            }
    916          
    917            /* Pointer to the common control register to which is belonging hadc    */
    918            /* (Depending on STM32F4 product, there may be up to 3 ADC and 1 common */
    919            /* control register)                                                    */
    920              tmpADC_Common = ADC_COMMON_REGISTER(hadc);
   \                     ??HAL_ADCEx_InjectedConfigChannel_15: (+1)
   \      0x1D6   0x....             LDR.N    R3,??DataTable6_3
    921          
    922            /* if ADC1 Channel_18 is selected enable VBAT Channel */
    923            if ((hadc->Instance == ADC1) && (sConfigInjected->InjectedChannel == ADC_CHANNEL_VBAT))
   \      0x1D8   0x....             LDR.N    R0,??DataTable6_4
   \      0x1DA   0x6814             LDR      R4,[R2, #+0]
   \      0x1DC   0x4284             CMP      R4,R0
   \      0x1DE   0xD106             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_16
   \      0x1E0   0x680C             LDR      R4,[R1, #+0]
   \      0x1E2   0x2C12             CMP      R4,#+18
   \      0x1E4   0xD103             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_16
    924            {
    925              /* Enable the VBAT channel*/
    926              tmpADC_Common->CCR |= ADC_CCR_VBATE;
   \      0x1E6   0x685C             LDR      R4,[R3, #+4]
   \      0x1E8   0xF454 0x0480      ORRS     R4,R4,#0x400000
   \      0x1EC   0x605C             STR      R4,[R3, #+4]
    927            }
    928            
    929            /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
    930            if ((hadc->Instance == ADC1) && ((sConfigInjected->InjectedChannel == ADC_CHANNEL_TEMPSENSOR) || (sConfigInjected->InjectedChannel == ADC_CHANNEL_VREFINT)))
   \                     ??HAL_ADCEx_InjectedConfigChannel_16: (+1)
   \      0x1EE   0x6814             LDR      R4,[R2, #+0]
   \      0x1F0   0x4284             CMP      R4,R0
   \      0x1F2   0xD109             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_17
   \      0x1F4   0x6808             LDR      R0,[R1, #+0]
   \      0x1F6   0x2810             CMP      R0,#+16
   \      0x1F8   0xD002             BEQ.N    ??HAL_ADCEx_InjectedConfigChannel_18
   \      0x1FA   0x6808             LDR      R0,[R1, #+0]
   \      0x1FC   0x2811             CMP      R0,#+17
   \      0x1FE   0xD103             BNE.N    ??HAL_ADCEx_InjectedConfigChannel_17
    931            {
    932              /* Enable the TSVREFE channel*/
    933              tmpADC_Common->CCR |= ADC_CCR_TSVREFE;
   \                     ??HAL_ADCEx_InjectedConfigChannel_18: (+1)
   \      0x200   0x6858             LDR      R0,[R3, #+4]
   \      0x202   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \      0x206   0x6058             STR      R0,[R3, #+4]
    934            }
    935            
    936            /* Process unlocked */
    937            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADCEx_InjectedConfigChannel_17: (+1)
   \      0x208   0x2000             MOVS     R0,#+0
   \      0x20A   0xF882 0x003C      STRB     R0,[R2, #+60]
    938            
    939            /* Return function status */
    940            return HAL_OK;
   \      0x20E   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADCEx_InjectedConfigChannel_2: (+1)
   \      0x210   0xBC70             POP      {R4-R6}
   \      0x212   0x4770             BX       LR
    941          }
    942          
    943          /**
    944            * @brief  Configures the ADC multi-mode 
    945            * @param  hadc       pointer to a ADC_HandleTypeDef structure that contains
    946            *                     the configuration information for the specified ADC.  
    947            * @param  multimode  pointer to an ADC_MultiModeTypeDef structure that contains 
    948            *                     the configuration information for  multimode.
    949            * @retval HAL status
    950            */

   \                                 In section .text, align 2, keep-with-next
    951          HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef* hadc, ADC_MultiModeTypeDef* multimode)
    952          {
   \                     HAL_ADCEx_MultiModeConfigChannel: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0002             MOVS     R2,R0
    953          
    954            ADC_Common_TypeDef *tmpADC_Common;
    955          
    956            /* Check the parameters */
    957            assert_param(IS_ADC_MODE(multimode->Mode));
    958            assert_param(IS_ADC_DMA_ACCESS_MODE(multimode->DMAAccessMode));
    959            assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
    960            
    961            /* Process locked */
    962            __HAL_LOCK(hadc);
   \        0x4   0xF892 0x003C      LDRB     R0,[R2, #+60]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE.N    ??HAL_ADCEx_MultiModeConfigChannel_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE01F             B.N      ??HAL_ADCEx_MultiModeConfigChannel_1
   \                     ??HAL_ADCEx_MultiModeConfigChannel_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xF882 0x003C      STRB     R0,[R2, #+60]
    963          
    964            /* Pointer to the common control register to which is belonging hadc    */
    965            /* (Depending on STM32F4 product, there may be up to 3 ADC and 1 common */
    966            /* control register)                                                    */
    967            tmpADC_Common = ADC_COMMON_REGISTER(hadc);
   \       0x16   0x....             LDR.N    R3,??DataTable6_3
    968          
    969            /* Set ADC mode */
    970            tmpADC_Common->CCR &= ~(ADC_CCR_MULTI);
   \       0x18   0x6858             LDR      R0,[R3, #+4]
   \       0x1A   0x0940             LSRS     R0,R0,#+5
   \       0x1C   0x0140             LSLS     R0,R0,#+5
   \       0x1E   0x6058             STR      R0,[R3, #+4]
    971            tmpADC_Common->CCR |= multimode->Mode;
   \       0x20   0x685C             LDR      R4,[R3, #+4]
   \       0x22   0x6808             LDR      R0,[R1, #+0]
   \       0x24   0x4304             ORRS     R4,R0,R4
   \       0x26   0x605C             STR      R4,[R3, #+4]
    972            
    973            /* Set the ADC DMA access mode */
    974            tmpADC_Common->CCR &= ~(ADC_CCR_DMA);
   \       0x28   0x6858             LDR      R0,[R3, #+4]
   \       0x2A   0xF430 0x4040      BICS     R0,R0,#0xC000
   \       0x2E   0x6058             STR      R0,[R3, #+4]
    975            tmpADC_Common->CCR |= multimode->DMAAccessMode;
   \       0x30   0x685C             LDR      R4,[R3, #+4]
   \       0x32   0x6848             LDR      R0,[R1, #+4]
   \       0x34   0x4304             ORRS     R4,R0,R4
   \       0x36   0x605C             STR      R4,[R3, #+4]
    976            
    977            /* Set delay between two sampling phases */
    978            tmpADC_Common->CCR &= ~(ADC_CCR_DELAY);
   \       0x38   0x6858             LDR      R0,[R3, #+4]
   \       0x3A   0xF430 0x6070      BICS     R0,R0,#0xF00
   \       0x3E   0x6058             STR      R0,[R3, #+4]
    979            tmpADC_Common->CCR |= multimode->TwoSamplingDelay;
   \       0x40   0x685C             LDR      R4,[R3, #+4]
   \       0x42   0x6888             LDR      R0,[R1, #+8]
   \       0x44   0x4304             ORRS     R4,R0,R4
   \       0x46   0x605C             STR      R4,[R3, #+4]
    980            
    981            /* Process unlocked */
    982            __HAL_UNLOCK(hadc);
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xF882 0x003C      STRB     R0,[R2, #+60]
    983            
    984            /* Return function status */
    985            return HAL_OK;
   \       0x4E   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADCEx_MultiModeConfigChannel_1: (+1)
   \       0x50   0xBC10             POP      {R4}
   \       0x52   0x4770             BX       LR
    986          }
    987          
    988          /**
    989            * @}
    990            */
    991          
    992          /**
    993            * @brief  DMA transfer complete callback. 
    994            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
    995            *                the configuration information for the specified DMA module.
    996            * @retval None
    997            */

   \                                 In section .text, align 4, keep-with-next
    998          static void ADC_MultiModeDMAConvCplt(DMA_HandleTypeDef *hdma)   
    999          {
   \                     ADC_MultiModeDMAConvCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1000            /* Retrieve ADC handle corresponding to current DMA handle */
   1001            ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   1002            
   1003            /* Update state machine on conversion status if not in error state */
   1004            if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
   \        0x6   0x6C28             LDR      R0,[R5, #+64]
   \        0x8   0xF010 0x0F50      TST      R0,#0x50
   \        0xC   0xD129             BNE.N    ??ADC_MultiModeDMAConvCplt_0
   1005            {
   1006              /* Update ADC state machine */
   1007              SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
   \        0xE   0x6C28             LDR      R0,[R5, #+64]
   \       0x10   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0x14   0x6428             STR      R0,[R5, #+64]
   1008              
   1009              /* Determine whether any further conversion upcoming on group regular   */
   1010              /* by external trigger, continuous mode or scan sequence on going.      */
   1011              /* Note: On STM32F4, there is no independent flag of end of sequence.   */
   1012              /*       The test of scan sequence on going is done either with scan    */
   1013              /*       sequence disabled or with end of conversion flag set to        */
   1014              /*       of end of sequence.                                            */
   1015              if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
   1016                 (hadc->Init.ContinuousConvMode == DISABLE)            &&
   1017                 (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
   1018                  HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
   \       0x16   0x6828             LDR      R0,[R5, #+0]
   \       0x18   0x6880             LDR      R0,[R0, #+8]
   \       0x1A   0xF010 0x5F40      TST      R0,#0x30000000
   \       0x1E   0xD11C             BNE.N    ??ADC_MultiModeDMAConvCplt_1
   \       0x20   0x7E28             LDRB     R0,[R5, #+24]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD119             BNE.N    ??ADC_MultiModeDMAConvCplt_1
   \       0x26   0x6828             LDR      R0,[R5, #+0]
   \       0x28   0x6AC0             LDR      R0,[R0, #+44]
   \       0x2A   0xF410 0x0F70      TST      R0,#0xF00000
   \       0x2E   0xD003             BEQ.N    ??ADC_MultiModeDMAConvCplt_2
   \       0x30   0x6828             LDR      R0,[R5, #+0]
   \       0x32   0x6880             LDR      R0,[R0, #+8]
   \       0x34   0x0540             LSLS     R0,R0,#+21
   \       0x36   0xD410             BMI.N    ??ADC_MultiModeDMAConvCplt_1
   1019              {
   1020                /* Disable ADC end of single conversion interrupt on group regular */
   1021                /* Note: Overrun interrupt was enabled with EOC interrupt in          */
   1022                /* HAL_ADC_Start_IT(), but is not disabled here because can be used   */
   1023                /* by overrun IRQ process below.                                      */
   1024                __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
   \                     ??ADC_MultiModeDMAConvCplt_2: (+1)
   \       0x38   0x6828             LDR      R0,[R5, #+0]
   \       0x3A   0x6840             LDR      R0,[R0, #+4]
   \       0x3C   0xF030 0x0020      BICS     R0,R0,#0x20
   \       0x40   0x6829             LDR      R1,[R5, #+0]
   \       0x42   0x6048             STR      R0,[R1, #+4]
   1025                
   1026                /* Set ADC state */
   1027                CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
   \       0x44   0x6C28             LDR      R0,[R5, #+64]
   \       0x46   0xF430 0x7080      BICS     R0,R0,#0x100
   \       0x4A   0x6428             STR      R0,[R5, #+64]
   1028                
   1029                if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \       0x4C   0x6C28             LDR      R0,[R5, #+64]
   \       0x4E   0x04C0             LSLS     R0,R0,#+19
   \       0x50   0xD403             BMI.N    ??ADC_MultiModeDMAConvCplt_1
   1030                {
   1031                  SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   \       0x52   0x6C28             LDR      R0,[R5, #+64]
   \       0x54   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x58   0x6428             STR      R0,[R5, #+64]
   1032                }
   1033              }
   1034              
   1035              /* Conversion complete callback */
   1036              HAL_ADC_ConvCpltCallback(hadc);
   \                     ??ADC_MultiModeDMAConvCplt_1: (+1)
   \       0x5A   0x0028             MOVS     R0,R5
   \       0x5C   0x.... 0x....      BL       HAL_ADC_ConvCpltCallback
   \       0x60   0xE003             B.N      ??ADC_MultiModeDMAConvCplt_3
   1037            }
   1038            else
   1039            {
   1040              /* Call DMA error callback */
   1041              hadc->DMA_Handle->XferErrorCallback(hdma);
   \                     ??ADC_MultiModeDMAConvCplt_0: (+1)
   \       0x62   0x0020             MOVS     R0,R4
   \       0x64   0x6BA9             LDR      R1,[R5, #+56]
   \       0x66   0x6CC9             LDR      R1,[R1, #+76]
   \       0x68   0x4788             BLX      R1
   1042            }
   1043          }
   \                     ??ADC_MultiModeDMAConvCplt_3: (+1)
   \       0x6A   0xBD31             POP      {R0,R4,R5,PC}
   1044          
   1045          /**
   1046            * @brief  DMA half transfer complete callback. 
   1047            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   1048            *                the configuration information for the specified DMA module.
   1049            * @retval None
   1050            */

   \                                 In section .text, align 4, keep-with-next
   1051          static void ADC_MultiModeDMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
   1052          {
   \                     ADC_MultiModeDMAHalfConvCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1053              ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   1054              /* Conversion complete callback */
   1055              HAL_ADC_ConvHalfCpltCallback(hadc); 
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x.... 0x....      BL       HAL_ADC_ConvHalfCpltCallback
   1056          }
   \        0xC   0xBD31             POP      {R0,R4,R5,PC}
   1057          
   1058          /**
   1059            * @brief  DMA error callback 
   1060            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   1061            *                the configuration information for the specified DMA module.
   1062            * @retval None
   1063            */

   \                                 In section .text, align 4, keep-with-next
   1064          static void ADC_MultiModeDMAError(DMA_HandleTypeDef *hdma)   
   1065          {
   \                     ADC_MultiModeDMAError: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1066              ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   1067              hadc->State= HAL_ADC_STATE_ERROR_DMA;
   \        0x6   0x2040             MOVS     R0,#+64
   \        0x8   0x6428             STR      R0,[R5, #+64]
   1068              /* Set ADC error code to DMA error */
   1069              hadc->ErrorCode |= HAL_ADC_ERROR_DMA;
   \        0xA   0x6C68             LDR      R0,[R5, #+68]
   \        0xC   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x10   0x6468             STR      R0,[R5, #+68]
   1070              HAL_ADC_ErrorCallback(hadc); 
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0x.... 0x....      BL       HAL_ADC_ErrorCallback
   1071          }
   \       0x18   0xBD31             POP      {R0,R4,R5,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x000F'4240        DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0xFFFF'DFFE        DC32     0xffffdffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0x4001'2300        DC32     0x40012300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \        0x0   0x4001'2000        DC32     0x40012000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \        0x0   0xFFFF'F9FE        DC32     0xfffff9fe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \        0x0   0x000F'0001        DC32     0xf0001
   1072          
   1073          /**
   1074            * @}
   1075            */
   1076          
   1077          #endif /* HAL_ADC_MODULE_ENABLED */
   1078          /**
   1079            * @}
   1080            */ 
   1081          
   1082          /**
   1083            * @}
   1084            */ 
   1085          
   1086          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ADC_MultiModeDMAConvCplt
        16   -- Indirect call
        16   -> HAL_ADC_ConvCpltCallback
      16   ADC_MultiModeDMAError
        16   -> HAL_ADC_ErrorCallback
      16   ADC_MultiModeDMAHalfConvCplt
        16   -> HAL_ADC_ConvHalfCpltCallback
      12   HAL_ADCEx_InjectedConfigChannel
       0   HAL_ADCEx_InjectedConvCpltCallback
       4   HAL_ADCEx_InjectedGetValue
      24   HAL_ADCEx_InjectedPollForConversion
        24   -> HAL_GetTick
      12   HAL_ADCEx_InjectedStart
      12   HAL_ADCEx_InjectedStart_IT
       0   HAL_ADCEx_InjectedStop
       0   HAL_ADCEx_InjectedStop_IT
       4   HAL_ADCEx_MultiModeConfigChannel
       0   HAL_ADCEx_MultiModeGetValue
      24   HAL_ADCEx_MultiModeStart_DMA
        24   -> HAL_DMA_Start_IT
      16   HAL_ADCEx_MultiModeStop_DMA
        16   -> HAL_DMA_Abort


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
     108  ADC_MultiModeDMAConvCplt
      26  ADC_MultiModeDMAError
      14  ADC_MultiModeDMAHalfConvCplt
     532  HAL_ADCEx_InjectedConfigChannel
       2  HAL_ADCEx_InjectedConvCpltCallback
      70  HAL_ADCEx_InjectedGetValue
     150  HAL_ADCEx_InjectedPollForConversion
     266  HAL_ADCEx_InjectedStart
     278  HAL_ADCEx_InjectedStart_IT
      94  HAL_ADCEx_InjectedStop
     106  HAL_ADCEx_InjectedStop_IT
      84  HAL_ADCEx_MultiModeConfigChannel
       8  HAL_ADCEx_MultiModeGetValue
     264  HAL_ADCEx_MultiModeStart_DMA
      98  HAL_ADCEx_MultiModeStop_DMA

 
 2'128 bytes in section .text
 
 2'126 bytes of CODE memory (+ 2 bytes shared)

Errors: none
Warnings: none
