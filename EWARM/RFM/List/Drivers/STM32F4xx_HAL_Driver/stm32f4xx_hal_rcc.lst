###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         15/Sep/2022  19:49:58
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\D\JDS_DATA\RFM_IAR_source_220915\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_rcc.c
#    Command line      =
#        -f
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_rcc.o.rsp
#        (C:\D\JDS_DATA\RFM_IAR_source_220915\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_rcc.c
#        -D USE_HAL_DRIVER -D STM32F407xx -lC
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver
#        -o
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../USB_DEVICE/App\ -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Core/Inc\ -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Drivers/CMSIS/Include\
#        -I C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Drivers/radio\ -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Drivers/display\ -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Library\ -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_rcc.o.d
#    Locale            =  C
#    List file         =
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_rcc.lst
#    Object file       =
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_rcc.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\D\JDS_DATA\RFM_IAR_source_220915\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_rcc.c
      4            * @author  MCD Application Team
      5            * @brief   RCC HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Reset and Clock Control (RCC) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + Peripheral Control functions
     10            *
     11            @verbatim
     12            ==============================================================================
     13                                ##### RCC specific features #####
     14            ==============================================================================
     15              [..]
     16                After reset the device is running from Internal High Speed oscillator
     17                (HSI 16MHz) with Flash 0 wait state, Flash prefetch buffer, D-Cache
     18                and I-Cache are disabled, and all peripherals are off except internal
     19                SRAM, Flash and JTAG.
     20                (+) There is no prescaler on High speed (AHB) and Low speed (APB) busses;
     21                    all peripherals mapped on these busses are running at HSI speed.
     22                (+) The clock for all peripherals is switched off, except the SRAM and FLASH.
     23                (+) All GPIOs are in input floating state, except the JTAG pins which
     24                    are assigned to be used for debug purpose.
     25          
     26              [..]
     27                Once the device started from reset, the user application has to:
     28                (+) Configure the clock source to be used to drive the System clock
     29                    (if the application needs higher frequency/performance)
     30                (+) Configure the System clock frequency and Flash settings
     31                (+) Configure the AHB and APB busses prescalers
     32                (+) Enable the clock for the peripheral(s) to be used
     33                (+) Configure the clock source(s) for peripherals which clocks are not
     34                    derived from the System clock (I2S, RTC, ADC, USB OTG FS/SDIO/RNG)
     35          
     36                                ##### RCC Limitations #####
     37            ==============================================================================
     38              [..]
     39                A delay between an RCC peripheral clock enable and the effective peripheral
     40                enabling should be taken into account in order to manage the peripheral read/write
     41                from/to registers.
     42                (+) This delay depends on the peripheral mapping.
     43                (+) If peripheral is mapped on AHB: the delay is 2 AHB clock cycle
     44                    after the clock enable bit is set on the hardware register
     45                (+) If peripheral is mapped on APB: the delay is 2 APB clock cycle
     46                    after the clock enable bit is set on the hardware register
     47          
     48              [..]
     49                Implemented Workaround:
     50                (+) For AHB & APB peripherals, a dummy read to the peripheral register has been
     51                    inserted in each __HAL_RCC_PPP_CLK_ENABLE() macro.
     52          
     53            @endverbatim
     54            ******************************************************************************
     55            * @attention
     56            *
     57            * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
     58            * All rights reserved.</center></h2>
     59            *
     60            * This software component is licensed by ST under BSD 3-Clause license,
     61            * the "License"; You may not use this file except in compliance with the
     62            * License. You may obtain a copy of the License at:
     63            *                        opensource.org/licenses/BSD-3-Clause
     64            *
     65            ******************************************************************************
     66            */
     67          
     68          /* Includes ------------------------------------------------------------------*/
     69          #include "stm32f4xx_hal.h"
     70          
     71          /** @addtogroup STM32F4xx_HAL_Driver
     72            * @{
     73            */
     74          
     75          /** @defgroup RCC RCC
     76            * @brief RCC HAL module driver
     77            * @{
     78            */
     79          
     80          #ifdef HAL_RCC_MODULE_ENABLED
     81          
     82          /* Private typedef -----------------------------------------------------------*/
     83          /* Private define ------------------------------------------------------------*/
     84          /** @addtogroup RCC_Private_Constants
     85            * @{
     86            */
     87          
     88          /* Private macro -------------------------------------------------------------*/
     89          #define __MCO1_CLK_ENABLE()   __HAL_RCC_GPIOA_CLK_ENABLE()
     90          #define MCO1_GPIO_PORT        GPIOA
     91          #define MCO1_PIN              GPIO_PIN_8
     92          
     93          #define __MCO2_CLK_ENABLE()   __HAL_RCC_GPIOC_CLK_ENABLE()
     94          #define MCO2_GPIO_PORT         GPIOC
     95          #define MCO2_PIN               GPIO_PIN_9
     96          /**
     97            * @}
     98            */
     99          
    100          /* Private variables ---------------------------------------------------------*/
    101          /** @defgroup RCC_Private_Variables RCC Private Variables
    102            * @{
    103            */
    104          /**
    105            * @}
    106            */
    107          /* Private function prototypes -----------------------------------------------*/
    108          /* Private functions ---------------------------------------------------------*/
    109          
    110          /** @defgroup RCC_Exported_Functions RCC Exported Functions
    111            *  @{
    112            */
    113          
    114          /** @defgroup RCC_Exported_Functions_Group1 Initialization and de-initialization functions
    115           *  @brief    Initialization and Configuration functions
    116           *
    117          @verbatim
    118           ===============================================================================
    119                     ##### Initialization and de-initialization functions #####
    120           ===============================================================================
    121              [..]
    122                This section provides functions allowing to configure the internal/external oscillators
    123                (HSE, HSI, LSE, LSI, PLL, CSS and MCO) and the System busses clocks (SYSCLK, AHB, APB1
    124                 and APB2).
    125          
    126              [..] Internal/external clock and PLL configuration
    127                   (#) HSI (high-speed internal), 16 MHz factory-trimmed RC used directly or through
    128                       the PLL as System clock source.
    129          
    130                   (#) LSI (low-speed internal), 32 KHz low consumption RC used as IWDG and/or RTC
    131                       clock source.
    132          
    133                   (#) HSE (high-speed external), 4 to 26 MHz crystal oscillator used directly or
    134                       through the PLL as System clock source. Can be used also as RTC clock source.
    135          
    136                   (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.
    137          
    138                   (#) PLL (clocked by HSI or HSE), featuring two different output clocks:
    139                     (++) The first output is used to generate the high speed system clock (up to 168 MHz)
    140                     (++) The second output is used to generate the clock for the USB OTG FS (48 MHz),
    141                          the random analog generator (<=48 MHz) and the SDIO (<= 48 MHz).
    142          
    143                   (#) CSS (Clock security system), once enable using the macro __HAL_RCC_CSS_ENABLE()
    144                       and if a HSE clock failure occurs(HSE used directly or through PLL as System
    145                       clock source), the System clocks automatically switched to HSI and an interrupt
    146                       is generated if enabled. The interrupt is linked to the Cortex-M4 NMI
    147                       (Non-Maskable Interrupt) exception vector.
    148          
    149                   (#) MCO1 (microcontroller clock output), used to output HSI, LSE, HSE or PLL
    150                       clock (through a configurable prescaler) on PA8 pin.
    151          
    152                   (#) MCO2 (microcontroller clock output), used to output HSE, PLL, SYSCLK or PLLI2S
    153                       clock (through a configurable prescaler) on PC9 pin.
    154          
    155              [..] System, AHB and APB busses clocks configuration
    156                   (#) Several clock sources can be used to drive the System clock (SYSCLK): HSI,
    157                       HSE and PLL.
    158                       The AHB clock (HCLK) is derived from System clock through configurable
    159                       prescaler and used to clock the CPU, memory and peripherals mapped
    160                       on AHB bus (DMA, GPIO...). APB1 (PCLK1) and APB2 (PCLK2) clocks are derived
    161                       from AHB clock through configurable prescalers and used to clock
    162                       the peripherals mapped on these busses. You can use
    163                       "HAL_RCC_GetSysClockFreq()" function to retrieve the frequencies of these clocks.
    164          
    165                   (#) For the STM32F405xx/07xx and STM32F415xx/17xx devices, the maximum
    166                       frequency of the SYSCLK and HCLK is 168 MHz, PCLK2 84 MHz and PCLK1 42 MHz.
    167                       Depending on the device voltage range, the maximum frequency should
    168                       be adapted accordingly (refer to the product datasheets for more details).
    169          
    170                   (#) For the STM32F42xxx, STM32F43xxx, STM32F446xx, STM32F469xx and STM32F479xx devices,
    171                       the maximum frequency of the SYSCLK and HCLK is 180 MHz, PCLK2 90 MHz and PCLK1 45 MHz.
    172                       Depending on the device voltage range, the maximum frequency should
    173                       be adapted accordingly (refer to the product datasheets for more details).
    174          
    175                   (#) For the STM32F401xx, the maximum frequency of the SYSCLK and HCLK is 84 MHz,
    176                       PCLK2 84 MHz and PCLK1 42 MHz.
    177                       Depending on the device voltage range, the maximum frequency should
    178                       be adapted accordingly (refer to the product datasheets for more details).
    179          
    180                   (#) For the STM32F41xxx, the maximum frequency of the SYSCLK and HCLK is 100 MHz,
    181                       PCLK2 100 MHz and PCLK1 50 MHz.
    182                       Depending on the device voltage range, the maximum frequency should
    183                       be adapted accordingly (refer to the product datasheets for more details).
    184          
    185          @endverbatim
    186            * @{
    187            */
    188          
    189          /**
    190            * @brief  Resets the RCC clock configuration to the default reset state.
    191            * @note   The default reset state of the clock configuration is given below:
    192            *            - HSI ON and used as system clock source
    193            *            - HSE and PLL OFF
    194            *            - AHB, APB1 and APB2 prescaler set to 1.
    195            *            - CSS, MCO1 and MCO2 OFF
    196            *            - All interrupts disabled
    197            * @note   This function doesn't modify the configuration of the
    198            *            - Peripheral clocks
    199            *            - LSI, LSE and RTC clocks
    200            * @retval HAL status
    201            */

   \                                 In section .text, align 2
    202          __weak HAL_StatusTypeDef HAL_RCC_DeInit(void)
    203          {
    204            return HAL_OK;
   \                     HAL_RCC_DeInit: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR
    205          }
    206          
    207          /**
    208            * @brief  Initializes the RCC Oscillators according to the specified parameters in the
    209            *         RCC_OscInitTypeDef.
    210            * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that
    211            *         contains the configuration information for the RCC Oscillators.
    212            * @note   The PLL is not disabled when used as system clock.
    213            * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not
    214            *         supported by this API. User should request a transition to LSE Off
    215            *         first and then LSE On or LSE Bypass.
    216            * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not
    217            *         supported by this API. User should request a transition to HSE Off
    218            *         first and then HSE On or HSE Bypass.
    219            * @retval HAL status
    220            */

   \                                 In section .text, align 4
    221          __weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
    222          {
   \                     HAL_RCC_OscConfig: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
    223            uint32_t tickstart, pll_config;
    224          
    225            /* Check Null pointer */
    226            if(RCC_OscInitStruct == NULL)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??HAL_RCC_OscConfig_1
    227            {
    228              return HAL_ERROR;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE1CF             B.N      ??HAL_RCC_OscConfig_2
    229            }
    230          
    231            /* Check the parameters */
    232            assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
    233            /*------------------------------- HSE Configuration ------------------------*/
    234            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   \                     ??HAL_RCC_OscConfig_1: (+1)
   \        0xE   0x7820             LDRB     R0,[R4, #+0]
   \       0x10   0x07C0             LSLS     R0,R0,#+31
   \       0x12   0xD55F             BPL.N    ??HAL_RCC_OscConfig_3
    235            {
    236              /* Check the parameters */
    237              assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    238              /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    239              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
    240                ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
   \       0x14   0xF8DF 0x039C      LDR.W    R0,??HAL_RCC_OscConfig_0
   \       0x18   0x6801             LDR      R1,[R0, #+0]
   \       0x1A   0xF011 0x010C      ANDS     R1,R1,#0xC
   \       0x1E   0x2904             CMP      R1,#+4
   \       0x20   0xD009             BEQ.N    ??HAL_RCC_OscConfig_4
   \       0x22   0x6800             LDR      R0,[R0, #+0]
   \       0x24   0xF010 0x000C      ANDS     R0,R0,#0xC
   \       0x28   0x2808             CMP      R0,#+8
   \       0x2A   0xD10E             BNE.N    ??HAL_RCC_OscConfig_5
   \       0x2C   0xF8DF 0x0388      LDR.W    R0,??HAL_RCC_OscConfig_0+0x4
   \       0x30   0x6800             LDR      R0,[R0, #+0]
   \       0x32   0x0240             LSLS     R0,R0,#+9
   \       0x34   0xD509             BPL.N    ??HAL_RCC_OscConfig_5
    241              {
    242                if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
   \                     ??HAL_RCC_OscConfig_4: (+1)
   \       0x36   0xF8DF 0x0384      LDR.W    R0,??HAL_RCC_OscConfig_0+0x8
   \       0x3A   0x6800             LDR      R0,[R0, #+0]
   \       0x3C   0x0380             LSLS     R0,R0,#+14
   \       0x3E   0xD549             BPL.N    ??HAL_RCC_OscConfig_3
   \       0x40   0x6860             LDR      R0,[R4, #+4]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD146             BNE.N    ??HAL_RCC_OscConfig_3
    243                {
    244                  return HAL_ERROR;
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0xE1B1             B.N      ??HAL_RCC_OscConfig_2
    245                }
    246              }
    247              else
    248              {
    249                /* Set the new HSE configuration ---------------------------------------*/
    250                __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
   \                     ??HAL_RCC_OscConfig_5: (+1)
   \       0x4A   0x6860             LDR      R0,[R4, #+4]
   \       0x4C   0xF5B0 0x3F80      CMP      R0,#+65536
   \       0x50   0xD106             BNE.N    ??HAL_RCC_OscConfig_6
   \       0x52   0xF8DF 0x0368      LDR.W    R0,??HAL_RCC_OscConfig_0+0x8
   \       0x56   0x6801             LDR      R1,[R0, #+0]
   \       0x58   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \       0x5C   0x6001             STR      R1,[R0, #+0]
   \       0x5E   0xE018             B.N      ??HAL_RCC_OscConfig_7
   \                     ??HAL_RCC_OscConfig_6: (+1)
   \       0x60   0x6860             LDR      R0,[R4, #+4]
   \       0x62   0xF5B0 0x2FA0      CMP      R0,#+327680
   \       0x66   0xD10A             BNE.N    ??HAL_RCC_OscConfig_8
   \       0x68   0xF8DF 0x0350      LDR.W    R0,??HAL_RCC_OscConfig_0+0x8
   \       0x6C   0x6801             LDR      R1,[R0, #+0]
   \       0x6E   0xF451 0x2180      ORRS     R1,R1,#0x40000
   \       0x72   0x6001             STR      R1,[R0, #+0]
   \       0x74   0x6801             LDR      R1,[R0, #+0]
   \       0x76   0xF451 0x3180      ORRS     R1,R1,#0x10000
   \       0x7A   0x6001             STR      R1,[R0, #+0]
   \       0x7C   0xE009             B.N      ??HAL_RCC_OscConfig_7
   \                     ??HAL_RCC_OscConfig_8: (+1)
   \       0x7E   0xF8DF 0x033C      LDR.W    R0,??HAL_RCC_OscConfig_0+0x8
   \       0x82   0x6801             LDR      R1,[R0, #+0]
   \       0x84   0xF431 0x3180      BICS     R1,R1,#0x10000
   \       0x88   0x6001             STR      R1,[R0, #+0]
   \       0x8A   0x6801             LDR      R1,[R0, #+0]
   \       0x8C   0xF431 0x2180      BICS     R1,R1,#0x40000
   \       0x90   0x6001             STR      R1,[R0, #+0]
    251          
    252                /* Check the HSE State */
    253                if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
   \                     ??HAL_RCC_OscConfig_7: (+1)
   \       0x92   0x6860             LDR      R0,[R4, #+4]
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD00E             BEQ.N    ??HAL_RCC_OscConfig_9
    254                {
    255                  /* Get Start Tick */
    256                  tickstart = HAL_GetTick();
   \       0x98   0x.... 0x....      BL       HAL_GetTick
   \       0x9C   0x0005             MOVS     R5,R0
    257          
    258                  /* Wait till HSE is ready */
    259                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
   \                     ??HAL_RCC_OscConfig_10: (+1)
   \       0x9E   0xF8DF 0x031C      LDR.W    R0,??HAL_RCC_OscConfig_0+0x8
   \       0xA2   0x6800             LDR      R0,[R0, #+0]
   \       0xA4   0x0380             LSLS     R0,R0,#+14
   \       0xA6   0xD415             BMI.N    ??HAL_RCC_OscConfig_3
    260                  {
    261                    if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
   \       0xA8   0x.... 0x....      BL       HAL_GetTick
   \       0xAC   0x1B40             SUBS     R0,R0,R5
   \       0xAE   0x2865             CMP      R0,#+101
   \       0xB0   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_10
    262                    {
    263                      return HAL_TIMEOUT;
   \       0xB2   0x2003             MOVS     R0,#+3
   \       0xB4   0xE17B             B.N      ??HAL_RCC_OscConfig_2
    264                    }
    265                  }
    266                }
    267                else
    268                {
    269                  /* Get Start Tick */
    270                  tickstart = HAL_GetTick();
   \                     ??HAL_RCC_OscConfig_9: (+1)
   \       0xB6   0x.... 0x....      BL       HAL_GetTick
   \       0xBA   0x0005             MOVS     R5,R0
    271          
    272                  /* Wait till HSE is bypassed or disabled */
    273                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
   \                     ??HAL_RCC_OscConfig_11: (+1)
   \       0xBC   0xF8DF 0x02FC      LDR.W    R0,??HAL_RCC_OscConfig_0+0x8
   \       0xC0   0x6800             LDR      R0,[R0, #+0]
   \       0xC2   0x0380             LSLS     R0,R0,#+14
   \       0xC4   0xD506             BPL.N    ??HAL_RCC_OscConfig_3
    274                  {
    275                    if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
   \       0xC6   0x.... 0x....      BL       HAL_GetTick
   \       0xCA   0x1B40             SUBS     R0,R0,R5
   \       0xCC   0x2865             CMP      R0,#+101
   \       0xCE   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_11
    276                    {
    277                      return HAL_TIMEOUT;
   \       0xD0   0x2003             MOVS     R0,#+3
   \       0xD2   0xE16C             B.N      ??HAL_RCC_OscConfig_2
    278                    }
    279                  }
    280                }
    281              }
    282            }
    283            /*----------------------------- HSI Configuration --------------------------*/
    284            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   \                     ??HAL_RCC_OscConfig_3: (+1)
   \       0xD4   0x7820             LDRB     R0,[R4, #+0]
   \       0xD6   0x0780             LSLS     R0,R0,#+30
   \       0xD8   0xD54B             BPL.N    ??HAL_RCC_OscConfig_12
    285            {
    286              /* Check the parameters */
    287              assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    288              assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    289          
    290              /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    291              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
    292                ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
   \       0xDA   0x48B6             LDR.N    R0,??HAL_RCC_OscConfig_0
   \       0xDC   0x6801             LDR      R1,[R0, #+0]
   \       0xDE   0xF011 0x0F0C      TST      R1,#0xC
   \       0xE2   0xD008             BEQ.N    ??HAL_RCC_OscConfig_13
   \       0xE4   0x6800             LDR      R0,[R0, #+0]
   \       0xE6   0xF010 0x000C      ANDS     R0,R0,#0xC
   \       0xEA   0x2808             CMP      R0,#+8
   \       0xEC   0xD114             BNE.N    ??HAL_RCC_OscConfig_14
   \       0xEE   0x48B2             LDR.N    R0,??HAL_RCC_OscConfig_0+0x4
   \       0xF0   0x6800             LDR      R0,[R0, #+0]
   \       0xF2   0x0240             LSLS     R0,R0,#+9
   \       0xF4   0xD410             BMI.N    ??HAL_RCC_OscConfig_14
    293              {
    294                /* When HSI is used as system clock it will not disabled */
    295                if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
   \                     ??HAL_RCC_OscConfig_13: (+1)
   \       0xF6   0x48B1             LDR.N    R0,??HAL_RCC_OscConfig_0+0x8
   \       0xF8   0x6801             LDR      R1,[R0, #+0]
   \       0xFA   0x0789             LSLS     R1,R1,#+30
   \       0xFC   0xD504             BPL.N    ??HAL_RCC_OscConfig_15
   \       0xFE   0x68E1             LDR      R1,[R4, #+12]
   \      0x100   0x2901             CMP      R1,#+1
   \      0x102   0xD001             BEQ.N    ??HAL_RCC_OscConfig_15
    296                {
    297                  return HAL_ERROR;
   \      0x104   0x2001             MOVS     R0,#+1
   \      0x106   0xE152             B.N      ??HAL_RCC_OscConfig_2
    298                }
    299                /* Otherwise, just the calibration is allowed */
    300                else
    301                {
    302                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    303                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
   \                     ??HAL_RCC_OscConfig_15: (+1)
   \      0x108   0x6801             LDR      R1,[R0, #+0]
   \      0x10A   0xF031 0x01F8      BICS     R1,R1,#0xF8
   \      0x10E   0x6922             LDR      R2,[R4, #+16]
   \      0x110   0xEA51 0x01C2      ORRS     R1,R1,R2, LSL #+3
   \      0x114   0x6001             STR      R1,[R0, #+0]
   \      0x116   0xE02C             B.N      ??HAL_RCC_OscConfig_12
    304                }
    305              }
    306              else
    307              {
    308                /* Check the HSI State */
    309                if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
   \                     ??HAL_RCC_OscConfig_14: (+1)
   \      0x118   0x68E0             LDR      R0,[R4, #+12]
   \      0x11A   0x2800             CMP      R0,#+0
   \      0x11C   0xD018             BEQ.N    ??HAL_RCC_OscConfig_16
    310                {
    311                  /* Enable the Internal High Speed oscillator (HSI). */
    312                  __HAL_RCC_HSI_ENABLE();
   \      0x11E   0x2001             MOVS     R0,#+1
   \      0x120   0x49A7             LDR.N    R1,??HAL_RCC_OscConfig_0+0xC
   \      0x122   0x6008             STR      R0,[R1, #+0]
    313          
    314                  /* Get Start Tick*/
    315                  tickstart = HAL_GetTick();
   \      0x124   0x.... 0x....      BL       HAL_GetTick
   \      0x128   0x0005             MOVS     R5,R0
    316          
    317                  /* Wait till HSI is ready */
    318                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
   \                     ??HAL_RCC_OscConfig_17: (+1)
   \      0x12A   0x48A4             LDR.N    R0,??HAL_RCC_OscConfig_0+0x8
   \      0x12C   0x6801             LDR      R1,[R0, #+0]
   \      0x12E   0x0789             LSLS     R1,R1,#+30
   \      0x130   0xD406             BMI.N    ??HAL_RCC_OscConfig_18
    319                  {
    320                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
   \      0x132   0x.... 0x....      BL       HAL_GetTick
   \      0x136   0x1B40             SUBS     R0,R0,R5
   \      0x138   0x2803             CMP      R0,#+3
   \      0x13A   0xD3F6             BCC.N    ??HAL_RCC_OscConfig_17
    321                    {
    322                      return HAL_TIMEOUT;
   \      0x13C   0x2003             MOVS     R0,#+3
   \      0x13E   0xE136             B.N      ??HAL_RCC_OscConfig_2
    323                    }
    324                  }
    325          
    326                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value. */
    327                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
   \                     ??HAL_RCC_OscConfig_18: (+1)
   \      0x140   0x6801             LDR      R1,[R0, #+0]
   \      0x142   0xF031 0x01F8      BICS     R1,R1,#0xF8
   \      0x146   0x6922             LDR      R2,[R4, #+16]
   \      0x148   0xEA51 0x01C2      ORRS     R1,R1,R2, LSL #+3
   \      0x14C   0x6001             STR      R1,[R0, #+0]
   \      0x14E   0xE010             B.N      ??HAL_RCC_OscConfig_12
    328                }
    329                else
    330                {
    331                  /* Disable the Internal High Speed oscillator (HSI). */
    332                  __HAL_RCC_HSI_DISABLE();
   \                     ??HAL_RCC_OscConfig_16: (+1)
   \      0x150   0x2000             MOVS     R0,#+0
   \      0x152   0x499B             LDR.N    R1,??HAL_RCC_OscConfig_0+0xC
   \      0x154   0x6008             STR      R0,[R1, #+0]
    333          
    334                  /* Get Start Tick*/
    335                  tickstart = HAL_GetTick();
   \      0x156   0x.... 0x....      BL       HAL_GetTick
   \      0x15A   0x0005             MOVS     R5,R0
    336          
    337                  /* Wait till HSI is ready */
    338                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
   \                     ??HAL_RCC_OscConfig_19: (+1)
   \      0x15C   0x4897             LDR.N    R0,??HAL_RCC_OscConfig_0+0x8
   \      0x15E   0x6800             LDR      R0,[R0, #+0]
   \      0x160   0x0780             LSLS     R0,R0,#+30
   \      0x162   0xD506             BPL.N    ??HAL_RCC_OscConfig_12
    339                  {
    340                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
   \      0x164   0x.... 0x....      BL       HAL_GetTick
   \      0x168   0x1B40             SUBS     R0,R0,R5
   \      0x16A   0x2803             CMP      R0,#+3
   \      0x16C   0xD3F6             BCC.N    ??HAL_RCC_OscConfig_19
    341                    {
    342                      return HAL_TIMEOUT;
   \      0x16E   0x2003             MOVS     R0,#+3
   \      0x170   0xE11D             B.N      ??HAL_RCC_OscConfig_2
    343                    }
    344                  }
    345                }
    346              }
    347            }
    348            /*------------------------------ LSI Configuration -------------------------*/
    349            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
   \                     ??HAL_RCC_OscConfig_12: (+1)
   \      0x172   0x7820             LDRB     R0,[R4, #+0]
   \      0x174   0x0700             LSLS     R0,R0,#+28
   \      0x176   0xD524             BPL.N    ??HAL_RCC_OscConfig_20
    350            {
    351              /* Check the parameters */
    352              assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    353          
    354              /* Check the LSI State */
    355              if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
   \      0x178   0x6960             LDR      R0,[R4, #+20]
   \      0x17A   0x2800             CMP      R0,#+0
   \      0x17C   0xD010             BEQ.N    ??HAL_RCC_OscConfig_21
    356              {
    357                /* Enable the Internal Low Speed oscillator (LSI). */
    358                __HAL_RCC_LSI_ENABLE();
   \      0x17E   0x2001             MOVS     R0,#+1
   \      0x180   0x4990             LDR.N    R1,??HAL_RCC_OscConfig_0+0x10
   \      0x182   0x6008             STR      R0,[R1, #+0]
    359          
    360                /* Get Start Tick*/
    361                tickstart = HAL_GetTick();
   \      0x184   0x.... 0x....      BL       HAL_GetTick
   \      0x188   0x0005             MOVS     R5,R0
    362          
    363                /* Wait till LSI is ready */
    364                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
   \                     ??HAL_RCC_OscConfig_22: (+1)
   \      0x18A   0x488F             LDR.N    R0,??HAL_RCC_OscConfig_0+0x14
   \      0x18C   0x6800             LDR      R0,[R0, #+0]
   \      0x18E   0x0780             LSLS     R0,R0,#+30
   \      0x190   0xD417             BMI.N    ??HAL_RCC_OscConfig_20
    365                {
    366                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
   \      0x192   0x.... 0x....      BL       HAL_GetTick
   \      0x196   0x1B40             SUBS     R0,R0,R5
   \      0x198   0x2803             CMP      R0,#+3
   \      0x19A   0xD3F6             BCC.N    ??HAL_RCC_OscConfig_22
    367                  {
    368                    return HAL_TIMEOUT;
   \      0x19C   0x2003             MOVS     R0,#+3
   \      0x19E   0xE106             B.N      ??HAL_RCC_OscConfig_2
    369                  }
    370                }
    371              }
    372              else
    373              {
    374                /* Disable the Internal Low Speed oscillator (LSI). */
    375                __HAL_RCC_LSI_DISABLE();
   \                     ??HAL_RCC_OscConfig_21: (+1)
   \      0x1A0   0x2000             MOVS     R0,#+0
   \      0x1A2   0x4988             LDR.N    R1,??HAL_RCC_OscConfig_0+0x10
   \      0x1A4   0x6008             STR      R0,[R1, #+0]
    376          
    377                /* Get Start Tick */
    378                tickstart = HAL_GetTick();
   \      0x1A6   0x.... 0x....      BL       HAL_GetTick
   \      0x1AA   0x0005             MOVS     R5,R0
    379          
    380                /* Wait till LSI is ready */
    381                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
   \                     ??HAL_RCC_OscConfig_23: (+1)
   \      0x1AC   0x4886             LDR.N    R0,??HAL_RCC_OscConfig_0+0x14
   \      0x1AE   0x6800             LDR      R0,[R0, #+0]
   \      0x1B0   0x0780             LSLS     R0,R0,#+30
   \      0x1B2   0xD506             BPL.N    ??HAL_RCC_OscConfig_20
    382                {
    383                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
   \      0x1B4   0x.... 0x....      BL       HAL_GetTick
   \      0x1B8   0x1B40             SUBS     R0,R0,R5
   \      0x1BA   0x2803             CMP      R0,#+3
   \      0x1BC   0xD3F6             BCC.N    ??HAL_RCC_OscConfig_23
    384                  {
    385                    return HAL_TIMEOUT;
   \      0x1BE   0x2003             MOVS     R0,#+3
   \      0x1C0   0xE0F5             B.N      ??HAL_RCC_OscConfig_2
    386                  }
    387                }
    388              }
    389            }
    390            /*------------------------------ LSE Configuration -------------------------*/
    391            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
   \                     ??HAL_RCC_OscConfig_20: (+1)
   \      0x1C2   0x7820             LDRB     R0,[R4, #+0]
   \      0x1C4   0x0740             LSLS     R0,R0,#+29
   \      0x1C6   0xD57C             BPL.N    ??HAL_RCC_OscConfig_24
    392            {
    393              FlagStatus       pwrclkchanged = RESET;
   \      0x1C8   0x2700             MOVS     R7,#+0
    394          
    395              /* Check the parameters */
    396              assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    397          
    398              /* Update LSE configuration in Backup Domain control register    */
    399              /* Requires to enable write access to Backup Domain of necessary */
    400              if(__HAL_RCC_PWR_IS_CLK_DISABLED())
   \      0x1CA   0xF8DF 0x8200      LDR.W    R8,??HAL_RCC_OscConfig_0+0x18
   \      0x1CE   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x1D2   0x00C0             LSLS     R0,R0,#+3
   \      0x1D4   0xD40F             BMI.N    ??HAL_RCC_OscConfig_25
    401              {
    402                __HAL_RCC_PWR_CLK_ENABLE();
   \      0x1D6   0x2000             MOVS     R0,#+0
   \      0x1D8   0x9000             STR      R0,[SP, #+0]
   \      0x1DA   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x1DE   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \      0x1E2   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \      0x1E6   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x1EA   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \      0x1EE   0x9000             STR      R0,[SP, #+0]
   \      0x1F0   0x9800             LDR      R0,[SP, #+0]
    403                pwrclkchanged = SET;
   \      0x1F2   0x2001             MOVS     R0,#+1
   \      0x1F4   0x0007             MOVS     R7,R0
    404              }
    405          
    406              if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
   \                     ??HAL_RCC_OscConfig_25: (+1)
   \      0x1F6   0xF8DF 0x91D8      LDR.W    R9,??HAL_RCC_OscConfig_0+0x1C
   \      0x1FA   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x1FE   0x05C0             LSLS     R0,R0,#+23
   \      0x200   0xD413             BMI.N    ??HAL_RCC_OscConfig_26
    407              {
    408                /* Enable write access to Backup domain */
    409                SET_BIT(PWR->CR, PWR_CR_DBP);
   \      0x202   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x206   0xF450 0x7080      ORRS     R0,R0,#0x100
   \      0x20A   0xF8C9 0x0000      STR      R0,[R9, #+0]
    410          
    411                /* Wait for Backup domain Write protection disable */
    412                tickstart = HAL_GetTick();
   \      0x20E   0x.... 0x....      BL       HAL_GetTick
   \      0x212   0x0005             MOVS     R5,R0
    413          
    414                while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
   \                     ??HAL_RCC_OscConfig_27: (+1)
   \      0x214   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x218   0x05C0             LSLS     R0,R0,#+23
   \      0x21A   0xD406             BMI.N    ??HAL_RCC_OscConfig_26
    415                {
    416                  if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
   \      0x21C   0x.... 0x....      BL       HAL_GetTick
   \      0x220   0x1B40             SUBS     R0,R0,R5
   \      0x222   0x2803             CMP      R0,#+3
   \      0x224   0xD3F6             BCC.N    ??HAL_RCC_OscConfig_27
    417                  {
    418                    return HAL_TIMEOUT;
   \      0x226   0x2003             MOVS     R0,#+3
   \      0x228   0xE0C1             B.N      ??HAL_RCC_OscConfig_2
    419                  }
    420                }
    421              }
    422          
    423              /* Set the new LSE configuration -----------------------------------------*/
    424              __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
   \                     ??HAL_RCC_OscConfig_26: (+1)
   \      0x22A   0x68A0             LDR      R0,[R4, #+8]
   \      0x22C   0x2801             CMP      R0,#+1
   \      0x22E   0xD105             BNE.N    ??HAL_RCC_OscConfig_28
   \      0x230   0x4868             LDR.N    R0,??HAL_RCC_OscConfig_0+0x20
   \      0x232   0x6801             LDR      R1,[R0, #+0]
   \      0x234   0xF051 0x0101      ORRS     R1,R1,#0x1
   \      0x238   0x6001             STR      R1,[R0, #+0]
   \      0x23A   0xE015             B.N      ??HAL_RCC_OscConfig_29
   \                     ??HAL_RCC_OscConfig_28: (+1)
   \      0x23C   0x68A0             LDR      R0,[R4, #+8]
   \      0x23E   0x2805             CMP      R0,#+5
   \      0x240   0xD109             BNE.N    ??HAL_RCC_OscConfig_30
   \      0x242   0x4864             LDR.N    R0,??HAL_RCC_OscConfig_0+0x20
   \      0x244   0x6801             LDR      R1,[R0, #+0]
   \      0x246   0xF051 0x0104      ORRS     R1,R1,#0x4
   \      0x24A   0x6001             STR      R1,[R0, #+0]
   \      0x24C   0x6801             LDR      R1,[R0, #+0]
   \      0x24E   0xF051 0x0101      ORRS     R1,R1,#0x1
   \      0x252   0x6001             STR      R1,[R0, #+0]
   \      0x254   0xE008             B.N      ??HAL_RCC_OscConfig_29
   \                     ??HAL_RCC_OscConfig_30: (+1)
   \      0x256   0x485F             LDR.N    R0,??HAL_RCC_OscConfig_0+0x20
   \      0x258   0x6801             LDR      R1,[R0, #+0]
   \      0x25A   0x0849             LSRS     R1,R1,#+1
   \      0x25C   0x0049             LSLS     R1,R1,#+1
   \      0x25E   0x6001             STR      R1,[R0, #+0]
   \      0x260   0x6801             LDR      R1,[R0, #+0]
   \      0x262   0xF031 0x0104      BICS     R1,R1,#0x4
   \      0x266   0x6001             STR      R1,[R0, #+0]
    425              /* Check the LSE State */
    426              if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
   \                     ??HAL_RCC_OscConfig_29: (+1)
   \      0x268   0x68A0             LDR      R0,[R4, #+8]
   \      0x26A   0x2800             CMP      R0,#+0
   \      0x26C   0xD00F             BEQ.N    ??HAL_RCC_OscConfig_31
    427              {
    428                /* Get Start Tick*/
    429                tickstart = HAL_GetTick();
   \      0x26E   0x.... 0x....      BL       HAL_GetTick
   \      0x272   0x0005             MOVS     R5,R0
    430          
    431                /* Wait till LSE is ready */
    432                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
   \                     ??HAL_RCC_OscConfig_32: (+1)
   \      0x274   0x4857             LDR.N    R0,??HAL_RCC_OscConfig_0+0x20
   \      0x276   0x6800             LDR      R0,[R0, #+0]
   \      0x278   0x0780             LSLS     R0,R0,#+30
   \      0x27A   0xD418             BMI.N    ??HAL_RCC_OscConfig_33
    433                {
    434                  if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \      0x27C   0x.... 0x....      BL       HAL_GetTick
   \      0x280   0x1B40             SUBS     R0,R0,R5
   \      0x282   0xF241 0x3189      MOVW     R1,#+5001
   \      0x286   0x4288             CMP      R0,R1
   \      0x288   0xD3F4             BCC.N    ??HAL_RCC_OscConfig_32
    435                  {
    436                    return HAL_TIMEOUT;
   \      0x28A   0x2003             MOVS     R0,#+3
   \      0x28C   0xE08F             B.N      ??HAL_RCC_OscConfig_2
    437                  }
    438                }
    439              }
    440              else
    441              {
    442                /* Get Start Tick */
    443                tickstart = HAL_GetTick();
   \                     ??HAL_RCC_OscConfig_31: (+1)
   \      0x28E   0x.... 0x....      BL       HAL_GetTick
   \      0x292   0x0005             MOVS     R5,R0
    444          
    445                /* Wait till LSE is ready */
    446                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
   \                     ??HAL_RCC_OscConfig_34: (+1)
   \      0x294   0x484F             LDR.N    R0,??HAL_RCC_OscConfig_0+0x20
   \      0x296   0x6800             LDR      R0,[R0, #+0]
   \      0x298   0x0780             LSLS     R0,R0,#+30
   \      0x29A   0xD508             BPL.N    ??HAL_RCC_OscConfig_33
    447                {
    448                  if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \      0x29C   0x.... 0x....      BL       HAL_GetTick
   \      0x2A0   0x1B40             SUBS     R0,R0,R5
   \      0x2A2   0xF241 0x3189      MOVW     R1,#+5001
   \      0x2A6   0x4288             CMP      R0,R1
   \      0x2A8   0xD3F4             BCC.N    ??HAL_RCC_OscConfig_34
    449                  {
    450                    return HAL_TIMEOUT;
   \      0x2AA   0x2003             MOVS     R0,#+3
   \      0x2AC   0xE07F             B.N      ??HAL_RCC_OscConfig_2
    451                  }
    452                }
    453              }
    454          
    455              /* Restore clock configuration if changed */
    456              if(pwrclkchanged == SET)
   \                     ??HAL_RCC_OscConfig_33: (+1)
   \      0x2AE   0x0038             MOVS     R0,R7
   \      0x2B0   0xB2C0             UXTB     R0,R0
   \      0x2B2   0x2801             CMP      R0,#+1
   \      0x2B4   0xD105             BNE.N    ??HAL_RCC_OscConfig_24
    457              {
    458                __HAL_RCC_PWR_CLK_DISABLE();
   \      0x2B6   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x2BA   0xF030 0x5080      BICS     R0,R0,#0x10000000
   \      0x2BE   0xF8C8 0x0000      STR      R0,[R8, #+0]
    459              }
    460            }
    461            /*-------------------------------- PLL Configuration -----------------------*/
    462            /* Check the parameters */
    463            assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
    464            if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
   \                     ??HAL_RCC_OscConfig_24: (+1)
   \      0x2C2   0x69A0             LDR      R0,[R4, #+24]
   \      0x2C4   0x2800             CMP      R0,#+0
   \      0x2C6   0xD071             BEQ.N    ??HAL_RCC_OscConfig_35
    465            {
    466              /* Check if the PLL is used as system clock or not */
    467              if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
   \      0x2C8   0x483A             LDR.N    R0,??HAL_RCC_OscConfig_0
   \      0x2CA   0x6800             LDR      R0,[R0, #+0]
   \      0x2CC   0xF010 0x000C      ANDS     R0,R0,#0xC
   \      0x2D0   0x2808             CMP      R0,#+8
   \      0x2D2   0xD047             BEQ.N    ??HAL_RCC_OscConfig_36
    468              {
    469                if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
   \      0x2D4   0x69A0             LDR      R0,[R4, #+24]
   \      0x2D6   0x2802             CMP      R0,#+2
   \      0x2D8   0xD133             BNE.N    ??HAL_RCC_OscConfig_37
    470                {
    471                  /* Check the parameters */
    472                  assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
    473                  assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
    474                  assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
    475                  assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
    476                  assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
    477          
    478                  /* Disable the main PLL. */
    479                  __HAL_RCC_PLL_DISABLE();
   \      0x2DA   0x4F3F             LDR.N    R7,??HAL_RCC_OscConfig_0+0x24
   \      0x2DC   0x2000             MOVS     R0,#+0
   \      0x2DE   0x6038             STR      R0,[R7, #+0]
    480          
    481                  /* Get Start Tick */
    482                  tickstart = HAL_GetTick();
   \      0x2E0   0x.... 0x....      BL       HAL_GetTick
   \      0x2E4   0x4680             MOV      R8,R0
    483          
    484                  /* Wait till PLL is ready */
    485                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
   \                     ??HAL_RCC_OscConfig_38: (+1)
   \      0x2E6   0xF8DF 0x90D4      LDR.W    R9,??HAL_RCC_OscConfig_0+0x8
   \      0x2EA   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x2EE   0x0180             LSLS     R0,R0,#+6
   \      0x2F0   0xD507             BPL.N    ??HAL_RCC_OscConfig_39
    486                  {
    487                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \      0x2F2   0x.... 0x....      BL       HAL_GetTick
   \      0x2F6   0xEBB0 0x0008      SUBS     R0,R0,R8
   \      0x2FA   0x2803             CMP      R0,#+3
   \      0x2FC   0xD3F3             BCC.N    ??HAL_RCC_OscConfig_38
    488                    {
    489                      return HAL_TIMEOUT;
   \      0x2FE   0x2003             MOVS     R0,#+3
   \      0x300   0xE055             B.N      ??HAL_RCC_OscConfig_2
    490                    }
    491                  }
    492          
    493                  /* Configure the main PLL clock source, multiplication and division factors. */
    494                  WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
    495                                           RCC_OscInitStruct->PLL.PLLM                                                 | \
    496                                           (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)             | \
    497                                           (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos) | \
    498                                           (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)));
   \                     ??HAL_RCC_OscConfig_39: (+1)
   \      0x302   0x69E1             LDR      R1,[R4, #+28]
   \      0x304   0x6A20             LDR      R0,[R4, #+32]
   \      0x306   0x4301             ORRS     R1,R0,R1
   \      0x308   0x6A60             LDR      R0,[R4, #+36]
   \      0x30A   0xEA51 0x1180      ORRS     R1,R1,R0, LSL #+6
   \      0x30E   0x6AA0             LDR      R0,[R4, #+40]
   \      0x310   0x0840             LSRS     R0,R0,#+1
   \      0x312   0x1E40             SUBS     R0,R0,#+1
   \      0x314   0xEA51 0x4100      ORRS     R1,R1,R0, LSL #+16
   \      0x318   0x6AE0             LDR      R0,[R4, #+44]
   \      0x31A   0xEA51 0x6100      ORRS     R1,R1,R0, LSL #+24
   \      0x31E   0x4826             LDR.N    R0,??HAL_RCC_OscConfig_0+0x4
   \      0x320   0x6001             STR      R1,[R0, #+0]
    499                  /* Enable the main PLL. */
    500                  __HAL_RCC_PLL_ENABLE();
   \      0x322   0x2001             MOVS     R0,#+1
   \      0x324   0x6038             STR      R0,[R7, #+0]
    501          
    502                  /* Get Start Tick */
    503                  tickstart = HAL_GetTick();
   \      0x326   0x.... 0x....      BL       HAL_GetTick
   \      0x32A   0x0005             MOVS     R5,R0
    504          
    505                  /* Wait till PLL is ready */
    506                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
   \                     ??HAL_RCC_OscConfig_40: (+1)
   \      0x32C   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x330   0x0180             LSLS     R0,R0,#+6
   \      0x332   0xD43B             BMI.N    ??HAL_RCC_OscConfig_35
    507                  {
    508                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \      0x334   0x.... 0x....      BL       HAL_GetTick
   \      0x338   0x1B40             SUBS     R0,R0,R5
   \      0x33A   0x2803             CMP      R0,#+3
   \      0x33C   0xD3F6             BCC.N    ??HAL_RCC_OscConfig_40
    509                    {
    510                      return HAL_TIMEOUT;
   \      0x33E   0x2003             MOVS     R0,#+3
   \      0x340   0xE035             B.N      ??HAL_RCC_OscConfig_2
    511                    }
    512                  }
    513                }
    514                else
    515                {
    516                  /* Disable the main PLL. */
    517                  __HAL_RCC_PLL_DISABLE();
   \                     ??HAL_RCC_OscConfig_37: (+1)
   \      0x342   0x2000             MOVS     R0,#+0
   \      0x344   0x4924             LDR.N    R1,??HAL_RCC_OscConfig_0+0x24
   \      0x346   0x6008             STR      R0,[R1, #+0]
    518          
    519                  /* Get Start Tick */
    520                  tickstart = HAL_GetTick();
   \      0x348   0x.... 0x....      BL       HAL_GetTick
   \      0x34C   0x0005             MOVS     R5,R0
    521          
    522                  /* Wait till PLL is ready */
    523                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
   \                     ??HAL_RCC_OscConfig_41: (+1)
   \      0x34E   0x481B             LDR.N    R0,??HAL_RCC_OscConfig_0+0x8
   \      0x350   0x6800             LDR      R0,[R0, #+0]
   \      0x352   0x0180             LSLS     R0,R0,#+6
   \      0x354   0xD52A             BPL.N    ??HAL_RCC_OscConfig_35
    524                  {
    525                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \      0x356   0x.... 0x....      BL       HAL_GetTick
   \      0x35A   0x1B40             SUBS     R0,R0,R5
   \      0x35C   0x2803             CMP      R0,#+3
   \      0x35E   0xD3F6             BCC.N    ??HAL_RCC_OscConfig_41
    526                    {
    527                      return HAL_TIMEOUT;
   \      0x360   0x2003             MOVS     R0,#+3
   \      0x362   0xE024             B.N      ??HAL_RCC_OscConfig_2
    528                    }
    529                  }
    530                }
    531              }
    532              else
    533              {
    534                /* Check if there is a request to disable the PLL used as System clock source */
    535                if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
   \                     ??HAL_RCC_OscConfig_36: (+1)
   \      0x364   0x69A0             LDR      R0,[R4, #+24]
   \      0x366   0x2801             CMP      R0,#+1
   \      0x368   0xD101             BNE.N    ??HAL_RCC_OscConfig_42
    536                {
    537                  return HAL_ERROR;
   \      0x36A   0x2001             MOVS     R0,#+1
   \      0x36C   0xE01F             B.N      ??HAL_RCC_OscConfig_2
    538                }
    539                else
    540                {
    541                  /* Do not return HAL_ERROR if request repeats the current configuration */
    542                  pll_config = RCC->PLLCFGR;
   \                     ??HAL_RCC_OscConfig_42: (+1)
   \      0x36E   0x4812             LDR.N    R0,??HAL_RCC_OscConfig_0+0x4
   \      0x370   0x6800             LDR      R0,[R0, #+0]
   \      0x372   0x0006             MOVS     R6,R0
    543                  if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
    544                     (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
    545                     (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != RCC_OscInitStruct->PLL.PLLN) ||
    546                     (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
    547                     (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ))
   \      0x374   0xF416 0x0080      ANDS     R0,R6,#0x400000
   \      0x378   0x69E1             LDR      R1,[R4, #+28]
   \      0x37A   0x4288             CMP      R0,R1
   \      0x37C   0xD114             BNE.N    ??HAL_RCC_OscConfig_43
   \      0x37E   0xF016 0x003F      ANDS     R0,R6,#0x3F
   \      0x382   0x6A21             LDR      R1,[R4, #+32]
   \      0x384   0x4288             CMP      R0,R1
   \      0x386   0xD10F             BNE.N    ??HAL_RCC_OscConfig_43
   \      0x388   0xF647 0x70C0      MOVW     R0,#+32704
   \      0x38C   0x4030             ANDS     R0,R0,R6
   \      0x38E   0x6A61             LDR      R1,[R4, #+36]
   \      0x390   0x4288             CMP      R0,R1
   \      0x392   0xD109             BNE.N    ??HAL_RCC_OscConfig_43
   \      0x394   0xF416 0x3040      ANDS     R0,R6,#0x30000
   \      0x398   0x6AA1             LDR      R1,[R4, #+40]
   \      0x39A   0x4288             CMP      R0,R1
   \      0x39C   0xD104             BNE.N    ??HAL_RCC_OscConfig_43
   \      0x39E   0xF016 0x6070      ANDS     R0,R6,#0xF000000
   \      0x3A2   0x6AE1             LDR      R1,[R4, #+44]
   \      0x3A4   0x4288             CMP      R0,R1
   \      0x3A6   0xD001             BEQ.N    ??HAL_RCC_OscConfig_35
    548                  {
    549                    return HAL_ERROR;
   \                     ??HAL_RCC_OscConfig_43: (+1)
   \      0x3A8   0x2001             MOVS     R0,#+1
   \      0x3AA   0xE000             B.N      ??HAL_RCC_OscConfig_2
    550                  }
    551                }
    552              }
    553            }
    554            return HAL_OK;
   \                     ??HAL_RCC_OscConfig_35: (+1)
   \      0x3AC   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_OscConfig_2: (+1)
   \      0x3AE   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   \      0x3B2   0xBF00             Nop
   \                     ??HAL_RCC_OscConfig_0:
   \      0x3B4   0x4002'3808        DC32     0x40023808
   \      0x3B8   0x4002'3804        DC32     0x40023804
   \      0x3BC   0x4002'3800        DC32     0x40023800
   \      0x3C0   0x4247'0000        DC32     0x42470000
   \      0x3C4   0x4247'0E80        DC32     0x42470e80
   \      0x3C8   0x4002'3874        DC32     0x40023874
   \      0x3CC   0x4002'3840        DC32     0x40023840
   \      0x3D0   0x4000'7000        DC32     0x40007000
   \      0x3D4   0x4002'3870        DC32     0x40023870
   \      0x3D8   0x4247'0060        DC32     0x42470060
    555          }
    556          
    557          /**
    558            * @brief  Initializes the CPU, AHB and APB busses clocks according to the specified
    559            *         parameters in the RCC_ClkInitStruct.
    560            * @param  RCC_ClkInitStruct pointer to an RCC_OscInitTypeDef structure that
    561            *         contains the configuration information for the RCC peripheral.
    562            * @param  FLatency FLASH Latency, this parameter depend on device selected
    563            *
    564            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
    565            *         and updated by HAL_RCC_GetHCLKFreq() function called within this function
    566            *
    567            * @note   The HSI is used (enabled by hardware) as system clock source after
    568            *         startup from Reset, wake-up from STOP and STANDBY mode, or in case
    569            *         of failure of the HSE used directly or indirectly as system clock
    570            *         (if the Clock Security System CSS is enabled).
    571            *
    572            * @note   A switch from one clock source to another occurs only if the target
    573            *         clock source is ready (clock stable after startup delay or PLL locked).
    574            *         If a clock source which is not yet ready is selected, the switch will
    575            *         occur when the clock source will be ready.
    576            *
    577            * @note   Depending on the device voltage range, the software has to set correctly
    578            *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
    579            *         (for more details refer to section above "Initialization/de-initialization functions")
    580            * @retval None
    581            */

   \                                 In section .text, align 2, keep-with-next
    582          HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
    583          {
   \                     HAL_RCC_ClockConfig: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    584            uint32_t tickstart;
    585          
    586            /* Check Null pointer */
    587            if(RCC_ClkInitStruct == NULL)
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD101             BNE.N    ??HAL_RCC_ClockConfig_0
    588            {
    589              return HAL_ERROR;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE095             B.N      ??HAL_RCC_ClockConfig_1
    590            }
    591          
    592            /* Check the parameters */
    593            assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
    594            assert_param(IS_FLASH_LATENCY(FLatency));
    595          
    596            /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    597              must be correctly programmed according to the frequency of the CPU clock
    598              (HCLK) and the supply voltage of the device. */
    599          
    600            /* Increasing the number of wait states because of higher CPU frequency */
    601            if(FLatency > __HAL_FLASH_GET_LATENCY())
   \                     ??HAL_RCC_ClockConfig_0: (+1)
   \       0x10   0x....             LDR.N    R7,??DataTable8
   \       0x12   0x6838             LDR      R0,[R7, #+0]
   \       0x14   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x18   0x42A8             CMP      R0,R5
   \       0x1A   0xD207             BCS.N    ??HAL_RCC_ClockConfig_2
    602            {
    603              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    604              __HAL_FLASH_SET_LATENCY(FLatency);
   \       0x1C   0x703D             STRB     R5,[R7, #+0]
    605          
    606              /* Check that the new number of wait states is taken into account to access the Flash
    607              memory by reading the FLASH_ACR register */
    608              if(__HAL_FLASH_GET_LATENCY() != FLatency)
   \       0x1E   0x6838             LDR      R0,[R7, #+0]
   \       0x20   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0x24   0x42A8             CMP      R0,R5
   \       0x26   0xD001             BEQ.N    ??HAL_RCC_ClockConfig_2
    609              {
    610                return HAL_ERROR;
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE087             B.N      ??HAL_RCC_ClockConfig_1
    611              }
    612            }
    613          
    614            /*-------------------------- HCLK Configuration --------------------------*/
    615            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
   \                     ??HAL_RCC_ClockConfig_2: (+1)
   \       0x2C   0x7820             LDRB     R0,[R4, #+0]
   \       0x2E   0x0780             LSLS     R0,R0,#+30
   \       0x30   0xD516             BPL.N    ??HAL_RCC_ClockConfig_3
    616            {
    617              /* Set the highest APBx dividers in order to ensure that we do not go through
    618                 a non-spec phase whatever we decrease or increase HCLK. */
    619              if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
   \       0x32   0x7820             LDRB     R0,[R4, #+0]
   \       0x34   0x0740             LSLS     R0,R0,#+29
   \       0x36   0xD504             BPL.N    ??HAL_RCC_ClockConfig_4
    620              {
    621                MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
   \       0x38   0x....             LDR.N    R0,??DataTable8_1
   \       0x3A   0x6801             LDR      R1,[R0, #+0]
   \       0x3C   0xF451 0x51E0      ORRS     R1,R1,#0x1C00
   \       0x40   0x6001             STR      R1,[R0, #+0]
    622              }
    623          
    624              if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
   \                     ??HAL_RCC_ClockConfig_4: (+1)
   \       0x42   0x7820             LDRB     R0,[R4, #+0]
   \       0x44   0x0700             LSLS     R0,R0,#+28
   \       0x46   0xD504             BPL.N    ??HAL_RCC_ClockConfig_5
    625              {
    626                MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
   \       0x48   0x....             LDR.N    R0,??DataTable8_1
   \       0x4A   0x6801             LDR      R1,[R0, #+0]
   \       0x4C   0xF451 0x4160      ORRS     R1,R1,#0xE000
   \       0x50   0x6001             STR      R1,[R0, #+0]
    627              }
    628          
    629              assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    630              MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
   \                     ??HAL_RCC_ClockConfig_5: (+1)
   \       0x52   0x....             LDR.N    R1,??DataTable8_1
   \       0x54   0x680A             LDR      R2,[R1, #+0]
   \       0x56   0xF032 0x02F0      BICS     R2,R2,#0xF0
   \       0x5A   0x68A0             LDR      R0,[R4, #+8]
   \       0x5C   0x4302             ORRS     R2,R0,R2
   \       0x5E   0x600A             STR      R2,[R1, #+0]
    631            }
    632          
    633            /*------------------------- SYSCLK Configuration ---------------------------*/
    634            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
   \                     ??HAL_RCC_ClockConfig_3: (+1)
   \       0x60   0x7820             LDRB     R0,[R4, #+0]
   \       0x62   0x07C0             LSLS     R0,R0,#+31
   \       0x64   0xD538             BPL.N    ??HAL_RCC_ClockConfig_6
    635            {
    636              assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    637          
    638              /* HSE is selected as System Clock Source */
    639              if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \       0x66   0x6860             LDR      R0,[R4, #+4]
   \       0x68   0x2801             CMP      R0,#+1
   \       0x6A   0xD105             BNE.N    ??HAL_RCC_ClockConfig_7
    640              {
    641                /* Check the HSE ready flag */
    642                if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
   \       0x6C   0x....             LDR.N    R0,??DataTable8_2
   \       0x6E   0x6800             LDR      R0,[R0, #+0]
   \       0x70   0x0380             LSLS     R0,R0,#+14
   \       0x72   0xD413             BMI.N    ??HAL_RCC_ClockConfig_8
    643                {
    644                  return HAL_ERROR;
   \       0x74   0x2001             MOVS     R0,#+1
   \       0x76   0xE061             B.N      ??HAL_RCC_ClockConfig_1
    645                }
    646              }
    647              /* PLL is selected as System Clock Source */
    648              else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
    649                      (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
   \                     ??HAL_RCC_ClockConfig_7: (+1)
   \       0x78   0x6860             LDR      R0,[R4, #+4]
   \       0x7A   0x2802             CMP      R0,#+2
   \       0x7C   0xD002             BEQ.N    ??HAL_RCC_ClockConfig_9
   \       0x7E   0x6860             LDR      R0,[R4, #+4]
   \       0x80   0x2803             CMP      R0,#+3
   \       0x82   0xD105             BNE.N    ??HAL_RCC_ClockConfig_10
    650              {
    651                /* Check the PLL ready flag */
    652                if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
   \                     ??HAL_RCC_ClockConfig_9: (+1)
   \       0x84   0x....             LDR.N    R0,??DataTable8_2
   \       0x86   0x6800             LDR      R0,[R0, #+0]
   \       0x88   0x0180             LSLS     R0,R0,#+6
   \       0x8A   0xD407             BMI.N    ??HAL_RCC_ClockConfig_8
    653                {
    654                  return HAL_ERROR;
   \       0x8C   0x2001             MOVS     R0,#+1
   \       0x8E   0xE055             B.N      ??HAL_RCC_ClockConfig_1
    655                }
    656              }
    657              /* HSI is selected as System Clock Source */
    658              else
    659              {
    660                /* Check the HSI ready flag */
    661                if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
   \                     ??HAL_RCC_ClockConfig_10: (+1)
   \       0x90   0x....             LDR.N    R0,??DataTable8_2
   \       0x92   0x6800             LDR      R0,[R0, #+0]
   \       0x94   0x0780             LSLS     R0,R0,#+30
   \       0x96   0xD401             BMI.N    ??HAL_RCC_ClockConfig_8
    662                {
    663                  return HAL_ERROR;
   \       0x98   0x2001             MOVS     R0,#+1
   \       0x9A   0xE04F             B.N      ??HAL_RCC_ClockConfig_1
    664                }
    665              }
    666          
    667              __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
   \                     ??HAL_RCC_ClockConfig_8: (+1)
   \       0x9C   0x.... 0x....      LDR.W    R8,??DataTable8_1
   \       0xA0   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0xA4   0x0889             LSRS     R1,R1,#+2
   \       0xA6   0x0089             LSLS     R1,R1,#+2
   \       0xA8   0x6860             LDR      R0,[R4, #+4]
   \       0xAA   0x4301             ORRS     R1,R0,R1
   \       0xAC   0xF8C8 0x1000      STR      R1,[R8, #+0]
    668          
    669              /* Get Start Tick */
    670              tickstart = HAL_GetTick();
   \       0xB0   0x.... 0x....      BL       HAL_GetTick
   \       0xB4   0x0006             MOVS     R6,R0
    671          
    672              while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
   \                     ??HAL_RCC_ClockConfig_11: (+1)
   \       0xB6   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xBA   0xF010 0x000C      ANDS     R0,R0,#0xC
   \       0xBE   0x6861             LDR      R1,[R4, #+4]
   \       0xC0   0xEBB0 0x0F81      CMP      R0,R1, LSL #+2
   \       0xC4   0xD008             BEQ.N    ??HAL_RCC_ClockConfig_6
    673              {
    674                if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
   \       0xC6   0x.... 0x....      BL       HAL_GetTick
   \       0xCA   0x1B80             SUBS     R0,R0,R6
   \       0xCC   0xF241 0x3189      MOVW     R1,#+5001
   \       0xD0   0x4288             CMP      R0,R1
   \       0xD2   0xD3F0             BCC.N    ??HAL_RCC_ClockConfig_11
    675                {
    676                  return HAL_TIMEOUT;
   \       0xD4   0x2003             MOVS     R0,#+3
   \       0xD6   0xE031             B.N      ??HAL_RCC_ClockConfig_1
    677                }
    678              }
    679            }
    680          
    681            /* Decreasing the number of wait states because of lower CPU frequency */
    682            if(FLatency < __HAL_FLASH_GET_LATENCY())
   \                     ??HAL_RCC_ClockConfig_6: (+1)
   \       0xD8   0x6838             LDR      R0,[R7, #+0]
   \       0xDA   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0xDE   0x4285             CMP      R5,R0
   \       0xE0   0xD207             BCS.N    ??HAL_RCC_ClockConfig_12
    683            {
    684               /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    685              __HAL_FLASH_SET_LATENCY(FLatency);
   \       0xE2   0x703D             STRB     R5,[R7, #+0]
    686          
    687              /* Check that the new number of wait states is taken into account to access the Flash
    688              memory by reading the FLASH_ACR register */
    689              if(__HAL_FLASH_GET_LATENCY() != FLatency)
   \       0xE4   0x6838             LDR      R0,[R7, #+0]
   \       0xE6   0xF010 0x000F      ANDS     R0,R0,#0xF
   \       0xEA   0x42A8             CMP      R0,R5
   \       0xEC   0xD001             BEQ.N    ??HAL_RCC_ClockConfig_12
    690              {
    691                return HAL_ERROR;
   \       0xEE   0x2001             MOVS     R0,#+1
   \       0xF0   0xE024             B.N      ??HAL_RCC_ClockConfig_1
    692              }
    693            }
    694          
    695            /*-------------------------- PCLK1 Configuration ---------------------------*/
    696            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
   \                     ??HAL_RCC_ClockConfig_12: (+1)
   \       0xF2   0x7820             LDRB     R0,[R4, #+0]
   \       0xF4   0x0740             LSLS     R0,R0,#+29
   \       0xF6   0xD506             BPL.N    ??HAL_RCC_ClockConfig_13
    697            {
    698              assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    699              MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
   \       0xF8   0x....             LDR.N    R1,??DataTable8_1
   \       0xFA   0x680A             LDR      R2,[R1, #+0]
   \       0xFC   0xF432 0x52E0      BICS     R2,R2,#0x1C00
   \      0x100   0x68E0             LDR      R0,[R4, #+12]
   \      0x102   0x4302             ORRS     R2,R0,R2
   \      0x104   0x600A             STR      R2,[R1, #+0]
    700            }
    701          
    702            /*-------------------------- PCLK2 Configuration ---------------------------*/
    703            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
   \                     ??HAL_RCC_ClockConfig_13: (+1)
   \      0x106   0x7820             LDRB     R0,[R4, #+0]
   \      0x108   0x0700             LSLS     R0,R0,#+28
   \      0x10A   0xD507             BPL.N    ??HAL_RCC_ClockConfig_14
    704            {
    705              assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    706              MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
   \      0x10C   0x....             LDR.N    R0,??DataTable8_1
   \      0x10E   0x6801             LDR      R1,[R0, #+0]
   \      0x110   0xF431 0x4160      BICS     R1,R1,#0xE000
   \      0x114   0x6922             LDR      R2,[R4, #+16]
   \      0x116   0xEA51 0x01C2      ORRS     R1,R1,R2, LSL #+3
   \      0x11A   0x6001             STR      R1,[R0, #+0]
    707            }
    708          
    709            /* Update the SystemCoreClock global variable */
    710            SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
   \                     ??HAL_RCC_ClockConfig_14: (+1)
   \      0x11C   0x.... 0x....      BL       HAL_RCC_GetSysClockFreq
   \      0x120   0x....             LDR.N    R1,??DataTable8_3
   \      0x122   0x....             LDR.N    R2,??DataTable8_1
   \      0x124   0x6812             LDR      R2,[R2, #+0]
   \      0x126   0xF3C2 0x1203      UBFX     R2,R2,#+4,#+4
   \      0x12A   0x5C89             LDRB     R1,[R1, R2]
   \      0x12C   0x40C8             LSRS     R0,R0,R1
   \      0x12E   0x....             LDR.N    R1,??DataTable8_4
   \      0x130   0x6008             STR      R0,[R1, #+0]
    711          
    712            /* Configure the source of time base considering new system clocks settings */
    713            HAL_InitTick (uwTickPrio);
   \      0x132   0x....             LDR.N    R0,??DataTable8_5
   \      0x134   0x6800             LDR      R0,[R0, #+0]
   \      0x136   0x.... 0x....      BL       HAL_InitTick
    714          
    715            return HAL_OK;
   \      0x13A   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_ClockConfig_1: (+1)
   \      0x13C   0xE8BD 0x81F0      POP      {R4-R8,PC}
    716          }
    717          
    718          /**
    719            * @}
    720            */
    721          
    722          /** @defgroup RCC_Exported_Functions_Group2 Peripheral Control functions
    723           *  @brief   RCC clocks control functions
    724           *
    725          @verbatim
    726           ===============================================================================
    727                                ##### Peripheral Control functions #####
    728           ===============================================================================
    729              [..]
    730              This subsection provides a set of functions allowing to control the RCC Clocks
    731              frequencies.
    732          
    733          @endverbatim
    734            * @{
    735            */
    736          
    737          /**
    738            * @brief  Selects the clock source to output on MCO1 pin(PA8) or on MCO2 pin(PC9).
    739            * @note   PA8/PC9 should be configured in alternate function mode.
    740            * @param  RCC_MCOx specifies the output direction for the clock source.
    741            *          This parameter can be one of the following values:
    742            *            @arg RCC_MCO1: Clock source to output on MCO1 pin(PA8).
    743            *            @arg RCC_MCO2: Clock source to output on MCO2 pin(PC9).
    744            * @param  RCC_MCOSource specifies the clock source to output.
    745            *          This parameter can be one of the following values:
    746            *            @arg RCC_MCO1SOURCE_HSI: HSI clock selected as MCO1 source
    747            *            @arg RCC_MCO1SOURCE_LSE: LSE clock selected as MCO1 source
    748            *            @arg RCC_MCO1SOURCE_HSE: HSE clock selected as MCO1 source
    749            *            @arg RCC_MCO1SOURCE_PLLCLK: main PLL clock selected as MCO1 source
    750            *            @arg RCC_MCO2SOURCE_SYSCLK: System clock (SYSCLK) selected as MCO2 source
    751            *            @arg RCC_MCO2SOURCE_PLLI2SCLK: PLLI2S clock selected as MCO2 source, available for all STM32F4 devices except STM32F410xx
    752            *            @arg RCC_MCO2SOURCE_I2SCLK: I2SCLK clock selected as MCO2 source, available only for STM32F410Rx devices
    753            *            @arg RCC_MCO2SOURCE_HSE: HSE clock selected as MCO2 source
    754            *            @arg RCC_MCO2SOURCE_PLLCLK: main PLL clock selected as MCO2 source
    755            * @param  RCC_MCODiv specifies the MCOx prescaler.
    756            *          This parameter can be one of the following values:
    757            *            @arg RCC_MCODIV_1: no division applied to MCOx clock
    758            *            @arg RCC_MCODIV_2: division by 2 applied to MCOx clock
    759            *            @arg RCC_MCODIV_3: division by 3 applied to MCOx clock
    760            *            @arg RCC_MCODIV_4: division by 4 applied to MCOx clock
    761            *            @arg RCC_MCODIV_5: division by 5 applied to MCOx clock
    762            * @note  For STM32F410Rx devices to output I2SCLK clock on MCO2 you should have
    763            *        at last one of the SPI clocks enabled (SPI1, SPI2 or SPI5).
    764            * @retval None
    765            */

   \                                 In section .text, align 2, keep-with-next
    766          void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
    767          {
   \                     HAL_RCC_MCOConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
    768            GPIO_InitTypeDef GPIO_InitStruct;
    769            /* Check the parameters */
    770            assert_param(IS_RCC_MCO(RCC_MCOx));
    771            assert_param(IS_RCC_MCODIV(RCC_MCODiv));
    772            /* RCC_MCO1 */
    773            if(RCC_MCOx == RCC_MCO1)
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD122             BNE.N    ??HAL_RCC_MCOConfig_0
    774            {
    775              assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
    776          
    777              /* MCO1 Clock Enable */
    778              __MCO1_CLK_ENABLE();
   \        0xE   0x2000             MOVS     R0,#+0
   \       0x10   0x9000             STR      R0,[SP, #+0]
   \       0x12   0x....             LDR.N    R0,??DataTable8_6
   \       0x14   0x6801             LDR      R1,[R0, #+0]
   \       0x16   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x1A   0x6001             STR      R1,[R0, #+0]
   \       0x1C   0x6800             LDR      R0,[R0, #+0]
   \       0x1E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0x22   0x9000             STR      R0,[SP, #+0]
   \       0x24   0x9800             LDR      R0,[SP, #+0]
    779          
    780              /* Configure the MCO1 pin in alternate function mode */
    781              GPIO_InitStruct.Pin = MCO1_PIN;
   \       0x26   0xF44F 0x7080      MOV      R0,#+256
   \       0x2A   0x9001             STR      R0,[SP, #+4]
    782              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \       0x2C   0x2002             MOVS     R0,#+2
   \       0x2E   0x9002             STR      R0,[SP, #+8]
    783              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \       0x30   0x2003             MOVS     R0,#+3
   \       0x32   0x9004             STR      R0,[SP, #+16]
    784              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x9003             STR      R0,[SP, #+12]
    785              GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x9005             STR      R0,[SP, #+20]
    786              HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
   \       0x3C   0xA901             ADD      R1,SP,#+4
   \       0x3E   0x....             LDR.N    R0,??DataTable8_7
   \       0x40   0x.... 0x....      BL       HAL_GPIO_Init
    787          
    788              /* Mask MCO1 and MCO1PRE[2:0] bits then Select MCO1 clock source and prescaler */
    789              MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
   \       0x44   0x....             LDR.N    R0,??DataTable8_1
   \       0x46   0x6801             LDR      R1,[R0, #+0]
   \       0x48   0xF031 0x61EC      BICS     R1,R1,#0x7600000
   \       0x4C   0x4329             ORRS     R1,R5,R1
   \       0x4E   0x4331             ORRS     R1,R6,R1
   \       0x50   0x6001             STR      R1,[R0, #+0]
   \       0x52   0xE022             B.N      ??HAL_RCC_MCOConfig_1
    790          
    791             /* This RCC MCO1 enable feature is available only on STM32F410xx devices */
    792          #if defined(RCC_CFGR_MCO1EN)
    793              __HAL_RCC_MCO1_ENABLE();
    794          #endif /* RCC_CFGR_MCO1EN */
    795            }
    796          #if defined(RCC_CFGR_MCO2)
    797            else
    798            {
    799              assert_param(IS_RCC_MCO2SOURCE(RCC_MCOSource));
    800          
    801              /* MCO2 Clock Enable */
    802              __MCO2_CLK_ENABLE();
   \                     ??HAL_RCC_MCOConfig_0: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x9000             STR      R0,[SP, #+0]
   \       0x58   0x....             LDR.N    R0,??DataTable8_6
   \       0x5A   0x6801             LDR      R1,[R0, #+0]
   \       0x5C   0xF051 0x0104      ORRS     R1,R1,#0x4
   \       0x60   0x6001             STR      R1,[R0, #+0]
   \       0x62   0x6800             LDR      R0,[R0, #+0]
   \       0x64   0xF010 0x0004      ANDS     R0,R0,#0x4
   \       0x68   0x9000             STR      R0,[SP, #+0]
   \       0x6A   0x9800             LDR      R0,[SP, #+0]
    803          
    804              /* Configure the MCO2 pin in alternate function mode */
    805              GPIO_InitStruct.Pin = MCO2_PIN;
   \       0x6C   0xF44F 0x7000      MOV      R0,#+512
   \       0x70   0x9001             STR      R0,[SP, #+4]
    806              GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
   \       0x72   0x2002             MOVS     R0,#+2
   \       0x74   0x9002             STR      R0,[SP, #+8]
    807              GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
   \       0x76   0x2003             MOVS     R0,#+3
   \       0x78   0x9004             STR      R0,[SP, #+16]
    808              GPIO_InitStruct.Pull = GPIO_NOPULL;
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0x9003             STR      R0,[SP, #+12]
    809              GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0x9005             STR      R0,[SP, #+20]
    810              HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
   \       0x82   0xA901             ADD      R1,SP,#+4
   \       0x84   0x....             LDR.N    R0,??DataTable8_8
   \       0x86   0x.... 0x....      BL       HAL_GPIO_Init
    811          
    812              /* Mask MCO2 and MCO2PRE[2:0] bits then Select MCO2 clock source and prescaler */
    813              MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 3U)));
   \       0x8A   0x....             LDR.N    R0,??DataTable8_1
   \       0x8C   0x6801             LDR      R1,[R0, #+0]
   \       0x8E   0xF021 0x4178      BIC      R1,R1,#0xF8000000
   \       0x92   0x4329             ORRS     R1,R5,R1
   \       0x94   0xEA51 0x01C6      ORRS     R1,R1,R6, LSL #+3
   \       0x98   0x6001             STR      R1,[R0, #+0]
    814          
    815             /* This RCC MCO2 enable feature is available only on STM32F410Rx devices */
    816          #if defined(RCC_CFGR_MCO2EN)
    817              __HAL_RCC_MCO2_ENABLE();
    818          #endif /* RCC_CFGR_MCO2EN */
    819            }
    820          #endif /* RCC_CFGR_MCO2 */
    821          }
   \                     ??HAL_RCC_MCOConfig_1: (+1)
   \       0x9A   0xB006             ADD      SP,SP,#+24
   \       0x9C   0xBD70             POP      {R4-R6,PC}
    822          
    823          /**
    824            * @brief  Enables the Clock Security System.
    825            * @note   If a failure is detected on the HSE oscillator clock, this oscillator
    826            *         is automatically disabled and an interrupt is generated to inform the
    827            *         software about the failure (Clock Security System Interrupt, CSSI),
    828            *         allowing the MCU to perform rescue operations. The CSSI is linked to
    829            *         the Cortex-M4 NMI (Non-Maskable Interrupt) exception vector.
    830            * @retval None
    831            */

   \                                 In section .text, align 2, keep-with-next
    832          void HAL_RCC_EnableCSS(void)
    833          {
    834            *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)ENABLE;
   \                     HAL_RCC_EnableCSS: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x....             LDR.N    R1,??DataTable8_9
   \        0x4   0x6008             STR      R0,[R1, #+0]
    835          }
   \        0x6   0x4770             BX       LR
    836          
    837          /**
    838            * @brief  Disables the Clock Security System.
    839            * @retval None
    840            */

   \                                 In section .text, align 2, keep-with-next
    841          void HAL_RCC_DisableCSS(void)
    842          {
    843            *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)DISABLE;
   \                     HAL_RCC_DisableCSS: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x....             LDR.N    R1,??DataTable8_9
   \        0x4   0x6008             STR      R0,[R1, #+0]
    844          }
   \        0x6   0x4770             BX       LR
    845          
    846          /**
    847            * @brief  Returns the SYSCLK frequency
    848            *
    849            * @note   The system frequency computed by this function is not the real
    850            *         frequency in the chip. It is calculated based on the predefined
    851            *         constant and the selected clock source:
    852            * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)
    853            * @note     If SYSCLK source is HSE, function returns values based on HSE_VALUE(**)
    854            * @note     If SYSCLK source is PLL, function returns values based on HSE_VALUE(**)
    855            *           or HSI_VALUE(*) multiplied/divided by the PLL factors.
    856            * @note     (*) HSI_VALUE is a constant defined in stm32f4xx_hal_conf.h file (default value
    857            *               16 MHz) but the real value may vary depending on the variations
    858            *               in voltage and temperature.
    859            * @note     (**) HSE_VALUE is a constant defined in stm32f4xx_hal_conf.h file (default value
    860            *                25 MHz), user has to ensure that HSE_VALUE is same as the real
    861            *                frequency of the crystal used. Otherwise, this function may
    862            *                have wrong result.
    863            *
    864            * @note   The result of this function could be not correct when using fractional
    865            *         value for HSE crystal.
    866            *
    867            * @note   This function can be used by the user application to compute the
    868            *         baudrate for the communication peripherals or configure other parameters.
    869            *
    870            * @note   Each time SYSCLK changes, this function must be called to update the
    871            *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
    872            *
    873            *
    874            * @retval SYSCLK frequency
    875            */

   \                                 In section .text, align 4
    876          __weak uint32_t HAL_RCC_GetSysClockFreq(void)
    877          {
   \                     HAL_RCC_GetSysClockFreq: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    878            uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
   \        0x4   0x2400             MOVS     R4,#+0
   \        0x6   0x2500             MOVS     R5,#+0
   \        0x8   0x2600             MOVS     R6,#+0
    879            uint32_t sysclockfreq = 0U;
   \        0xA   0x2700             MOVS     R7,#+0
    880          
    881            /* Get SYSCLK source -------------------------------------------------------*/
    882            switch (RCC->CFGR & RCC_CFGR_SWS)
   \        0xC   0x481F             LDR.N    R0,??HAL_RCC_GetSysClockFreq_0
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0xF010 0x000C      ANDS     R0,R0,#0xC
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD004             BEQ.N    ??HAL_RCC_GetSysClockFreq_1
   \       0x18   0x2804             CMP      R0,#+4
   \       0x1A   0xD004             BEQ.N    ??HAL_RCC_GetSysClockFreq_2
   \       0x1C   0x2808             CMP      R0,#+8
   \       0x1E   0xD004             BEQ.N    ??HAL_RCC_GetSysClockFreq_3
   \       0x20   0xE031             B.N      ??HAL_RCC_GetSysClockFreq_4
    883            {
    884              case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    885              {
    886                sysclockfreq = HSI_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_1: (+1)
   \       0x22   0x481B             LDR.N    R0,??HAL_RCC_GetSysClockFreq_0+0x4
    887                 break;
   \       0x24   0xE030             B.N      ??HAL_RCC_GetSysClockFreq_5
    888              }
    889              case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    890              {
    891                sysclockfreq = HSE_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_2: (+1)
   \       0x26   0x481B             LDR.N    R0,??HAL_RCC_GetSysClockFreq_0+0x8
    892                break;
   \       0x28   0xE02E             B.N      ??HAL_RCC_GetSysClockFreq_5
    893              }
    894              case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    895              {
    896                /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
    897                SYSCLK = PLL_VCO / PLLP */
    898                pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
   \                     ??HAL_RCC_GetSysClockFreq_3: (+1)
   \       0x2A   0xF8DF 0x806C      LDR.W    R8,??HAL_RCC_GetSysClockFreq_0+0xC
   \       0x2E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x32   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \       0x36   0x0004             MOVS     R4,R0
    899                if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
   \       0x38   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x3C   0x0240             LSLS     R0,R0,#+9
   \       0x3E   0xD50C             BPL.N    ??HAL_RCC_GetSysClockFreq_6
    900                {
    901                  /* HSE used as PLL clock source */
    902                  pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
   \       0x40   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x44   0xF3C0 0x1088      UBFX     R0,R0,#+6,#+9
   \       0x48   0x4912             LDR.N    R1,??HAL_RCC_GetSysClockFreq_0+0x8
   \       0x4A   0xFBA1 0x0100      UMULL    R0,R1,R1,R0
   \       0x4E   0x0022             MOVS     R2,R4
   \       0x50   0x2300             MOVS     R3,#+0
   \       0x52   0x.... 0x....      BL       __aeabi_uldivmod
   \       0x56   0x0005             MOVS     R5,R0
   \       0x58   0xE00B             B.N      ??HAL_RCC_GetSysClockFreq_7
    903                }
    904                else
    905                {
    906                  /* HSI used as PLL clock source */
    907                  pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
   \                     ??HAL_RCC_GetSysClockFreq_6: (+1)
   \       0x5A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x5E   0xF3C0 0x1088      UBFX     R0,R0,#+6,#+9
   \       0x62   0x490B             LDR.N    R1,??HAL_RCC_GetSysClockFreq_0+0x4
   \       0x64   0xFBA1 0x0100      UMULL    R0,R1,R1,R0
   \       0x68   0x0022             MOVS     R2,R4
   \       0x6A   0x2300             MOVS     R3,#+0
   \       0x6C   0x.... 0x....      BL       __aeabi_uldivmod
   \       0x70   0x0005             MOVS     R5,R0
    908                }
    909                pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
   \                     ??HAL_RCC_GetSysClockFreq_7: (+1)
   \       0x72   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x76   0xF3C0 0x4001      UBFX     R0,R0,#+16,#+2
   \       0x7A   0x1C40             ADDS     R0,R0,#+1
   \       0x7C   0x0040             LSLS     R0,R0,#+1
   \       0x7E   0x0006             MOVS     R6,R0
    910          
    911                sysclockfreq = pllvco/pllp;
   \       0x80   0xFBB5 0xF0F6      UDIV     R0,R5,R6
    912                break;
   \       0x84   0xE000             B.N      ??HAL_RCC_GetSysClockFreq_5
    913              }
    914              default:
    915              {
    916                sysclockfreq = HSI_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_4: (+1)
   \       0x86   0x4802             LDR.N    R0,??HAL_RCC_GetSysClockFreq_0+0x4
    917                break;
    918              }
    919            }
    920            return sysclockfreq;
   \                     ??HAL_RCC_GetSysClockFreq_5: (+1)
   \       0x88   0xE8BD 0x81F0      POP      {R4-R8,PC}
   \                     ??HAL_RCC_GetSysClockFreq_0:
   \       0x8C   0x4002'3808        DC32     0x40023808
   \       0x90   0x00F4'2400        DC32     0xf42400
   \       0x94   0x01C9'C380        DC32     0x1c9c380
   \       0x98   0x4002'3804        DC32     0x40023804
    921          }
    922          
    923          /**
    924            * @brief  Returns the HCLK frequency
    925            * @note   Each time HCLK changes, this function must be called to update the
    926            *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
    927            *
    928            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
    929            *         and updated within this function
    930            * @retval HCLK frequency
    931            */

   \                                 In section .text, align 2, keep-with-next
    932          uint32_t HAL_RCC_GetHCLKFreq(void)
    933          {
    934            return SystemCoreClock;
   \                     HAL_RCC_GetHCLKFreq: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable8_4
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
    935          }
    936          
    937          /**
    938            * @brief  Returns the PCLK1 frequency
    939            * @note   Each time PCLK1 changes, this function must be called to update the
    940            *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
    941            * @retval PCLK1 frequency
    942            */

   \                                 In section .text, align 2, keep-with-next
    943          uint32_t HAL_RCC_GetPCLK1Freq(void)
    944          {
   \                     HAL_RCC_GetPCLK1Freq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    945            /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
    946            return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
   \        0x2   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \        0x6   0x....             LDR.N    R1,??DataTable8_10
   \        0x8   0x....             LDR.N    R2,??DataTable8_1
   \        0xA   0x6812             LDR      R2,[R2, #+0]
   \        0xC   0xF3C2 0x2282      UBFX     R2,R2,#+10,#+3
   \       0x10   0x5C89             LDRB     R1,[R1, R2]
   \       0x12   0x40C8             LSRS     R0,R0,R1
   \       0x14   0xBD02             POP      {R1,PC}
    947          }
    948          
    949          /**
    950            * @brief  Returns the PCLK2 frequency
    951            * @note   Each time PCLK2 changes, this function must be called to update the
    952            *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
    953            * @retval PCLK2 frequency
    954            */

   \                                 In section .text, align 2, keep-with-next
    955          uint32_t HAL_RCC_GetPCLK2Freq(void)
    956          {
   \                     HAL_RCC_GetPCLK2Freq: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    957            /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
    958            return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
   \        0x2   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \        0x6   0x....             LDR.N    R1,??DataTable8_10
   \        0x8   0x....             LDR.N    R2,??DataTable8_1
   \        0xA   0x6812             LDR      R2,[R2, #+0]
   \        0xC   0xF3C2 0x3242      UBFX     R2,R2,#+13,#+3
   \       0x10   0x5C89             LDRB     R1,[R1, R2]
   \       0x12   0x40C8             LSRS     R0,R0,R1
   \       0x14   0xBD02             POP      {R1,PC}
    959          }
    960          
    961          /**
    962            * @brief  Configures the RCC_OscInitStruct according to the internal
    963            * RCC configuration registers.
    964            * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that
    965            * will be configured.
    966            * @retval None
    967            */

   \                                 In section .text, align 4
    968          __weak void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
    969          {
    970            /* Set all possible values for the Oscillator type parameter ---------------*/
    971            RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
   \                     HAL_RCC_GetOscConfig: (+1)
   \        0x0   0x210F             MOVS     R1,#+15
   \        0x2   0x6001             STR      R1,[R0, #+0]
    972          
    973            /* Get the HSE configuration -----------------------------------------------*/
    974            if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
   \        0x4   0x492A             LDR.N    R1,??HAL_RCC_GetOscConfig_0
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0x0352             LSLS     R2,R2,#+13
   \        0xA   0xD503             BPL.N    ??HAL_RCC_GetOscConfig_1
    975            {
    976              RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
   \        0xC   0xF45F 0x22A0      MOVS     R2,#+327680
   \       0x10   0x6042             STR      R2,[R0, #+4]
   \       0x12   0xE008             B.N      ??HAL_RCC_GetOscConfig_2
    977            }
    978            else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
   \                     ??HAL_RCC_GetOscConfig_1: (+1)
   \       0x14   0x680A             LDR      R2,[R1, #+0]
   \       0x16   0x03D2             LSLS     R2,R2,#+15
   \       0x18   0xD503             BPL.N    ??HAL_RCC_GetOscConfig_3
    979            {
    980              RCC_OscInitStruct->HSEState = RCC_HSE_ON;
   \       0x1A   0xF45F 0x3280      MOVS     R2,#+65536
   \       0x1E   0x6042             STR      R2,[R0, #+4]
   \       0x20   0xE001             B.N      ??HAL_RCC_GetOscConfig_2
    981            }
    982            else
    983            {
    984              RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
   \                     ??HAL_RCC_GetOscConfig_3: (+1)
   \       0x22   0x2200             MOVS     R2,#+0
   \       0x24   0x6042             STR      R2,[R0, #+4]
    985            }
    986          
    987            /* Get the HSI configuration -----------------------------------------------*/
    988            if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
   \                     ??HAL_RCC_GetOscConfig_2: (+1)
   \       0x26   0x680A             LDR      R2,[R1, #+0]
   \       0x28   0x07D2             LSLS     R2,R2,#+31
   \       0x2A   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_4
    989            {
    990              RCC_OscInitStruct->HSIState = RCC_HSI_ON;
   \       0x2C   0x2201             MOVS     R2,#+1
   \       0x2E   0x60C2             STR      R2,[R0, #+12]
   \       0x30   0xE001             B.N      ??HAL_RCC_GetOscConfig_5
    991            }
    992            else
    993            {
    994              RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_4: (+1)
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0x60C2             STR      R2,[R0, #+12]
    995            }
    996          
    997            RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR &RCC_CR_HSITRIM) >> RCC_CR_HSITRIM_Pos);
   \                     ??HAL_RCC_GetOscConfig_5: (+1)
   \       0x36   0x680A             LDR      R2,[R1, #+0]
   \       0x38   0xF3C2 0x02C4      UBFX     R2,R2,#+3,#+5
   \       0x3C   0x6102             STR      R2,[R0, #+16]
    998          
    999            /* Get the LSE configuration -----------------------------------------------*/
   1000            if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
   \       0x3E   0x4A1D             LDR.N    R2,??HAL_RCC_GetOscConfig_0+0x4
   \       0x40   0x6813             LDR      R3,[R2, #+0]
   \       0x42   0x075B             LSLS     R3,R3,#+29
   \       0x44   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_6
   1001            {
   1002              RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
   \       0x46   0x2205             MOVS     R2,#+5
   \       0x48   0x6082             STR      R2,[R0, #+8]
   \       0x4A   0xE007             B.N      ??HAL_RCC_GetOscConfig_7
   1003            }
   1004            else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
   \                     ??HAL_RCC_GetOscConfig_6: (+1)
   \       0x4C   0x6812             LDR      R2,[R2, #+0]
   \       0x4E   0x07D2             LSLS     R2,R2,#+31
   \       0x50   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_8
   1005            {
   1006              RCC_OscInitStruct->LSEState = RCC_LSE_ON;
   \       0x52   0x2201             MOVS     R2,#+1
   \       0x54   0x6082             STR      R2,[R0, #+8]
   \       0x56   0xE001             B.N      ??HAL_RCC_GetOscConfig_7
   1007            }
   1008            else
   1009            {
   1010              RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
   \                     ??HAL_RCC_GetOscConfig_8: (+1)
   \       0x58   0x2200             MOVS     R2,#+0
   \       0x5A   0x6082             STR      R2,[R0, #+8]
   1011            }
   1012          
   1013            /* Get the LSI configuration -----------------------------------------------*/
   1014            if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
   \                     ??HAL_RCC_GetOscConfig_7: (+1)
   \       0x5C   0x4A16             LDR.N    R2,??HAL_RCC_GetOscConfig_0+0x8
   \       0x5E   0x6812             LDR      R2,[R2, #+0]
   \       0x60   0x07D2             LSLS     R2,R2,#+31
   \       0x62   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_9
   1015            {
   1016              RCC_OscInitStruct->LSIState = RCC_LSI_ON;
   \       0x64   0x2201             MOVS     R2,#+1
   \       0x66   0x6142             STR      R2,[R0, #+20]
   \       0x68   0xE001             B.N      ??HAL_RCC_GetOscConfig_10
   1017            }
   1018            else
   1019            {
   1020              RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_9: (+1)
   \       0x6A   0x2200             MOVS     R2,#+0
   \       0x6C   0x6142             STR      R2,[R0, #+20]
   1021            }
   1022          
   1023            /* Get the PLL configuration -----------------------------------------------*/
   1024            if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
   \                     ??HAL_RCC_GetOscConfig_10: (+1)
   \       0x6E   0x6809             LDR      R1,[R1, #+0]
   \       0x70   0x01C9             LSLS     R1,R1,#+7
   \       0x72   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_11
   1025            {
   1026              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
   \       0x74   0x2102             MOVS     R1,#+2
   \       0x76   0x6181             STR      R1,[R0, #+24]
   \       0x78   0xE001             B.N      ??HAL_RCC_GetOscConfig_12
   1027            }
   1028            else
   1029            {
   1030              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
   \                     ??HAL_RCC_GetOscConfig_11: (+1)
   \       0x7A   0x2101             MOVS     R1,#+1
   \       0x7C   0x6181             STR      R1,[R0, #+24]
   1031            }
   1032            RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
   \                     ??HAL_RCC_GetOscConfig_12: (+1)
   \       0x7E   0x490F             LDR.N    R1,??HAL_RCC_GetOscConfig_0+0xC
   \       0x80   0x680A             LDR      R2,[R1, #+0]
   \       0x82   0xF412 0x0280      ANDS     R2,R2,#0x400000
   \       0x86   0x61C2             STR      R2,[R0, #+28]
   1033            RCC_OscInitStruct->PLL.PLLM = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);
   \       0x88   0x680A             LDR      R2,[R1, #+0]
   \       0x8A   0xF012 0x023F      ANDS     R2,R2,#0x3F
   \       0x8E   0x6202             STR      R2,[R0, #+32]
   1034            RCC_OscInitStruct->PLL.PLLN = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
   \       0x90   0x680A             LDR      R2,[R1, #+0]
   \       0x92   0xF3C2 0x1288      UBFX     R2,R2,#+6,#+9
   \       0x96   0x6242             STR      R2,[R0, #+36]
   1035            RCC_OscInitStruct->PLL.PLLP = (uint32_t)((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) + RCC_PLLCFGR_PLLP_0) << 1U) >> RCC_PLLCFGR_PLLP_Pos);
   \       0x98   0x680A             LDR      R2,[R1, #+0]
   \       0x9A   0xF412 0x3240      ANDS     R2,R2,#0x30000
   \       0x9E   0xF512 0x3280      ADDS     R2,R2,#+65536
   \       0xA2   0x0BD2             LSRS     R2,R2,#+15
   \       0xA4   0x6282             STR      R2,[R0, #+40]
   1036            RCC_OscInitStruct->PLL.PLLQ = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLQ) >> RCC_PLLCFGR_PLLQ_Pos);
   \       0xA6   0x6809             LDR      R1,[R1, #+0]
   \       0xA8   0xF3C1 0x6103      UBFX     R1,R1,#+24,#+4
   \       0xAC   0x62C1             STR      R1,[R0, #+44]
   1037          }
   \       0xAE   0x4770             BX       LR
   \                     ??HAL_RCC_GetOscConfig_0:
   \       0xB0   0x4002'3800        DC32     0x40023800
   \       0xB4   0x4002'3870        DC32     0x40023870
   \       0xB8   0x4002'3874        DC32     0x40023874
   \       0xBC   0x4002'3804        DC32     0x40023804
   1038          
   1039          /**
   1040            * @brief  Configures the RCC_ClkInitStruct according to the internal
   1041            * RCC configuration registers.
   1042            * @param  RCC_ClkInitStruct pointer to an RCC_ClkInitTypeDef structure that
   1043            * will be configured.
   1044            * @param  pFLatency Pointer on the Flash Latency.
   1045            * @retval None
   1046            */

   \                                 In section .text, align 2, keep-with-next
   1047          void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
   1048          {
   1049            /* Set all possible values for the Clock type parameter --------------------*/
   1050            RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
   \                     HAL_RCC_GetClockConfig: (+1)
   \        0x0   0x220F             MOVS     R2,#+15
   \        0x2   0x6002             STR      R2,[R0, #+0]
   1051          
   1052            /* Get the SYSCLK configuration --------------------------------------------*/
   1053            RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
   \        0x4   0x....             LDR.N    R2,??DataTable8_1
   \        0x6   0x6813             LDR      R3,[R2, #+0]
   \        0x8   0xF013 0x0303      ANDS     R3,R3,#0x3
   \        0xC   0x6043             STR      R3,[R0, #+4]
   1054          
   1055            /* Get the HCLK configuration ----------------------------------------------*/
   1056            RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
   \        0xE   0x6813             LDR      R3,[R2, #+0]
   \       0x10   0xF013 0x03F0      ANDS     R3,R3,#0xF0
   \       0x14   0x6083             STR      R3,[R0, #+8]
   1057          
   1058            /* Get the APB1 configuration ----------------------------------------------*/
   1059            RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
   \       0x16   0x6813             LDR      R3,[R2, #+0]
   \       0x18   0xF413 0x53E0      ANDS     R3,R3,#0x1C00
   \       0x1C   0x60C3             STR      R3,[R0, #+12]
   1060          
   1061            /* Get the APB2 configuration ----------------------------------------------*/
   1062            RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3U);
   \       0x1E   0x6812             LDR      R2,[R2, #+0]
   \       0x20   0x08D2             LSRS     R2,R2,#+3
   \       0x22   0xF412 0x52E0      ANDS     R2,R2,#0x1C00
   \       0x26   0x6102             STR      R2,[R0, #+16]
   1063          
   1064            /* Get the Flash Wait State (Latency) configuration ------------------------*/
   1065            *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
   \       0x28   0x....             LDR.N    R2,??DataTable8
   \       0x2A   0x6812             LDR      R2,[R2, #+0]
   \       0x2C   0xF012 0x020F      ANDS     R2,R2,#0xF
   \       0x30   0x600A             STR      R2,[R1, #+0]
   1066          }
   \       0x32   0x4770             BX       LR
   1067          
   1068          /**
   1069            * @brief This function handles the RCC CSS interrupt request.
   1070            * @note This API should be called under the NMI_Handler().
   1071            * @retval None
   1072            */

   \                                 In section .text, align 2, keep-with-next
   1073          void HAL_RCC_NMI_IRQHandler(void)
   1074          {
   \                     HAL_RCC_NMI_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1075            /* Check RCC CSSF flag  */
   1076            if(__HAL_RCC_GET_IT(RCC_IT_CSS))
   \        0x2   0x....             LDR.N    R0,??DataTable8_11
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x0600             LSLS     R0,R0,#+24
   \        0x8   0xD504             BPL.N    ??HAL_RCC_NMI_IRQHandler_0
   1077            {
   1078              /* RCC Clock Security System interrupt user callback */
   1079              HAL_RCC_CSSCallback();
   \        0xA   0x.... 0x....      BL       HAL_RCC_CSSCallback
   1080          
   1081              /* Clear RCC CSS pending bit */
   1082              __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
   \        0xE   0x2080             MOVS     R0,#+128
   \       0x10   0x....             LDR.N    R1,??DataTable8_12
   \       0x12   0x7008             STRB     R0,[R1, #+0]
   1083            }
   1084          }
   \                     ??HAL_RCC_NMI_IRQHandler_0: (+1)
   \       0x14   0xBD01             POP      {R0,PC}
   1085          
   1086          /**
   1087            * @brief  RCC Clock Security System interrupt callback
   1088            * @retval None
   1089            */

   \                                 In section .text, align 2
   1090          __weak void HAL_RCC_CSSCallback(void)
   1091          {
   1092            /* NOTE : This function Should not be modified, when the callback is needed,
   1093                      the HAL_RCC_CSSCallback could be implemented in the user file
   1094             */
   1095          }
   \                     HAL_RCC_CSSCallback: (+1)
   \        0x0   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x4002'3C00        DC32     0x40023c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x4002'3808        DC32     0x40023808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x4002'3800        DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x....'....        DC32     AHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x....'....        DC32     uwTickPrio

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0x4002'3830        DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \        0x0   0x4002'0000        DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \        0x0   0x4002'0800        DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \        0x0   0x4247'004C        DC32     0x4247004c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \        0x0   0x....'....        DC32     APBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \        0x0   0x4002'380C        DC32     0x4002380c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \        0x0   0x4002'380E        DC32     0x4002380e
   1096          
   1097          /**
   1098            * @}
   1099            */
   1100          
   1101          /**
   1102            * @}
   1103            */
   1104          
   1105          #endif /* HAL_RCC_MODULE_ENABLED */
   1106          /**
   1107            * @}
   1108            */
   1109          
   1110          /**
   1111            * @}
   1112            */
   1113          
   1114          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RCC_CSSCallback
      24   HAL_RCC_ClockConfig
        24   -> HAL_GetTick
        24   -> HAL_InitTick
        24   -> HAL_RCC_GetSysClockFreq
       0   HAL_RCC_DeInit
       0   HAL_RCC_DisableCSS
       0   HAL_RCC_EnableCSS
       0   HAL_RCC_GetClockConfig
       0   HAL_RCC_GetHCLKFreq
       0   HAL_RCC_GetOscConfig
       8   HAL_RCC_GetPCLK1Freq
         8   -> HAL_RCC_GetHCLKFreq
       8   HAL_RCC_GetPCLK2Freq
         8   -> HAL_RCC_GetHCLKFreq
      24   HAL_RCC_GetSysClockFreq
        24 __aeabi_uldivmod
      40   HAL_RCC_MCOConfig
        40   -> HAL_GPIO_Init
       8   HAL_RCC_NMI_IRQHandler
         8   -> HAL_RCC_CSSCallback
      32   HAL_RCC_OscConfig
        32   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       2  HAL_RCC_CSSCallback
     320  HAL_RCC_ClockConfig
       4  HAL_RCC_DeInit
       8  HAL_RCC_DisableCSS
       8  HAL_RCC_EnableCSS
      52  HAL_RCC_GetClockConfig
       6  HAL_RCC_GetHCLKFreq
     192  HAL_RCC_GetOscConfig
      22  HAL_RCC_GetPCLK1Freq
      22  HAL_RCC_GetPCLK2Freq
     156  HAL_RCC_GetSysClockFreq
     158  HAL_RCC_MCOConfig
      22  HAL_RCC_NMI_IRQHandler
     988  HAL_RCC_OscConfig

 
 2'012 bytes in section .text
 
 670 bytes of CODE memory (+ 1'342 bytes shared)

Errors: none
Warnings: none
