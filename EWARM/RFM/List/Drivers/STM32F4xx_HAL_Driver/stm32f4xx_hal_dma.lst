###############################################################################
#
#                                                         22/Sep/2022  08:40:07
# IAR ANSI C/C++ Compiler V9.20.3.326/W64 for ARM Functional Safety
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_dma.c
#    Command line      =
#        -f
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_dma.o.rsp
#        (C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_dma.c
#        -D USE_HAL_DRIVER -D STM32F407xx -lC
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver
#        -o
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0 EWARM FS
#        9.20.3\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/App\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Core/Inc\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Include\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/display\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Library\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.0 EWARM FS 9.20.3\arm\CMSIS\Core\Include\\")
#        --dependencies=n
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_dma.o.d
#    Locale            =  C
#    List file         =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_dma.lst
#    Object file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_dma.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_dma.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_dma.c
      4            * @author  MCD Application Team
      5            * @brief   DMA HAL module driver.
      6            *    
      7            *          This file provides firmware functions to manage the following 
      8            *          functionalities of the Direct Memory Access (DMA) peripheral:
      9            *           + Initialization and de-initialization functions
     10            *           + IO operation functions
     11            *           + Peripheral State and errors functions
     12            @verbatim     
     13            ==============================================================================
     14                                  ##### How to use this driver #####
     15            ==============================================================================
     16            [..]
     17             (#) Enable and configure the peripheral to be connected to the DMA Stream
     18                 (except for internal SRAM/FLASH memories: no initialization is 
     19                 necessary) please refer to Reference manual for connection between peripherals
     20                 and DMA requests.
     21          
     22             (#) For a given Stream, program the required configuration through the following parameters:
     23                 Transfer Direction, Source and Destination data formats, 
     24                 Circular, Normal or peripheral flow control mode, Stream Priority level, 
     25                 Source and Destination Increment mode, FIFO mode and its Threshold (if needed), 
     26                 Burst mode for Source and/or Destination (if needed) using HAL_DMA_Init() function.
     27          
     28             -@-   Prior to HAL_DMA_Init() the clock must be enabled for DMA through the following macros:
     29                   __HAL_RCC_DMA1_CLK_ENABLE() or __HAL_RCC_DMA2_CLK_ENABLE().
     30          
     31               *** Polling mode IO operation ***
     32               =================================
     33              [..]
     34                    (+) Use HAL_DMA_Start() to start DMA transfer after the configuration of Source 
     35                        address and destination address and the Length of data to be transferred.
     36                    (+) Use HAL_DMA_PollForTransfer() to poll for the end of current transfer, in this  
     37                        case a fixed Timeout can be configured by User depending from his application.
     38                    (+) Use HAL_DMA_Abort() function to abort the current transfer.
     39          
     40               *** Interrupt mode IO operation ***
     41               ===================================
     42              [..]
     43                    (+) Configure the DMA interrupt priority using HAL_NVIC_SetPriority()
     44                    (+) Enable the DMA IRQ handler using HAL_NVIC_EnableIRQ() 
     45                    (+) Use HAL_DMA_Start_IT() to start DMA transfer after the configuration of  
     46                        Source address and destination address and the Length of data to be transferred. In this 
     47                        case the DMA interrupt is configured 
     48                    (+) Use HAL_DMA_IRQHandler() called under DMA_IRQHandler() Interrupt subroutine
     49                    (+) At the end of data transfer HAL_DMA_IRQHandler() function is executed and user can 
     50                        add his own function by customization of function pointer XferCpltCallback and 
     51                        XferErrorCallback (i.e a member of DMA handle structure).
     52              [..]
     53               (#) Use HAL_DMA_GetState() function to return the DMA state and HAL_DMA_GetError() in case of error 
     54                   detection.
     55          
     56               (#) Use HAL_DMA_Abort_IT() function to abort the current transfer
     57          
     58               -@-   In Memory-to-Memory transfer mode, Circular mode is not allowed.
     59          
     60               -@-   The FIFO is used mainly to reduce bus usage and to allow data packing/unpacking: it is
     61                     possible to set different Data Sizes for the Peripheral and the Memory (ie. you can set
     62                     Half-Word data size for the peripheral to access its data register and set Word data size
     63                     for the Memory to gain in access time. Each two half words will be packed and written in
     64                     a single access to a Word in the Memory).
     65          
     66               -@-   When FIFO is disabled, it is not allowed to configure different Data Sizes for Source
     67                     and Destination. In this case the Peripheral Data Size will be applied to both Source
     68                     and Destination.
     69          
     70               *** DMA HAL driver macros list ***
     71               =============================================
     72               [..]
     73                 Below the list of most used macros in DMA HAL driver.
     74                 
     75                (+) __HAL_DMA_ENABLE: Enable the specified DMA Stream.
     76                (+) __HAL_DMA_DISABLE: Disable the specified DMA Stream.
     77                (+) __HAL_DMA_GET_IT_SOURCE: Check whether the specified DMA Stream interrupt has occurred or not. 
     78          
     79               [..]
     80                (@) You can refer to the DMA HAL driver header file for more useful macros
     81          
     82            @endverbatim
     83            ******************************************************************************
     84            * @attention
     85            *
     86            * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
     87            * All rights reserved.</center></h2>
     88            *
     89            * This software component is licensed by ST under BSD 3-Clause license,
     90            * the "License"; You may not use this file except in compliance with the
     91            * License. You may obtain a copy of the License at:
     92            *                        opensource.org/licenses/BSD-3-Clause
     93            *
     94            ******************************************************************************
     95            */ 
     96          
     97          /* Includes ------------------------------------------------------------------*/
     98          #include "stm32f4xx_hal.h"
     99          
    100          /** @addtogroup STM32F4xx_HAL_Driver
    101            * @{
    102            */
    103          
    104          /** @defgroup DMA DMA
    105            * @brief DMA HAL module driver
    106            * @{
    107            */
    108          
    109          #ifdef HAL_DMA_MODULE_ENABLED
    110          
    111          /* Private types -------------------------------------------------------------*/
    112          typedef struct
    113          {
    114            __IO uint32_t ISR;   /*!< DMA interrupt status register */
    115            __IO uint32_t Reserved0;
    116            __IO uint32_t IFCR;  /*!< DMA interrupt flag clear register */
    117          } DMA_Base_Registers;
    118          
    119          /* Private variables ---------------------------------------------------------*/
    120          /* Private constants ---------------------------------------------------------*/
    121          /** @addtogroup DMA_Private_Constants
    122           * @{
    123           */
    124           #define HAL_TIMEOUT_DMA_ABORT    5U  /* 5 ms */
    125          /**
    126            * @}
    127            */
    128          /* Private macros ------------------------------------------------------------*/
    129          /* Private functions ---------------------------------------------------------*/
    130          /** @addtogroup DMA_Private_Functions
    131            * @{
    132            */
    133          static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength);
    134          static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma);
    135          static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma);
    136          
    137          /**
    138            * @}
    139            */  
    140          
    141          /* Exported functions ---------------------------------------------------------*/
    142          /** @addtogroup DMA_Exported_Functions
    143            * @{
    144            */
    145          
    146          /** @addtogroup DMA_Exported_Functions_Group1
    147            *
    148          @verbatim
    149           ===============================================================================
    150                       ##### Initialization and de-initialization functions  #####
    151           ===============================================================================
    152              [..]
    153              This section provides functions allowing to initialize the DMA Stream source
    154              and destination addresses, incrementation and data sizes, transfer direction, 
    155              circular/normal mode selection, memory-to-memory mode selection and Stream priority value.
    156              [..]
    157              The HAL_DMA_Init() function follows the DMA configuration procedures as described in
    158              reference manual.
    159          
    160          @endverbatim
    161            * @{
    162            */
    163            
    164          /**
    165            * @brief  Initialize the DMA according to the specified
    166            *         parameters in the DMA_InitTypeDef and create the associated handle.
    167            * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
    168            *               the configuration information for the specified DMA Stream.  
    169            * @retval HAL status
    170            */

   \                                 In section .text, align 2, keep-with-next
    171          HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
    172          {
   \                     HAL_DMA_Init: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    173            uint32_t tmp = 0U;
   \        0x4   0x2600             MOVS     R6,#+0
    174            uint32_t tickstart = HAL_GetTick();
   \        0x6   0x.... 0x....      BL       HAL_GetTick
   \        0xA   0x0005             MOVS     R5,R0
    175            DMA_Base_Registers *regs;
    176          
    177            /* Check the DMA peripheral state */
    178            if(hdma == NULL)
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD101             BNE.N    ??HAL_DMA_Init_0
    179            {
    180              return HAL_ERROR;
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xE065             B.N      ??HAL_DMA_Init_1
    181            }
    182          
    183            /* Check the parameters */
    184            assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
    185            assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));
    186            assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
    187            assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
    188            assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
    189            assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
    190            assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
    191            assert_param(IS_DMA_MODE(hdma->Init.Mode));
    192            assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
    193            assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
    194            /* Check the memory burst, peripheral burst and FIFO threshold parameters only
    195               when FIFO mode is enabled */
    196            if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
   \                     ??HAL_DMA_Init_0: (+1)
   \       0x14   0x6A60             LDR      R0,[R4, #+36]
   \       0x16   0x2800             CMP      R0,#+0
    197            {
    198              assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
    199              assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    200              assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    201            }
    202            
    203            /* Allocate lock resource */
    204            __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_Init_2: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xF884 0x0034      STRB     R0,[R4, #+52]
    205          
    206            /* Change DMA peripheral state */
    207            hdma->State = HAL_DMA_STATE_BUSY;
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0xF884 0x0035      STRB     R0,[R4, #+53]
    208            
    209            /* Disable the peripheral */
    210            __HAL_DMA_DISABLE(hdma);
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x6800             LDR      R0,[R0, #+0]
   \       0x28   0x0840             LSRS     R0,R0,#+1
   \       0x2A   0x0040             LSLS     R0,R0,#+1
   \       0x2C   0x6821             LDR      R1,[R4, #+0]
   \       0x2E   0x6008             STR      R0,[R1, #+0]
    211            
    212            /* Check if the DMA Stream is effectively disabled */
    213            while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
   \                     ??HAL_DMA_Init_3: (+1)
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6800             LDR      R0,[R0, #+0]
   \       0x34   0x07C0             LSLS     R0,R0,#+31
   \       0x36   0xD50B             BPL.N    ??HAL_DMA_Init_4
    214            {
    215              /* Check for the Timeout */
    216              if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
   \       0x38   0x.... 0x....      BL       HAL_GetTick
   \       0x3C   0x1B40             SUBS     R0,R0,R5
   \       0x3E   0x2806             CMP      R0,#+6
   \       0x40   0xD3F6             BCC.N    ??HAL_DMA_Init_3
    217              {
    218                /* Update error code */
    219                hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
   \       0x42   0x2020             MOVS     R0,#+32
   \       0x44   0x6560             STR      R0,[R4, #+84]
    220                
    221                /* Change the DMA state */
    222                hdma->State = HAL_DMA_STATE_TIMEOUT;
   \       0x46   0x2003             MOVS     R0,#+3
   \       0x48   0xF884 0x0035      STRB     R0,[R4, #+53]
    223                
    224                return HAL_TIMEOUT;
   \       0x4C   0x2003             MOVS     R0,#+3
   \       0x4E   0xE047             B.N      ??HAL_DMA_Init_1
    225              }
    226            }
    227            
    228            /* Get the CR register value */
    229            tmp = hdma->Instance->CR;
   \                     ??HAL_DMA_Init_4: (+1)
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x6801             LDR      R1,[R0, #+0]
    230          
    231            /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
    232            tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
    233                                DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
    234                                DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
    235                                DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));
   \       0x54   0x.... 0x....      LDR.W    R0,??DataTable2
   \       0x58   0x4001             ANDS     R1,R0,R1
    236          
    237            /* Prepare the DMA Stream configuration */
    238            tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
    239                    hdma->Init.PeriphInc           | hdma->Init.MemInc           |
    240                    hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
    241                    hdma->Init.Mode                | hdma->Init.Priority;
   \       0x5A   0x6860             LDR      R0,[R4, #+4]
   \       0x5C   0x4301             ORRS     R1,R0,R1
   \       0x5E   0x68A0             LDR      R0,[R4, #+8]
   \       0x60   0x4301             ORRS     R1,R0,R1
   \       0x62   0x68E0             LDR      R0,[R4, #+12]
   \       0x64   0x4301             ORRS     R1,R0,R1
   \       0x66   0x6920             LDR      R0,[R4, #+16]
   \       0x68   0x4301             ORRS     R1,R0,R1
   \       0x6A   0x6960             LDR      R0,[R4, #+20]
   \       0x6C   0x4301             ORRS     R1,R0,R1
   \       0x6E   0x69A0             LDR      R0,[R4, #+24]
   \       0x70   0x4301             ORRS     R1,R0,R1
   \       0x72   0x69E0             LDR      R0,[R4, #+28]
   \       0x74   0x4301             ORRS     R1,R0,R1
   \       0x76   0x6A20             LDR      R0,[R4, #+32]
   \       0x78   0x4301             ORRS     R1,R0,R1
    242          
    243            /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
    244            if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
   \       0x7A   0x6A60             LDR      R0,[R4, #+36]
   \       0x7C   0x2804             CMP      R0,#+4
   \       0x7E   0xD103             BNE.N    ??HAL_DMA_Init_5
    245            {
    246              /* Get memory burst and peripheral burst */
    247              tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
   \       0x80   0x6AE0             LDR      R0,[R4, #+44]
   \       0x82   0x4301             ORRS     R1,R0,R1
   \       0x84   0x6B20             LDR      R0,[R4, #+48]
   \       0x86   0x4301             ORRS     R1,R0,R1
    248            }
    249            
    250            /* Write to DMA Stream CR register */
    251            hdma->Instance->CR = tmp;  
   \                     ??HAL_DMA_Init_5: (+1)
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6001             STR      R1,[R0, #+0]
    252          
    253            /* Get the FCR register value */
    254            tmp = hdma->Instance->FCR;
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x6946             LDR      R6,[R0, #+20]
    255          
    256            /* Clear Direct mode and FIFO threshold bits */
    257            tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
   \       0x90   0x08F6             LSRS     R6,R6,#+3
   \       0x92   0x00F6             LSLS     R6,R6,#+3
    258          
    259            /* Prepare the DMA Stream FIFO configuration */
    260            tmp |= hdma->Init.FIFOMode;
   \       0x94   0x6A60             LDR      R0,[R4, #+36]
   \       0x96   0x4306             ORRS     R6,R0,R6
    261          
    262            /* The FIFO threshold is not used when the FIFO mode is disabled */
    263            if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
   \       0x98   0x6A60             LDR      R0,[R4, #+36]
   \       0x9A   0x2804             CMP      R0,#+4
   \       0x9C   0xD110             BNE.N    ??HAL_DMA_Init_6
    264            {
    265              /* Get the FIFO threshold */
    266              tmp |= hdma->Init.FIFOThreshold;
   \       0x9E   0x6AA0             LDR      R0,[R4, #+40]
   \       0xA0   0x4306             ORRS     R6,R0,R6
    267              
    268              /* Check compatibility between FIFO threshold level and size of the memory burst */
    269              /* for INCR4, INCR8, INCR16 bursts */
    270              if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
   \       0xA2   0x6AE0             LDR      R0,[R4, #+44]
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD00B             BEQ.N    ??HAL_DMA_Init_6
    271              {
    272                if (DMA_CheckFifoParam(hdma) != HAL_OK)
   \       0xA8   0x0020             MOVS     R0,R4
   \       0xAA   0x.... 0x....      BL       DMA_CheckFifoParam
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD006             BEQ.N    ??HAL_DMA_Init_6
    273                {
    274                  /* Update error code */
    275                  hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
   \       0xB2   0x2040             MOVS     R0,#+64
   \       0xB4   0x6560             STR      R0,[R4, #+84]
    276                  
    277                  /* Change the DMA state */
    278                  hdma->State = HAL_DMA_STATE_READY;
   \       0xB6   0x2001             MOVS     R0,#+1
   \       0xB8   0xF884 0x0035      STRB     R0,[R4, #+53]
    279                  
    280                  return HAL_ERROR; 
   \       0xBC   0x2001             MOVS     R0,#+1
   \       0xBE   0xE00F             B.N      ??HAL_DMA_Init_1
    281                }
    282              }
    283            }
    284            
    285            /* Write to DMA Stream FCR */
    286            hdma->Instance->FCR = tmp;
   \                     ??HAL_DMA_Init_6: (+1)
   \       0xC0   0x6820             LDR      R0,[R4, #+0]
   \       0xC2   0x6146             STR      R6,[R0, #+20]
    287          
    288            /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
    289               DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    290            regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
   \       0xC4   0x0020             MOVS     R0,R4
   \       0xC6   0x.... 0x....      BL       DMA_CalcBaseAndBitshift
   \       0xCA   0x0001             MOVS     R1,R0
    291            
    292            /* Clear all interrupt flags */
    293            regs->IFCR = 0x3FU << hdma->StreamIndex;
   \       0xCC   0x223F             MOVS     R2,#+63
   \       0xCE   0x6DE0             LDR      R0,[R4, #+92]
   \       0xD0   0x4082             LSLS     R2,R2,R0
   \       0xD2   0x608A             STR      R2,[R1, #+8]
    294          
    295            /* Initialize the error code */
    296            hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \       0xD4   0x2000             MOVS     R0,#+0
   \       0xD6   0x6560             STR      R0,[R4, #+84]
    297                                                                                               
    298            /* Initialize the DMA state */
    299            hdma->State = HAL_DMA_STATE_READY;
   \       0xD8   0x2001             MOVS     R0,#+1
   \       0xDA   0xF884 0x0035      STRB     R0,[R4, #+53]
    300          
    301            return HAL_OK;
   \       0xDE   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA_Init_1: (+1)
   \       0xE0   0xBD70             POP      {R4-R6,PC}
    302          }
    303          
    304          /**
    305            * @brief  DeInitializes the DMA peripheral 
    306            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
    307            *               the configuration information for the specified DMA Stream.  
    308            * @retval HAL status
    309            */

   \                                 In section .text, align 2, keep-with-next
    310          HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
    311          {
   \                     HAL_DMA_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    312            DMA_Base_Registers *regs;
    313          
    314            /* Check the DMA peripheral state */
    315            if(hdma == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_DMA_DeInit_0
    316            {
    317              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE03A             B.N      ??HAL_DMA_DeInit_1
    318            }
    319            
    320            /* Check the DMA peripheral state */
    321            if(hdma->State == HAL_DMA_STATE_BUSY)
   \                     ??HAL_DMA_DeInit_0: (+1)
   \        0xC   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \       0x10   0x2802             CMP      R0,#+2
   \       0x12   0xD101             BNE.N    ??HAL_DMA_DeInit_2
    322            {
    323              /* Return error status */
    324              return HAL_BUSY;
   \       0x14   0x2002             MOVS     R0,#+2
   \       0x16   0xE034             B.N      ??HAL_DMA_DeInit_1
    325            }
    326          
    327            /* Check the parameters */
    328            assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
    329          
    330            /* Disable the selected DMA Streamx */
    331            __HAL_DMA_DISABLE(hdma);
   \                     ??HAL_DMA_DeInit_2: (+1)
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0x0840             LSRS     R0,R0,#+1
   \       0x1E   0x0040             LSLS     R0,R0,#+1
   \       0x20   0x6821             LDR      R1,[R4, #+0]
   \       0x22   0x6008             STR      R0,[R1, #+0]
    332          
    333            /* Reset DMA Streamx control register */
    334            hdma->Instance->CR   = 0U;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x6821             LDR      R1,[R4, #+0]
   \       0x28   0x6008             STR      R0,[R1, #+0]
    335          
    336            /* Reset DMA Streamx number of data to transfer register */
    337            hdma->Instance->NDTR = 0U;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x6821             LDR      R1,[R4, #+0]
   \       0x2E   0x6048             STR      R0,[R1, #+4]
    338          
    339            /* Reset DMA Streamx peripheral address register */
    340            hdma->Instance->PAR  = 0U;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x6821             LDR      R1,[R4, #+0]
   \       0x34   0x6088             STR      R0,[R1, #+8]
    341          
    342            /* Reset DMA Streamx memory 0 address register */
    343            hdma->Instance->M0AR = 0U;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x6821             LDR      R1,[R4, #+0]
   \       0x3A   0x60C8             STR      R0,[R1, #+12]
    344            
    345            /* Reset DMA Streamx memory 1 address register */
    346            hdma->Instance->M1AR = 0U;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0x6821             LDR      R1,[R4, #+0]
   \       0x40   0x6108             STR      R0,[R1, #+16]
    347            
    348            /* Reset DMA Streamx FIFO control register */
    349            hdma->Instance->FCR  = 0x00000021U;
   \       0x42   0x2021             MOVS     R0,#+33
   \       0x44   0x6821             LDR      R1,[R4, #+0]
   \       0x46   0x6148             STR      R0,[R1, #+20]
    350            
    351            /* Get DMA steam Base Address */  
    352            regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x.... 0x....      BL       DMA_CalcBaseAndBitshift
   \       0x4E   0x0001             MOVS     R1,R0
    353            
    354            /* Clean all callbacks */
    355            hdma->XferCpltCallback = NULL;
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x63E0             STR      R0,[R4, #+60]
    356            hdma->XferHalfCpltCallback = NULL;
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x6420             STR      R0,[R4, #+64]
    357            hdma->XferM1CpltCallback = NULL;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x6460             STR      R0,[R4, #+68]
    358            hdma->XferM1HalfCpltCallback = NULL;
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x64A0             STR      R0,[R4, #+72]
    359            hdma->XferErrorCallback = NULL;
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0x64E0             STR      R0,[R4, #+76]
    360            hdma->XferAbortCallback = NULL;
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x6520             STR      R0,[R4, #+80]
    361          
    362            /* Clear all interrupt flags at correct offset within the register */
    363            regs->IFCR = 0x3FU << hdma->StreamIndex;
   \       0x68   0x223F             MOVS     R2,#+63
   \       0x6A   0x6DE0             LDR      R0,[R4, #+92]
   \       0x6C   0x4082             LSLS     R2,R2,R0
   \       0x6E   0x608A             STR      R2,[R1, #+8]
    364          
    365            /* Reset the error code */
    366            hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x6560             STR      R0,[R4, #+84]
    367          
    368            /* Reset the DMA state */
    369            hdma->State = HAL_DMA_STATE_RESET;
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xF884 0x0035      STRB     R0,[R4, #+53]
    370          
    371            /* Release Lock */
    372            __HAL_UNLOCK(hdma);
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0xF884 0x0034      STRB     R0,[R4, #+52]
    373          
    374            return HAL_OK;
   \       0x80   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA_DeInit_1: (+1)
   \       0x82   0xBD10             POP      {R4,PC}
    375          }
    376          
    377          /**
    378            * @}
    379            */
    380          
    381          /** @addtogroup DMA_Exported_Functions_Group2
    382            *
    383          @verbatim   
    384           ===============================================================================
    385                                #####  IO operation functions  #####
    386           ===============================================================================
    387              [..]  This section provides functions allowing to:
    388                (+) Configure the source, destination address and data length and Start DMA transfer
    389                (+) Configure the source, destination address and data length and 
    390                    Start DMA transfer with interrupt
    391                (+) Abort DMA transfer
    392                (+) Poll for transfer complete
    393                (+) Handle DMA interrupt request  
    394          
    395          @endverbatim
    396            * @{
    397            */
    398          
    399          /**
    400            * @brief  Starts the DMA Transfer.
    401            * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
    402            *                     the configuration information for the specified DMA Stream.
    403            * @param  SrcAddress The source memory Buffer address
    404            * @param  DstAddress The destination memory Buffer address
    405            * @param  DataLength The length of data to be transferred from source to destination
    406            * @retval HAL status
    407            */

   \                                 In section .text, align 2, keep-with-next
    408          HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    409          {
   \                     HAL_DMA_Start: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    410            HAL_StatusTypeDef status = HAL_OK;
   \        0xC   0xF05F 0x0800      MOVS     R8,#+0
    411            
    412            /* Check the parameters */
    413            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    414          
    415            /* Process locked */
    416            __HAL_LOCK(hdma);
   \       0x10   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD101             BNE.N    ??HAL_DMA_Start_0
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0xE01F             B.N      ??HAL_DMA_Start_1
   \                     ??HAL_DMA_Start_0: (+1)
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xF884 0x0034      STRB     R0,[R4, #+52]
    417          
    418            if(HAL_DMA_STATE_READY == hdma->State)
   \       0x22   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \       0x26   0x2801             CMP      R0,#+1
   \       0x28   0xD111             BNE.N    ??HAL_DMA_Start_2
    419            {
    420              /* Change DMA peripheral state */
    421              hdma->State = HAL_DMA_STATE_BUSY;
   \       0x2A   0x2002             MOVS     R0,#+2
   \       0x2C   0xF884 0x0035      STRB     R0,[R4, #+53]
    422              
    423              /* Initialize the error code */
    424              hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x6560             STR      R0,[R4, #+84]
    425              
    426              /* Configure the source, destination address and the data length */
    427              DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
   \       0x34   0x003B             MOVS     R3,R7
   \       0x36   0x0032             MOVS     R2,R6
   \       0x38   0x0029             MOVS     R1,R5
   \       0x3A   0x0020             MOVS     R0,R4
   \       0x3C   0x.... 0x....      BL       DMA_SetConfig
    428          
    429              /* Enable the Peripheral */
    430              __HAL_DMA_ENABLE(hdma);
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x6800             LDR      R0,[R0, #+0]
   \       0x44   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x48   0x6821             LDR      R1,[R4, #+0]
   \       0x4A   0x6008             STR      R0,[R1, #+0]
   \       0x4C   0xE004             B.N      ??HAL_DMA_Start_3
    431            }
    432            else
    433            {
    434              /* Process unlocked */
    435              __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_Start_2: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xF884 0x0034      STRB     R0,[R4, #+52]
    436              
    437              /* Return error status */
    438              status = HAL_BUSY;
   \       0x54   0x2002             MOVS     R0,#+2
   \       0x56   0x4680             MOV      R8,R0
    439            } 
    440            return status; 
   \                     ??HAL_DMA_Start_3: (+1)
   \       0x58   0x4640             MOV      R0,R8
   \       0x5A   0xB2C0             UXTB     R0,R0
   \                     ??HAL_DMA_Start_1: (+1)
   \       0x5C   0xE8BD 0x81F0      POP      {R4-R8,PC}
    441          }
    442          
    443          /**
    444            * @brief  Start the DMA Transfer with interrupt enabled.
    445            * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
    446            *                     the configuration information for the specified DMA Stream.  
    447            * @param  SrcAddress The source memory Buffer address
    448            * @param  DstAddress The destination memory Buffer address
    449            * @param  DataLength The length of data to be transferred from source to destination
    450            * @retval HAL status
    451            */

   \                                 In section .text, align 2, keep-with-next
    452          HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
    453          {
   \                     HAL_DMA_Start_IT: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    454            HAL_StatusTypeDef status = HAL_OK;
   \        0xC   0xF05F 0x0800      MOVS     R8,#+0
    455          
    456            /* calculate DMA base and stream number */
    457            DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
   \       0x10   0xF8D4 0x9058      LDR      R9,[R4, #+88]
    458            
    459            /* Check the parameters */
    460            assert_param(IS_DMA_BUFFER_SIZE(DataLength));
    461           
    462            /* Process locked */
    463            __HAL_LOCK(hdma);
   \       0x14   0xF894 0x0034      LDRB     R0,[R4, #+52]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD101             BNE.N    ??HAL_DMA_Start_IT_0
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0xE033             B.N      ??HAL_DMA_Start_IT_1
   \                     ??HAL_DMA_Start_IT_0: (+1)
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xF884 0x0034      STRB     R0,[R4, #+52]
    464            
    465            if(HAL_DMA_STATE_READY == hdma->State)
   \       0x26   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD125             BNE.N    ??HAL_DMA_Start_IT_2
    466            {
    467              /* Change DMA peripheral state */
    468              hdma->State = HAL_DMA_STATE_BUSY;
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0xF884 0x0035      STRB     R0,[R4, #+53]
    469              
    470              /* Initialize the error code */
    471              hdma->ErrorCode = HAL_DMA_ERROR_NONE;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x6560             STR      R0,[R4, #+84]
    472              
    473              /* Configure the source, destination address and the data length */
    474              DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
   \       0x38   0x003B             MOVS     R3,R7
   \       0x3A   0x0032             MOVS     R2,R6
   \       0x3C   0x0029             MOVS     R1,R5
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0x.... 0x....      BL       DMA_SetConfig
    475              
    476              /* Clear all interrupt flags at correct offset within the register */
    477              regs->IFCR = 0x3FU << hdma->StreamIndex;
   \       0x44   0x213F             MOVS     R1,#+63
   \       0x46   0x6DE0             LDR      R0,[R4, #+92]
   \       0x48   0x4081             LSLS     R1,R1,R0
   \       0x4A   0xF8C9 0x1008      STR      R1,[R9, #+8]
    478              
    479              /* Enable Common interrupts*/
    480              hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x6800             LDR      R0,[R0, #+0]
   \       0x52   0xF050 0x0016      ORRS     R0,R0,#0x16
   \       0x56   0x6821             LDR      R1,[R4, #+0]
   \       0x58   0x6008             STR      R0,[R1, #+0]
    481              
    482              if(hdma->XferHalfCpltCallback != NULL)
   \       0x5A   0x6C20             LDR      R0,[R4, #+64]
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD005             BEQ.N    ??HAL_DMA_Start_IT_3
    483              {
    484                hdma->Instance->CR  |= DMA_IT_HT;
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x6800             LDR      R0,[R0, #+0]
   \       0x64   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0x68   0x6821             LDR      R1,[R4, #+0]
   \       0x6A   0x6008             STR      R0,[R1, #+0]
    485              }
    486              
    487              /* Enable the Peripheral */
    488              __HAL_DMA_ENABLE(hdma);
   \                     ??HAL_DMA_Start_IT_3: (+1)
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x6800             LDR      R0,[R0, #+0]
   \       0x70   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x74   0x6821             LDR      R1,[R4, #+0]
   \       0x76   0x6008             STR      R0,[R1, #+0]
   \       0x78   0xE004             B.N      ??HAL_DMA_Start_IT_4
    489            }
    490            else
    491            {
    492              /* Process unlocked */
    493              __HAL_UNLOCK(hdma);	  
   \                     ??HAL_DMA_Start_IT_2: (+1)
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0xF884 0x0034      STRB     R0,[R4, #+52]
    494              
    495              /* Return error status */
    496              status = HAL_BUSY;
   \       0x80   0x2002             MOVS     R0,#+2
   \       0x82   0x4680             MOV      R8,R0
    497            }
    498            
    499            return status;
   \                     ??HAL_DMA_Start_IT_4: (+1)
   \       0x84   0x4640             MOV      R0,R8
   \       0x86   0xB2C0             UXTB     R0,R0
   \                     ??HAL_DMA_Start_IT_1: (+1)
   \       0x88   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    500          }
    501          
    502          /**
    503            * @brief  Aborts the DMA Transfer.
    504            * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
    505            *                 the configuration information for the specified DMA Stream.
    506            *                   
    507            * @note  After disabling a DMA Stream, a check for wait until the DMA Stream is 
    508            *        effectively disabled is added. If a Stream is disabled 
    509            *        while a data transfer is ongoing, the current data will be transferred
    510            *        and the Stream will be effectively disabled only after the transfer of
    511            *        this single data is finished.  
    512            * @retval HAL status
    513            */

   \                                 In section .text, align 2, keep-with-next
    514          HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
    515          {
   \                     HAL_DMA_Abort: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    516            /* calculate DMA base and stream number */
    517            DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
   \        0x4   0x6DA5             LDR      R5,[R4, #+88]
    518            
    519            uint32_t tickstart = HAL_GetTick();
   \        0x6   0x.... 0x....      BL       HAL_GetTick
   \        0xA   0x0006             MOVS     R6,R0
    520            
    521            if(hdma->State != HAL_DMA_STATE_BUSY)
   \        0xC   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \       0x10   0x2802             CMP      R0,#+2
   \       0x12   0xD006             BEQ.N    ??HAL_DMA_Abort_0
    522            {
    523              hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
   \       0x14   0x2080             MOVS     R0,#+128
   \       0x16   0x6560             STR      R0,[R4, #+84]
    524              
    525              /* Process Unlocked */
    526              __HAL_UNLOCK(hdma);
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xF884 0x0034      STRB     R0,[R4, #+52]
    527              
    528              return HAL_ERROR;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xE03B             B.N      ??HAL_DMA_Abort_1
    529            }
    530            else
    531            {
    532              /* Disable all the transfer interrupts */
    533              hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
   \                     ??HAL_DMA_Abort_0: (+1)
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0xF030 0x0016      BICS     R0,R0,#0x16
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6008             STR      R0,[R1, #+0]
    534              hdma->Instance->FCR &= ~(DMA_IT_FE);
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x6940             LDR      R0,[R0, #+20]
   \       0x32   0xF030 0x0080      BICS     R0,R0,#0x80
   \       0x36   0x6821             LDR      R1,[R4, #+0]
   \       0x38   0x6148             STR      R0,[R1, #+20]
    535              
    536              if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
   \       0x3A   0x6C20             LDR      R0,[R4, #+64]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD102             BNE.N    ??HAL_DMA_Abort_2
   \       0x40   0x6CA0             LDR      R0,[R4, #+72]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD005             BEQ.N    ??HAL_DMA_Abort_3
    537              {
    538                hdma->Instance->CR  &= ~(DMA_IT_HT);
   \                     ??HAL_DMA_Abort_2: (+1)
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x6800             LDR      R0,[R0, #+0]
   \       0x4A   0xF030 0x0008      BICS     R0,R0,#0x8
   \       0x4E   0x6821             LDR      R1,[R4, #+0]
   \       0x50   0x6008             STR      R0,[R1, #+0]
    539              }
    540              
    541              /* Disable the stream */
    542              __HAL_DMA_DISABLE(hdma);
   \                     ??HAL_DMA_Abort_3: (+1)
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x6800             LDR      R0,[R0, #+0]
   \       0x56   0x0840             LSRS     R0,R0,#+1
   \       0x58   0x0040             LSLS     R0,R0,#+1
   \       0x5A   0x6821             LDR      R1,[R4, #+0]
   \       0x5C   0x6008             STR      R0,[R1, #+0]
    543              
    544              /* Check if the DMA Stream is effectively disabled */
    545              while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
   \                     ??HAL_DMA_Abort_4: (+1)
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6800             LDR      R0,[R0, #+0]
   \       0x62   0x07C0             LSLS     R0,R0,#+31
   \       0x64   0xD50E             BPL.N    ??HAL_DMA_Abort_5
    546              {
    547                /* Check for the Timeout */
    548                if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
   \       0x66   0x.... 0x....      BL       HAL_GetTick
   \       0x6A   0x1B80             SUBS     R0,R0,R6
   \       0x6C   0x2806             CMP      R0,#+6
   \       0x6E   0xD3F6             BCC.N    ??HAL_DMA_Abort_4
    549                {
    550                  /* Update error code */
    551                  hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
   \       0x70   0x2020             MOVS     R0,#+32
   \       0x72   0x6560             STR      R0,[R4, #+84]
    552                  
    553                  /* Process Unlocked */
    554                  __HAL_UNLOCK(hdma);
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0xF884 0x0034      STRB     R0,[R4, #+52]
    555                  
    556                  /* Change the DMA state */
    557                  hdma->State = HAL_DMA_STATE_TIMEOUT;
   \       0x7A   0x2003             MOVS     R0,#+3
   \       0x7C   0xF884 0x0035      STRB     R0,[R4, #+53]
    558                  
    559                  return HAL_TIMEOUT;
   \       0x80   0x2003             MOVS     R0,#+3
   \       0x82   0xE00A             B.N      ??HAL_DMA_Abort_1
    560                }
    561              }
    562              
    563              /* Clear all interrupt flags at correct offset within the register */
    564              regs->IFCR = 0x3FU << hdma->StreamIndex;
   \                     ??HAL_DMA_Abort_5: (+1)
   \       0x84   0x213F             MOVS     R1,#+63
   \       0x86   0x6DE0             LDR      R0,[R4, #+92]
   \       0x88   0x4081             LSLS     R1,R1,R0
   \       0x8A   0x60A9             STR      R1,[R5, #+8]
    565              
    566              /* Process Unlocked */
    567              __HAL_UNLOCK(hdma);
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0xF884 0x0034      STRB     R0,[R4, #+52]
    568              
    569              /* Change the DMA state*/
    570              hdma->State = HAL_DMA_STATE_READY;
   \       0x92   0x2001             MOVS     R0,#+1
   \       0x94   0xF884 0x0035      STRB     R0,[R4, #+53]
    571            }
    572            return HAL_OK;
   \       0x98   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA_Abort_1: (+1)
   \       0x9A   0xBD70             POP      {R4-R6,PC}
    573          }
    574          
    575          /**
    576            * @brief  Aborts the DMA Transfer in Interrupt mode.
    577            * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
    578            *                 the configuration information for the specified DMA Stream.
    579            * @retval HAL status
    580            */

   \                                 In section .text, align 2, keep-with-next
    581          HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
    582          {
   \                     HAL_DMA_Abort_IT: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    583            if(hdma->State != HAL_DMA_STATE_BUSY)
   \        0x2   0xF891 0x0035      LDRB     R0,[R1, #+53]
   \        0x6   0x2802             CMP      R0,#+2
   \        0x8   0xD003             BEQ.N    ??HAL_DMA_Abort_IT_0
    584            {
    585              hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
   \        0xA   0x2080             MOVS     R0,#+128
   \        0xC   0x6548             STR      R0,[R1, #+84]
    586              return HAL_ERROR;
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xE009             B.N      ??HAL_DMA_Abort_IT_1
    587            }
    588            else
    589            {
    590              /* Set Abort State  */
    591              hdma->State = HAL_DMA_STATE_ABORT;
   \                     ??HAL_DMA_Abort_IT_0: (+1)
   \       0x12   0x2005             MOVS     R0,#+5
   \       0x14   0xF881 0x0035      STRB     R0,[R1, #+53]
    592              
    593              /* Disable the stream */
    594              __HAL_DMA_DISABLE(hdma);
   \       0x18   0x6808             LDR      R0,[R1, #+0]
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0x0840             LSRS     R0,R0,#+1
   \       0x1E   0x0040             LSLS     R0,R0,#+1
   \       0x20   0x680A             LDR      R2,[R1, #+0]
   \       0x22   0x6010             STR      R0,[R2, #+0]
    595            }
    596          
    597            return HAL_OK;
   \       0x24   0x2000             MOVS     R0,#+0
   \                     ??HAL_DMA_Abort_IT_1: (+1)
   \       0x26   0x4770             BX       LR
    598          }
    599          
    600          /**
    601            * @brief  Polling for transfer complete.
    602            * @param  hdma          pointer to a DMA_HandleTypeDef structure that contains
    603            *                        the configuration information for the specified DMA Stream.
    604            * @param  CompleteLevel Specifies the DMA level complete.
    605            * @note   The polling mode is kept in this version for legacy. it is recommanded to use the IT model instead.
    606            *         This model could be used for debug purpose.
    607            * @note   The HAL_DMA_PollForTransfer API cannot be used in circular and double buffering mode (automatic circular mode). 
    608            * @param  Timeout       Timeout duration.
    609            * @retval HAL status
    610            */

   \                                 In section .text, align 2, keep-with-next
    611          HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
    612          {
   \                     HAL_DMA_PollForTransfer: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
    613            HAL_StatusTypeDef status = HAL_OK; 
   \        0xA   0x2700             MOVS     R7,#+0
    614            uint32_t mask_cpltlevel;
    615            uint32_t tickstart = HAL_GetTick(); 
   \        0xC   0x.... 0x....      BL       HAL_GetTick
   \       0x10   0x4680             MOV      R8,R0
    616            uint32_t tmpisr;
    617            
    618            /* calculate DMA base and stream number */
    619            DMA_Base_Registers *regs;
    620          
    621            if(HAL_DMA_STATE_BUSY != hdma->State)
   \       0x12   0xF895 0x0035      LDRB     R0,[R5, #+53]
   \       0x16   0x2802             CMP      R0,#+2
   \       0x18   0xD006             BEQ.N    ??HAL_DMA_PollForTransfer_0
    622            {
    623              /* No transfer ongoing */
    624              hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
   \       0x1A   0x2080             MOVS     R0,#+128
   \       0x1C   0x6568             STR      R0,[R5, #+84]
    625              __HAL_UNLOCK(hdma);
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xF885 0x0034      STRB     R0,[R5, #+52]
    626              return HAL_ERROR;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xE093             B.N      ??HAL_DMA_PollForTransfer_1
    627            }
    628          
    629            /* Polling mode not supported in circular mode and double buffering mode */
    630            if ((hdma->Instance->CR & DMA_SxCR_CIRC) != RESET)
   \                     ??HAL_DMA_PollForTransfer_0: (+1)
   \       0x28   0x6828             LDR      R0,[R5, #+0]
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0x05C0             LSLS     R0,R0,#+23
   \       0x2E   0xD504             BPL.N    ??HAL_DMA_PollForTransfer_2
    631            {
    632              hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
   \       0x30   0xF44F 0x7080      MOV      R0,#+256
   \       0x34   0x6568             STR      R0,[R5, #+84]
    633              return HAL_ERROR;
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0xE08A             B.N      ??HAL_DMA_PollForTransfer_1
    634            }
    635            
    636            /* Get the level transfer complete flag */
    637            if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
   \                     ??HAL_DMA_PollForTransfer_2: (+1)
   \       0x3A   0x0030             MOVS     R0,R6
   \       0x3C   0xB2C0             UXTB     R0,R0
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD105             BNE.N    ??HAL_DMA_PollForTransfer_3
    638            {
    639              /* Transfer Complete flag */
    640              mask_cpltlevel = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
   \       0x42   0x2020             MOVS     R0,#+32
   \       0x44   0xF8D5 0x905C      LDR      R9,[R5, #+92]
   \       0x48   0xFA10 0xF909      LSLS     R9,R0,R9
   \       0x4C   0xE004             B.N      ??HAL_DMA_PollForTransfer_4
    641            }
    642            else
    643            {
    644              /* Half Transfer Complete flag */
    645              mask_cpltlevel = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
   \                     ??HAL_DMA_PollForTransfer_3: (+1)
   \       0x4E   0x2010             MOVS     R0,#+16
   \       0x50   0xF8D5 0x905C      LDR      R9,[R5, #+92]
   \       0x54   0xFA10 0xF909      LSLS     R9,R0,R9
    646            }
    647            
    648            regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
   \                     ??HAL_DMA_PollForTransfer_4: (+1)
   \       0x58   0xF8D5 0xA058      LDR      R10,[R5, #+88]
    649            tmpisr = regs->ISR;
   \       0x5C   0xF8DA 0xB000      LDR      R11,[R10, #+0]
    650            
    651            while(((tmpisr & mask_cpltlevel) == RESET) && ((hdma->ErrorCode & HAL_DMA_ERROR_TE) == RESET))
   \                     ??HAL_DMA_PollForTransfer_5: (+1)
   \       0x60   0xEA1B 0x0F09      TST      R11,R9
   \       0x64   0xD147             BNE.N    ??HAL_DMA_PollForTransfer_6
   \       0x66   0x6D68             LDR      R0,[R5, #+84]
   \       0x68   0x07C0             LSLS     R0,R0,#+31
   \       0x6A   0xD444             BMI.N    ??HAL_DMA_PollForTransfer_6
    652            {
    653              /* Check for the Timeout (Not applicable in circular mode)*/
    654              if(Timeout != HAL_MAX_DELAY)
   \       0x6C   0xF114 0x0F01      CMN      R4,#+1
   \       0x70   0xD011             BEQ.N    ??HAL_DMA_PollForTransfer_7
    655              {
    656                if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
   \       0x72   0x2C00             CMP      R4,#+0
   \       0x74   0xD005             BEQ.N    ??HAL_DMA_PollForTransfer_8
   \       0x76   0x.... 0x....      BL       HAL_GetTick
   \       0x7A   0xEBB0 0x0008      SUBS     R0,R0,R8
   \       0x7E   0x4284             CMP      R4,R0
   \       0x80   0xD209             BCS.N    ??HAL_DMA_PollForTransfer_7
    657                {
    658                  /* Update error code */
    659                  hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
   \                     ??HAL_DMA_PollForTransfer_8: (+1)
   \       0x82   0x2020             MOVS     R0,#+32
   \       0x84   0x6568             STR      R0,[R5, #+84]
    660          
    661                  /* Process Unlocked */
    662                  __HAL_UNLOCK(hdma);
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0xF885 0x0034      STRB     R0,[R5, #+52]
    663                  
    664                  /* Change the DMA state */
    665                  hdma->State = HAL_DMA_STATE_READY;
   \       0x8C   0x2001             MOVS     R0,#+1
   \       0x8E   0xF885 0x0035      STRB     R0,[R5, #+53]
    666                  
    667                  return HAL_TIMEOUT;
   \       0x92   0x2003             MOVS     R0,#+3
   \       0x94   0xE05C             B.N      ??HAL_DMA_PollForTransfer_1
    668                }
    669              }
    670          
    671              /* Get the ISR register value */
    672              tmpisr = regs->ISR;
   \                     ??HAL_DMA_PollForTransfer_7: (+1)
   \       0x96   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \       0x9A   0x4683             MOV      R11,R0
    673          
    674              if((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
   \       0x9C   0x2108             MOVS     R1,#+8
   \       0x9E   0x6DE8             LDR      R0,[R5, #+92]
   \       0xA0   0xFA11 0xF000      LSLS     R0,R1,R0
   \       0xA4   0xEA1B 0x0F00      TST      R11,R0
   \       0xA8   0xD007             BEQ.N    ??HAL_DMA_PollForTransfer_9
    675              {
    676                /* Update error code */
    677                hdma->ErrorCode |= HAL_DMA_ERROR_TE;
   \       0xAA   0x6D68             LDR      R0,[R5, #+84]
   \       0xAC   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xB0   0x6568             STR      R0,[R5, #+84]
    678                
    679                /* Clear the transfer error flag */
    680                regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
   \       0xB2   0x6DE8             LDR      R0,[R5, #+92]
   \       0xB4   0x4081             LSLS     R1,R1,R0
   \       0xB6   0xF8CA 0x1008      STR      R1,[R10, #+8]
    681              }
    682              
    683              if((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
   \                     ??HAL_DMA_PollForTransfer_9: (+1)
   \       0xBA   0x6DE8             LDR      R0,[R5, #+92]
   \       0xBC   0x4659             MOV      R1,R11
   \       0xBE   0x40C1             LSRS     R1,R1,R0
   \       0xC0   0x07C8             LSLS     R0,R1,#+31
   \       0xC2   0xD508             BPL.N    ??HAL_DMA_PollForTransfer_10
    684              {
    685                /* Update error code */
    686                hdma->ErrorCode |= HAL_DMA_ERROR_FE;
   \       0xC4   0x6D68             LDR      R0,[R5, #+84]
   \       0xC6   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0xCA   0x6568             STR      R0,[R5, #+84]
    687                
    688                /* Clear the FIFO error flag */
    689                regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
   \       0xCC   0x2101             MOVS     R1,#+1
   \       0xCE   0x6DE8             LDR      R0,[R5, #+92]
   \       0xD0   0x4081             LSLS     R1,R1,R0
   \       0xD2   0xF8CA 0x1008      STR      R1,[R10, #+8]
    690              }
    691              
    692              if((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
   \                     ??HAL_DMA_PollForTransfer_10: (+1)
   \       0xD6   0x2104             MOVS     R1,#+4
   \       0xD8   0x6DE8             LDR      R0,[R5, #+92]
   \       0xDA   0xFA11 0xF000      LSLS     R0,R1,R0
   \       0xDE   0xEA1B 0x0F00      TST      R11,R0
   \       0xE2   0xD0BD             BEQ.N    ??HAL_DMA_PollForTransfer_5
    693              {
    694                /* Update error code */
    695                hdma->ErrorCode |= HAL_DMA_ERROR_DME;
   \       0xE4   0x6D68             LDR      R0,[R5, #+84]
   \       0xE6   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0xEA   0x6568             STR      R0,[R5, #+84]
    696                
    697                /* Clear the Direct Mode error flag */
    698                regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
   \       0xEC   0x6DE8             LDR      R0,[R5, #+92]
   \       0xEE   0x4081             LSLS     R1,R1,R0
   \       0xF0   0xF8CA 0x1008      STR      R1,[R10, #+8]
   \       0xF4   0xE7B4             B.N      ??HAL_DMA_PollForTransfer_5
    699              }
    700            }
    701            
    702            if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
   \                     ??HAL_DMA_PollForTransfer_6: (+1)
   \       0xF6   0x6D68             LDR      R0,[R5, #+84]
   \       0xF8   0x2800             CMP      R0,#+0
   \       0xFA   0xD012             BEQ.N    ??HAL_DMA_PollForTransfer_11
    703            {
    704              if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
   \       0xFC   0x6D68             LDR      R0,[R5, #+84]
   \       0xFE   0x07C0             LSLS     R0,R0,#+31
   \      0x100   0xD50F             BPL.N    ??HAL_DMA_PollForTransfer_11
    705              {
    706                HAL_DMA_Abort(hdma);
   \      0x102   0x0028             MOVS     R0,R5
   \      0x104   0x.... 0x....      BL       HAL_DMA_Abort
    707              
    708                /* Clear the half transfer and transfer complete flags */
    709                regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
   \      0x108   0x2130             MOVS     R1,#+48
   \      0x10A   0x6DE8             LDR      R0,[R5, #+92]
   \      0x10C   0x4081             LSLS     R1,R1,R0
   \      0x10E   0xF8CA 0x1008      STR      R1,[R10, #+8]
    710              
    711                /* Process Unlocked */
    712                __HAL_UNLOCK(hdma);
   \      0x112   0x2000             MOVS     R0,#+0
   \      0x114   0xF885 0x0034      STRB     R0,[R5, #+52]
    713          
    714                /* Change the DMA state */
    715                hdma->State= HAL_DMA_STATE_READY;
   \      0x118   0x2001             MOVS     R0,#+1
   \      0x11A   0xF885 0x0035      STRB     R0,[R5, #+53]
    716          
    717                return HAL_ERROR;
   \      0x11E   0x2001             MOVS     R0,#+1
   \      0x120   0xE016             B.N      ??HAL_DMA_PollForTransfer_1
    718             }
    719            }
    720            
    721            /* Get the level transfer complete flag */
    722            if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
   \                     ??HAL_DMA_PollForTransfer_11: (+1)
   \      0x122   0x0030             MOVS     R0,R6
   \      0x124   0xB2C0             UXTB     R0,R0
   \      0x126   0x2800             CMP      R0,#+0
   \      0x128   0xD10B             BNE.N    ??HAL_DMA_PollForTransfer_12
    723            {
    724              /* Clear the half transfer and transfer complete flags */
    725              regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
   \      0x12A   0x2130             MOVS     R1,#+48
   \      0x12C   0x6DE8             LDR      R0,[R5, #+92]
   \      0x12E   0x4081             LSLS     R1,R1,R0
   \      0x130   0xF8CA 0x1008      STR      R1,[R10, #+8]
    726              
    727              /* Process Unlocked */
    728              __HAL_UNLOCK(hdma);
   \      0x134   0x2000             MOVS     R0,#+0
   \      0x136   0xF885 0x0034      STRB     R0,[R5, #+52]
    729          
    730              hdma->State = HAL_DMA_STATE_READY;
   \      0x13A   0x2001             MOVS     R0,#+1
   \      0x13C   0xF885 0x0035      STRB     R0,[R5, #+53]
   \      0x140   0xE004             B.N      ??HAL_DMA_PollForTransfer_13
    731            }
    732            else
    733            {
    734              /* Clear the half transfer and transfer complete flags */
    735              regs->IFCR = (DMA_FLAG_HTIF0_4) << hdma->StreamIndex;
   \                     ??HAL_DMA_PollForTransfer_12: (+1)
   \      0x142   0x2110             MOVS     R1,#+16
   \      0x144   0x6DE8             LDR      R0,[R5, #+92]
   \      0x146   0x4081             LSLS     R1,R1,R0
   \      0x148   0xF8CA 0x1008      STR      R1,[R10, #+8]
    736            }
    737            
    738            return status;
   \                     ??HAL_DMA_PollForTransfer_13: (+1)
   \      0x14C   0x0038             MOVS     R0,R7
   \      0x14E   0xB2C0             UXTB     R0,R0
   \                     ??HAL_DMA_PollForTransfer_1: (+1)
   \      0x150   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
    739          }
    740          
    741          /**
    742            * @brief  Handles DMA interrupt request.
    743            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
    744            *               the configuration information for the specified DMA Stream.  
    745            * @retval None
    746            */

   \                                 In section .text, align 2, keep-with-next
    747          void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
    748          {
   \                     HAL_DMA_IRQHandler: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
    749            uint32_t tmpisr;
    750            __IO uint32_t count = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
    751            uint32_t timeout = SystemCoreClock / 9600U;
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable2_1
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0xF44F 0x5116      MOV      R1,#+9600
   \       0x12   0xFBB0 0xF5F1      UDIV     R5,R0,R1
    752          
    753            /* calculate DMA base and stream number */
    754            DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
   \       0x16   0x6DA6             LDR      R6,[R4, #+88]
    755          
    756            tmpisr = regs->ISR;
   \       0x18   0x6837             LDR      R7,[R6, #+0]
    757          
    758            /* Transfer Error Interrupt management ***************************************/
    759            if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
   \       0x1A   0x2108             MOVS     R1,#+8
   \       0x1C   0x6DE0             LDR      R0,[R4, #+92]
   \       0x1E   0xFA11 0xF000      LSLS     R0,R1,R0
   \       0x22   0x4207             TST      R7,R0
   \       0x24   0xD010             BEQ.N    ??HAL_DMA_IRQHandler_0
    760            {
    761              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0x0740             LSLS     R0,R0,#+29
   \       0x2C   0xD50C             BPL.N    ??HAL_DMA_IRQHandler_0
    762              {
    763                /* Disable the transfer error interrupt */
    764                hdma->Instance->CR  &= ~(DMA_IT_TE);
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x6800             LDR      R0,[R0, #+0]
   \       0x32   0xF030 0x0004      BICS     R0,R0,#0x4
   \       0x36   0x6822             LDR      R2,[R4, #+0]
   \       0x38   0x6010             STR      R0,[R2, #+0]
    765                
    766                /* Clear the transfer error flag */
    767                regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
   \       0x3A   0x6DE0             LDR      R0,[R4, #+92]
   \       0x3C   0x4081             LSLS     R1,R1,R0
   \       0x3E   0x60B1             STR      R1,[R6, #+8]
    768                
    769                /* Update error code */
    770                hdma->ErrorCode |= HAL_DMA_ERROR_TE;
   \       0x40   0x6D60             LDR      R0,[R4, #+84]
   \       0x42   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x46   0x6560             STR      R0,[R4, #+84]
    771              }
    772            }
    773            /* FIFO Error Interrupt management ******************************************/
    774            if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
   \                     ??HAL_DMA_IRQHandler_0: (+1)
   \       0x48   0x6DE0             LDR      R0,[R4, #+92]
   \       0x4A   0x0039             MOVS     R1,R7
   \       0x4C   0x40C1             LSRS     R1,R1,R0
   \       0x4E   0x07C8             LSLS     R0,R1,#+31
   \       0x50   0xD50B             BPL.N    ??HAL_DMA_IRQHandler_1
    775            {
    776              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x6940             LDR      R0,[R0, #+20]
   \       0x56   0x0600             LSLS     R0,R0,#+24
   \       0x58   0xD507             BPL.N    ??HAL_DMA_IRQHandler_1
    777              {
    778                /* Clear the FIFO error flag */
    779                regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
   \       0x5A   0x2101             MOVS     R1,#+1
   \       0x5C   0x6DE0             LDR      R0,[R4, #+92]
   \       0x5E   0x4081             LSLS     R1,R1,R0
   \       0x60   0x60B1             STR      R1,[R6, #+8]
    780          
    781                /* Update error code */
    782                hdma->ErrorCode |= HAL_DMA_ERROR_FE;
   \       0x62   0x6D60             LDR      R0,[R4, #+84]
   \       0x64   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x68   0x6560             STR      R0,[R4, #+84]
    783              }
    784            }
    785            /* Direct Mode Error Interrupt management ***********************************/
    786            if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
   \                     ??HAL_DMA_IRQHandler_1: (+1)
   \       0x6A   0x2104             MOVS     R1,#+4
   \       0x6C   0x6DE0             LDR      R0,[R4, #+92]
   \       0x6E   0xFA11 0xF000      LSLS     R0,R1,R0
   \       0x72   0x4207             TST      R7,R0
   \       0x74   0xD00A             BEQ.N    ??HAL_DMA_IRQHandler_2
    787            {
    788              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x6800             LDR      R0,[R0, #+0]
   \       0x7A   0x0780             LSLS     R0,R0,#+30
   \       0x7C   0xD506             BPL.N    ??HAL_DMA_IRQHandler_2
    789              {
    790                /* Clear the direct mode error flag */
    791                regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
   \       0x7E   0x6DE0             LDR      R0,[R4, #+92]
   \       0x80   0x4081             LSLS     R1,R1,R0
   \       0x82   0x60B1             STR      R1,[R6, #+8]
    792          
    793                /* Update error code */
    794                hdma->ErrorCode |= HAL_DMA_ERROR_DME;
   \       0x84   0x6D60             LDR      R0,[R4, #+84]
   \       0x86   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x8A   0x6560             STR      R0,[R4, #+84]
    795              }
    796            }
    797            /* Half Transfer Complete Interrupt management ******************************/
    798            if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
   \                     ??HAL_DMA_IRQHandler_2: (+1)
   \       0x8C   0x2110             MOVS     R1,#+16
   \       0x8E   0x6DE0             LDR      R0,[R4, #+92]
   \       0x90   0xFA11 0xF000      LSLS     R0,R1,R0
   \       0x94   0x4207             TST      R7,R0
   \       0x96   0xD02C             BEQ.N    ??HAL_DMA_IRQHandler_3
    799            {
    800              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
   \       0x98   0x6820             LDR      R0,[R4, #+0]
   \       0x9A   0x6800             LDR      R0,[R0, #+0]
   \       0x9C   0x0700             LSLS     R0,R0,#+28
   \       0x9E   0xD528             BPL.N    ??HAL_DMA_IRQHandler_3
    801              {
    802                /* Clear the half transfer complete flag */
    803                regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
   \       0xA0   0x6DE0             LDR      R0,[R4, #+92]
   \       0xA2   0x4081             LSLS     R1,R1,R0
   \       0xA4   0x60B1             STR      R1,[R6, #+8]
    804                
    805                /* Multi_Buffering mode enabled */
    806                if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
   \       0xA6   0x6820             LDR      R0,[R4, #+0]
   \       0xA8   0x6800             LDR      R0,[R0, #+0]
   \       0xAA   0x0340             LSLS     R0,R0,#+13
   \       0xAC   0xD511             BPL.N    ??HAL_DMA_IRQHandler_4
    807                {
    808                  /* Current memory buffer used is Memory 0 */
    809                  if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
   \       0xAE   0x6820             LDR      R0,[R4, #+0]
   \       0xB0   0x6800             LDR      R0,[R0, #+0]
   \       0xB2   0x0300             LSLS     R0,R0,#+12
   \       0xB4   0xD406             BMI.N    ??HAL_DMA_IRQHandler_5
    810                  {
    811                    if(hdma->XferHalfCpltCallback != NULL)
   \       0xB6   0x6C20             LDR      R0,[R4, #+64]
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD01A             BEQ.N    ??HAL_DMA_IRQHandler_3
    812                    {
    813                      /* Half transfer callback */
    814                      hdma->XferHalfCpltCallback(hdma);
   \       0xBC   0x0020             MOVS     R0,R4
   \       0xBE   0x6C21             LDR      R1,[R4, #+64]
   \       0xC0   0x4788             BLX      R1
   \       0xC2   0xE016             B.N      ??HAL_DMA_IRQHandler_3
    815                    }
    816                  }
    817                  /* Current memory buffer used is Memory 1 */
    818                  else
    819                  {
    820                    if(hdma->XferM1HalfCpltCallback != NULL)
   \                     ??HAL_DMA_IRQHandler_5: (+1)
   \       0xC4   0x6CA0             LDR      R0,[R4, #+72]
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD013             BEQ.N    ??HAL_DMA_IRQHandler_3
    821                    {
    822                      /* Half transfer callback */
    823                      hdma->XferM1HalfCpltCallback(hdma);
   \       0xCA   0x0020             MOVS     R0,R4
   \       0xCC   0x6CA1             LDR      R1,[R4, #+72]
   \       0xCE   0x4788             BLX      R1
   \       0xD0   0xE00F             B.N      ??HAL_DMA_IRQHandler_3
    824                    }
    825                  }
    826                }
    827                else
    828                {
    829                  /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
    830                  if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
   \                     ??HAL_DMA_IRQHandler_4: (+1)
   \       0xD2   0x6820             LDR      R0,[R4, #+0]
   \       0xD4   0x6800             LDR      R0,[R0, #+0]
   \       0xD6   0x05C0             LSLS     R0,R0,#+23
   \       0xD8   0xD405             BMI.N    ??HAL_DMA_IRQHandler_6
    831                  {
    832                    /* Disable the half transfer interrupt */
    833                    hdma->Instance->CR  &= ~(DMA_IT_HT);
   \       0xDA   0x6820             LDR      R0,[R4, #+0]
   \       0xDC   0x6800             LDR      R0,[R0, #+0]
   \       0xDE   0xF030 0x0008      BICS     R0,R0,#0x8
   \       0xE2   0x6821             LDR      R1,[R4, #+0]
   \       0xE4   0x6008             STR      R0,[R1, #+0]
    834                  }
    835                  
    836                  if(hdma->XferHalfCpltCallback != NULL)
   \                     ??HAL_DMA_IRQHandler_6: (+1)
   \       0xE6   0x6C20             LDR      R0,[R4, #+64]
   \       0xE8   0x2800             CMP      R0,#+0
   \       0xEA   0xD002             BEQ.N    ??HAL_DMA_IRQHandler_3
    837                  {
    838                    /* Half transfer callback */
    839                    hdma->XferHalfCpltCallback(hdma);
   \       0xEC   0x0020             MOVS     R0,R4
   \       0xEE   0x6C21             LDR      R1,[R4, #+64]
   \       0xF0   0x4788             BLX      R1
    840                  }
    841                }
    842              }
    843            }
    844            /* Transfer Complete Interrupt management ***********************************/
    845            if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
   \                     ??HAL_DMA_IRQHandler_3: (+1)
   \       0xF2   0x2120             MOVS     R1,#+32
   \       0xF4   0x6DE0             LDR      R0,[R4, #+92]
   \       0xF6   0xFA11 0xF000      LSLS     R0,R1,R0
   \       0xFA   0x4207             TST      R7,R0
   \       0xFC   0xD05F             BEQ.N    ??HAL_DMA_IRQHandler_7
    846            {
    847              if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
   \       0xFE   0x6820             LDR      R0,[R4, #+0]
   \      0x100   0x6800             LDR      R0,[R0, #+0]
   \      0x102   0x06C0             LSLS     R0,R0,#+27
   \      0x104   0xD55B             BPL.N    ??HAL_DMA_IRQHandler_7
    848              {
    849                /* Clear the transfer complete flag */
    850                regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
   \      0x106   0x6DE0             LDR      R0,[R4, #+92]
   \      0x108   0x4081             LSLS     R1,R1,R0
   \      0x10A   0x60B1             STR      R1,[R6, #+8]
    851                
    852                if(HAL_DMA_STATE_ABORT == hdma->State)
   \      0x10C   0xF894 0x0035      LDRB     R0,[R4, #+53]
   \      0x110   0x2805             CMP      R0,#+5
   \      0x112   0xD128             BNE.N    ??HAL_DMA_IRQHandler_8
    853                {
    854                  /* Disable all the transfer interrupts */
    855                  hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
   \      0x114   0x6820             LDR      R0,[R4, #+0]
   \      0x116   0x6800             LDR      R0,[R0, #+0]
   \      0x118   0xF030 0x0016      BICS     R0,R0,#0x16
   \      0x11C   0x6821             LDR      R1,[R4, #+0]
   \      0x11E   0x6008             STR      R0,[R1, #+0]
    856                  hdma->Instance->FCR &= ~(DMA_IT_FE);
   \      0x120   0x6820             LDR      R0,[R4, #+0]
   \      0x122   0x6940             LDR      R0,[R0, #+20]
   \      0x124   0xF030 0x0080      BICS     R0,R0,#0x80
   \      0x128   0x6821             LDR      R1,[R4, #+0]
   \      0x12A   0x6148             STR      R0,[R1, #+20]
    857                  
    858                  if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
   \      0x12C   0x6C20             LDR      R0,[R4, #+64]
   \      0x12E   0x2800             CMP      R0,#+0
   \      0x130   0xD102             BNE.N    ??HAL_DMA_IRQHandler_9
   \      0x132   0x6CA0             LDR      R0,[R4, #+72]
   \      0x134   0x2800             CMP      R0,#+0
   \      0x136   0xD005             BEQ.N    ??HAL_DMA_IRQHandler_10
    859                  {
    860                    hdma->Instance->CR  &= ~(DMA_IT_HT);
   \                     ??HAL_DMA_IRQHandler_9: (+1)
   \      0x138   0x6820             LDR      R0,[R4, #+0]
   \      0x13A   0x6800             LDR      R0,[R0, #+0]
   \      0x13C   0xF030 0x0008      BICS     R0,R0,#0x8
   \      0x140   0x6821             LDR      R1,[R4, #+0]
   \      0x142   0x6008             STR      R0,[R1, #+0]
    861                  }
    862          
    863                  /* Clear all interrupt flags at correct offset within the register */
    864                  regs->IFCR = 0x3FU << hdma->StreamIndex;
   \                     ??HAL_DMA_IRQHandler_10: (+1)
   \      0x144   0x213F             MOVS     R1,#+63
   \      0x146   0x6DE0             LDR      R0,[R4, #+92]
   \      0x148   0x4081             LSLS     R1,R1,R0
   \      0x14A   0x60B1             STR      R1,[R6, #+8]
    865          
    866                  /* Process Unlocked */
    867                  __HAL_UNLOCK(hdma);
   \      0x14C   0x2000             MOVS     R0,#+0
   \      0x14E   0xF884 0x0034      STRB     R0,[R4, #+52]
    868          
    869                  /* Change the DMA state */
    870                  hdma->State = HAL_DMA_STATE_READY;
   \      0x152   0x2001             MOVS     R0,#+1
   \      0x154   0xF884 0x0035      STRB     R0,[R4, #+53]
    871          
    872                  if(hdma->XferAbortCallback != NULL)
   \      0x158   0x6D20             LDR      R0,[R4, #+80]
   \      0x15A   0x2800             CMP      R0,#+0
   \      0x15C   0xD002             BEQ.N    ??HAL_DMA_IRQHandler_11
    873                  {
    874                    hdma->XferAbortCallback(hdma);
   \      0x15E   0x0020             MOVS     R0,R4
   \      0x160   0x6D21             LDR      R1,[R4, #+80]
   \      0x162   0x4788             BLX      R1
    875                  }
    876                  return;
   \                     ??HAL_DMA_IRQHandler_11: (+1)
   \      0x164   0xE04F             B.N      ??HAL_DMA_IRQHandler_12
    877                }
    878          
    879                if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
   \                     ??HAL_DMA_IRQHandler_8: (+1)
   \      0x166   0x6820             LDR      R0,[R4, #+0]
   \      0x168   0x6800             LDR      R0,[R0, #+0]
   \      0x16A   0x0340             LSLS     R0,R0,#+13
   \      0x16C   0xD511             BPL.N    ??HAL_DMA_IRQHandler_13
    880                {
    881                  /* Current memory buffer used is Memory 0 */
    882                  if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
   \      0x16E   0x6820             LDR      R0,[R4, #+0]
   \      0x170   0x6800             LDR      R0,[R0, #+0]
   \      0x172   0x0300             LSLS     R0,R0,#+12
   \      0x174   0xD406             BMI.N    ??HAL_DMA_IRQHandler_14
    883                  {
    884                    if(hdma->XferM1CpltCallback != NULL)
   \      0x176   0x6C60             LDR      R0,[R4, #+68]
   \      0x178   0x2800             CMP      R0,#+0
   \      0x17A   0xD020             BEQ.N    ??HAL_DMA_IRQHandler_7
    885                    {
    886                      /* Transfer complete Callback for memory1 */
    887                      hdma->XferM1CpltCallback(hdma);
   \      0x17C   0x0020             MOVS     R0,R4
   \      0x17E   0x6C61             LDR      R1,[R4, #+68]
   \      0x180   0x4788             BLX      R1
   \      0x182   0xE01C             B.N      ??HAL_DMA_IRQHandler_7
    888                    }
    889                  }
    890                  /* Current memory buffer used is Memory 1 */
    891                  else
    892                  {
    893                    if(hdma->XferCpltCallback != NULL)
   \                     ??HAL_DMA_IRQHandler_14: (+1)
   \      0x184   0x6BE0             LDR      R0,[R4, #+60]
   \      0x186   0x2800             CMP      R0,#+0
   \      0x188   0xD019             BEQ.N    ??HAL_DMA_IRQHandler_7
    894                    {
    895                      /* Transfer complete Callback for memory0 */
    896                      hdma->XferCpltCallback(hdma);
   \      0x18A   0x0020             MOVS     R0,R4
   \      0x18C   0x6BE1             LDR      R1,[R4, #+60]
   \      0x18E   0x4788             BLX      R1
   \      0x190   0xE015             B.N      ??HAL_DMA_IRQHandler_7
    897                    }
    898                  }
    899                }
    900                /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
    901                else
    902                {
    903                  if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
   \                     ??HAL_DMA_IRQHandler_13: (+1)
   \      0x192   0x6820             LDR      R0,[R4, #+0]
   \      0x194   0x6800             LDR      R0,[R0, #+0]
   \      0x196   0x05C0             LSLS     R0,R0,#+23
   \      0x198   0xD40B             BMI.N    ??HAL_DMA_IRQHandler_15
    904                  {
    905                    /* Disable the transfer complete interrupt */
    906                    hdma->Instance->CR  &= ~(DMA_IT_TC);
   \      0x19A   0x6820             LDR      R0,[R4, #+0]
   \      0x19C   0x6800             LDR      R0,[R0, #+0]
   \      0x19E   0xF030 0x0010      BICS     R0,R0,#0x10
   \      0x1A2   0x6821             LDR      R1,[R4, #+0]
   \      0x1A4   0x6008             STR      R0,[R1, #+0]
    907          
    908                    /* Process Unlocked */
    909                    __HAL_UNLOCK(hdma);
   \      0x1A6   0x2000             MOVS     R0,#+0
   \      0x1A8   0xF884 0x0034      STRB     R0,[R4, #+52]
    910          
    911                    /* Change the DMA state */
    912                    hdma->State = HAL_DMA_STATE_READY;
   \      0x1AC   0x2001             MOVS     R0,#+1
   \      0x1AE   0xF884 0x0035      STRB     R0,[R4, #+53]
    913                  }
    914          
    915                  if(hdma->XferCpltCallback != NULL)
   \                     ??HAL_DMA_IRQHandler_15: (+1)
   \      0x1B2   0x6BE0             LDR      R0,[R4, #+60]
   \      0x1B4   0x2800             CMP      R0,#+0
   \      0x1B6   0xD002             BEQ.N    ??HAL_DMA_IRQHandler_7
    916                  {
    917                    /* Transfer complete callback */
    918                    hdma->XferCpltCallback(hdma);
   \      0x1B8   0x0020             MOVS     R0,R4
   \      0x1BA   0x6BE1             LDR      R1,[R4, #+60]
   \      0x1BC   0x4788             BLX      R1
    919                  }
    920                }
    921              }
    922            }
    923            
    924            /* manage error case */
    925            if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
   \                     ??HAL_DMA_IRQHandler_7: (+1)
   \      0x1BE   0x6D60             LDR      R0,[R4, #+84]
   \      0x1C0   0x2800             CMP      R0,#+0
   \      0x1C2   0xD020             BEQ.N    ??HAL_DMA_IRQHandler_16
    926            {
    927              if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
   \      0x1C4   0x6D60             LDR      R0,[R4, #+84]
   \      0x1C6   0x07C0             LSLS     R0,R0,#+31
   \      0x1C8   0xD517             BPL.N    ??HAL_DMA_IRQHandler_17
    928              {
    929                hdma->State = HAL_DMA_STATE_ABORT;
   \      0x1CA   0x2005             MOVS     R0,#+5
   \      0x1CC   0xF884 0x0035      STRB     R0,[R4, #+53]
    930          
    931                /* Disable the stream */
    932                __HAL_DMA_DISABLE(hdma);
   \      0x1D0   0x6820             LDR      R0,[R4, #+0]
   \      0x1D2   0x6800             LDR      R0,[R0, #+0]
   \      0x1D4   0x0840             LSRS     R0,R0,#+1
   \      0x1D6   0x0040             LSLS     R0,R0,#+1
   \      0x1D8   0x6821             LDR      R1,[R4, #+0]
   \      0x1DA   0x6008             STR      R0,[R1, #+0]
    933          
    934                do
    935                {
    936                  if (++count > timeout)
   \                     ??HAL_DMA_IRQHandler_18: (+1)
   \      0x1DC   0x9800             LDR      R0,[SP, #+0]
   \      0x1DE   0x1C40             ADDS     R0,R0,#+1
   \      0x1E0   0x9000             STR      R0,[SP, #+0]
   \      0x1E2   0x4285             CMP      R5,R0
   \      0x1E4   0xD303             BCC.N    ??HAL_DMA_IRQHandler_19
    937                  {
    938                    break;
    939                  }
    940                }
    941                while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
   \                     ??HAL_DMA_IRQHandler_20: (+1)
   \      0x1E6   0x6820             LDR      R0,[R4, #+0]
   \      0x1E8   0x6800             LDR      R0,[R0, #+0]
   \      0x1EA   0x07C0             LSLS     R0,R0,#+31
   \      0x1EC   0xD4F6             BMI.N    ??HAL_DMA_IRQHandler_18
    942          
    943                /* Process Unlocked */
    944                __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_IRQHandler_19: (+1)
   \      0x1EE   0x2000             MOVS     R0,#+0
   \      0x1F0   0xF884 0x0034      STRB     R0,[R4, #+52]
    945          
    946                /* Change the DMA state */
    947                hdma->State = HAL_DMA_STATE_READY;
   \      0x1F4   0x2001             MOVS     R0,#+1
   \      0x1F6   0xF884 0x0035      STRB     R0,[R4, #+53]
    948              }
    949          
    950              if(hdma->XferErrorCallback != NULL)
   \                     ??HAL_DMA_IRQHandler_17: (+1)
   \      0x1FA   0x6CE0             LDR      R0,[R4, #+76]
   \      0x1FC   0x2800             CMP      R0,#+0
   \      0x1FE   0xD002             BEQ.N    ??HAL_DMA_IRQHandler_16
    951              {
    952                /* Transfer error callback */
    953                hdma->XferErrorCallback(hdma);
   \      0x200   0x0020             MOVS     R0,R4
   \      0x202   0x6CE1             LDR      R1,[R4, #+76]
   \      0x204   0x4788             BLX      R1
    954              }
    955            }
    956          }
   \                     ??HAL_DMA_IRQHandler_16: (+1)
   \                     ??HAL_DMA_IRQHandler_12: (+1)
   \      0x206   0xBDF1             POP      {R0,R4-R7,PC}
    957          
    958          /**
    959            * @brief  Register callbacks
    960            * @param  hdma                 pointer to a DMA_HandleTypeDef structure that contains
    961            *                               the configuration information for the specified DMA Stream.
    962            * @param  CallbackID           User Callback identifer
    963            *                               a DMA_HandleTypeDef structure as parameter.
    964            * @param  pCallback            pointer to private callbacsk function which has pointer to 
    965            *                               a DMA_HandleTypeDef structure as parameter.
    966            * @retval HAL status
    967            */                      

   \                                 In section .text, align 2, keep-with-next
    968          HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
    969          {
   \                     HAL_DMA_RegisterCallback: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0003             MOVS     R3,R0
    970          
    971            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2400             MOVS     R4,#+0
    972          
    973            /* Process locked */
    974            __HAL_LOCK(hdma);
   \        0x6   0xF893 0x0034      LDRB     R0,[R3, #+52]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE.N    ??HAL_DMA_RegisterCallback_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE027             B.N      ??HAL_DMA_RegisterCallback_1
   \                     ??HAL_DMA_RegisterCallback_0: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xF883 0x0034      STRB     R0,[R3, #+52]
    975          
    976            if(HAL_DMA_STATE_READY == hdma->State)
   \       0x18   0xF893 0x0035      LDRB     R0,[R3, #+53]
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xD119             BNE.N    ??HAL_DMA_RegisterCallback_2
    977            {
    978              switch (CallbackID)
   \       0x20   0x0008             MOVS     R0,R1
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD008             BEQ.N    ??HAL_DMA_RegisterCallback_3
   \       0x28   0x2802             CMP      R0,#+2
   \       0x2A   0xD00A             BEQ.N    ??HAL_DMA_RegisterCallback_4
   \       0x2C   0xD307             BCC.N    ??HAL_DMA_RegisterCallback_5
   \       0x2E   0x2804             CMP      R0,#+4
   \       0x30   0xD00B             BEQ.N    ??HAL_DMA_RegisterCallback_6
   \       0x32   0xD308             BCC.N    ??HAL_DMA_RegisterCallback_7
   \       0x34   0x2805             CMP      R0,#+5
   \       0x36   0xD00A             BEQ.N    ??HAL_DMA_RegisterCallback_8
   \       0x38   0xE00B             B.N      ??HAL_DMA_RegisterCallback_9
    979              {
    980              case  HAL_DMA_XFER_CPLT_CB_ID:
    981                hdma->XferCpltCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_3: (+1)
   \       0x3A   0x63DA             STR      R2,[R3, #+60]
    982                break;
   \       0x3C   0xE00C             B.N      ??HAL_DMA_RegisterCallback_10
    983          
    984              case  HAL_DMA_XFER_HALFCPLT_CB_ID:
    985                hdma->XferHalfCpltCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_5: (+1)
   \       0x3E   0x641A             STR      R2,[R3, #+64]
    986                break;
   \       0x40   0xE00A             B.N      ??HAL_DMA_RegisterCallback_10
    987          
    988              case  HAL_DMA_XFER_M1CPLT_CB_ID:
    989                hdma->XferM1CpltCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_4: (+1)
   \       0x42   0x645A             STR      R2,[R3, #+68]
    990                break;
   \       0x44   0xE008             B.N      ??HAL_DMA_RegisterCallback_10
    991          
    992              case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
    993                hdma->XferM1HalfCpltCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_7: (+1)
   \       0x46   0x649A             STR      R2,[R3, #+72]
    994                break;
   \       0x48   0xE006             B.N      ??HAL_DMA_RegisterCallback_10
    995          
    996              case  HAL_DMA_XFER_ERROR_CB_ID:
    997                hdma->XferErrorCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_6: (+1)
   \       0x4A   0x64DA             STR      R2,[R3, #+76]
    998                break;
   \       0x4C   0xE004             B.N      ??HAL_DMA_RegisterCallback_10
    999          
   1000              case  HAL_DMA_XFER_ABORT_CB_ID:
   1001                hdma->XferAbortCallback = pCallback;
   \                     ??HAL_DMA_RegisterCallback_8: (+1)
   \       0x4E   0x651A             STR      R2,[R3, #+80]
   1002                break;
   \       0x50   0xE002             B.N      ??HAL_DMA_RegisterCallback_10
   1003          
   1004              default:
   1005                break;
   \                     ??HAL_DMA_RegisterCallback_9: (+1)
   \       0x52   0xE001             B.N      ??HAL_DMA_RegisterCallback_10
   1006              }
   1007            }
   1008            else
   1009            {
   1010              /* Return error status */
   1011              status =  HAL_ERROR;
   \                     ??HAL_DMA_RegisterCallback_2: (+1)
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0x0004             MOVS     R4,R0
   1012            }
   1013          
   1014            /* Release Lock */
   1015            __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_RegisterCallback_10: (+1)
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xF883 0x0034      STRB     R0,[R3, #+52]
   1016            
   1017            return status;
   \       0x5E   0x0020             MOVS     R0,R4
   \       0x60   0xB2C0             UXTB     R0,R0
   \                     ??HAL_DMA_RegisterCallback_1: (+1)
   \       0x62   0xBC10             POP      {R4}
   \       0x64   0x4770             BX       LR
   1018          }
   1019          
   1020          /**
   1021            * @brief  UnRegister callbacks
   1022            * @param  hdma                 pointer to a DMA_HandleTypeDef structure that contains
   1023            *                               the configuration information for the specified DMA Stream.
   1024            * @param  CallbackID           User Callback identifer
   1025            *                               a HAL_DMA_CallbackIDTypeDef ENUM as parameter.
   1026            * @retval HAL status
   1027            */              

   \                                 In section .text, align 2, keep-with-next
   1028          HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
   1029          {
   \                     HAL_DMA_UnRegisterCallback: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   1030            HAL_StatusTypeDef status = HAL_OK;
   \        0x2   0x2300             MOVS     R3,#+0
   1031            
   1032            /* Process locked */
   1033            __HAL_LOCK(hdma);
   \        0x4   0xF892 0x0034      LDRB     R0,[R2, #+52]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE.N    ??HAL_DMA_UnRegisterCallback_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE03D             B.N      ??HAL_DMA_UnRegisterCallback_1
   \                     ??HAL_DMA_UnRegisterCallback_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xF882 0x0034      STRB     R0,[R2, #+52]
   1034            
   1035            if(HAL_DMA_STATE_READY == hdma->State)
   \       0x16   0xF892 0x0035      LDRB     R0,[R2, #+53]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD12F             BNE.N    ??HAL_DMA_UnRegisterCallback_2
   1036            {
   1037              switch (CallbackID)
   \       0x1E   0x0008             MOVS     R0,R1
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD009             BEQ.N    ??HAL_DMA_UnRegisterCallback_3
   \       0x26   0x2802             CMP      R0,#+2
   \       0x28   0xD00D             BEQ.N    ??HAL_DMA_UnRegisterCallback_4
   \       0x2A   0xD309             BCC.N    ??HAL_DMA_UnRegisterCallback_5
   \       0x2C   0x2804             CMP      R0,#+4
   \       0x2E   0xD010             BEQ.N    ??HAL_DMA_UnRegisterCallback_6
   \       0x30   0xD30C             BCC.N    ??HAL_DMA_UnRegisterCallback_7
   \       0x32   0x2806             CMP      R0,#+6
   \       0x34   0xD013             BEQ.N    ??HAL_DMA_UnRegisterCallback_8
   \       0x36   0xD30F             BCC.N    ??HAL_DMA_UnRegisterCallback_9
   \       0x38   0xE01E             B.N      ??HAL_DMA_UnRegisterCallback_10
   1038              {
   1039              case  HAL_DMA_XFER_CPLT_CB_ID:
   1040                hdma->XferCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_3: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x63D0             STR      R0,[R2, #+60]
   1041                break;
   \       0x3E   0xE020             B.N      ??HAL_DMA_UnRegisterCallback_11
   1042                
   1043              case  HAL_DMA_XFER_HALFCPLT_CB_ID:
   1044                hdma->XferHalfCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_5: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x6410             STR      R0,[R2, #+64]
   1045                break;
   \       0x44   0xE01D             B.N      ??HAL_DMA_UnRegisterCallback_11
   1046                
   1047              case  HAL_DMA_XFER_M1CPLT_CB_ID:
   1048                hdma->XferM1CpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_4: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x6450             STR      R0,[R2, #+68]
   1049                break;
   \       0x4A   0xE01A             B.N      ??HAL_DMA_UnRegisterCallback_11
   1050                
   1051              case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
   1052                hdma->XferM1HalfCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_7: (+1)
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x6490             STR      R0,[R2, #+72]
   1053                break;
   \       0x50   0xE017             B.N      ??HAL_DMA_UnRegisterCallback_11
   1054                
   1055              case  HAL_DMA_XFER_ERROR_CB_ID:
   1056                hdma->XferErrorCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_6: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x64D0             STR      R0,[R2, #+76]
   1057                break;
   \       0x56   0xE014             B.N      ??HAL_DMA_UnRegisterCallback_11
   1058                
   1059              case  HAL_DMA_XFER_ABORT_CB_ID:
   1060                hdma->XferAbortCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_9: (+1)
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x6510             STR      R0,[R2, #+80]
   1061                break; 
   \       0x5C   0xE011             B.N      ??HAL_DMA_UnRegisterCallback_11
   1062                
   1063              case   HAL_DMA_XFER_ALL_CB_ID:
   1064                hdma->XferCpltCallback = NULL;
   \                     ??HAL_DMA_UnRegisterCallback_8: (+1)
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x63D0             STR      R0,[R2, #+60]
   1065                hdma->XferHalfCpltCallback = NULL;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x6410             STR      R0,[R2, #+64]
   1066                hdma->XferM1CpltCallback = NULL;
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x6450             STR      R0,[R2, #+68]
   1067                hdma->XferM1HalfCpltCallback = NULL;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x6490             STR      R0,[R2, #+72]
   1068                hdma->XferErrorCallback = NULL;
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0x64D0             STR      R0,[R2, #+76]
   1069                hdma->XferAbortCallback = NULL;
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0x6510             STR      R0,[R2, #+80]
   1070                break; 
   \       0x76   0xE004             B.N      ??HAL_DMA_UnRegisterCallback_11
   1071                
   1072              default:
   1073                status = HAL_ERROR;
   \                     ??HAL_DMA_UnRegisterCallback_10: (+1)
   \       0x78   0x2001             MOVS     R0,#+1
   \       0x7A   0x0003             MOVS     R3,R0
   1074                break;
   \       0x7C   0xE001             B.N      ??HAL_DMA_UnRegisterCallback_11
   1075              }
   1076            }
   1077            else
   1078            {
   1079              status = HAL_ERROR;
   \                     ??HAL_DMA_UnRegisterCallback_2: (+1)
   \       0x7E   0x2001             MOVS     R0,#+1
   \       0x80   0x0003             MOVS     R3,R0
   1080            }
   1081            
   1082            /* Release Lock */
   1083            __HAL_UNLOCK(hdma);
   \                     ??HAL_DMA_UnRegisterCallback_11: (+1)
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0xF882 0x0034      STRB     R0,[R2, #+52]
   1084            
   1085            return status;
   \       0x88   0x0018             MOVS     R0,R3
   \       0x8A   0xB2C0             UXTB     R0,R0
   \                     ??HAL_DMA_UnRegisterCallback_1: (+1)
   \       0x8C   0x4770             BX       LR
   1086          }
   1087          
   1088          /**
   1089            * @}
   1090            */
   1091          
   1092          /** @addtogroup DMA_Exported_Functions_Group3
   1093            *
   1094          @verbatim
   1095           ===============================================================================
   1096                              ##### State and Errors functions #####
   1097           ===============================================================================
   1098              [..]
   1099              This subsection provides functions allowing to
   1100                (+) Check the DMA state
   1101                (+) Get error code
   1102          
   1103          @endverbatim
   1104            * @{
   1105            */
   1106          
   1107          /**
   1108            * @brief  Returns the DMA state.
   1109            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   1110            *               the configuration information for the specified DMA Stream.
   1111            * @retval HAL state
   1112            */

   \                                 In section .text, align 2, keep-with-next
   1113          HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
   1114          {
   1115            return hdma->State;
   \                     HAL_DMA_GetState: (+1)
   \        0x0   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \        0x4   0x4770             BX       LR
   1116          }
   1117          
   1118          /**
   1119            * @brief  Return the DMA error code
   1120            * @param  hdma  pointer to a DMA_HandleTypeDef structure that contains
   1121            *              the configuration information for the specified DMA Stream.
   1122            * @retval DMA Error Code
   1123            */

   \                                 In section .text, align 2, keep-with-next
   1124          uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
   1125          {
   1126            return hdma->ErrorCode;
   \                     HAL_DMA_GetError: (+1)
   \        0x0   0x6D40             LDR      R0,[R0, #+84]
   \        0x2   0x4770             BX       LR
   1127          }
   1128          
   1129          /**
   1130            * @}
   1131            */
   1132          
   1133          /**
   1134            * @}
   1135            */
   1136          
   1137          /** @addtogroup DMA_Private_Functions
   1138            * @{
   1139            */
   1140          
   1141          /**
   1142            * @brief  Sets the DMA Transfer parameter.
   1143            * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
   1144            *                     the configuration information for the specified DMA Stream.
   1145            * @param  SrcAddress The source memory Buffer address
   1146            * @param  DstAddress The destination memory Buffer address
   1147            * @param  DataLength The length of data to be transferred from source to destination
   1148            * @retval HAL status
   1149            */

   \                                 In section .text, align 2, keep-with-next
   1150          static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
   1151          {
   \                     DMA_SetConfig: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   1152            /* Clear DBM bit */
   1153            hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
   \        0x2   0x6804             LDR      R4,[R0, #+0]
   \        0x4   0x6824             LDR      R4,[R4, #+0]
   \        0x6   0xF434 0x2480      BICS     R4,R4,#0x40000
   \        0xA   0x6805             LDR      R5,[R0, #+0]
   \        0xC   0x602C             STR      R4,[R5, #+0]
   1154          
   1155            /* Configure DMA Stream data length */
   1156            hdma->Instance->NDTR = DataLength;
   \        0xE   0x6804             LDR      R4,[R0, #+0]
   \       0x10   0x6063             STR      R3,[R4, #+4]
   1157          
   1158            /* Memory to Peripheral */
   1159            if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
   \       0x12   0x6884             LDR      R4,[R0, #+8]
   \       0x14   0x2C40             CMP      R4,#+64
   \       0x16   0xD104             BNE.N    ??DMA_SetConfig_0
   1160            {
   1161              /* Configure DMA Stream destination address */
   1162              hdma->Instance->PAR = DstAddress;
   \       0x18   0x6804             LDR      R4,[R0, #+0]
   \       0x1A   0x60A2             STR      R2,[R4, #+8]
   1163          
   1164              /* Configure DMA Stream source address */
   1165              hdma->Instance->M0AR = SrcAddress;
   \       0x1C   0x6804             LDR      R4,[R0, #+0]
   \       0x1E   0x60E1             STR      R1,[R4, #+12]
   \       0x20   0xE003             B.N      ??DMA_SetConfig_1
   1166            }
   1167            /* Peripheral to Memory */
   1168            else
   1169            {
   1170              /* Configure DMA Stream source address */
   1171              hdma->Instance->PAR = SrcAddress;
   \                     ??DMA_SetConfig_0: (+1)
   \       0x22   0x6804             LDR      R4,[R0, #+0]
   \       0x24   0x60A1             STR      R1,[R4, #+8]
   1172          
   1173              /* Configure DMA Stream destination address */
   1174              hdma->Instance->M0AR = DstAddress;
   \       0x26   0x6804             LDR      R4,[R0, #+0]
   \       0x28   0x60E2             STR      R2,[R4, #+12]
   1175            }
   1176          }
   \                     ??DMA_SetConfig_1: (+1)
   \       0x2A   0xBC30             POP      {R4,R5}
   \       0x2C   0x4770             BX       LR
   1177          
   1178          /**
   1179            * @brief  Returns the DMA Stream base address depending on stream number
   1180            * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
   1181            *                     the configuration information for the specified DMA Stream. 
   1182            * @retval Stream base address
   1183            */

   \                                 In section .text, align 2, keep-with-next
   1184          static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
   1185          {
   1186            uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
   \                     DMA_CalcBaseAndBitshift: (+1)
   \        0x0   0x7801             LDRB     R1,[R0, #+0]
   \        0x2   0xF001 0x01FF      AND      R1,R1,#0xFF
   \        0x6   0x3910             SUBS     R1,R1,#+16
   \        0x8   0x2218             MOVS     R2,#+24
   \        0xA   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   1187            
   1188            /* lookup table for necessary bitshift of flags within status registers */
   1189            static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
   1190            hdma->StreamIndex = flagBitshiftOffset[stream_number];
   \        0xE   0x....             LDR.N    R2,??DataTable2_2
   \       0x10   0x5C52             LDRB     R2,[R2, R1]
   \       0x12   0x65C2             STR      R2,[R0, #+92]
   1191            
   1192            if (stream_number > 3U)
   \       0x14   0x2904             CMP      R1,#+4
   \       0x16   0xD305             BCC.N    ??DMA_CalcBaseAndBitshift_0
   1193            {
   1194              /* return pointer to HISR and HIFCR */
   1195              hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
   \       0x18   0x6802             LDR      R2,[R0, #+0]
   \       0x1A   0x0A92             LSRS     R2,R2,#+10
   \       0x1C   0x0292             LSLS     R2,R2,#+10
   \       0x1E   0x1D12             ADDS     R2,R2,#+4
   \       0x20   0x6582             STR      R2,[R0, #+88]
   \       0x22   0xE003             B.N      ??DMA_CalcBaseAndBitshift_1
   1196            }
   1197            else
   1198            {
   1199              /* return pointer to LISR and LIFCR */
   1200              hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
   \                     ??DMA_CalcBaseAndBitshift_0: (+1)
   \       0x24   0x6802             LDR      R2,[R0, #+0]
   \       0x26   0x0A92             LSRS     R2,R2,#+10
   \       0x28   0x0292             LSLS     R2,R2,#+10
   \       0x2A   0x6582             STR      R2,[R0, #+88]
   1201            }
   1202            
   1203            return hdma->StreamBaseAddress;
   \                     ??DMA_CalcBaseAndBitshift_1: (+1)
   \       0x2C   0x6D80             LDR      R0,[R0, #+88]
   \       0x2E   0x4770             BX       LR
   1204          }

   \                                 In section .rodata, align 4
   \                     `DMA_CalcBaseAndBitshift::flagBitshiftOffset`:
   \        0x0   0x00 0x06          DC8 0, 6, 16, 22, 0, 6, 16, 22

   \              0x10 0x16    

   \              0x00 0x06    

   \              0x10 0x16
   1205          
   1206          /**
   1207            * @brief  Check compatibility between FIFO threshold level and size of the memory burst
   1208            * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
   1209            *                     the configuration information for the specified DMA Stream. 
   1210            * @retval HAL status
   1211            */

   \                                 In section .text, align 2, keep-with-next
   1212          static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
   1213          {
   \                     DMA_CheckFifoParam: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0002             MOVS     R2,R0
   1214            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2000             MOVS     R0,#+0
   1215            uint32_t tmp = hdma->Init.FIFOThreshold;
   \        0x6   0x6A93             LDR      R3,[R2, #+40]
   1216            
   1217            /* Memory Data size equal to Byte */
   1218            if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
   \        0x8   0x6991             LDR      R1,[R2, #+24]
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD116             BNE.N    ??DMA_CheckFifoParam_0
   1219            {
   1220              switch (tmp)
   \        0xE   0x2B00             CMP      R3,#+0
   \       0x10   0xD005             BEQ.N    ??DMA_CheckFifoParam_1
   \       0x12   0x2B02             CMP      R3,#+2
   \       0x14   0xD003             BEQ.N    ??DMA_CheckFifoParam_1
   \       0x16   0xD308             BCC.N    ??DMA_CheckFifoParam_2
   \       0x18   0x2B03             CMP      R3,#+3
   \       0x1A   0xD00D             BEQ.N    ??DMA_CheckFifoParam_3
   \       0x1C   0xE00D             B.N      ??DMA_CheckFifoParam_4
   1221              {
   1222              case DMA_FIFO_THRESHOLD_1QUARTERFULL:
   1223              case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
   1224                if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
   \                     ??DMA_CheckFifoParam_1: (+1)
   \       0x1E   0x6AD1             LDR      R1,[R2, #+44]
   \       0x20   0x01C9             LSLS     R1,R1,#+7
   \       0x22   0xD501             BPL.N    ??DMA_CheckFifoParam_5
   1225                {
   1226                  status = HAL_ERROR;
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0x0008             MOVS     R0,R1
   1227                }
   1228                break;
   \                     ??DMA_CheckFifoParam_5: (+1)
   \       0x28   0xE035             B.N      ??DMA_CheckFifoParam_6
   1229              case DMA_FIFO_THRESHOLD_HALFFULL:
   1230                if (hdma->Init.MemBurst == DMA_MBURST_INC16)
   \                     ??DMA_CheckFifoParam_2: (+1)
   \       0x2A   0x6AD1             LDR      R1,[R2, #+44]
   \       0x2C   0xF1B1 0x7FC0      CMP      R1,#+25165824
   \       0x30   0xD101             BNE.N    ??DMA_CheckFifoParam_7
   1231                {
   1232                  status = HAL_ERROR;
   \       0x32   0x2101             MOVS     R1,#+1
   \       0x34   0x0008             MOVS     R0,R1
   1233                }
   1234                break;
   \                     ??DMA_CheckFifoParam_7: (+1)
   \       0x36   0xE02E             B.N      ??DMA_CheckFifoParam_6
   1235              case DMA_FIFO_THRESHOLD_FULL:
   1236                break;
   \                     ??DMA_CheckFifoParam_3: (+1)
   \       0x38   0xE02D             B.N      ??DMA_CheckFifoParam_6
   1237              default:
   1238                break;
   \                     ??DMA_CheckFifoParam_4: (+1)
   \       0x3A   0xE02C             B.N      ??DMA_CheckFifoParam_6
   1239              }
   1240            }
   1241            
   1242            /* Memory Data size equal to Half-Word */
   1243            else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
   \                     ??DMA_CheckFifoParam_0: (+1)
   \       0x3C   0x6991             LDR      R1,[R2, #+24]
   \       0x3E   0xF5B1 0x5F00      CMP      R1,#+8192
   \       0x42   0xD118             BNE.N    ??DMA_CheckFifoParam_8
   1244            {
   1245              switch (tmp)
   \       0x44   0x2B00             CMP      R3,#+0
   \       0x46   0xD005             BEQ.N    ??DMA_CheckFifoParam_9
   \       0x48   0x2B02             CMP      R3,#+2
   \       0x4A   0xD003             BEQ.N    ??DMA_CheckFifoParam_9
   \       0x4C   0xD305             BCC.N    ??DMA_CheckFifoParam_10
   \       0x4E   0x2B03             CMP      R3,#+3
   \       0x50   0xD009             BEQ.N    ??DMA_CheckFifoParam_11
   \       0x52   0xE00F             B.N      ??DMA_CheckFifoParam_12
   1246              {
   1247              case DMA_FIFO_THRESHOLD_1QUARTERFULL:
   1248              case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
   1249                status = HAL_ERROR;
   \                     ??DMA_CheckFifoParam_9: (+1)
   \       0x54   0x2101             MOVS     R1,#+1
   \       0x56   0x0008             MOVS     R0,R1
   1250                break;
   \       0x58   0xE01D             B.N      ??DMA_CheckFifoParam_6
   1251              case DMA_FIFO_THRESHOLD_HALFFULL:
   1252                if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
   \                     ??DMA_CheckFifoParam_10: (+1)
   \       0x5A   0x6AD1             LDR      R1,[R2, #+44]
   \       0x5C   0x01C9             LSLS     R1,R1,#+7
   \       0x5E   0xD501             BPL.N    ??DMA_CheckFifoParam_13
   1253                {
   1254                  status = HAL_ERROR;
   \       0x60   0x2101             MOVS     R1,#+1
   \       0x62   0x0008             MOVS     R0,R1
   1255                }
   1256                break;
   \                     ??DMA_CheckFifoParam_13: (+1)
   \       0x64   0xE017             B.N      ??DMA_CheckFifoParam_6
   1257              case DMA_FIFO_THRESHOLD_FULL:
   1258                if (hdma->Init.MemBurst == DMA_MBURST_INC16)
   \                     ??DMA_CheckFifoParam_11: (+1)
   \       0x66   0x6AD1             LDR      R1,[R2, #+44]
   \       0x68   0xF1B1 0x7FC0      CMP      R1,#+25165824
   \       0x6C   0xD101             BNE.N    ??DMA_CheckFifoParam_14
   1259                {
   1260                  status = HAL_ERROR;
   \       0x6E   0x2101             MOVS     R1,#+1
   \       0x70   0x0008             MOVS     R0,R1
   1261                }
   1262                break;   
   \                     ??DMA_CheckFifoParam_14: (+1)
   \       0x72   0xE010             B.N      ??DMA_CheckFifoParam_6
   1263              default:
   1264                break;
   \                     ??DMA_CheckFifoParam_12: (+1)
   \       0x74   0xE00F             B.N      ??DMA_CheckFifoParam_6
   1265              }
   1266            }
   1267            
   1268            /* Memory Data size equal to Word */
   1269            else
   1270            {
   1271              switch (tmp)
   \                     ??DMA_CheckFifoParam_8: (+1)
   \       0x76   0x0019             MOVS     R1,R3
   \       0x78   0x2900             CMP      R1,#+0
   \       0x7A   0x2902             CMP      R1,#+2
   \       0x7C   0xD902             BLS.N    ??DMA_CheckFifoParam_15
   \       0x7E   0x1EC9             SUBS     R1,R1,#+3
   \       0x80   0xD003             BEQ.N    ??DMA_CheckFifoParam_16
   \       0x82   0xE008             B.N      ??DMA_CheckFifoParam_17
   1272              {
   1273              case DMA_FIFO_THRESHOLD_1QUARTERFULL:
   1274              case DMA_FIFO_THRESHOLD_HALFFULL:
   1275              case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
   1276                status = HAL_ERROR;
   \                     ??DMA_CheckFifoParam_15: (+1)
   \       0x84   0x2101             MOVS     R1,#+1
   \       0x86   0x0008             MOVS     R0,R1
   1277                break;
   \       0x88   0xE005             B.N      ??DMA_CheckFifoParam_6
   1278              case DMA_FIFO_THRESHOLD_FULL:
   1279                if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
   \                     ??DMA_CheckFifoParam_16: (+1)
   \       0x8A   0x6AD1             LDR      R1,[R2, #+44]
   \       0x8C   0x01C9             LSLS     R1,R1,#+7
   \       0x8E   0xD501             BPL.N    ??DMA_CheckFifoParam_18
   1280                {
   1281                  status = HAL_ERROR;
   \       0x90   0x2101             MOVS     R1,#+1
   \       0x92   0x0008             MOVS     R0,R1
   1282                }
   1283                break;
   \                     ??DMA_CheckFifoParam_18: (+1)
   \       0x94   0xE7FF             B.N      ??DMA_CheckFifoParam_6
   1284              default:
   1285                break;
   1286              }
   1287            } 
   1288            
   1289            return status; 
   \                     ??DMA_CheckFifoParam_17: (+1)
   \                     ??DMA_CheckFifoParam_6: (+1)
   \       0x96   0xB2C0             UXTB     R0,R0
   \       0x98   0xBC10             POP      {R4}
   \       0x9A   0x4770             BX       LR
   1290          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0xF010'803F        DC32     0xf010803f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x....'....        DC32     `DMA_CalcBaseAndBitshift::flagBitshiftOffset`
   1291          
   1292          /**
   1293            * @}
   1294            */
   1295          
   1296          #endif /* HAL_DMA_MODULE_ENABLED */
   1297          /**
   1298            * @}
   1299            */
   1300          
   1301          /**
   1302            * @}
   1303            */
   1304          
   1305          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DMA_CalcBaseAndBitshift
       4   DMA_CheckFifoParam
       8   DMA_SetConfig
      16   HAL_DMA_Abort
        16   -> HAL_GetTick
       0   HAL_DMA_Abort_IT
       8   HAL_DMA_DeInit
         8   -> DMA_CalcBaseAndBitshift
       0   HAL_DMA_GetError
       0   HAL_DMA_GetState
      24   HAL_DMA_IRQHandler
        24   -- Indirect call
      16   HAL_DMA_Init
        16   -> DMA_CalcBaseAndBitshift
        16   -> DMA_CheckFifoParam
        16   -> HAL_GetTick
      40   HAL_DMA_PollForTransfer
        40   -> HAL_DMA_Abort
        40   -> HAL_GetTick
       4   HAL_DMA_RegisterCallback
      24   HAL_DMA_Start
        24   -> DMA_SetConfig
      32   HAL_DMA_Start_IT
        32   -> DMA_SetConfig
       0   HAL_DMA_UnRegisterCallback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
      48  DMA_CalcBaseAndBitshift
     156  DMA_CheckFifoParam
      46  DMA_SetConfig
     156  HAL_DMA_Abort
      40  HAL_DMA_Abort_IT
     132  HAL_DMA_DeInit
       4  HAL_DMA_GetError
       6  HAL_DMA_GetState
     520  HAL_DMA_IRQHandler
     226  HAL_DMA_Init
     340  HAL_DMA_PollForTransfer
     102  HAL_DMA_RegisterCallback
      96  HAL_DMA_Start
     140  HAL_DMA_Start_IT
     142  HAL_DMA_UnRegisterCallback
       8  flagBitshiftOffset

 
     8 bytes in section .rodata
 2'166 bytes in section .text
 
 2'166 bytes of CODE  memory
     8 bytes of CONST memory

Errors: none
Warnings: none
