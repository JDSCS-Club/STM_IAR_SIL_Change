###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         27/Sep/2022  19:40:25
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_i2s.c
#    Command line      =
#        -f
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_i2s.o.rsp
#        (C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_i2s.c
#        -D USE_HAL_DRIVER -D STM32F407xx -lC
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver
#        -o
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/App\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Core/Inc\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Include\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/display\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Library\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_i2s.o.d
#    Locale            =  C
#    List file         =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_i2s.lst
#    Object file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_i2s.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_i2s.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_i2s.c
      4            * @author  MCD Application Team
      5            * @brief   I2S HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Integrated Interchip Sound (I2S) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *           + Peripheral State and Errors functions
     11            @verbatim
     12           ===============================================================================
     13                            ##### How to use this driver #####
     14           ===============================================================================
     15           [..]
     16              The I2S HAL driver can be used as follow:
     17          
     18              (#) Declare a I2S_HandleTypeDef handle structure.
     19              (#) Initialize the I2S low level resources by implement the HAL_I2S_MspInit() API:
     20                  (##) Enable the SPIx interface clock.
     21                  (##) I2S pins configuration:
     22                      (+++) Enable the clock for the I2S GPIOs.
     23                      (+++) Configure these I2S pins as alternate function pull-up.
     24                  (##) NVIC configuration if you need to use interrupt process (HAL_I2S_Transmit_IT()
     25                       and HAL_I2S_Receive_IT() APIs).
     26                      (+++) Configure the I2Sx interrupt priority.
     27                      (+++) Enable the NVIC I2S IRQ handle.
     28                  (##) DMA Configuration if you need to use DMA process (HAL_I2S_Transmit_DMA()
     29                       and HAL_I2S_Receive_DMA() APIs:
     30                      (+++) Declare a DMA handle structure for the Tx/Rx Stream/Channel.
     31                      (+++) Enable the DMAx interface clock.
     32                      (+++) Configure the declared DMA handle structure with the required Tx/Rx parameters.
     33                      (+++) Configure the DMA Tx/Rx Stream/Channel.
     34                      (+++) Associate the initialized DMA handle to the I2S DMA Tx/Rx handle.
     35                      (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the
     36                            DMA Tx/Rx Stream/Channel.
     37          
     38             (#) Program the Mode, Standard, Data Format, MCLK Output, Audio frequency and Polarity
     39                 using HAL_I2S_Init() function.
     40          
     41             -@- The specific I2S interrupts (Transmission complete interrupt,
     42                 RXNE interrupt and Error Interrupts) will be managed using the macros
     43                 __HAL_I2S_ENABLE_IT() and __HAL_I2S_DISABLE_IT() inside the transmit and receive process.
     44             -@- Make sure that either:
     45                  (+@) I2S PLL clock is configured or
     46                  (+@) External clock source is configured after setting correctly
     47                       the define constant EXTERNAL_CLOCK_VALUE in the stm32f4xx_hal_conf.h file.
     48          
     49              (#) Three mode of operations are available within this driver :
     50          
     51             *** Polling mode IO operation ***
     52             =================================
     53             [..]
     54               (+) Send an amount of data in blocking mode using HAL_I2S_Transmit()
     55               (+) Receive an amount of data in blocking mode using HAL_I2S_Receive()
     56          
     57             *** Interrupt mode IO operation ***
     58             ===================================
     59             [..]
     60               (+) Send an amount of data in non blocking mode using HAL_I2S_Transmit_IT()
     61               (+) At transmission end of half transfer HAL_I2S_TxHalfCpltCallback is executed and user can
     62                   add his own code by customization of function pointer HAL_I2S_TxHalfCpltCallback
     63               (+) At transmission end of transfer HAL_I2S_TxCpltCallback is executed and user can
     64                   add his own code by customization of function pointer HAL_I2S_TxCpltCallback
     65               (+) Receive an amount of data in non blocking mode using HAL_I2S_Receive_IT()
     66               (+) At reception end of half transfer HAL_I2S_RxHalfCpltCallback is executed and user can
     67                   add his own code by customization of function pointer HAL_I2S_RxHalfCpltCallback
     68               (+) At reception end of transfer HAL_I2S_RxCpltCallback is executed and user can
     69                   add his own code by customization of function pointer HAL_I2S_RxCpltCallback
     70               (+) In case of transfer Error, HAL_I2S_ErrorCallback() function is executed and user can
     71                   add his own code by customization of function pointer HAL_I2S_ErrorCallback
     72          
     73             *** DMA mode IO operation ***
     74             ==============================
     75             [..]
     76               (+) Send an amount of data in non blocking mode (DMA) using HAL_I2S_Transmit_DMA()
     77               (+) At transmission end of half transfer HAL_I2S_TxHalfCpltCallback is executed and user can
     78                   add his own code by customization of function pointer HAL_I2S_TxHalfCpltCallback
     79               (+) At transmission end of transfer HAL_I2S_TxCpltCallback is executed and user can
     80                   add his own code by customization of function pointer HAL_I2S_TxCpltCallback
     81               (+) Receive an amount of data in non blocking mode (DMA) using HAL_I2S_Receive_DMA()
     82               (+) At reception end of half transfer HAL_I2S_RxHalfCpltCallback is executed and user can
     83                   add his own code by customization of function pointer HAL_I2S_RxHalfCpltCallback
     84               (+) At reception end of transfer HAL_I2S_RxCpltCallback is executed and user can
     85                   add his own code by customization of function pointer HAL_I2S_RxCpltCallback
     86               (+) In case of transfer Error, HAL_I2S_ErrorCallback() function is executed and user can
     87                   add his own code by customization of function pointer HAL_I2S_ErrorCallback
     88               (+) Pause the DMA Transfer using HAL_I2S_DMAPause()
     89               (+) Resume the DMA Transfer using HAL_I2S_DMAResume()
     90               (+) Stop the DMA Transfer using HAL_I2S_DMAStop()
     91                   In Slave mode, if HAL_I2S_DMAStop is used to stop the communication, an error
     92                   HAL_I2S_ERROR_BUSY_LINE_RX is raised as the master continue to transmit data.
     93                   In this case __HAL_I2S_FLUSH_RX_DR macro must be used to flush the remaining data 
     94                   inside DR register and avoid using DeInit/Init process for the next transfer.
     95          
     96             *** I2S HAL driver macros list ***
     97             ===================================
     98             [..]
     99               Below the list of most used macros in I2S HAL driver.
    100          
    101                (+) __HAL_I2S_ENABLE: Enable the specified SPI peripheral (in I2S mode)
    102                (+) __HAL_I2S_DISABLE: Disable the specified SPI peripheral (in I2S mode)
    103                (+) __HAL_I2S_ENABLE_IT : Enable the specified I2S interrupts
    104                (+) __HAL_I2S_DISABLE_IT : Disable the specified I2S interrupts
    105                (+) __HAL_I2S_GET_FLAG: Check whether the specified I2S flag is set or not
    106          
    107                (+) __HAL_I2S_FLUSH_RX_DR: Read DR Register to Flush RX Data
    108              [..]
    109                (@) You can refer to the I2S HAL driver header file for more useful macros
    110          
    111             *** I2S HAL driver macros list ***
    112             ===================================
    113             [..]
    114                 Callback registration:
    115          
    116                (#) The compilation flag USE_HAL_I2S_REGISTER_CALLBACKS when set to 1U
    117                    allows the user to configure dynamically the driver callbacks.
    118                    Use Functions HAL_I2S_RegisterCallback() to register an interrupt callback.
    119          
    120                    Function HAL_I2S_RegisterCallback() allows to register following callbacks:
    121                      (++) TxCpltCallback        : I2S Tx Completed callback
    122                      (++) RxCpltCallback        : I2S Rx Completed callback
    123                      (++) TxRxCpltCallback      : I2S TxRx Completed callback
    124                      (++) TxHalfCpltCallback    : I2S Tx Half Completed callback
    125                      (++) RxHalfCpltCallback    : I2S Rx Half Completed callback
    126                      (++) ErrorCallback         : I2S Error callback
    127                      (++) MspInitCallback       : I2S Msp Init callback
    128                      (++) MspDeInitCallback     : I2S Msp DeInit callback
    129                    This function takes as parameters the HAL peripheral handle, the Callback ID
    130                    and a pointer to the user callback function.
    131          
    132          
    133                (#) Use function HAL_I2S_UnRegisterCallback to reset a callback to the default
    134                    weak function.
    135                    HAL_I2S_UnRegisterCallback takes as parameters the HAL peripheral handle,
    136                    and the Callback ID.
    137                    This function allows to reset following callbacks:
    138                      (++) TxCpltCallback        : I2S Tx Completed callback
    139                      (++) RxCpltCallback        : I2S Rx Completed callback
    140                      (++) TxRxCpltCallback      : I2S TxRx Completed callback
    141                      (++) TxHalfCpltCallback    : I2S Tx Half Completed callback
    142                      (++) RxHalfCpltCallback    : I2S Rx Half Completed callback
    143                      (++) ErrorCallback         : I2S Error callback
    144                      (++) MspInitCallback       : I2S Msp Init callback
    145                      (++) MspDeInitCallback     : I2S Msp DeInit callback
    146          
    147                 [..]
    148                 By default, after the HAL_I2S_Init() and when the state is HAL_I2S_STATE_RESET
    149                 all callbacks are set to the corresponding weak functions:
    150                 examples HAL_I2S_MasterTxCpltCallback(), HAL_I2S_MasterRxCpltCallback().
    151                 Exception done for MspInit and MspDeInit functions that are
    152                 reset to the legacy weak functions in the HAL_I2S_Init()/ HAL_I2S_DeInit() only when
    153                 these callbacks are null (not registered beforehand).
    154                 If MspInit or MspDeInit are not null, the HAL_I2S_Init()/ HAL_I2S_DeInit()
    155                 keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
    156          
    157                 [..]
    158                 Callbacks can be registered/unregistered in HAL_I2S_STATE_READY state only.
    159                 Exception done MspInit/MspDeInit functions that can be registered/unregistered
    160                 in HAL_I2S_STATE_READY or HAL_I2S_STATE_RESET state,
    161                 thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    162                 Then, the user first registers the MspInit/MspDeInit user callbacks
    163                 using HAL_I2S_RegisterCallback() before calling HAL_I2S_DeInit()
    164                 or HAL_I2S_Init() function.
    165          
    166                 [..]
    167                 When the compilation define USE_HAL_I2S_REGISTER_CALLBACKS is set to 0 or
    168                 not defined, the callback registering feature is not available
    169                 and weak (surcharged) callbacks are used.
    170          
    171            @endverbatim
    172            ******************************************************************************
    173            * @attention
    174            *
    175            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
    176            * All rights reserved.</center></h2>
    177            *
    178            * This software component is licensed by ST under BSD 3-Clause license,
    179            * the "License"; You may not use this file except in compliance with the
    180            * License. You may obtain a copy of the License at:
    181            *                        opensource.org/licenses/BSD-3-Clause
    182            *
    183            ******************************************************************************
    184            */
    185          
    186          /* Includes ------------------------------------------------------------------*/
    187          #include "stm32f4xx_hal.h"
    188          
    189          #ifdef HAL_I2S_MODULE_ENABLED
    190          
    191          /** @addtogroup STM32F4xx_HAL_Driver
    192            * @{
    193            */
    194          
    195          /** @defgroup I2S I2S
    196            * @brief I2S HAL module driver
    197            * @{
    198            */
    199          
    200          /* Private typedef -----------------------------------------------------------*/
    201          /* Private define ------------------------------------------------------------*/
    202          #define I2S_TIMEOUT_FLAG          100U         /*!< Timeout 100 ms            */
    203          /* Private macro -------------------------------------------------------------*/
    204          /* Private variables ---------------------------------------------------------*/
    205          /* Private function prototypes -----------------------------------------------*/
    206          /** @defgroup I2S_Private_Functions I2S Private Functions
    207            * @{
    208            */
    209          static void               I2S_DMATxCplt(DMA_HandleTypeDef *hdma);
    210          static void               I2S_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    211          static void               I2S_DMARxCplt(DMA_HandleTypeDef *hdma);
    212          static void               I2S_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    213          static void               I2S_DMAError(DMA_HandleTypeDef *hdma);
    214          static void               I2S_Transmit_IT(I2S_HandleTypeDef *hi2s);
    215          static void               I2S_Receive_IT(I2S_HandleTypeDef *hi2s);
    216          static void               I2S_IRQHandler(I2S_HandleTypeDef *hi2s);
    217          static HAL_StatusTypeDef  I2S_WaitFlagStateUntilTimeout(I2S_HandleTypeDef *hi2s, uint32_t Flag, FlagStatus State,
    218                                                                  uint32_t Timeout);
    219          /**
    220            * @}
    221            */
    222          
    223          /* Exported functions ---------------------------------------------------------*/
    224          
    225          /** @defgroup I2S_Exported_Functions I2S Exported Functions
    226            * @{
    227            */
    228          
    229          /** @defgroup  I2S_Exported_Functions_Group1 Initialization and de-initialization functions
    230            *  @brief    Initialization and Configuration functions
    231            *
    232          @verbatim
    233           ===============================================================================
    234                        ##### Initialization and de-initialization functions #####
    235           ===============================================================================
    236              [..]  This subsection provides a set of functions allowing to initialize and
    237                    de-initialize the I2Sx peripheral in simplex mode:
    238          
    239                (+) User must Implement HAL_I2S_MspInit() function in which he configures
    240                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    241          
    242                (+) Call the function HAL_I2S_Init() to configure the selected device with
    243                    the selected configuration:
    244                  (++) Mode
    245                  (++) Standard
    246                  (++) Data Format
    247                  (++) MCLK Output
    248                  (++) Audio frequency
    249                  (++) Polarity
    250                  (++) Full duplex mode
    251          
    252               (+) Call the function HAL_I2S_DeInit() to restore the default configuration
    253                    of the selected I2Sx peripheral.
    254            @endverbatim
    255            * @{
    256            */
    257          
    258          /**
    259            * @brief  Initializes the I2S according to the specified parameters
    260            *         in the I2S_InitTypeDef and create the associated handle.
    261            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
    262            *         the configuration information for I2S module
    263            * @retval HAL status
    264            */

   \                                 In section .text, align 2, keep-with-next
    265          HAL_StatusTypeDef HAL_I2S_Init(I2S_HandleTypeDef *hi2s)
    266          {
   \                     HAL_I2S_Init: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
    267            uint32_t i2sdiv;
    268            uint32_t i2sodd;
    269            uint32_t packetlength;
    270            uint32_t tmp;
    271            uint32_t i2sclk;
    272          #if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
    273            uint16_t tmpreg;
    274          #endif
    275          
    276            /* Check the I2S handle allocation */
    277            if (hi2s == NULL)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??HAL_I2S_Init_0
    278            {
    279              return HAL_ERROR;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE0D0             B.N      ??HAL_I2S_Init_1
    280            }
    281          
    282            /* Check the I2S parameters */
    283            assert_param(IS_I2S_ALL_INSTANCE(hi2s->Instance));
    284            assert_param(IS_I2S_MODE(hi2s->Init.Mode));
    285            assert_param(IS_I2S_STANDARD(hi2s->Init.Standard));
    286            assert_param(IS_I2S_DATA_FORMAT(hi2s->Init.DataFormat));
    287            assert_param(IS_I2S_MCLK_OUTPUT(hi2s->Init.MCLKOutput));
    288            assert_param(IS_I2S_AUDIO_FREQ(hi2s->Init.AudioFreq));
    289            assert_param(IS_I2S_CPOL(hi2s->Init.CPOL));
    290            assert_param(IS_I2S_CLOCKSOURCE(hi2s->Init.ClockSource));
    291          
    292            if (hi2s->State == HAL_I2S_STATE_RESET)
   \                     ??HAL_I2S_Init_0: (+1)
   \        0xE   0xF894 0x0041      LDRB     R0,[R4, #+65]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD108             BNE.N    ??HAL_I2S_Init_2
    293            {
    294              /* Allocate lock resource and initialize it */
    295              hi2s->Lock = HAL_UNLOCKED;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0xF884 0x0040      STRB     R0,[R4, #+64]
    296          
    297              /* Initialize Default I2S IrqHandler ISR */
    298              hi2s->IrqHandlerISR = I2S_IRQHandler;
   \       0x1C   0x.... 0x....      ADR.W    R0,I2S_IRQHandler
   \       0x20   0x6360             STR      R0,[R4, #+52]
    299          
    300          #if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
    301              /* Init the I2S Callback settings */
    302              hi2s->TxCpltCallback       = HAL_I2S_TxCpltCallback;          /* Legacy weak TxCpltCallback       */
    303              hi2s->RxCpltCallback       = HAL_I2S_RxCpltCallback;          /* Legacy weak RxCpltCallback       */
    304          #if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
    305              hi2s->TxRxCpltCallback     = HAL_I2SEx_TxRxCpltCallback;      /* Legacy weak TxRxCpltCallback     */
    306          #endif
    307              hi2s->TxHalfCpltCallback   = HAL_I2S_TxHalfCpltCallback;      /* Legacy weak TxHalfCpltCallback   */
    308              hi2s->RxHalfCpltCallback   = HAL_I2S_RxHalfCpltCallback;      /* Legacy weak RxHalfCpltCallback   */
    309          #if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
    310              hi2s->TxRxHalfCpltCallback = HAL_I2SEx_TxRxHalfCpltCallback;  /* Legacy weak TxRxHalfCpltCallback */
    311          #endif
    312              hi2s->ErrorCallback        = HAL_I2S_ErrorCallback;           /* Legacy weak ErrorCallback        */
    313          
    314              if (hi2s->MspInitCallback == NULL)
    315              {
    316                hi2s->MspInitCallback = HAL_I2S_MspInit; /* Legacy weak MspInit  */
    317              }
    318          
    319              /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    320              hi2s->MspInitCallback(hi2s);
    321          #else
    322              /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    323              HAL_I2S_MspInit(hi2s);
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       HAL_I2S_MspInit
    324          #endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    325            }
    326          
    327            hi2s->State = HAL_I2S_STATE_BUSY;
   \                     ??HAL_I2S_Init_2: (+1)
   \       0x28   0x2002             MOVS     R0,#+2
   \       0x2A   0xF884 0x0041      STRB     R0,[R4, #+65]
    328          
    329            /*----------------------- SPIx I2SCFGR & I2SPR Configuration ----------------*/
    330            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    331            CLEAR_BIT(hi2s->Instance->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
    332                                                SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
    333                                                SPI_I2SCFGR_I2SE | SPI_I2SCFGR_I2SMOD));
   \       0x2E   0x.... 0x....      LDR.W    R9,??DataTable3
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x69C0             LDR      R0,[R0, #+28]
   \       0x36   0xEA19 0x0000      ANDS     R0,R9,R0
   \       0x3A   0x6821             LDR      R1,[R4, #+0]
   \       0x3C   0x61C8             STR      R0,[R1, #+28]
    334            hi2s->Instance->I2SPR = 0x0002U;
   \       0x3E   0x2002             MOVS     R0,#+2
   \       0x40   0x6821             LDR      R1,[R4, #+0]
   \       0x42   0x6208             STR      R0,[R1, #+32]
    335          
    336            /*----------------------- I2SPR: I2SDIV and ODD Calculation -----------------*/
    337            /* If the requested audio frequency is not the default, compute the prescaler */
    338            if (hi2s->Init.AudioFreq != I2S_AUDIOFREQ_DEFAULT)
   \       0x44   0x6960             LDR      R0,[R4, #+20]
   \       0x46   0x2802             CMP      R0,#+2
   \       0x48   0xD03B             BEQ.N    ??HAL_I2S_Init_3
    339            {
    340              /* Check the frame length (For the Prescaler computing) ********************/
    341              if (hi2s->Init.DataFormat == I2S_DATAFORMAT_16B)
   \       0x4A   0x68E0             LDR      R0,[R4, #+12]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD102             BNE.N    ??HAL_I2S_Init_4
    342              {
    343                /* Packet length is 16 bits */
    344                packetlength = 16U;
   \       0x50   0x2010             MOVS     R0,#+16
   \       0x52   0x0006             MOVS     R6,R0
   \       0x54   0xE001             B.N      ??HAL_I2S_Init_5
    345              }
    346              else
    347              {
    348                /* Packet length is 32 bits */
    349                packetlength = 32U;
   \                     ??HAL_I2S_Init_4: (+1)
   \       0x56   0x2020             MOVS     R0,#+32
   \       0x58   0x0006             MOVS     R6,R0
    350              }
    351          
    352              /* I2S standard */
    353              if (hi2s->Init.Standard <= I2S_STANDARD_LSB)
   \                     ??HAL_I2S_Init_5: (+1)
   \       0x5A   0x68A0             LDR      R0,[R4, #+8]
   \       0x5C   0x2821             CMP      R0,#+33
   \       0x5E   0xD200             BCS.N    ??HAL_I2S_Init_6
    354              {
    355                /* In I2S standard packet lenght is multiplied by 2 */
    356                packetlength = packetlength * 2U;
   \       0x60   0x0076             LSLS     R6,R6,#+1
    357              }
    358          
    359              /* Get the source clock value **********************************************/
    360          #if defined(I2S_APB1_APB2_FEATURE)
    361              if (IS_I2S_APB1_INSTANCE(hi2s->Instance))
    362              {
    363                i2sclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2S_APB1);
    364              }
    365              else
    366              {
    367                i2sclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2S_APB2);
    368              }
    369          #else
    370              i2sclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2S);
   \                     ??HAL_I2S_Init_6: (+1)
   \       0x62   0x2001             MOVS     R0,#+1
   \       0x64   0x.... 0x....      BL       HAL_RCCEx_GetPeriphCLKFreq
   \       0x68   0x0005             MOVS     R5,R0
    371          #endif
    372          
    373              /* Compute the Real divider depending on the MCLK output state, with a floating point */
    374              if (hi2s->Init.MCLKOutput == I2S_MCLKOUTPUT_ENABLE)
   \       0x6A   0x6920             LDR      R0,[R4, #+16]
   \       0x6C   0xF5B0 0x7F00      CMP      R0,#+512
   \       0x70   0xD116             BNE.N    ??HAL_I2S_Init_7
    375              {
    376                /* MCLK output is enabled */
    377                if (hi2s->Init.DataFormat != I2S_DATAFORMAT_16B)
   \       0x72   0x68E0             LDR      R0,[R4, #+12]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD009             BEQ.N    ??HAL_I2S_Init_8
    378                {
    379                  tmp = (uint32_t)(((((i2sclk / (packetlength * 4U)) * 10U) / hi2s->Init.AudioFreq)) + 5U);
   \       0x78   0x00B0             LSLS     R0,R6,#+2
   \       0x7A   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \       0x7E   0x200A             MOVS     R0,#+10
   \       0x80   0x4341             MULS     R1,R0,R1
   \       0x82   0x6960             LDR      R0,[R4, #+20]
   \       0x84   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \       0x88   0x1D40             ADDS     R0,R0,#+5
   \       0x8A   0xE011             B.N      ??HAL_I2S_Init_9
    380                }
    381                else
    382                {
    383                  tmp = (uint32_t)(((((i2sclk / (packetlength * 8U)) * 10U) / hi2s->Init.AudioFreq)) + 5U);
   \                     ??HAL_I2S_Init_8: (+1)
   \       0x8C   0x00F0             LSLS     R0,R6,#+3
   \       0x8E   0xFBB5 0xF1F0      UDIV     R1,R5,R0
   \       0x92   0x200A             MOVS     R0,#+10
   \       0x94   0x4341             MULS     R1,R0,R1
   \       0x96   0x6960             LDR      R0,[R4, #+20]
   \       0x98   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \       0x9C   0x1D40             ADDS     R0,R0,#+5
   \       0x9E   0xE007             B.N      ??HAL_I2S_Init_9
    384                }
    385              }
    386              else
    387              {
    388                /* MCLK output is disabled */
    389                tmp = (uint32_t)(((((i2sclk / packetlength) * 10U) / hi2s->Init.AudioFreq)) + 5U);
   \                     ??HAL_I2S_Init_7: (+1)
   \       0xA0   0xFBB5 0xF1F6      UDIV     R1,R5,R6
   \       0xA4   0x200A             MOVS     R0,#+10
   \       0xA6   0x4341             MULS     R1,R0,R1
   \       0xA8   0x6960             LDR      R0,[R4, #+20]
   \       0xAA   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \       0xAE   0x1D40             ADDS     R0,R0,#+5
    390              }
    391          
    392              /* Remove the flatting point */
    393              tmp = tmp / 10U;
   \                     ??HAL_I2S_Init_9: (+1)
   \       0xB0   0x210A             MOVS     R1,#+10
   \       0xB2   0xFBB0 0xF7F1      UDIV     R7,R0,R1
    394          
    395              /* Check the parity of the divider */
    396              i2sodd = (uint32_t)(tmp & (uint32_t)1U);
   \       0xB6   0xF017 0x0301      ANDS     R3,R7,#0x1
    397          
    398              /* Compute the i2sdiv prescaler */
    399              i2sdiv = (uint32_t)((tmp - i2sodd) / 2U);
   \       0xBA   0x1AFA             SUBS     R2,R7,R3
   \       0xBC   0x0852             LSRS     R2,R2,#+1
    400          
    401              /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    402              i2sodd = (uint32_t)(i2sodd << 8U);
   \       0xBE   0x021B             LSLS     R3,R3,#+8
   \       0xC0   0xE001             B.N      ??HAL_I2S_Init_10
    403            }
    404            else
    405            {
    406              /* Set the default values */
    407              i2sdiv = 2U;
   \                     ??HAL_I2S_Init_3: (+1)
   \       0xC2   0x2202             MOVS     R2,#+2
    408              i2sodd = 0U;
   \       0xC4   0x2300             MOVS     R3,#+0
    409            }
    410          
    411            /* Test if the divider is 1 or 0 or greater than 0xFF */
    412            if ((i2sdiv < 2U) || (i2sdiv > 0xFFU))
   \                     ??HAL_I2S_Init_10: (+1)
   \       0xC6   0x2A02             CMP      R2,#+2
   \       0xC8   0xD302             BCC.N    ??HAL_I2S_Init_11
   \       0xCA   0xF5B2 0x7F80      CMP      R2,#+256
   \       0xCE   0xD305             BCC.N    ??HAL_I2S_Init_12
    413            {
    414              /* Set the error code and execute error callback*/
    415              SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_PRESCALER);
   \                     ??HAL_I2S_Init_11: (+1)
   \       0xD0   0x6C60             LDR      R0,[R4, #+68]
   \       0xD2   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xD6   0x6460             STR      R0,[R4, #+68]
    416              return  HAL_ERROR;
   \       0xD8   0x2001             MOVS     R0,#+1
   \       0xDA   0xE069             B.N      ??HAL_I2S_Init_1
    417            }
    418          
    419            /*----------------------- SPIx I2SCFGR & I2SPR Configuration ----------------*/
    420          
    421            /* Write to SPIx I2SPR register the computed value */
    422            hi2s->Instance->I2SPR = (uint32_t)((uint32_t)i2sdiv | (uint32_t)(i2sodd | (uint32_t)hi2s->Init.MCLKOutput));
   \                     ??HAL_I2S_Init_12: (+1)
   \       0xDC   0xEA53 0x0102      ORRS     R1,R3,R2
   \       0xE0   0x6920             LDR      R0,[R4, #+16]
   \       0xE2   0x4301             ORRS     R1,R0,R1
   \       0xE4   0x6820             LDR      R0,[R4, #+0]
   \       0xE6   0x6201             STR      R1,[R0, #+32]
    423          
    424            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    425            /* And configure the I2S with the I2S_InitStruct values                      */
    426            MODIFY_REG(hi2s->Instance->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | \
    427                                                 SPI_I2SCFGR_CKPOL | SPI_I2SCFGR_I2SSTD | \
    428                                                 SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
    429                                                 SPI_I2SCFGR_I2SE  | SPI_I2SCFGR_I2SMOD), \
    430                       (SPI_I2SCFGR_I2SMOD | hi2s->Init.Mode | \
    431                        hi2s->Init.Standard | hi2s->Init.DataFormat | \
    432                        hi2s->Init.CPOL));
   \       0xE8   0x6820             LDR      R0,[R4, #+0]
   \       0xEA   0x69C1             LDR      R1,[R0, #+28]
   \       0xEC   0xEA19 0x0101      ANDS     R1,R9,R1
   \       0xF0   0x6860             LDR      R0,[R4, #+4]
   \       0xF2   0x4301             ORRS     R1,R0,R1
   \       0xF4   0x68A0             LDR      R0,[R4, #+8]
   \       0xF6   0x4301             ORRS     R1,R0,R1
   \       0xF8   0x68E0             LDR      R0,[R4, #+12]
   \       0xFA   0x4301             ORRS     R1,R0,R1
   \       0xFC   0x69A0             LDR      R0,[R4, #+24]
   \       0xFE   0x4301             ORRS     R1,R0,R1
   \      0x100   0xF451 0x6100      ORRS     R1,R1,#0x800
   \      0x104   0x6820             LDR      R0,[R4, #+0]
   \      0x106   0x61C1             STR      R1,[R0, #+28]
    433          
    434          #if defined(SPI_I2SCFGR_ASTRTEN)
    435            if ((hi2s->Init.Standard == I2S_STANDARD_PCM_SHORT) || ((hi2s->Init.Standard == I2S_STANDARD_PCM_LONG)))
    436            {
    437              /* Write to SPIx I2SCFGR */
    438              SET_BIT(hi2s->Instance->I2SCFGR, SPI_I2SCFGR_ASTRTEN);
    439            }
    440          #endif /* SPI_I2SCFGR_ASTRTEN */
    441          
    442          #if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
    443          
    444            /* Configure the I2S extended if the full duplex mode is enabled */
    445            assert_param(IS_I2S_FULLDUPLEX_MODE(hi2s->Init.FullDuplexMode));
    446          
    447            if (hi2s->Init.FullDuplexMode == I2S_FULLDUPLEXMODE_ENABLE)
   \      0x108   0x6A20             LDR      R0,[R4, #+32]
   \      0x10A   0x2801             CMP      R0,#+1
   \      0x10C   0xD14A             BNE.N    ??HAL_I2S_Init_13
    448            {
    449              /* Set FullDuplex I2S IrqHandler ISR if FULLDUPLEXMODE is enabled */
    450              hi2s->IrqHandlerISR = HAL_I2SEx_FullDuplex_IRQHandler;
   \      0x10E   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \      0x112   0x6360             STR      R0,[R4, #+52]
    451          
    452              /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    453              CLEAR_BIT(I2SxEXT(hi2s->Instance)->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
    454                                                           SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
    455                                                           SPI_I2SCFGR_I2SE | SPI_I2SCFGR_I2SMOD));
   \      0x114   0x.... 0x....      LDR.W    R12,??DataTable3_2
   \      0x118   0x6820             LDR      R0,[R4, #+0]
   \      0x11A   0x4560             CMP      R0,R12
   \      0x11C   0xD102             BNE.N    ??HAL_I2S_Init_14
   \      0x11E   0x.... 0x....      LDR.W    R0,??DataTable3_3
   \      0x122   0xE001             B.N      ??HAL_I2S_Init_15
   \                     ??HAL_I2S_Init_14: (+1)
   \      0x124   0xF05F 0x2040      MOVS     R0,#+1073758208
   \                     ??HAL_I2S_Init_15: (+1)
   \      0x128   0x69C1             LDR      R1,[R0, #+28]
   \      0x12A   0xEA19 0x0901      ANDS     R9,R9,R1
   \      0x12E   0xF8C0 0x901C      STR      R9,[R0, #+28]
    456              I2SxEXT(hi2s->Instance)->I2SPR = 2U;
   \      0x132   0x6820             LDR      R0,[R4, #+0]
   \      0x134   0x4560             CMP      R0,R12
   \      0x136   0xD102             BNE.N    ??HAL_I2S_Init_16
   \      0x138   0x.... 0x....      LDR.W    R0,??DataTable3_3
   \      0x13C   0xE001             B.N      ??HAL_I2S_Init_17
   \                     ??HAL_I2S_Init_16: (+1)
   \      0x13E   0xF05F 0x2040      MOVS     R0,#+1073758208
   \                     ??HAL_I2S_Init_17: (+1)
   \      0x142   0x2102             MOVS     R1,#+2
   \      0x144   0x6201             STR      R1,[R0, #+32]
    457          
    458              /* Get the I2SCFGR register value */
    459              tmpreg = I2SxEXT(hi2s->Instance)->I2SCFGR;
   \      0x146   0x6820             LDR      R0,[R4, #+0]
   \      0x148   0x4560             CMP      R0,R12
   \      0x14A   0xD102             BNE.N    ??HAL_I2S_Init_18
   \      0x14C   0x.... 0x....      LDR.W    R0,??DataTable3_3
   \      0x150   0xE001             B.N      ??HAL_I2S_Init_19
   \                     ??HAL_I2S_Init_18: (+1)
   \      0x152   0xF05F 0x2040      MOVS     R0,#+1073758208
   \                     ??HAL_I2S_Init_19: (+1)
   \      0x156   0x69C1             LDR      R1,[R0, #+28]
    460          
    461              /* Get the mode to be configured for the extended I2S */
    462              if ((hi2s->Init.Mode == I2S_MODE_MASTER_TX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_TX))
   \      0x158   0x6860             LDR      R0,[R4, #+4]
   \      0x15A   0xF5B0 0x7F00      CMP      R0,#+512
   \      0x15E   0xD002             BEQ.N    ??HAL_I2S_Init_20
   \      0x160   0x6860             LDR      R0,[R4, #+4]
   \      0x162   0x2800             CMP      R0,#+0
   \      0x164   0xD103             BNE.N    ??HAL_I2S_Init_21
    463              {
    464                tmp = I2S_MODE_SLAVE_RX;
   \                     ??HAL_I2S_Init_20: (+1)
   \      0x166   0xF44F 0x7080      MOV      R0,#+256
   \      0x16A   0x0007             MOVS     R7,R0
   \      0x16C   0xE001             B.N      ??HAL_I2S_Init_22
    465              }
    466              else /* I2S_MODE_MASTER_RX ||  I2S_MODE_SLAVE_RX */
    467              {
    468                tmp = I2S_MODE_SLAVE_TX;
   \                     ??HAL_I2S_Init_21: (+1)
   \      0x16E   0x2000             MOVS     R0,#+0
   \      0x170   0x0007             MOVS     R7,R0
    469              }
    470          
    471              /* Configure the I2S Slave with the I2S Master parameter values */
    472              tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
    473                                   (uint16_t)(hi2s->Init.Standard | (uint16_t)(hi2s->Init.DataFormat | \
    474                                              (uint16_t)hi2s->Init.CPOL))));
   \                     ??HAL_I2S_Init_22: (+1)
   \      0x172   0x4688             MOV      R8,R1
   \      0x174   0xEA57 0x0808      ORRS     R8,R7,R8
   \      0x178   0x68A0             LDR      R0,[R4, #+8]
   \      0x17A   0xEA50 0x0808      ORRS     R8,R0,R8
   \      0x17E   0x68E0             LDR      R0,[R4, #+12]
   \      0x180   0xEA50 0x0808      ORRS     R8,R0,R8
   \      0x184   0x69A0             LDR      R0,[R4, #+24]
   \      0x186   0xEA50 0x0808      ORRS     R8,R0,R8
   \      0x18A   0xF458 0x6800      ORRS     R8,R8,#0x800
    475          
    476              /* Write to SPIx I2SCFGR */
    477              WRITE_REG(I2SxEXT(hi2s->Instance)->I2SCFGR, tmpreg);
   \      0x18E   0x6820             LDR      R0,[R4, #+0]
   \      0x190   0x4560             CMP      R0,R12
   \      0x192   0xD102             BNE.N    ??HAL_I2S_Init_23
   \      0x194   0x.... 0x....      LDR.W    R0,??DataTable3_3
   \      0x198   0xE001             B.N      ??HAL_I2S_Init_24
   \                     ??HAL_I2S_Init_23: (+1)
   \      0x19A   0xF05F 0x2040      MOVS     R0,#+1073758208
   \                     ??HAL_I2S_Init_24: (+1)
   \      0x19E   0x4641             MOV      R1,R8
   \      0x1A0   0xB289             UXTH     R1,R1
   \      0x1A2   0x61C1             STR      R1,[R0, #+28]
    478            }
    479          #endif /* SPI_I2S_FULLDUPLEX_SUPPORT */
    480          
    481            hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \                     ??HAL_I2S_Init_13: (+1)
   \      0x1A4   0x2000             MOVS     R0,#+0
   \      0x1A6   0x6460             STR      R0,[R4, #+68]
    482            hi2s->State     = HAL_I2S_STATE_READY;
   \      0x1A8   0x2001             MOVS     R0,#+1
   \      0x1AA   0xF884 0x0041      STRB     R0,[R4, #+65]
    483          
    484            return HAL_OK;
   \      0x1AE   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2S_Init_1: (+1)
   \      0x1B0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
    485          }
    486          
    487          /**
    488            * @brief DeInitializes the I2S peripheral
    489            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
    490            *         the configuration information for I2S module
    491            * @retval HAL status
    492            */

   \                                 In section .text, align 2, keep-with-next
    493          HAL_StatusTypeDef HAL_I2S_DeInit(I2S_HandleTypeDef *hi2s)
    494          {
   \                     HAL_I2S_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    495            /* Check the I2S handle allocation */
    496            if (hi2s == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_I2S_DeInit_0
    497            {
    498              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE014             B.N      ??HAL_I2S_DeInit_1
    499            }
    500          
    501            /* Check the parameters */
    502            assert_param(IS_I2S_ALL_INSTANCE(hi2s->Instance));
    503          
    504            hi2s->State = HAL_I2S_STATE_BUSY;
   \                     ??HAL_I2S_DeInit_0: (+1)
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xF884 0x0041      STRB     R0,[R4, #+65]
    505          
    506            /* Disable the I2S Peripheral Clock */
    507            __HAL_I2S_DISABLE(hi2s);
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x69C0             LDR      R0,[R0, #+28]
   \       0x16   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x1A   0x6821             LDR      R1,[R4, #+0]
   \       0x1C   0x61C8             STR      R0,[R1, #+28]
    508          
    509          #if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
    510            if (hi2s->MspDeInitCallback == NULL)
    511            {
    512              hi2s->MspDeInitCallback = HAL_I2S_MspDeInit; /* Legacy weak MspDeInit  */
    513            }
    514          
    515            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    516            hi2s->MspDeInitCallback(hi2s);
    517          #else
    518            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    519            HAL_I2S_MspDeInit(hi2s);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       HAL_I2S_MspDeInit
    520          #endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    521          
    522            hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x6460             STR      R0,[R4, #+68]
    523            hi2s->State     = HAL_I2S_STATE_RESET;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xF884 0x0041      STRB     R0,[R4, #+65]
    524          
    525            /* Release Lock */
    526            __HAL_UNLOCK(hi2s);
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xF884 0x0040      STRB     R0,[R4, #+64]
    527          
    528            return HAL_OK;
   \       0x34   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2S_DeInit_1: (+1)
   \       0x36   0xBD10             POP      {R4,PC}
    529          }
    530          
    531          /**
    532            * @brief I2S MSP Init
    533            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
    534            *         the configuration information for I2S module
    535            * @retval None
    536            */

   \                                 In section .text, align 2
    537          __weak void HAL_I2S_MspInit(I2S_HandleTypeDef *hi2s)
    538          {
    539            /* Prevent unused argument(s) compilation warning */
    540            UNUSED(hi2s);
    541          
    542            /* NOTE : This function Should not be modified, when the callback is needed,
    543                      the HAL_I2S_MspInit could be implemented in the user file
    544             */
    545          }
   \                     HAL_I2S_MspInit: (+1)
   \        0x0   0x4770             BX       LR
    546          
    547          /**
    548            * @brief I2S MSP DeInit
    549            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
    550            *         the configuration information for I2S module
    551            * @retval None
    552            */

   \                                 In section .text, align 2
    553          __weak void HAL_I2S_MspDeInit(I2S_HandleTypeDef *hi2s)
    554          {
    555            /* Prevent unused argument(s) compilation warning */
    556            UNUSED(hi2s);
    557          
    558            /* NOTE : This function Should not be modified, when the callback is needed,
    559                      the HAL_I2S_MspDeInit could be implemented in the user file
    560             */
    561          }
   \                     HAL_I2S_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
    562          
    563          #if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
    564          /**
    565            * @brief  Register a User I2S Callback
    566            *         To be used instead of the weak predefined callback
    567            * @param  hi2s Pointer to a I2S_HandleTypeDef structure that contains
    568            *                the configuration information for the specified I2S.
    569            * @param  CallbackID ID of the callback to be registered
    570            * @param  pCallback pointer to the Callback function
    571            * @retval HAL status
    572            */
    573          HAL_StatusTypeDef HAL_I2S_RegisterCallback(I2S_HandleTypeDef *hi2s, HAL_I2S_CallbackIDTypeDef CallbackID,
    574                                                     pI2S_CallbackTypeDef pCallback)
    575          {
    576            HAL_StatusTypeDef status = HAL_OK;
    577          
    578            if (pCallback == NULL)
    579            {
    580              /* Update the error code */
    581              hi2s->ErrorCode |= HAL_I2S_ERROR_INVALID_CALLBACK;
    582          
    583              return HAL_ERROR;
    584            }
    585            /* Process locked */
    586            __HAL_LOCK(hi2s);
    587          
    588            if (HAL_I2S_STATE_READY == hi2s->State)
    589            {
    590              switch (CallbackID)
    591              {
    592                case HAL_I2S_TX_COMPLETE_CB_ID :
    593                  hi2s->TxCpltCallback = pCallback;
    594                  break;
    595          
    596                case HAL_I2S_RX_COMPLETE_CB_ID :
    597                  hi2s->RxCpltCallback = pCallback;
    598                  break;
    599          
    600          #if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
    601                case HAL_I2S_TX_RX_COMPLETE_CB_ID :
    602                  hi2s->TxRxCpltCallback = pCallback;
    603                  break;
    604          #endif
    605          
    606                case HAL_I2S_TX_HALF_COMPLETE_CB_ID :
    607                  hi2s->TxHalfCpltCallback = pCallback;
    608                  break;
    609          
    610                case HAL_I2S_RX_HALF_COMPLETE_CB_ID :
    611                  hi2s->RxHalfCpltCallback = pCallback;
    612                  break;
    613          
    614          #if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
    615                case HAL_I2S_TX_RX_HALF_COMPLETE_CB_ID :
    616                  hi2s->TxRxHalfCpltCallback = pCallback;
    617                  break;
    618          #endif
    619          
    620                case HAL_I2S_ERROR_CB_ID :
    621                  hi2s->ErrorCallback = pCallback;
    622                  break;
    623          
    624                case HAL_I2S_MSPINIT_CB_ID :
    625                  hi2s->MspInitCallback = pCallback;
    626                  break;
    627          
    628                case HAL_I2S_MSPDEINIT_CB_ID :
    629                  hi2s->MspDeInitCallback = pCallback;
    630                  break;
    631          
    632                default :
    633                  /* Update the error code */
    634                  SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_INVALID_CALLBACK);
    635          
    636                  /* Return error status */
    637                  status =  HAL_ERROR;
    638                  break;
    639              }
    640            }
    641            else if (HAL_I2S_STATE_RESET == hi2s->State)
    642            {
    643              switch (CallbackID)
    644              {
    645                case HAL_I2S_MSPINIT_CB_ID :
    646                  hi2s->MspInitCallback = pCallback;
    647                  break;
    648          
    649                case HAL_I2S_MSPDEINIT_CB_ID :
    650                  hi2s->MspDeInitCallback = pCallback;
    651                  break;
    652          
    653                default :
    654                  /* Update the error code */
    655                  SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_INVALID_CALLBACK);
    656          
    657                  /* Return error status */
    658                  status =  HAL_ERROR;
    659                  break;
    660              }
    661            }
    662            else
    663            {
    664              /* Update the error code */
    665              SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_INVALID_CALLBACK);
    666          
    667              /* Return error status */
    668              status =  HAL_ERROR;
    669            }
    670          
    671            /* Release Lock */
    672            __HAL_UNLOCK(hi2s);
    673            return status;
    674          }
    675          
    676          /**
    677            * @brief  Unregister an I2S Callback
    678            *         I2S callback is redirected to the weak predefined callback
    679            * @param  hi2s Pointer to a I2S_HandleTypeDef structure that contains
    680            *                the configuration information for the specified I2S.
    681            * @param  CallbackID ID of the callback to be unregistered
    682            * @retval HAL status
    683            */
    684          HAL_StatusTypeDef HAL_I2S_UnRegisterCallback(I2S_HandleTypeDef *hi2s, HAL_I2S_CallbackIDTypeDef CallbackID)
    685          {
    686            HAL_StatusTypeDef status = HAL_OK;
    687          
    688            /* Process locked */
    689            __HAL_LOCK(hi2s);
    690          
    691            if (HAL_I2S_STATE_READY == hi2s->State)
    692            {
    693              switch (CallbackID)
    694              {
    695                case HAL_I2S_TX_COMPLETE_CB_ID :
    696                  hi2s->TxCpltCallback = HAL_I2S_TxCpltCallback;                /* Legacy weak TxCpltCallback       */
    697                  break;
    698          
    699                case HAL_I2S_RX_COMPLETE_CB_ID :
    700                  hi2s->RxCpltCallback = HAL_I2S_RxCpltCallback;                /* Legacy weak RxCpltCallback       */
    701                  break;
    702          
    703          #if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
    704                case HAL_I2S_TX_RX_COMPLETE_CB_ID :
    705                  hi2s->TxRxCpltCallback = HAL_I2SEx_TxRxCpltCallback;          /* Legacy weak TxRxCpltCallback     */
    706                  break;
    707          #endif
    708          
    709                case HAL_I2S_TX_HALF_COMPLETE_CB_ID :
    710                  hi2s->TxHalfCpltCallback = HAL_I2S_TxHalfCpltCallback;        /* Legacy weak TxHalfCpltCallback   */
    711                  break;
    712          
    713                case HAL_I2S_RX_HALF_COMPLETE_CB_ID :
    714                  hi2s->RxHalfCpltCallback = HAL_I2S_RxHalfCpltCallback;        /* Legacy weak RxHalfCpltCallback   */
    715                  break;
    716          
    717          #if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
    718                case HAL_I2S_TX_RX_HALF_COMPLETE_CB_ID :
    719                  hi2s->TxRxHalfCpltCallback = HAL_I2SEx_TxRxHalfCpltCallback;  /* Legacy weak TxRxHalfCpltCallback */
    720                  break;
    721          #endif
    722          
    723                case HAL_I2S_ERROR_CB_ID :
    724                  hi2s->ErrorCallback = HAL_I2S_ErrorCallback;                  /* Legacy weak ErrorCallback        */
    725                  break;
    726          
    727                case HAL_I2S_MSPINIT_CB_ID :
    728                  hi2s->MspInitCallback = HAL_I2S_MspInit;                      /* Legacy weak MspInit              */
    729                  break;
    730          
    731                case HAL_I2S_MSPDEINIT_CB_ID :
    732                  hi2s->MspDeInitCallback = HAL_I2S_MspDeInit;                  /* Legacy weak MspDeInit            */
    733                  break;
    734          
    735                default :
    736                  /* Update the error code */
    737                  SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_INVALID_CALLBACK);
    738          
    739                  /* Return error status */
    740                  status =  HAL_ERROR;
    741                  break;
    742              }
    743            }
    744            else if (HAL_I2S_STATE_RESET == hi2s->State)
    745            {
    746              switch (CallbackID)
    747              {
    748                case HAL_I2S_MSPINIT_CB_ID :
    749                  hi2s->MspInitCallback = HAL_I2S_MspInit;                      /* Legacy weak MspInit              */
    750                  break;
    751          
    752                case HAL_I2S_MSPDEINIT_CB_ID :
    753                  hi2s->MspDeInitCallback = HAL_I2S_MspDeInit;                  /* Legacy weak MspDeInit            */
    754                  break;
    755          
    756                default :
    757                  /* Update the error code */
    758                  SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_INVALID_CALLBACK);
    759          
    760                  /* Return error status */
    761                  status =  HAL_ERROR;
    762                  break;
    763              }
    764            }
    765            else
    766            {
    767              /* Update the error code */
    768              SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_INVALID_CALLBACK);
    769          
    770              /* Return error status */
    771              status =  HAL_ERROR;
    772            }
    773          
    774            /* Release Lock */
    775            __HAL_UNLOCK(hi2s);
    776            return status;
    777          }
    778          #endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    779          /**
    780            * @}
    781            */
    782          
    783          /** @defgroup I2S_Exported_Functions_Group2 IO operation functions
    784            *  @brief Data transfers functions
    785            *
    786          @verbatim
    787           ===============================================================================
    788                                ##### IO operation functions #####
    789           ===============================================================================
    790              [..]
    791              This subsection provides a set of functions allowing to manage the I2S data
    792              transfers.
    793          
    794              (#) There are two modes of transfer:
    795                 (++) Blocking mode : The communication is performed in the polling mode.
    796                      The status of all data processing is returned by the same function
    797                      after finishing transfer.
    798                 (++) No-Blocking mode : The communication is performed using Interrupts
    799                      or DMA. These functions return the status of the transfer startup.
    800                      The end of the data processing will be indicated through the
    801                      dedicated I2S IRQ when using Interrupt mode or the DMA IRQ when
    802                      using DMA mode.
    803          
    804              (#) Blocking mode functions are :
    805                  (++) HAL_I2S_Transmit()
    806                  (++) HAL_I2S_Receive()
    807          
    808              (#) No-Blocking mode functions with Interrupt are :
    809                  (++) HAL_I2S_Transmit_IT()
    810                  (++) HAL_I2S_Receive_IT()
    811          
    812              (#) No-Blocking mode functions with DMA are :
    813                  (++) HAL_I2S_Transmit_DMA()
    814                  (++) HAL_I2S_Receive_DMA()
    815          
    816              (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:
    817                  (++) HAL_I2S_TxCpltCallback()
    818                  (++) HAL_I2S_RxCpltCallback()
    819                  (++) HAL_I2S_ErrorCallback()
    820          
    821          @endverbatim
    822            * @{
    823            */
    824          
    825          /**
    826            * @brief  Transmit an amount of data in blocking mode
    827            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
    828            *         the configuration information for I2S module
    829            * @param  pData a 16-bit pointer to data buffer.
    830            * @param  Size number of data sample to be sent:
    831            * @note   When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
    832            *         configuration phase, the Size parameter means the number of 16-bit data length
    833            *         in the transaction and when a 24-bit data frame or a 32-bit data frame is selected
    834            *         the Size parameter means the number of 16-bit data length.
    835            * @param  Timeout Timeout duration
    836            * @note   The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization
    837            *         between Master and Slave(example: audio streaming).
    838            * @retval HAL status
    839            */

   \                                 In section .text, align 2, keep-with-next
    840          HAL_StatusTypeDef HAL_I2S_Transmit(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size, uint32_t Timeout)
    841          {
   \                     HAL_I2S_Transmit: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    842            uint32_t tmpreg_cfgr;
    843          
    844            if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD003             BEQ.N    ??HAL_I2S_Transmit_0
   \       0x10   0x0030             MOVS     R0,R6
   \       0x12   0xB280             UXTH     R0,R0
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??HAL_I2S_Transmit_1
    845            {
    846              return  HAL_ERROR;
   \                     ??HAL_I2S_Transmit_0: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE09A             B.N      ??HAL_I2S_Transmit_2
    847            }
    848          
    849            /* Process Locked */
    850            __HAL_LOCK(hi2s);
   \                     ??HAL_I2S_Transmit_1: (+1)
   \       0x1C   0xF895 0x0040      LDRB     R0,[R5, #+64]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD101             BNE.N    ??HAL_I2S_Transmit_3
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0xE094             B.N      ??HAL_I2S_Transmit_2
   \                     ??HAL_I2S_Transmit_3: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xF885 0x0040      STRB     R0,[R5, #+64]
    851          
    852            if (hi2s->State != HAL_I2S_STATE_READY)
   \       0x2E   0xF895 0x0041      LDRB     R0,[R5, #+65]
   \       0x32   0x2801             CMP      R0,#+1
   \       0x34   0xD004             BEQ.N    ??HAL_I2S_Transmit_4
    853            {
    854              __HAL_UNLOCK(hi2s);
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xF885 0x0040      STRB     R0,[R5, #+64]
    855              return HAL_BUSY;
   \       0x3C   0x2002             MOVS     R0,#+2
   \       0x3E   0xE088             B.N      ??HAL_I2S_Transmit_2
    856            }
    857          
    858            /* Set state and reset error code */
    859            hi2s->State = HAL_I2S_STATE_BUSY_TX;
   \                     ??HAL_I2S_Transmit_4: (+1)
   \       0x40   0x2003             MOVS     R0,#+3
   \       0x42   0xF885 0x0041      STRB     R0,[R5, #+65]
    860            hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x6468             STR      R0,[R5, #+68]
    861            hi2s->pTxBuffPtr = pData;
   \       0x4A   0x626C             STR      R4,[R5, #+36]
    862          
    863            tmpreg_cfgr = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
   \       0x4C   0x6828             LDR      R0,[R5, #+0]
   \       0x4E   0x69C0             LDR      R0,[R0, #+28]
   \       0x50   0xF010 0x0007      ANDS     R0,R0,#0x7
    864          
    865            if ((tmpreg_cfgr == I2S_DATAFORMAT_24B) || (tmpreg_cfgr == I2S_DATAFORMAT_32B))
   \       0x54   0x2803             CMP      R0,#+3
   \       0x56   0xD001             BEQ.N    ??HAL_I2S_Transmit_5
   \       0x58   0x2805             CMP      R0,#+5
   \       0x5A   0xD104             BNE.N    ??HAL_I2S_Transmit_6
    866            {
    867              hi2s->TxXferSize = (Size << 1U);
   \                     ??HAL_I2S_Transmit_5: (+1)
   \       0x5C   0x0071             LSLS     R1,R6,#+1
   \       0x5E   0x8529             STRH     R1,[R5, #+40]
    868              hi2s->TxXferCount = (Size << 1U);
   \       0x60   0x0071             LSLS     R1,R6,#+1
   \       0x62   0x8569             STRH     R1,[R5, #+42]
   \       0x64   0xE001             B.N      ??HAL_I2S_Transmit_7
    869            }
    870            else
    871            {
    872              hi2s->TxXferSize = Size;
   \                     ??HAL_I2S_Transmit_6: (+1)
   \       0x66   0x852E             STRH     R6,[R5, #+40]
    873              hi2s->TxXferCount = Size;
   \       0x68   0x856E             STRH     R6,[R5, #+42]
    874            }
    875          
    876            tmpreg_cfgr = hi2s->Instance->I2SCFGR;
   \                     ??HAL_I2S_Transmit_7: (+1)
   \       0x6A   0x6829             LDR      R1,[R5, #+0]
   \       0x6C   0xF8D1 0x801C      LDR      R8,[R1, #+28]
    877          
    878            /* Check if the I2S is already enabled */
    879            if ((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
   \       0x70   0x6829             LDR      R1,[R5, #+0]
   \       0x72   0x69C9             LDR      R1,[R1, #+28]
   \       0x74   0x0549             LSLS     R1,R1,#+21
   \       0x76   0xD405             BMI.N    ??HAL_I2S_Transmit_8
    880            {
    881              /* Enable I2S peripheral */
    882              __HAL_I2S_ENABLE(hi2s);
   \       0x78   0x6828             LDR      R0,[R5, #+0]
   \       0x7A   0x69C0             LDR      R0,[R0, #+28]
   \       0x7C   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0x80   0x6829             LDR      R1,[R5, #+0]
   \       0x82   0x61C8             STR      R0,[R1, #+28]
    883            }
    884          
    885            /* Wait until TXE flag is set */
    886            if (I2S_WaitFlagStateUntilTimeout(hi2s, I2S_FLAG_TXE, SET, Timeout) != HAL_OK)
   \                     ??HAL_I2S_Transmit_8: (+1)
   \       0x84   0x003B             MOVS     R3,R7
   \       0x86   0x2201             MOVS     R2,#+1
   \       0x88   0x2102             MOVS     R1,#+2
   \       0x8A   0x0028             MOVS     R0,R5
   \       0x8C   0x.... 0x....      BL       I2S_WaitFlagStateUntilTimeout
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD00B             BEQ.N    ??HAL_I2S_Transmit_9
    887            {
    888              /* Set the error code */
    889              SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_TIMEOUT);
   \       0x94   0x6C68             LDR      R0,[R5, #+68]
   \       0x96   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x9A   0x6468             STR      R0,[R5, #+68]
    890              hi2s->State = HAL_I2S_STATE_READY;
   \       0x9C   0x2001             MOVS     R0,#+1
   \       0x9E   0xF885 0x0041      STRB     R0,[R5, #+65]
    891              __HAL_UNLOCK(hi2s);
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0xF885 0x0040      STRB     R0,[R5, #+64]
    892              return HAL_ERROR;
   \       0xA8   0x2001             MOVS     R0,#+1
   \       0xAA   0xE052             B.N      ??HAL_I2S_Transmit_2
    893            }
    894          
    895            while (hi2s->TxXferCount > 0U)
   \                     ??HAL_I2S_Transmit_9: (+1)
   \       0xAC   0x8D68             LDRH     R0,[R5, #+42]
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD02C             BEQ.N    ??HAL_I2S_Transmit_10
    896            {
    897              hi2s->Instance->DR = (*hi2s->pTxBuffPtr);
   \       0xB2   0x6A68             LDR      R0,[R5, #+36]
   \       0xB4   0x8800             LDRH     R0,[R0, #+0]
   \       0xB6   0x6829             LDR      R1,[R5, #+0]
   \       0xB8   0x60C8             STR      R0,[R1, #+12]
    898              hi2s->pTxBuffPtr++;
   \       0xBA   0x6A68             LDR      R0,[R5, #+36]
   \       0xBC   0x1C80             ADDS     R0,R0,#+2
   \       0xBE   0x6268             STR      R0,[R5, #+36]
    899              hi2s->TxXferCount--;
   \       0xC0   0x8D68             LDRH     R0,[R5, #+42]
   \       0xC2   0x1E40             SUBS     R0,R0,#+1
   \       0xC4   0x8568             STRH     R0,[R5, #+42]
    900          
    901              /* Wait until TXE flag is set */
    902              if (I2S_WaitFlagStateUntilTimeout(hi2s, I2S_FLAG_TXE, SET, Timeout) != HAL_OK)
   \       0xC6   0x003B             MOVS     R3,R7
   \       0xC8   0x2201             MOVS     R2,#+1
   \       0xCA   0x2102             MOVS     R1,#+2
   \       0xCC   0x0028             MOVS     R0,R5
   \       0xCE   0x.... 0x....      BL       I2S_WaitFlagStateUntilTimeout
   \       0xD2   0x2800             CMP      R0,#+0
   \       0xD4   0xD00B             BEQ.N    ??HAL_I2S_Transmit_11
    903              {
    904                /* Set the error code */
    905                SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_TIMEOUT);
   \       0xD6   0x6C68             LDR      R0,[R5, #+68]
   \       0xD8   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xDC   0x6468             STR      R0,[R5, #+68]
    906                hi2s->State = HAL_I2S_STATE_READY;
   \       0xDE   0x2001             MOVS     R0,#+1
   \       0xE0   0xF885 0x0041      STRB     R0,[R5, #+65]
    907                __HAL_UNLOCK(hi2s);
   \       0xE4   0x2000             MOVS     R0,#+0
   \       0xE6   0xF885 0x0040      STRB     R0,[R5, #+64]
    908                return HAL_ERROR;
   \       0xEA   0x2001             MOVS     R0,#+1
   \       0xEC   0xE031             B.N      ??HAL_I2S_Transmit_2
    909              }
    910          
    911              /* Check if an underrun occurs */
    912              if (__HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_UDR) == SET)
   \                     ??HAL_I2S_Transmit_11: (+1)
   \       0xEE   0x6828             LDR      R0,[R5, #+0]
   \       0xF0   0x6880             LDR      R0,[R0, #+8]
   \       0xF2   0x0700             LSLS     R0,R0,#+28
   \       0xF4   0xD5DA             BPL.N    ??HAL_I2S_Transmit_9
    913              {
    914                /* Clear underrun flag */
    915                __HAL_I2S_CLEAR_UDRFLAG(hi2s);
   \       0xF6   0x2000             MOVS     R0,#+0
   \       0xF8   0x9000             STR      R0,[SP, #+0]
   \       0xFA   0x6828             LDR      R0,[R5, #+0]
   \       0xFC   0x6880             LDR      R0,[R0, #+8]
   \       0xFE   0x9000             STR      R0,[SP, #+0]
   \      0x100   0x9800             LDR      R0,[SP, #+0]
    916          
    917                /* Set the error code */
    918                SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
   \      0x102   0x6C68             LDR      R0,[R5, #+68]
   \      0x104   0xF050 0x0004      ORRS     R0,R0,#0x4
   \      0x108   0x6468             STR      R0,[R5, #+68]
   \      0x10A   0xE7CF             B.N      ??HAL_I2S_Transmit_9
    919              }
    920            }
    921          
    922            /* Check if Slave mode is selected */
    923            if (((tmpreg_cfgr & SPI_I2SCFGR_I2SCFG) == I2S_MODE_SLAVE_TX)
    924                || ((tmpreg_cfgr & SPI_I2SCFGR_I2SCFG) == I2S_MODE_SLAVE_RX))
   \                     ??HAL_I2S_Transmit_10: (+1)
   \      0x10C   0xF418 0x7F40      TST      R8,#0x300
   \      0x110   0xD004             BEQ.N    ??HAL_I2S_Transmit_12
   \      0x112   0xF418 0x7040      ANDS     R0,R8,#0x300
   \      0x116   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x11A   0xD113             BNE.N    ??HAL_I2S_Transmit_13
    925            {
    926              /* Wait until Busy flag is reset */
    927              if (I2S_WaitFlagStateUntilTimeout(hi2s, I2S_FLAG_BSY, RESET, Timeout) != HAL_OK)
   \                     ??HAL_I2S_Transmit_12: (+1)
   \      0x11C   0x003B             MOVS     R3,R7
   \      0x11E   0x2200             MOVS     R2,#+0
   \      0x120   0x2180             MOVS     R1,#+128
   \      0x122   0x0028             MOVS     R0,R5
   \      0x124   0x.... 0x....      BL       I2S_WaitFlagStateUntilTimeout
   \      0x128   0x2800             CMP      R0,#+0
   \      0x12A   0xD00B             BEQ.N    ??HAL_I2S_Transmit_13
    928              {
    929                /* Set the error code */
    930                SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_TIMEOUT);
   \      0x12C   0x6C68             LDR      R0,[R5, #+68]
   \      0x12E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x132   0x6468             STR      R0,[R5, #+68]
    931                hi2s->State = HAL_I2S_STATE_READY;
   \      0x134   0x2001             MOVS     R0,#+1
   \      0x136   0xF885 0x0041      STRB     R0,[R5, #+65]
    932                __HAL_UNLOCK(hi2s);
   \      0x13A   0x2000             MOVS     R0,#+0
   \      0x13C   0xF885 0x0040      STRB     R0,[R5, #+64]
    933                return HAL_ERROR;
   \      0x140   0x2001             MOVS     R0,#+1
   \      0x142   0xE006             B.N      ??HAL_I2S_Transmit_2
    934              }
    935            }
    936          
    937            hi2s->State = HAL_I2S_STATE_READY;
   \                     ??HAL_I2S_Transmit_13: (+1)
   \      0x144   0x2001             MOVS     R0,#+1
   \      0x146   0xF885 0x0041      STRB     R0,[R5, #+65]
    938            __HAL_UNLOCK(hi2s);
   \      0x14A   0x2000             MOVS     R0,#+0
   \      0x14C   0xF885 0x0040      STRB     R0,[R5, #+64]
    939            return HAL_OK;
   \      0x150   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2S_Transmit_2: (+1)
   \      0x152   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
    940          }
    941          
    942          /**
    943            * @brief  Receive an amount of data in blocking mode
    944            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
    945            *         the configuration information for I2S module
    946            * @param  pData a 16-bit pointer to data buffer.
    947            * @param  Size number of data sample to be sent:
    948            * @note   When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
    949            *         configuration phase, the Size parameter means the number of 16-bit data length
    950            *         in the transaction and when a 24-bit data frame or a 32-bit data frame is selected
    951            *         the Size parameter means the number of 16-bit data length.
    952            * @param  Timeout Timeout duration
    953            * @note   The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization
    954            *         between Master and Slave(example: audio streaming).
    955            * @note   In I2S Master Receiver mode, just after enabling the peripheral the clock will be generate
    956            *         in continuous way and as the I2S is not disabled at the end of the I2S transaction.
    957            * @retval HAL status
    958            */

   \                                 In section .text, align 2, keep-with-next
    959          HAL_StatusTypeDef HAL_I2S_Receive(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size, uint32_t Timeout)
    960          {
   \                     HAL_I2S_Receive: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
    961            uint32_t tmpreg_cfgr;
    962          
    963            if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD003             BEQ.N    ??HAL_I2S_Receive_0
   \       0x10   0x0030             MOVS     R0,R6
   \       0x12   0xB280             UXTH     R0,R0
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??HAL_I2S_Receive_1
    964            {
    965              return  HAL_ERROR;
   \                     ??HAL_I2S_Receive_0: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE07D             B.N      ??HAL_I2S_Receive_2
    966            }
    967          
    968            /* Process Locked */
    969            __HAL_LOCK(hi2s);
   \                     ??HAL_I2S_Receive_1: (+1)
   \       0x1C   0xF895 0x0040      LDRB     R0,[R5, #+64]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD101             BNE.N    ??HAL_I2S_Receive_3
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0xE077             B.N      ??HAL_I2S_Receive_2
   \                     ??HAL_I2S_Receive_3: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xF885 0x0040      STRB     R0,[R5, #+64]
    970          
    971            if (hi2s->State != HAL_I2S_STATE_READY)
   \       0x2E   0xF895 0x0041      LDRB     R0,[R5, #+65]
   \       0x32   0x2801             CMP      R0,#+1
   \       0x34   0xD004             BEQ.N    ??HAL_I2S_Receive_4
    972            {
    973              __HAL_UNLOCK(hi2s);
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xF885 0x0040      STRB     R0,[R5, #+64]
    974              return HAL_BUSY;
   \       0x3C   0x2002             MOVS     R0,#+2
   \       0x3E   0xE06B             B.N      ??HAL_I2S_Receive_2
    975            }
    976          
    977            /* Set state and reset error code */
    978            hi2s->State = HAL_I2S_STATE_BUSY_RX;
   \                     ??HAL_I2S_Receive_4: (+1)
   \       0x40   0x2004             MOVS     R0,#+4
   \       0x42   0xF885 0x0041      STRB     R0,[R5, #+65]
    979            hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x6468             STR      R0,[R5, #+68]
    980            hi2s->pRxBuffPtr = pData;
   \       0x4A   0x62EC             STR      R4,[R5, #+44]
    981          
    982            tmpreg_cfgr = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
   \       0x4C   0x6828             LDR      R0,[R5, #+0]
   \       0x4E   0xF8D0 0x801C      LDR      R8,[R0, #+28]
   \       0x52   0xF018 0x0807      ANDS     R8,R8,#0x7
    983          
    984            if ((tmpreg_cfgr == I2S_DATAFORMAT_24B) || (tmpreg_cfgr == I2S_DATAFORMAT_32B))
   \       0x56   0xF1B8 0x0F03      CMP      R8,#+3
   \       0x5A   0xD002             BEQ.N    ??HAL_I2S_Receive_5
   \       0x5C   0xF1B8 0x0F05      CMP      R8,#+5
   \       0x60   0xD104             BNE.N    ??HAL_I2S_Receive_6
    985            {
    986              hi2s->RxXferSize = (Size << 1U);
   \                     ??HAL_I2S_Receive_5: (+1)
   \       0x62   0x0070             LSLS     R0,R6,#+1
   \       0x64   0x8628             STRH     R0,[R5, #+48]
    987              hi2s->RxXferCount = (Size << 1U);
   \       0x66   0x0070             LSLS     R0,R6,#+1
   \       0x68   0x8668             STRH     R0,[R5, #+50]
   \       0x6A   0xE001             B.N      ??HAL_I2S_Receive_7
    988            }
    989            else
    990            {
    991              hi2s->RxXferSize = Size;
   \                     ??HAL_I2S_Receive_6: (+1)
   \       0x6C   0x862E             STRH     R6,[R5, #+48]
    992              hi2s->RxXferCount = Size;
   \       0x6E   0x866E             STRH     R6,[R5, #+50]
    993            }
    994          
    995            /* Check if the I2S is already enabled */
    996            if ((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
   \                     ??HAL_I2S_Receive_7: (+1)
   \       0x70   0x6828             LDR      R0,[R5, #+0]
   \       0x72   0x69C0             LDR      R0,[R0, #+28]
   \       0x74   0x0540             LSLS     R0,R0,#+21
   \       0x76   0xD405             BMI.N    ??HAL_I2S_Receive_8
    997            {
    998              /* Enable I2S peripheral */
    999              __HAL_I2S_ENABLE(hi2s);
   \       0x78   0x6828             LDR      R0,[R5, #+0]
   \       0x7A   0x69C0             LDR      R0,[R0, #+28]
   \       0x7C   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0x80   0x6829             LDR      R1,[R5, #+0]
   \       0x82   0x61C8             STR      R0,[R1, #+28]
   1000            }
   1001          
   1002            /* Check if Master Receiver mode is selected */
   1003            if ((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_MASTER_RX)
   \                     ??HAL_I2S_Receive_8: (+1)
   \       0x84   0x6828             LDR      R0,[R5, #+0]
   \       0x86   0x69C0             LDR      R0,[R0, #+28]
   \       0x88   0xF410 0x7040      ANDS     R0,R0,#0x300
   \       0x8C   0xF5B0 0x7F40      CMP      R0,#+768
   \       0x90   0xD108             BNE.N    ??HAL_I2S_Receive_9
   1004            {
   1005              /* Clear the Overrun Flag by a read operation on the SPI_DR register followed by a read
   1006              access to the SPI_SR register. */
   1007              __HAL_I2S_CLEAR_OVRFLAG(hi2s);
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0x9000             STR      R0,[SP, #+0]
   \       0x96   0x6828             LDR      R0,[R5, #+0]
   \       0x98   0x68C0             LDR      R0,[R0, #+12]
   \       0x9A   0x9000             STR      R0,[SP, #+0]
   \       0x9C   0x6828             LDR      R0,[R5, #+0]
   \       0x9E   0x6880             LDR      R0,[R0, #+8]
   \       0xA0   0x9000             STR      R0,[SP, #+0]
   \       0xA2   0x9800             LDR      R0,[SP, #+0]
   1008            }
   1009          
   1010            /* Receive data */
   1011            while (hi2s->RxXferCount > 0U)
   \                     ??HAL_I2S_Receive_9: (+1)
   \       0xA4   0x8E68             LDRH     R0,[R5, #+50]
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD02F             BEQ.N    ??HAL_I2S_Receive_10
   1012            {
   1013              /* Wait until RXNE flag is set */
   1014              if (I2S_WaitFlagStateUntilTimeout(hi2s, I2S_FLAG_RXNE, SET, Timeout) != HAL_OK)
   \       0xAA   0x003B             MOVS     R3,R7
   \       0xAC   0x2201             MOVS     R2,#+1
   \       0xAE   0x2101             MOVS     R1,#+1
   \       0xB0   0x0028             MOVS     R0,R5
   \       0xB2   0x.... 0x....      BL       I2S_WaitFlagStateUntilTimeout
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD00B             BEQ.N    ??HAL_I2S_Receive_11
   1015              {
   1016                /* Set the error code */
   1017                SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_TIMEOUT);
   \       0xBA   0x6C68             LDR      R0,[R5, #+68]
   \       0xBC   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xC0   0x6468             STR      R0,[R5, #+68]
   1018                hi2s->State = HAL_I2S_STATE_READY;
   \       0xC2   0x2001             MOVS     R0,#+1
   \       0xC4   0xF885 0x0041      STRB     R0,[R5, #+65]
   1019                __HAL_UNLOCK(hi2s);
   \       0xC8   0x2000             MOVS     R0,#+0
   \       0xCA   0xF885 0x0040      STRB     R0,[R5, #+64]
   1020                return HAL_ERROR;
   \       0xCE   0x2001             MOVS     R0,#+1
   \       0xD0   0xE022             B.N      ??HAL_I2S_Receive_2
   1021              }
   1022          
   1023              (*hi2s->pRxBuffPtr) = (uint16_t)hi2s->Instance->DR;
   \                     ??HAL_I2S_Receive_11: (+1)
   \       0xD2   0x6828             LDR      R0,[R5, #+0]
   \       0xD4   0x68C0             LDR      R0,[R0, #+12]
   \       0xD6   0x6AE9             LDR      R1,[R5, #+44]
   \       0xD8   0x8008             STRH     R0,[R1, #+0]
   1024              hi2s->pRxBuffPtr++;
   \       0xDA   0x6AE8             LDR      R0,[R5, #+44]
   \       0xDC   0x1C80             ADDS     R0,R0,#+2
   \       0xDE   0x62E8             STR      R0,[R5, #+44]
   1025              hi2s->RxXferCount--;
   \       0xE0   0x8E68             LDRH     R0,[R5, #+50]
   \       0xE2   0x1E40             SUBS     R0,R0,#+1
   \       0xE4   0x8668             STRH     R0,[R5, #+50]
   1026          
   1027              /* Check if an overrun occurs */
   1028              if (__HAL_I2S_GET_FLAG(hi2s, I2S_FLAG_OVR) == SET)
   \       0xE6   0x6828             LDR      R0,[R5, #+0]
   \       0xE8   0x6880             LDR      R0,[R0, #+8]
   \       0xEA   0x0640             LSLS     R0,R0,#+25
   \       0xEC   0xD5DA             BPL.N    ??HAL_I2S_Receive_9
   1029              {
   1030                /* Clear overrun flag */
   1031                __HAL_I2S_CLEAR_OVRFLAG(hi2s);
   \       0xEE   0x2000             MOVS     R0,#+0
   \       0xF0   0x9000             STR      R0,[SP, #+0]
   \       0xF2   0x6828             LDR      R0,[R5, #+0]
   \       0xF4   0x68C0             LDR      R0,[R0, #+12]
   \       0xF6   0x9000             STR      R0,[SP, #+0]
   \       0xF8   0x6828             LDR      R0,[R5, #+0]
   \       0xFA   0x6880             LDR      R0,[R0, #+8]
   \       0xFC   0x9000             STR      R0,[SP, #+0]
   \       0xFE   0x9800             LDR      R0,[SP, #+0]
   1032          
   1033                /* Set the error code */
   1034                SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
   \      0x100   0x6C68             LDR      R0,[R5, #+68]
   \      0x102   0xF050 0x0002      ORRS     R0,R0,#0x2
   \      0x106   0x6468             STR      R0,[R5, #+68]
   \      0x108   0xE7CC             B.N      ??HAL_I2S_Receive_9
   1035              }
   1036            }
   1037          
   1038            hi2s->State = HAL_I2S_STATE_READY;
   \                     ??HAL_I2S_Receive_10: (+1)
   \      0x10A   0x2001             MOVS     R0,#+1
   \      0x10C   0xF885 0x0041      STRB     R0,[R5, #+65]
   1039            __HAL_UNLOCK(hi2s);
   \      0x110   0x2000             MOVS     R0,#+0
   \      0x112   0xF885 0x0040      STRB     R0,[R5, #+64]
   1040            return HAL_OK;
   \      0x116   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2S_Receive_2: (+1)
   \      0x118   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   1041          }
   1042          
   1043          /**
   1044            * @brief  Transmit an amount of data in non-blocking mode with Interrupt
   1045            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   1046            *         the configuration information for I2S module
   1047            * @param  pData a 16-bit pointer to data buffer.
   1048            * @param  Size number of data sample to be sent:
   1049            * @note   When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
   1050            *         configuration phase, the Size parameter means the number of 16-bit data length
   1051            *         in the transaction and when a 24-bit data frame or a 32-bit data frame is selected
   1052            *         the Size parameter means the number of 16-bit data length.
   1053            * @note   The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization
   1054            *         between Master and Slave(example: audio streaming).
   1055            * @retval HAL status
   1056            */

   \                                 In section .text, align 2, keep-with-next
   1057          HAL_StatusTypeDef HAL_I2S_Transmit_IT(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
   1058          {
   \                     HAL_I2S_Transmit_IT: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x0003             MOVS     R3,R0
   1059            uint32_t tmpreg_cfgr;
   1060          
   1061            if ((pData == NULL) || (Size == 0U))
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD003             BEQ.N    ??HAL_I2S_Transmit_IT_0
   \        0x8   0x0010             MOVS     R0,R2
   \        0xA   0xB280             UXTH     R0,R0
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD101             BNE.N    ??HAL_I2S_Transmit_IT_1
   1062            {
   1063              return  HAL_ERROR;
   \                     ??HAL_I2S_Transmit_IT_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xE03A             B.N      ??HAL_I2S_Transmit_IT_2
   1064            }
   1065          
   1066            /* Process Locked */
   1067            __HAL_LOCK(hi2s);
   \                     ??HAL_I2S_Transmit_IT_1: (+1)
   \       0x14   0xF893 0x0040      LDRB     R0,[R3, #+64]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD101             BNE.N    ??HAL_I2S_Transmit_IT_3
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0xE034             B.N      ??HAL_I2S_Transmit_IT_2
   \                     ??HAL_I2S_Transmit_IT_3: (+1)
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xF883 0x0040      STRB     R0,[R3, #+64]
   1068          
   1069            if (hi2s->State != HAL_I2S_STATE_READY)
   \       0x26   0xF893 0x0041      LDRB     R0,[R3, #+65]
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD004             BEQ.N    ??HAL_I2S_Transmit_IT_4
   1070            {
   1071              __HAL_UNLOCK(hi2s);
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xF883 0x0040      STRB     R0,[R3, #+64]
   1072              return HAL_BUSY;
   \       0x34   0x2002             MOVS     R0,#+2
   \       0x36   0xE028             B.N      ??HAL_I2S_Transmit_IT_2
   1073            }
   1074          
   1075            /* Set state and reset error code */
   1076            hi2s->State = HAL_I2S_STATE_BUSY_TX;
   \                     ??HAL_I2S_Transmit_IT_4: (+1)
   \       0x38   0x2003             MOVS     R0,#+3
   \       0x3A   0xF883 0x0041      STRB     R0,[R3, #+65]
   1077            hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x6458             STR      R0,[R3, #+68]
   1078            hi2s->pTxBuffPtr = pData;
   \       0x42   0x6259             STR      R1,[R3, #+36]
   1079          
   1080            tmpreg_cfgr = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
   \       0x44   0x6818             LDR      R0,[R3, #+0]
   \       0x46   0x69C4             LDR      R4,[R0, #+28]
   \       0x48   0xF014 0x0407      ANDS     R4,R4,#0x7
   1081          
   1082            if ((tmpreg_cfgr == I2S_DATAFORMAT_24B) || (tmpreg_cfgr == I2S_DATAFORMAT_32B))
   \       0x4C   0x2C03             CMP      R4,#+3
   \       0x4E   0xD001             BEQ.N    ??HAL_I2S_Transmit_IT_5
   \       0x50   0x2C05             CMP      R4,#+5
   \       0x52   0xD104             BNE.N    ??HAL_I2S_Transmit_IT_6
   1083            {
   1084              hi2s->TxXferSize = (Size << 1U);
   \                     ??HAL_I2S_Transmit_IT_5: (+1)
   \       0x54   0x0050             LSLS     R0,R2,#+1
   \       0x56   0x8518             STRH     R0,[R3, #+40]
   1085              hi2s->TxXferCount = (Size << 1U);
   \       0x58   0x0050             LSLS     R0,R2,#+1
   \       0x5A   0x8558             STRH     R0,[R3, #+42]
   \       0x5C   0xE001             B.N      ??HAL_I2S_Transmit_IT_7
   1086            }
   1087            else
   1088            {
   1089              hi2s->TxXferSize = Size;
   \                     ??HAL_I2S_Transmit_IT_6: (+1)
   \       0x5E   0x851A             STRH     R2,[R3, #+40]
   1090              hi2s->TxXferCount = Size;
   \       0x60   0x855A             STRH     R2,[R3, #+42]
   1091            }
   1092          
   1093            /* Enable TXE and ERR interrupt */
   1094            __HAL_I2S_ENABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
   \                     ??HAL_I2S_Transmit_IT_7: (+1)
   \       0x62   0x6818             LDR      R0,[R3, #+0]
   \       0x64   0x6840             LDR      R0,[R0, #+4]
   \       0x66   0xF050 0x00A0      ORRS     R0,R0,#0xA0
   \       0x6A   0x681D             LDR      R5,[R3, #+0]
   \       0x6C   0x6068             STR      R0,[R5, #+4]
   1095          
   1096            /* Check if the I2S is already enabled */
   1097            if ((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
   \       0x6E   0x6818             LDR      R0,[R3, #+0]
   \       0x70   0x69C0             LDR      R0,[R0, #+28]
   \       0x72   0x0540             LSLS     R0,R0,#+21
   \       0x74   0xD405             BMI.N    ??HAL_I2S_Transmit_IT_8
   1098            {
   1099              /* Enable I2S peripheral */
   1100              __HAL_I2S_ENABLE(hi2s);
   \       0x76   0x6818             LDR      R0,[R3, #+0]
   \       0x78   0x69C0             LDR      R0,[R0, #+28]
   \       0x7A   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0x7E   0x681D             LDR      R5,[R3, #+0]
   \       0x80   0x61E8             STR      R0,[R5, #+28]
   1101            }
   1102          
   1103            __HAL_UNLOCK(hi2s);
   \                     ??HAL_I2S_Transmit_IT_8: (+1)
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0xF883 0x0040      STRB     R0,[R3, #+64]
   1104            return HAL_OK;
   \       0x88   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2S_Transmit_IT_2: (+1)
   \       0x8A   0xBC30             POP      {R4,R5}
   \       0x8C   0x4770             BX       LR
   1105          }
   1106          
   1107          /**
   1108            * @brief  Receive an amount of data in non-blocking mode with Interrupt
   1109            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   1110            *         the configuration information for I2S module
   1111            * @param  pData a 16-bit pointer to the Receive data buffer.
   1112            * @param  Size number of data sample to be sent:
   1113            * @note   When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
   1114            *         configuration phase, the Size parameter means the number of 16-bit data length
   1115            *         in the transaction and when a 24-bit data frame or a 32-bit data frame is selected
   1116            *         the Size parameter means the number of 16-bit data length.
   1117            * @note   The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization
   1118            *         between Master and Slave(example: audio streaming).
   1119            * @note   It is recommended to use DMA for the I2S receiver to avoid de-synchronization
   1120            * between Master and Slave otherwise the I2S interrupt should be optimized.
   1121            * @retval HAL status
   1122            */

   \                                 In section .text, align 2, keep-with-next
   1123          HAL_StatusTypeDef HAL_I2S_Receive_IT(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
   1124          {
   \                     HAL_I2S_Receive_IT: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x0003             MOVS     R3,R0
   1125            uint32_t tmpreg_cfgr;
   1126          
   1127            if ((pData == NULL) || (Size == 0U))
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD003             BEQ.N    ??HAL_I2S_Receive_IT_0
   \        0x8   0x0010             MOVS     R0,R2
   \        0xA   0xB280             UXTH     R0,R0
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD101             BNE.N    ??HAL_I2S_Receive_IT_1
   1128            {
   1129              return  HAL_ERROR;
   \                     ??HAL_I2S_Receive_IT_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xE03A             B.N      ??HAL_I2S_Receive_IT_2
   1130            }
   1131          
   1132            /* Process Locked */
   1133            __HAL_LOCK(hi2s);
   \                     ??HAL_I2S_Receive_IT_1: (+1)
   \       0x14   0xF893 0x0040      LDRB     R0,[R3, #+64]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD101             BNE.N    ??HAL_I2S_Receive_IT_3
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0xE034             B.N      ??HAL_I2S_Receive_IT_2
   \                     ??HAL_I2S_Receive_IT_3: (+1)
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xF883 0x0040      STRB     R0,[R3, #+64]
   1134          
   1135            if (hi2s->State != HAL_I2S_STATE_READY)
   \       0x26   0xF893 0x0041      LDRB     R0,[R3, #+65]
   \       0x2A   0x2801             CMP      R0,#+1
   \       0x2C   0xD004             BEQ.N    ??HAL_I2S_Receive_IT_4
   1136            {
   1137              __HAL_UNLOCK(hi2s);
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xF883 0x0040      STRB     R0,[R3, #+64]
   1138              return HAL_BUSY;
   \       0x34   0x2002             MOVS     R0,#+2
   \       0x36   0xE028             B.N      ??HAL_I2S_Receive_IT_2
   1139            }
   1140          
   1141            /* Set state and reset error code */
   1142            hi2s->State = HAL_I2S_STATE_BUSY_RX;
   \                     ??HAL_I2S_Receive_IT_4: (+1)
   \       0x38   0x2004             MOVS     R0,#+4
   \       0x3A   0xF883 0x0041      STRB     R0,[R3, #+65]
   1143            hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x6458             STR      R0,[R3, #+68]
   1144            hi2s->pRxBuffPtr = pData;
   \       0x42   0x62D9             STR      R1,[R3, #+44]
   1145          
   1146            tmpreg_cfgr = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
   \       0x44   0x6818             LDR      R0,[R3, #+0]
   \       0x46   0x69C4             LDR      R4,[R0, #+28]
   \       0x48   0xF014 0x0407      ANDS     R4,R4,#0x7
   1147          
   1148            if ((tmpreg_cfgr == I2S_DATAFORMAT_24B) || (tmpreg_cfgr == I2S_DATAFORMAT_32B))
   \       0x4C   0x2C03             CMP      R4,#+3
   \       0x4E   0xD001             BEQ.N    ??HAL_I2S_Receive_IT_5
   \       0x50   0x2C05             CMP      R4,#+5
   \       0x52   0xD104             BNE.N    ??HAL_I2S_Receive_IT_6
   1149            {
   1150              hi2s->RxXferSize = (Size << 1U);
   \                     ??HAL_I2S_Receive_IT_5: (+1)
   \       0x54   0x0050             LSLS     R0,R2,#+1
   \       0x56   0x8618             STRH     R0,[R3, #+48]
   1151              hi2s->RxXferCount = (Size << 1U);
   \       0x58   0x0050             LSLS     R0,R2,#+1
   \       0x5A   0x8658             STRH     R0,[R3, #+50]
   \       0x5C   0xE001             B.N      ??HAL_I2S_Receive_IT_7
   1152            }
   1153            else
   1154            {
   1155              hi2s->RxXferSize = Size;
   \                     ??HAL_I2S_Receive_IT_6: (+1)
   \       0x5E   0x861A             STRH     R2,[R3, #+48]
   1156              hi2s->RxXferCount = Size;
   \       0x60   0x865A             STRH     R2,[R3, #+50]
   1157            }
   1158          
   1159            /* Enable RXNE and ERR interrupt */
   1160            __HAL_I2S_ENABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
   \                     ??HAL_I2S_Receive_IT_7: (+1)
   \       0x62   0x6818             LDR      R0,[R3, #+0]
   \       0x64   0x6840             LDR      R0,[R0, #+4]
   \       0x66   0xF050 0x0060      ORRS     R0,R0,#0x60
   \       0x6A   0x681D             LDR      R5,[R3, #+0]
   \       0x6C   0x6068             STR      R0,[R5, #+4]
   1161          
   1162            /* Check if the I2S is already enabled */
   1163            if ((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SE) != SPI_I2SCFGR_I2SE)
   \       0x6E   0x6818             LDR      R0,[R3, #+0]
   \       0x70   0x69C0             LDR      R0,[R0, #+28]
   \       0x72   0x0540             LSLS     R0,R0,#+21
   \       0x74   0xD405             BMI.N    ??HAL_I2S_Receive_IT_8
   1164            {
   1165              /* Enable I2S peripheral */
   1166              __HAL_I2S_ENABLE(hi2s);
   \       0x76   0x6818             LDR      R0,[R3, #+0]
   \       0x78   0x69C0             LDR      R0,[R0, #+28]
   \       0x7A   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0x7E   0x681D             LDR      R5,[R3, #+0]
   \       0x80   0x61E8             STR      R0,[R5, #+28]
   1167            }
   1168          
   1169            __HAL_UNLOCK(hi2s);
   \                     ??HAL_I2S_Receive_IT_8: (+1)
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0xF883 0x0040      STRB     R0,[R3, #+64]
   1170            return HAL_OK;
   \       0x88   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2S_Receive_IT_2: (+1)
   \       0x8A   0xBC30             POP      {R4,R5}
   \       0x8C   0x4770             BX       LR
   1171          }
   1172          
   1173          /**
   1174            * @brief  Transmit an amount of data in non-blocking mode with DMA
   1175            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   1176            *         the configuration information for I2S module
   1177            * @param  pData a 16-bit pointer to the Transmit data buffer.
   1178            * @param  Size number of data sample to be sent:
   1179            * @note   When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
   1180            *         configuration phase, the Size parameter means the number of 16-bit data length
   1181            *         in the transaction and when a 24-bit data frame or a 32-bit data frame is selected
   1182            *         the Size parameter means the number of 16-bit data length.
   1183            * @note   The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization
   1184            *         between Master and Slave(example: audio streaming).
   1185            * @retval HAL status
   1186            */

   \                                 In section .text, align 2, keep-with-next
   1187          HAL_StatusTypeDef HAL_I2S_Transmit_DMA(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
   1188          {
   \                     HAL_I2S_Transmit_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0016             MOVS     R6,R2
   1189            uint32_t tmpreg_cfgr;
   1190          
   1191            if ((pData == NULL) || (Size == 0U))
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD003             BEQ.N    ??HAL_I2S_Transmit_DMA_0
   \        0xC   0x0030             MOVS     R0,R6
   \        0xE   0xB280             UXTH     R0,R0
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD101             BNE.N    ??HAL_I2S_Transmit_DMA_1
   1192            {
   1193              return  HAL_ERROR;
   \                     ??HAL_I2S_Transmit_DMA_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xE060             B.N      ??HAL_I2S_Transmit_DMA_2
   1194            }
   1195          
   1196            /* Process Locked */
   1197            __HAL_LOCK(hi2s);
   \                     ??HAL_I2S_Transmit_DMA_1: (+1)
   \       0x18   0xF895 0x0040      LDRB     R0,[R5, #+64]
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xD101             BNE.N    ??HAL_I2S_Transmit_DMA_3
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xE05A             B.N      ??HAL_I2S_Transmit_DMA_2
   \                     ??HAL_I2S_Transmit_DMA_3: (+1)
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xF885 0x0040      STRB     R0,[R5, #+64]
   1198          
   1199            if (hi2s->State != HAL_I2S_STATE_READY)
   \       0x2A   0xF895 0x0041      LDRB     R0,[R5, #+65]
   \       0x2E   0x2801             CMP      R0,#+1
   \       0x30   0xD004             BEQ.N    ??HAL_I2S_Transmit_DMA_4
   1200            {
   1201              __HAL_UNLOCK(hi2s);
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xF885 0x0040      STRB     R0,[R5, #+64]
   1202              return HAL_BUSY;
   \       0x38   0x2002             MOVS     R0,#+2
   \       0x3A   0xE04E             B.N      ??HAL_I2S_Transmit_DMA_2
   1203            }
   1204          
   1205            /* Set state and reset error code */
   1206            hi2s->State = HAL_I2S_STATE_BUSY_TX;
   \                     ??HAL_I2S_Transmit_DMA_4: (+1)
   \       0x3C   0x2003             MOVS     R0,#+3
   \       0x3E   0xF885 0x0041      STRB     R0,[R5, #+65]
   1207            hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x6468             STR      R0,[R5, #+68]
   1208            hi2s->pTxBuffPtr = pData;
   \       0x46   0x626C             STR      R4,[R5, #+36]
   1209          
   1210            tmpreg_cfgr = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
   \       0x48   0x6828             LDR      R0,[R5, #+0]
   \       0x4A   0x69C7             LDR      R7,[R0, #+28]
   \       0x4C   0xF017 0x0707      ANDS     R7,R7,#0x7
   1211          
   1212            if ((tmpreg_cfgr == I2S_DATAFORMAT_24B) || (tmpreg_cfgr == I2S_DATAFORMAT_32B))
   \       0x50   0x2F03             CMP      R7,#+3
   \       0x52   0xD001             BEQ.N    ??HAL_I2S_Transmit_DMA_5
   \       0x54   0x2F05             CMP      R7,#+5
   \       0x56   0xD104             BNE.N    ??HAL_I2S_Transmit_DMA_6
   1213            {
   1214              hi2s->TxXferSize = (Size << 1U);
   \                     ??HAL_I2S_Transmit_DMA_5: (+1)
   \       0x58   0x0070             LSLS     R0,R6,#+1
   \       0x5A   0x8528             STRH     R0,[R5, #+40]
   1215              hi2s->TxXferCount = (Size << 1U);
   \       0x5C   0x0070             LSLS     R0,R6,#+1
   \       0x5E   0x8568             STRH     R0,[R5, #+42]
   \       0x60   0xE001             B.N      ??HAL_I2S_Transmit_DMA_7
   1216            }
   1217            else
   1218            {
   1219              hi2s->TxXferSize = Size;
   \                     ??HAL_I2S_Transmit_DMA_6: (+1)
   \       0x62   0x852E             STRH     R6,[R5, #+40]
   1220              hi2s->TxXferCount = Size;
   \       0x64   0x856E             STRH     R6,[R5, #+42]
   1221            }
   1222          
   1223            /* Set the I2S Tx DMA Half transfer complete callback */
   1224            hi2s->hdmatx->XferHalfCpltCallback = I2S_DMATxHalfCplt;
   \                     ??HAL_I2S_Transmit_DMA_7: (+1)
   \       0x66   0x.... 0x....      ADR.W    R0,I2S_DMATxHalfCplt
   \       0x6A   0x6BA9             LDR      R1,[R5, #+56]
   \       0x6C   0x6408             STR      R0,[R1, #+64]
   1225          
   1226            /* Set the I2S Tx DMA transfer complete callback */
   1227            hi2s->hdmatx->XferCpltCallback = I2S_DMATxCplt;
   \       0x6E   0x.... 0x....      ADR.W    R0,I2S_DMATxCplt
   \       0x72   0x6BA9             LDR      R1,[R5, #+56]
   \       0x74   0x63C8             STR      R0,[R1, #+60]
   1228          
   1229            /* Set the DMA error callback */
   1230            hi2s->hdmatx->XferErrorCallback = I2S_DMAError;
   \       0x76   0x.... 0x....      ADR.W    R0,I2S_DMAError
   \       0x7A   0x6BA9             LDR      R1,[R5, #+56]
   \       0x7C   0x64C8             STR      R0,[R1, #+76]
   1231          
   1232            /* Enable the Tx DMA Stream/Channel */
   1233            if (HAL_OK != HAL_DMA_Start_IT(hi2s->hdmatx,
   1234                                           (uint32_t)hi2s->pTxBuffPtr,
   1235                                           (uint32_t)&hi2s->Instance->DR,
   1236                                           hi2s->TxXferSize))
   \       0x7E   0x8D2B             LDRH     R3,[R5, #+40]
   \       0x80   0x6828             LDR      R0,[R5, #+0]
   \       0x82   0xF110 0x020C      ADDS     R2,R0,#+12
   \       0x86   0x6A69             LDR      R1,[R5, #+36]
   \       0x88   0x6BA8             LDR      R0,[R5, #+56]
   \       0x8A   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD00B             BEQ.N    ??HAL_I2S_Transmit_DMA_8
   1237            {
   1238              /* Update SPI error code */
   1239              SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_DMA);
   \       0x92   0x6C68             LDR      R0,[R5, #+68]
   \       0x94   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0x98   0x6468             STR      R0,[R5, #+68]
   1240              hi2s->State = HAL_I2S_STATE_READY;
   \       0x9A   0x2001             MOVS     R0,#+1
   \       0x9C   0xF885 0x0041      STRB     R0,[R5, #+65]
   1241          
   1242              __HAL_UNLOCK(hi2s);
   \       0xA0   0x2000             MOVS     R0,#+0
   \       0xA2   0xF885 0x0040      STRB     R0,[R5, #+64]
   1243              return HAL_ERROR;
   \       0xA6   0x2001             MOVS     R0,#+1
   \       0xA8   0xE017             B.N      ??HAL_I2S_Transmit_DMA_2
   1244            }
   1245          
   1246            /* Check if the I2S is already enabled */
   1247            if (HAL_IS_BIT_CLR(hi2s->Instance->I2SCFGR, SPI_I2SCFGR_I2SE))
   \                     ??HAL_I2S_Transmit_DMA_8: (+1)
   \       0xAA   0x6828             LDR      R0,[R5, #+0]
   \       0xAC   0x69C0             LDR      R0,[R0, #+28]
   \       0xAE   0x0540             LSLS     R0,R0,#+21
   \       0xB0   0xD405             BMI.N    ??HAL_I2S_Transmit_DMA_9
   1248            {
   1249              /* Enable I2S peripheral */
   1250              __HAL_I2S_ENABLE(hi2s);
   \       0xB2   0x6828             LDR      R0,[R5, #+0]
   \       0xB4   0x69C0             LDR      R0,[R0, #+28]
   \       0xB6   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0xBA   0x6829             LDR      R1,[R5, #+0]
   \       0xBC   0x61C8             STR      R0,[R1, #+28]
   1251            }
   1252          
   1253            /* Check if the I2S Tx request is already enabled */
   1254            if (HAL_IS_BIT_CLR(hi2s->Instance->CR2, SPI_CR2_TXDMAEN))
   \                     ??HAL_I2S_Transmit_DMA_9: (+1)
   \       0xBE   0x6828             LDR      R0,[R5, #+0]
   \       0xC0   0x6840             LDR      R0,[R0, #+4]
   \       0xC2   0x0780             LSLS     R0,R0,#+30
   \       0xC4   0xD405             BMI.N    ??HAL_I2S_Transmit_DMA_10
   1255            {
   1256              /* Enable Tx DMA Request */
   1257              SET_BIT(hi2s->Instance->CR2, SPI_CR2_TXDMAEN);
   \       0xC6   0x6828             LDR      R0,[R5, #+0]
   \       0xC8   0x6840             LDR      R0,[R0, #+4]
   \       0xCA   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0xCE   0x6829             LDR      R1,[R5, #+0]
   \       0xD0   0x6048             STR      R0,[R1, #+4]
   1258            }
   1259          
   1260            __HAL_UNLOCK(hi2s);
   \                     ??HAL_I2S_Transmit_DMA_10: (+1)
   \       0xD2   0x2000             MOVS     R0,#+0
   \       0xD4   0xF885 0x0040      STRB     R0,[R5, #+64]
   1261            return HAL_OK;
   \       0xD8   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2S_Transmit_DMA_2: (+1)
   \       0xDA   0xBDF2             POP      {R1,R4-R7,PC}
   1262          }
   1263          
   1264          /**
   1265            * @brief  Receive an amount of data in non-blocking mode with DMA
   1266            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   1267            *         the configuration information for I2S module
   1268            * @param  pData a 16-bit pointer to the Receive data buffer.
   1269            * @param  Size number of data sample to be sent:
   1270            * @note   When a 16-bit data frame or a 16-bit data frame extended is selected during the I2S
   1271            *         configuration phase, the Size parameter means the number of 16-bit data length
   1272            *         in the transaction and when a 24-bit data frame or a 32-bit data frame is selected
   1273            *         the Size parameter means the number of 16-bit data length.
   1274            * @note   The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization
   1275            *         between Master and Slave(example: audio streaming).
   1276            * @retval HAL status
   1277            */

   \                                 In section .text, align 2, keep-with-next
   1278          HAL_StatusTypeDef HAL_I2S_Receive_DMA(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
   1279          {
   \                     HAL_I2S_Receive_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0016             MOVS     R6,R2
   1280            uint32_t tmpreg_cfgr;
   1281          
   1282            if ((pData == NULL) || (Size == 0U))
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD003             BEQ.N    ??HAL_I2S_Receive_DMA_0
   \        0xC   0x0030             MOVS     R0,R6
   \        0xE   0xB280             UXTH     R0,R0
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD101             BNE.N    ??HAL_I2S_Receive_DMA_1
   1283            {
   1284              return  HAL_ERROR;
   \                     ??HAL_I2S_Receive_DMA_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xE070             B.N      ??HAL_I2S_Receive_DMA_2
   1285            }
   1286          
   1287            /* Process Locked */
   1288            __HAL_LOCK(hi2s);
   \                     ??HAL_I2S_Receive_DMA_1: (+1)
   \       0x18   0xF895 0x0040      LDRB     R0,[R5, #+64]
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xD101             BNE.N    ??HAL_I2S_Receive_DMA_3
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0xE06A             B.N      ??HAL_I2S_Receive_DMA_2
   \                     ??HAL_I2S_Receive_DMA_3: (+1)
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xF885 0x0040      STRB     R0,[R5, #+64]
   1289          
   1290            if (hi2s->State != HAL_I2S_STATE_READY)
   \       0x2A   0xF895 0x0041      LDRB     R0,[R5, #+65]
   \       0x2E   0x2801             CMP      R0,#+1
   \       0x30   0xD004             BEQ.N    ??HAL_I2S_Receive_DMA_4
   1291            {
   1292              __HAL_UNLOCK(hi2s);
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xF885 0x0040      STRB     R0,[R5, #+64]
   1293              return HAL_BUSY;
   \       0x38   0x2002             MOVS     R0,#+2
   \       0x3A   0xE05E             B.N      ??HAL_I2S_Receive_DMA_2
   1294            }
   1295          
   1296            /* Set state and reset error code */
   1297            hi2s->State = HAL_I2S_STATE_BUSY_RX;
   \                     ??HAL_I2S_Receive_DMA_4: (+1)
   \       0x3C   0x2004             MOVS     R0,#+4
   \       0x3E   0xF885 0x0041      STRB     R0,[R5, #+65]
   1298            hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x6468             STR      R0,[R5, #+68]
   1299            hi2s->pRxBuffPtr = pData;
   \       0x46   0x62EC             STR      R4,[R5, #+44]
   1300          
   1301            tmpreg_cfgr = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
   \       0x48   0x6828             LDR      R0,[R5, #+0]
   \       0x4A   0x69C7             LDR      R7,[R0, #+28]
   \       0x4C   0xF017 0x0707      ANDS     R7,R7,#0x7
   1302          
   1303            if ((tmpreg_cfgr == I2S_DATAFORMAT_24B) || (tmpreg_cfgr == I2S_DATAFORMAT_32B))
   \       0x50   0x2F03             CMP      R7,#+3
   \       0x52   0xD001             BEQ.N    ??HAL_I2S_Receive_DMA_5
   \       0x54   0x2F05             CMP      R7,#+5
   \       0x56   0xD104             BNE.N    ??HAL_I2S_Receive_DMA_6
   1304            {
   1305              hi2s->RxXferSize = (Size << 1U);
   \                     ??HAL_I2S_Receive_DMA_5: (+1)
   \       0x58   0x0070             LSLS     R0,R6,#+1
   \       0x5A   0x8628             STRH     R0,[R5, #+48]
   1306              hi2s->RxXferCount = (Size << 1U);
   \       0x5C   0x0070             LSLS     R0,R6,#+1
   \       0x5E   0x8668             STRH     R0,[R5, #+50]
   \       0x60   0xE001             B.N      ??HAL_I2S_Receive_DMA_7
   1307            }
   1308            else
   1309            {
   1310              hi2s->RxXferSize = Size;
   \                     ??HAL_I2S_Receive_DMA_6: (+1)
   \       0x62   0x862E             STRH     R6,[R5, #+48]
   1311              hi2s->RxXferCount = Size;
   \       0x64   0x866E             STRH     R6,[R5, #+50]
   1312            }
   1313          
   1314            /* Set the I2S Rx DMA Half transfer complete callback */
   1315            hi2s->hdmarx->XferHalfCpltCallback = I2S_DMARxHalfCplt;
   \                     ??HAL_I2S_Receive_DMA_7: (+1)
   \       0x66   0x.... 0x....      ADR.W    R0,I2S_DMARxHalfCplt
   \       0x6A   0x6BE9             LDR      R1,[R5, #+60]
   \       0x6C   0x6408             STR      R0,[R1, #+64]
   1316          
   1317            /* Set the I2S Rx DMA transfer complete callback */
   1318            hi2s->hdmarx->XferCpltCallback = I2S_DMARxCplt;
   \       0x6E   0x.... 0x....      ADR.W    R0,I2S_DMARxCplt
   \       0x72   0x6BE9             LDR      R1,[R5, #+60]
   \       0x74   0x63C8             STR      R0,[R1, #+60]
   1319          
   1320            /* Set the DMA error callback */
   1321            hi2s->hdmarx->XferErrorCallback = I2S_DMAError;
   \       0x76   0x.... 0x....      ADR.W    R0,I2S_DMAError
   \       0x7A   0x6BE9             LDR      R1,[R5, #+60]
   \       0x7C   0x64C8             STR      R0,[R1, #+76]
   1322          
   1323            /* Check if Master Receiver mode is selected */
   1324            if ((hi2s->Instance->I2SCFGR & SPI_I2SCFGR_I2SCFG) == I2S_MODE_MASTER_RX)
   \       0x7E   0x6828             LDR      R0,[R5, #+0]
   \       0x80   0x69C0             LDR      R0,[R0, #+28]
   \       0x82   0xF410 0x7040      ANDS     R0,R0,#0x300
   \       0x86   0xF5B0 0x7F40      CMP      R0,#+768
   \       0x8A   0xD108             BNE.N    ??HAL_I2S_Receive_DMA_8
   1325            {
   1326              /* Clear the Overrun Flag by a read operation to the SPI_DR register followed by a read
   1327              access to the SPI_SR register. */
   1328              __HAL_I2S_CLEAR_OVRFLAG(hi2s);
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0x9000             STR      R0,[SP, #+0]
   \       0x90   0x6828             LDR      R0,[R5, #+0]
   \       0x92   0x68C0             LDR      R0,[R0, #+12]
   \       0x94   0x9000             STR      R0,[SP, #+0]
   \       0x96   0x6828             LDR      R0,[R5, #+0]
   \       0x98   0x6880             LDR      R0,[R0, #+8]
   \       0x9A   0x9000             STR      R0,[SP, #+0]
   \       0x9C   0x9800             LDR      R0,[SP, #+0]
   1329            }
   1330          
   1331            /* Enable the Rx DMA Stream/Channel */
   1332            if (HAL_OK != HAL_DMA_Start_IT(hi2s->hdmarx, (uint32_t)&hi2s->Instance->DR, (uint32_t)hi2s->pRxBuffPtr,
   1333                                           hi2s->RxXferSize))
   \                     ??HAL_I2S_Receive_DMA_8: (+1)
   \       0x9E   0x8E2B             LDRH     R3,[R5, #+48]
   \       0xA0   0x6AEA             LDR      R2,[R5, #+44]
   \       0xA2   0x6828             LDR      R0,[R5, #+0]
   \       0xA4   0xF110 0x010C      ADDS     R1,R0,#+12
   \       0xA8   0x6BE8             LDR      R0,[R5, #+60]
   \       0xAA   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD00B             BEQ.N    ??HAL_I2S_Receive_DMA_9
   1334            {
   1335              /* Update SPI error code */
   1336              SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_DMA);
   \       0xB2   0x6C68             LDR      R0,[R5, #+68]
   \       0xB4   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0xB8   0x6468             STR      R0,[R5, #+68]
   1337              hi2s->State = HAL_I2S_STATE_READY;
   \       0xBA   0x2001             MOVS     R0,#+1
   \       0xBC   0xF885 0x0041      STRB     R0,[R5, #+65]
   1338          
   1339              __HAL_UNLOCK(hi2s);
   \       0xC0   0x2000             MOVS     R0,#+0
   \       0xC2   0xF885 0x0040      STRB     R0,[R5, #+64]
   1340              return HAL_ERROR;
   \       0xC6   0x2001             MOVS     R0,#+1
   \       0xC8   0xE017             B.N      ??HAL_I2S_Receive_DMA_2
   1341            }
   1342          
   1343            /* Check if the I2S is already enabled */
   1344            if (HAL_IS_BIT_CLR(hi2s->Instance->I2SCFGR, SPI_I2SCFGR_I2SE))
   \                     ??HAL_I2S_Receive_DMA_9: (+1)
   \       0xCA   0x6828             LDR      R0,[R5, #+0]
   \       0xCC   0x69C0             LDR      R0,[R0, #+28]
   \       0xCE   0x0540             LSLS     R0,R0,#+21
   \       0xD0   0xD405             BMI.N    ??HAL_I2S_Receive_DMA_10
   1345            {
   1346              /* Enable I2S peripheral */
   1347              __HAL_I2S_ENABLE(hi2s);
   \       0xD2   0x6828             LDR      R0,[R5, #+0]
   \       0xD4   0x69C0             LDR      R0,[R0, #+28]
   \       0xD6   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0xDA   0x6829             LDR      R1,[R5, #+0]
   \       0xDC   0x61C8             STR      R0,[R1, #+28]
   1348            }
   1349          
   1350            /* Check if the I2S Rx request is already enabled */
   1351            if (HAL_IS_BIT_CLR(hi2s->Instance->CR2, SPI_CR2_RXDMAEN))
   \                     ??HAL_I2S_Receive_DMA_10: (+1)
   \       0xDE   0x6828             LDR      R0,[R5, #+0]
   \       0xE0   0x6840             LDR      R0,[R0, #+4]
   \       0xE2   0x07C0             LSLS     R0,R0,#+31
   \       0xE4   0xD405             BMI.N    ??HAL_I2S_Receive_DMA_11
   1352            {
   1353              /* Enable Rx DMA Request */
   1354              SET_BIT(hi2s->Instance->CR2, SPI_CR2_RXDMAEN);
   \       0xE6   0x6828             LDR      R0,[R5, #+0]
   \       0xE8   0x6840             LDR      R0,[R0, #+4]
   \       0xEA   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xEE   0x6829             LDR      R1,[R5, #+0]
   \       0xF0   0x6048             STR      R0,[R1, #+4]
   1355            }
   1356          
   1357            __HAL_UNLOCK(hi2s);
   \                     ??HAL_I2S_Receive_DMA_11: (+1)
   \       0xF2   0x2000             MOVS     R0,#+0
   \       0xF4   0xF885 0x0040      STRB     R0,[R5, #+64]
   1358            return HAL_OK;
   \       0xF8   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2S_Receive_DMA_2: (+1)
   \       0xFA   0xBDF2             POP      {R1,R4-R7,PC}
   1359          }
   1360          
   1361          /**
   1362            * @brief  Pauses the audio DMA Stream/Channel playing from the Media.
   1363            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   1364            *         the configuration information for I2S module
   1365            * @retval HAL status
   1366            */

   \                                 In section .text, align 2, keep-with-next
   1367          HAL_StatusTypeDef HAL_I2S_DMAPause(I2S_HandleTypeDef *hi2s)
   1368          {
   \                     HAL_I2S_DMAPause: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   1369            /* Process Locked */
   1370            __HAL_LOCK(hi2s);
   \        0x2   0xF891 0x0040      LDRB     R0,[R1, #+64]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD101             BNE.N    ??HAL_I2S_DMAPause_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xE034             B.N      ??HAL_I2S_DMAPause_1
   \                     ??HAL_I2S_DMAPause_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF881 0x0040      STRB     R0,[R1, #+64]
   1371          
   1372            if (hi2s->State == HAL_I2S_STATE_BUSY_TX)
   \       0x14   0xF891 0x0041      LDRB     R0,[R1, #+65]
   \       0x18   0x2803             CMP      R0,#+3
   \       0x1A   0xD106             BNE.N    ??HAL_I2S_DMAPause_2
   1373            {
   1374              /* Disable the I2S DMA Tx request */
   1375              CLEAR_BIT(hi2s->Instance->CR2, SPI_CR2_TXDMAEN);
   \       0x1C   0x6808             LDR      R0,[R1, #+0]
   \       0x1E   0x6840             LDR      R0,[R0, #+4]
   \       0x20   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x24   0x680A             LDR      R2,[R1, #+0]
   \       0x26   0x6050             STR      R0,[R2, #+4]
   \       0x28   0xE022             B.N      ??HAL_I2S_DMAPause_3
   1376            }
   1377            else if (hi2s->State == HAL_I2S_STATE_BUSY_RX)
   \                     ??HAL_I2S_DMAPause_2: (+1)
   \       0x2A   0xF891 0x0041      LDRB     R0,[R1, #+65]
   \       0x2E   0x2804             CMP      R0,#+4
   \       0x30   0xD106             BNE.N    ??HAL_I2S_DMAPause_4
   1378            {
   1379              /* Disable the I2S DMA Rx request */
   1380              CLEAR_BIT(hi2s->Instance->CR2, SPI_CR2_RXDMAEN);
   \       0x32   0x6808             LDR      R0,[R1, #+0]
   \       0x34   0x6840             LDR      R0,[R0, #+4]
   \       0x36   0x0840             LSRS     R0,R0,#+1
   \       0x38   0x0040             LSLS     R0,R0,#+1
   \       0x3A   0x680A             LDR      R2,[R1, #+0]
   \       0x3C   0x6050             STR      R0,[R2, #+4]
   \       0x3E   0xE017             B.N      ??HAL_I2S_DMAPause_3
   1381            }
   1382          #if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
   1383            else if (hi2s->State == HAL_I2S_STATE_BUSY_TX_RX)
   \                     ??HAL_I2S_DMAPause_4: (+1)
   \       0x40   0xF891 0x0041      LDRB     R0,[R1, #+65]
   \       0x44   0x2805             CMP      R0,#+5
   \       0x46   0xD113             BNE.N    ??HAL_I2S_DMAPause_3
   1384            {
   1385              /* Pause the audio file playing by disabling the I2S DMA request */
   1386              CLEAR_BIT(hi2s->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
   \       0x48   0x6808             LDR      R0,[R1, #+0]
   \       0x4A   0x6840             LDR      R0,[R0, #+4]
   \       0x4C   0x0880             LSRS     R0,R0,#+2
   \       0x4E   0x0080             LSLS     R0,R0,#+2
   \       0x50   0x680A             LDR      R2,[R1, #+0]
   \       0x52   0x6050             STR      R0,[R2, #+4]
   1387              CLEAR_BIT(I2SxEXT(hi2s->Instance)->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
   \       0x54   0x6808             LDR      R0,[R1, #+0]
   \       0x56   0x.... 0x....      LDR.W    R2,??DataTable3_2
   \       0x5A   0x4290             CMP      R0,R2
   \       0x5C   0xD102             BNE.N    ??HAL_I2S_DMAPause_5
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable3_3
   \       0x62   0xE001             B.N      ??HAL_I2S_DMAPause_6
   \                     ??HAL_I2S_DMAPause_5: (+1)
   \       0x64   0xF05F 0x2040      MOVS     R0,#+1073758208
   \                     ??HAL_I2S_DMAPause_6: (+1)
   \       0x68   0x6842             LDR      R2,[R0, #+4]
   \       0x6A   0x0892             LSRS     R2,R2,#+2
   \       0x6C   0x0092             LSLS     R2,R2,#+2
   \       0x6E   0x6042             STR      R2,[R0, #+4]
   1388            }
   1389          #endif /* SPI_I2S_FULLDUPLEX_SUPPORT */
   1390            else
   1391            {
   1392              /* nothing to do */
   1393            }
   1394          
   1395            /* Process Unlocked */
   1396            __HAL_UNLOCK(hi2s);
   \                     ??HAL_I2S_DMAPause_3: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0xF881 0x0040      STRB     R0,[R1, #+64]
   1397          
   1398            return HAL_OK;
   \       0x76   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2S_DMAPause_1: (+1)
   \       0x78   0x4770             BX       LR
   1399          }
   1400          
   1401          /**
   1402            * @brief  Resumes the audio DMA Stream/Channel playing from the Media.
   1403            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   1404            *         the configuration information for I2S module
   1405            * @retval HAL status
   1406            */

   \                                 In section .text, align 2, keep-with-next
   1407          HAL_StatusTypeDef HAL_I2S_DMAResume(I2S_HandleTypeDef *hi2s)
   1408          {
   \                     HAL_I2S_DMAResume: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   1409            /* Process Locked */
   1410            __HAL_LOCK(hi2s);
   \        0x2   0xF891 0x0040      LDRB     R0,[R1, #+64]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD101             BNE.N    ??HAL_I2S_DMAResume_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xE051             B.N      ??HAL_I2S_DMAResume_1
   \                     ??HAL_I2S_DMAResume_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF881 0x0040      STRB     R0,[R1, #+64]
   1411          
   1412            if (hi2s->State == HAL_I2S_STATE_BUSY_TX)
   \       0x14   0xF891 0x0041      LDRB     R0,[R1, #+65]
   \       0x18   0x2803             CMP      R0,#+3
   \       0x1A   0xD106             BNE.N    ??HAL_I2S_DMAResume_2
   1413            {
   1414              /* Enable the I2S DMA Tx request */
   1415              SET_BIT(hi2s->Instance->CR2, SPI_CR2_TXDMAEN);
   \       0x1C   0x6808             LDR      R0,[R1, #+0]
   \       0x1E   0x6840             LDR      R0,[R0, #+4]
   \       0x20   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x24   0x680A             LDR      R2,[R1, #+0]
   \       0x26   0x6050             STR      R0,[R2, #+4]
   \       0x28   0xE035             B.N      ??HAL_I2S_DMAResume_3
   1416            }
   1417            else if (hi2s->State == HAL_I2S_STATE_BUSY_RX)
   \                     ??HAL_I2S_DMAResume_2: (+1)
   \       0x2A   0xF891 0x0041      LDRB     R0,[R1, #+65]
   \       0x2E   0x2804             CMP      R0,#+4
   \       0x30   0xD106             BNE.N    ??HAL_I2S_DMAResume_4
   1418            {
   1419              /* Enable the I2S DMA Rx request */
   1420              SET_BIT(hi2s->Instance->CR2, SPI_CR2_RXDMAEN);
   \       0x32   0x6808             LDR      R0,[R1, #+0]
   \       0x34   0x6840             LDR      R0,[R0, #+4]
   \       0x36   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x3A   0x680A             LDR      R2,[R1, #+0]
   \       0x3C   0x6050             STR      R0,[R2, #+4]
   \       0x3E   0xE02A             B.N      ??HAL_I2S_DMAResume_3
   1421            }
   1422          #if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
   1423            else if (hi2s->State == HAL_I2S_STATE_BUSY_TX_RX)
   \                     ??HAL_I2S_DMAResume_4: (+1)
   \       0x40   0xF891 0x0041      LDRB     R0,[R1, #+65]
   \       0x44   0x2805             CMP      R0,#+5
   \       0x46   0xD126             BNE.N    ??HAL_I2S_DMAResume_3
   1424            {
   1425              /* Pause the audio file playing by disabling the I2S DMA request */
   1426              SET_BIT(hi2s->Instance->CR2, (SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN));
   \       0x48   0x6808             LDR      R0,[R1, #+0]
   \       0x4A   0x6840             LDR      R0,[R0, #+4]
   \       0x4C   0xF050 0x0003      ORRS     R0,R0,#0x3
   \       0x50   0x680A             LDR      R2,[R1, #+0]
   \       0x52   0x6050             STR      R0,[R2, #+4]
   1427              SET_BIT(I2SxEXT(hi2s->Instance)->CR2, (SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN));
   \       0x54   0x....             LDR.N    R0,??DataTable3_2
   \       0x56   0x680A             LDR      R2,[R1, #+0]
   \       0x58   0x4282             CMP      R2,R0
   \       0x5A   0xD101             BNE.N    ??HAL_I2S_DMAResume_5
   \       0x5C   0x....             LDR.N    R2,??DataTable3_3
   \       0x5E   0xE001             B.N      ??HAL_I2S_DMAResume_6
   \                     ??HAL_I2S_DMAResume_5: (+1)
   \       0x60   0xF05F 0x2240      MOVS     R2,#+1073758208
   \                     ??HAL_I2S_DMAResume_6: (+1)
   \       0x64   0x6853             LDR      R3,[R2, #+4]
   \       0x66   0xF053 0x0303      ORRS     R3,R3,#0x3
   \       0x6A   0x6053             STR      R3,[R2, #+4]
   1428          
   1429              /* If the I2Sext peripheral is still not enabled, enable it */
   1430              if ((I2SxEXT(hi2s->Instance)->I2SCFGR & SPI_I2SCFGR_I2SE) == 0U)
   \       0x6C   0x680A             LDR      R2,[R1, #+0]
   \       0x6E   0x4282             CMP      R2,R0
   \       0x70   0xD101             BNE.N    ??HAL_I2S_DMAResume_7
   \       0x72   0x....             LDR.N    R2,??DataTable3_3
   \       0x74   0xE001             B.N      ??HAL_I2S_DMAResume_8
   \                     ??HAL_I2S_DMAResume_7: (+1)
   \       0x76   0xF05F 0x2240      MOVS     R2,#+1073758208
   \                     ??HAL_I2S_DMAResume_8: (+1)
   \       0x7A   0x69D2             LDR      R2,[R2, #+28]
   \       0x7C   0x0552             LSLS     R2,R2,#+21
   \       0x7E   0xD40A             BMI.N    ??HAL_I2S_DMAResume_3
   1431              {
   1432                /* Enable I2Sext peripheral */
   1433                __HAL_I2SEXT_ENABLE(hi2s);
   \       0x80   0x680A             LDR      R2,[R1, #+0]
   \       0x82   0x4282             CMP      R2,R0
   \       0x84   0xD101             BNE.N    ??HAL_I2S_DMAResume_9
   \       0x86   0x....             LDR.N    R0,??DataTable3_3
   \       0x88   0xE001             B.N      ??HAL_I2S_DMAResume_10
   \                     ??HAL_I2S_DMAResume_9: (+1)
   \       0x8A   0xF05F 0x2040      MOVS     R0,#+1073758208
   \                     ??HAL_I2S_DMAResume_10: (+1)
   \       0x8E   0x69C2             LDR      R2,[R0, #+28]
   \       0x90   0xF452 0x6280      ORRS     R2,R2,#0x400
   \       0x94   0x61C2             STR      R2,[R0, #+28]
   1434              }
   1435            }
   1436          #endif /* SPI_I2S_FULLDUPLEX_SUPPORT */
   1437            else
   1438            {
   1439              /* nothing to do */
   1440            }
   1441          
   1442            /* If the I2S peripheral is still not enabled, enable it */
   1443            if (HAL_IS_BIT_CLR(hi2s->Instance->I2SCFGR, SPI_I2SCFGR_I2SE))
   \                     ??HAL_I2S_DMAResume_3: (+1)
   \       0x96   0x6808             LDR      R0,[R1, #+0]
   \       0x98   0x69C0             LDR      R0,[R0, #+28]
   \       0x9A   0x0540             LSLS     R0,R0,#+21
   \       0x9C   0xD405             BMI.N    ??HAL_I2S_DMAResume_11
   1444            {
   1445              /* Enable I2S peripheral */
   1446              __HAL_I2S_ENABLE(hi2s);
   \       0x9E   0x6808             LDR      R0,[R1, #+0]
   \       0xA0   0x69C0             LDR      R0,[R0, #+28]
   \       0xA2   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0xA6   0x680A             LDR      R2,[R1, #+0]
   \       0xA8   0x61D0             STR      R0,[R2, #+28]
   1447            }
   1448          
   1449            /* Process Unlocked */
   1450            __HAL_UNLOCK(hi2s);
   \                     ??HAL_I2S_DMAResume_11: (+1)
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0xF881 0x0040      STRB     R0,[R1, #+64]
   1451          
   1452            return HAL_OK;
   \       0xB0   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2S_DMAResume_1: (+1)
   \       0xB2   0x4770             BX       LR
   1453          }
   1454          
   1455          /**
   1456            * @brief  Stops the audio DMA Stream/Channel playing from the Media.
   1457            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   1458            *         the configuration information for I2S module
   1459            * @retval HAL status
   1460            */

   \                                 In section .text, align 2, keep-with-next
   1461          HAL_StatusTypeDef HAL_I2S_DMAStop(I2S_HandleTypeDef *hi2s)
   1462          {
   \                     HAL_I2S_DMAStop: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1463          #if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
   1464            uint32_t tickstart;
   1465          #endif /* SPI_I2S_FULLDUPLEX_SUPPORT */
   1466            HAL_StatusTypeDef errorcode = HAL_OK;
   \        0x4   0x2600             MOVS     R6,#+0
   1467            /* The Lock is not implemented on this API to allow the user application
   1468               to call the HAL SPI API under callbacks HAL_I2S_TxCpltCallback() or HAL_I2S_RxCpltCallback()
   1469               when calling HAL_DMA_Abort() API the DMA TX or RX Transfer complete interrupt is generated
   1470               and the correspond call back is executed HAL_I2S_TxCpltCallback() or HAL_I2S_RxCpltCallback()
   1471               */
   1472          
   1473            if ((hi2s->Init.Mode == I2S_MODE_MASTER_TX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_TX))
   \        0x6   0x6860             LDR      R0,[R4, #+4]
   \        0x8   0xF5B0 0x7F00      CMP      R0,#+512
   \        0xC   0xD003             BEQ.N    ??HAL_I2S_DMAStop_0
   \        0xE   0x6860             LDR      R0,[R4, #+4]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xF040 0x8097      BNE.W    ??HAL_I2S_DMAStop_1
   1474            {
   1475              /* Abort the I2S DMA tx Stream/Channel */
   1476              if (hi2s->hdmatx != NULL)
   \                     ??HAL_I2S_DMAStop_0: (+1)
   \       0x16   0x6BA0             LDR      R0,[R4, #+56]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD00A             BEQ.N    ??HAL_I2S_DMAStop_2
   1477              {
   1478                /* Disable the I2S DMA tx Stream/Channel */
   1479                if (HAL_OK != HAL_DMA_Abort(hi2s->hdmatx))
   \       0x1C   0x6BA0             LDR      R0,[R4, #+56]
   \       0x1E   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD005             BEQ.N    ??HAL_I2S_DMAStop_2
   1480                {
   1481                  SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_DMA);
   \       0x26   0x6C60             LDR      R0,[R4, #+68]
   \       0x28   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0x2C   0x6460             STR      R0,[R4, #+68]
   1482                  errorcode = HAL_ERROR;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0x0006             MOVS     R6,R0
   1483                }
   1484              }
   1485          
   1486              /* Wait until TXE flag is set */
   1487              if (I2S_WaitFlagStateUntilTimeout(hi2s, I2S_FLAG_TXE, SET, I2S_TIMEOUT_FLAG) != HAL_OK)
   \                     ??HAL_I2S_DMAStop_2: (+1)
   \       0x32   0x2364             MOVS     R3,#+100
   \       0x34   0x2201             MOVS     R2,#+1
   \       0x36   0x2102             MOVS     R1,#+2
   \       0x38   0x0020             MOVS     R0,R4
   \       0x3A   0x.... 0x....      BL       I2S_WaitFlagStateUntilTimeout
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD008             BEQ.N    ??HAL_I2S_DMAStop_3
   1488              {
   1489                /* Set the error code */
   1490                SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_TIMEOUT);
   \       0x42   0x6C60             LDR      R0,[R4, #+68]
   \       0x44   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x48   0x6460             STR      R0,[R4, #+68]
   1491                hi2s->State = HAL_I2S_STATE_READY;
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0xF884 0x0041      STRB     R0,[R4, #+65]
   1492                errorcode   = HAL_ERROR;
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0x0006             MOVS     R6,R0
   1493              }
   1494          
   1495              /* Wait until BSY flag is Reset */
   1496              if (I2S_WaitFlagStateUntilTimeout(hi2s, I2S_FLAG_BSY, RESET, I2S_TIMEOUT_FLAG) != HAL_OK)
   \                     ??HAL_I2S_DMAStop_3: (+1)
   \       0x54   0x2364             MOVS     R3,#+100
   \       0x56   0x2200             MOVS     R2,#+0
   \       0x58   0x2180             MOVS     R1,#+128
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x.... 0x....      BL       I2S_WaitFlagStateUntilTimeout
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD008             BEQ.N    ??HAL_I2S_DMAStop_4
   1497              {
   1498                /* Set the error code */
   1499                SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_TIMEOUT);
   \       0x64   0x6C60             LDR      R0,[R4, #+68]
   \       0x66   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x6A   0x6460             STR      R0,[R4, #+68]
   1500                hi2s->State = HAL_I2S_STATE_READY;
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0xF884 0x0041      STRB     R0,[R4, #+65]
   1501                errorcode   = HAL_ERROR;
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0x0006             MOVS     R6,R0
   1502              }
   1503          
   1504              /* Disable I2S peripheral */
   1505              __HAL_I2S_DISABLE(hi2s);
   \                     ??HAL_I2S_DMAStop_4: (+1)
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x69C0             LDR      R0,[R0, #+28]
   \       0x7A   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x7E   0x6821             LDR      R1,[R4, #+0]
   \       0x80   0x61C8             STR      R0,[R1, #+28]
   1506          
   1507              /* Clear UDR flag */
   1508              __HAL_I2S_CLEAR_UDRFLAG(hi2s);
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0x9000             STR      R0,[SP, #+0]
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x6880             LDR      R0,[R0, #+8]
   \       0x8A   0x9000             STR      R0,[SP, #+0]
   \       0x8C   0x9800             LDR      R0,[SP, #+0]
   1509          
   1510              /* Disable the I2S Tx DMA requests */
   1511              CLEAR_BIT(hi2s->Instance->CR2, SPI_CR2_TXDMAEN);
   \       0x8E   0x6820             LDR      R0,[R4, #+0]
   \       0x90   0x6840             LDR      R0,[R0, #+4]
   \       0x92   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x96   0x6821             LDR      R1,[R4, #+0]
   \       0x98   0x6048             STR      R0,[R1, #+4]
   1512          
   1513          #if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
   1514          
   1515              if (hi2s->State == HAL_I2S_STATE_BUSY_TX_RX)
   \       0x9A   0xF894 0x0041      LDRB     R0,[R4, #+65]
   \       0x9E   0x2805             CMP      R0,#+5
   \       0xA0   0xF040 0x80F6      BNE.W    ??HAL_I2S_DMAStop_5
   1516              {
   1517                /* Abort the I2S DMA rx Stream/Channel */
   1518                if (hi2s->hdmarx != NULL)
   \       0xA4   0x6BE0             LDR      R0,[R4, #+60]
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD00A             BEQ.N    ??HAL_I2S_DMAStop_6
   1519                {
   1520                  /* Disable the I2S DMA rx Stream/Channel */
   1521                  if (HAL_OK != HAL_DMA_Abort(hi2s->hdmarx))
   \       0xAA   0x6BE0             LDR      R0,[R4, #+60]
   \       0xAC   0x.... 0x....      BL       HAL_DMA_Abort
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD005             BEQ.N    ??HAL_I2S_DMAStop_6
   1522                  {
   1523                    SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_DMA);
   \       0xB4   0x6C60             LDR      R0,[R4, #+68]
   \       0xB6   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0xBA   0x6460             STR      R0,[R4, #+68]
   1524                    errorcode = HAL_ERROR;
   \       0xBC   0x2001             MOVS     R0,#+1
   \       0xBE   0x0006             MOVS     R6,R0
   1525                  }
   1526                }
   1527          
   1528                /* Disable I2Sext peripheral */
   1529                __HAL_I2SEXT_DISABLE(hi2s);
   \                     ??HAL_I2S_DMAStop_6: (+1)
   \       0xC0   0x....             LDR.N    R1,??DataTable3_2
   \       0xC2   0x6820             LDR      R0,[R4, #+0]
   \       0xC4   0x4288             CMP      R0,R1
   \       0xC6   0xD101             BNE.N    ??HAL_I2S_DMAStop_7
   \       0xC8   0x....             LDR.N    R0,??DataTable3_3
   \       0xCA   0xE001             B.N      ??HAL_I2S_DMAStop_8
   \                     ??HAL_I2S_DMAStop_7: (+1)
   \       0xCC   0xF05F 0x2040      MOVS     R0,#+1073758208
   \                     ??HAL_I2S_DMAStop_8: (+1)
   \       0xD0   0x69C2             LDR      R2,[R0, #+28]
   \       0xD2   0xF432 0x6280      BICS     R2,R2,#0x400
   \       0xD6   0x61C2             STR      R2,[R0, #+28]
   1530          
   1531                /* Clear OVR flag */
   1532                __HAL_I2SEXT_CLEAR_OVRFLAG(hi2s);
   \       0xD8   0x2000             MOVS     R0,#+0
   \       0xDA   0x9000             STR      R0,[SP, #+0]
   \       0xDC   0x6820             LDR      R0,[R4, #+0]
   \       0xDE   0x4288             CMP      R0,R1
   \       0xE0   0xD101             BNE.N    ??HAL_I2S_DMAStop_9
   \       0xE2   0x....             LDR.N    R0,??DataTable3_3
   \       0xE4   0xE001             B.N      ??HAL_I2S_DMAStop_10
   \                     ??HAL_I2S_DMAStop_9: (+1)
   \       0xE6   0xF05F 0x2040      MOVS     R0,#+1073758208
   \                     ??HAL_I2S_DMAStop_10: (+1)
   \       0xEA   0x68C0             LDR      R0,[R0, #+12]
   \       0xEC   0x9000             STR      R0,[SP, #+0]
   \       0xEE   0x6820             LDR      R0,[R4, #+0]
   \       0xF0   0x4288             CMP      R0,R1
   \       0xF2   0xD101             BNE.N    ??HAL_I2S_DMAStop_11
   \       0xF4   0x....             LDR.N    R0,??DataTable3_3
   \       0xF6   0xE001             B.N      ??HAL_I2S_DMAStop_12
   \                     ??HAL_I2S_DMAStop_11: (+1)
   \       0xF8   0xF05F 0x2040      MOVS     R0,#+1073758208
   \                     ??HAL_I2S_DMAStop_12: (+1)
   \       0xFC   0x6880             LDR      R0,[R0, #+8]
   \       0xFE   0x9000             STR      R0,[SP, #+0]
   \      0x100   0x9800             LDR      R0,[SP, #+0]
   1533          
   1534                /* Disable the I2SxEXT DMA request */
   1535                CLEAR_BIT(I2SxEXT(hi2s->Instance)->CR2, SPI_CR2_RXDMAEN);
   \      0x102   0x6820             LDR      R0,[R4, #+0]
   \      0x104   0x4288             CMP      R0,R1
   \      0x106   0xD101             BNE.N    ??HAL_I2S_DMAStop_13
   \      0x108   0x....             LDR.N    R0,??DataTable3_3
   \      0x10A   0xE001             B.N      ??HAL_I2S_DMAStop_14
   \                     ??HAL_I2S_DMAStop_13: (+1)
   \      0x10C   0xF05F 0x2040      MOVS     R0,#+1073758208
   \                     ??HAL_I2S_DMAStop_14: (+1)
   \      0x110   0x6842             LDR      R2,[R0, #+4]
   \      0x112   0x0852             LSRS     R2,R2,#+1
   \      0x114   0x0052             LSLS     R2,R2,#+1
   \      0x116   0x6042             STR      R2,[R0, #+4]
   1536          
   1537                if (hi2s->Init.Mode == I2S_MODE_SLAVE_TX)
   \      0x118   0x6860             LDR      R0,[R4, #+4]
   \      0x11A   0x2800             CMP      R0,#+0
   \      0x11C   0xD109             BNE.N    ??HAL_I2S_DMAStop_15
   1538                {
   1539                  /* Set the error code */
   1540                  SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_BUSY_LINE_RX);
   \      0x11E   0x6C60             LDR      R0,[R4, #+68]
   \      0x120   0xF050 0x0040      ORRS     R0,R0,#0x40
   \      0x124   0x6460             STR      R0,[R4, #+68]
   1541          
   1542                  /* Set the I2S State ready */
   1543                  hi2s->State = HAL_I2S_STATE_READY;
   \      0x126   0x2001             MOVS     R0,#+1
   \      0x128   0xF884 0x0041      STRB     R0,[R4, #+65]
   1544                  errorcode = HAL_ERROR;
   \      0x12C   0x2001             MOVS     R0,#+1
   \      0x12E   0x0006             MOVS     R6,R0
   \      0x130   0xE0AE             B.N      ??HAL_I2S_DMAStop_5
   1545                }
   1546                else
   1547                {
   1548                  /* Read DR to Flush RX Data */
   1549                  READ_REG(I2SxEXT(hi2s->Instance)->DR);
   \                     ??HAL_I2S_DMAStop_15: (+1)
   \      0x132   0x6820             LDR      R0,[R4, #+0]
   \      0x134   0x4288             CMP      R0,R1
   \      0x136   0xD101             BNE.N    ??HAL_I2S_DMAStop_16
   \      0x138   0x....             LDR.N    R0,??DataTable3_3
   \      0x13A   0xE001             B.N      ??HAL_I2S_DMAStop_17
   \                     ??HAL_I2S_DMAStop_16: (+1)
   \      0x13C   0xF05F 0x2040      MOVS     R0,#+1073758208
   \                     ??HAL_I2S_DMAStop_17: (+1)
   \      0x140   0x68C0             LDR      R0,[R0, #+12]
   \      0x142   0xE0A5             B.N      ??HAL_I2S_DMAStop_5
   1550                }
   1551              }
   1552          #endif /* SPI_I2S_FULLDUPLEX_SUPPORT */
   1553            }
   1554          
   1555            else if ((hi2s->Init.Mode == I2S_MODE_MASTER_RX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_RX))
   \                     ??HAL_I2S_DMAStop_1: (+1)
   \      0x144   0x6860             LDR      R0,[R4, #+4]
   \      0x146   0xF5B0 0x7F40      CMP      R0,#+768
   \      0x14A   0xD004             BEQ.N    ??HAL_I2S_DMAStop_18
   \      0x14C   0x6860             LDR      R0,[R4, #+4]
   \      0x14E   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x152   0xF040 0x809D      BNE.W    ??HAL_I2S_DMAStop_5
   1556            {
   1557              /* Abort the I2S DMA rx Stream/Channel */
   1558              if (hi2s->hdmarx != NULL)
   \                     ??HAL_I2S_DMAStop_18: (+1)
   \      0x156   0x6BE0             LDR      R0,[R4, #+60]
   \      0x158   0x2800             CMP      R0,#+0
   \      0x15A   0xD00A             BEQ.N    ??HAL_I2S_DMAStop_19
   1559              {
   1560                /* Disable the I2S DMA rx Stream/Channel */
   1561                if (HAL_OK != HAL_DMA_Abort(hi2s->hdmarx))
   \      0x15C   0x6BE0             LDR      R0,[R4, #+60]
   \      0x15E   0x.... 0x....      BL       HAL_DMA_Abort
   \      0x162   0x2800             CMP      R0,#+0
   \      0x164   0xD005             BEQ.N    ??HAL_I2S_DMAStop_19
   1562                {
   1563                  SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_DMA);
   \      0x166   0x6C60             LDR      R0,[R4, #+68]
   \      0x168   0xF050 0x0008      ORRS     R0,R0,#0x8
   \      0x16C   0x6460             STR      R0,[R4, #+68]
   1564                  errorcode = HAL_ERROR;
   \      0x16E   0x2001             MOVS     R0,#+1
   \      0x170   0x0006             MOVS     R6,R0
   1565                }
   1566              }
   1567          #if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
   1568          
   1569              if (hi2s->State == HAL_I2S_STATE_BUSY_TX_RX)
   \                     ??HAL_I2S_DMAStop_19: (+1)
   \      0x172   0xF894 0x0041      LDRB     R0,[R4, #+65]
   \      0x176   0x2805             CMP      R0,#+5
   \      0x178   0xD165             BNE.N    ??HAL_I2S_DMAStop_20
   1570              {
   1571                /* Abort the I2S DMA tx Stream/Channel */
   1572                if (hi2s->hdmatx != NULL)
   \      0x17A   0x6BA0             LDR      R0,[R4, #+56]
   \      0x17C   0x2800             CMP      R0,#+0
   \      0x17E   0xD00A             BEQ.N    ??HAL_I2S_DMAStop_21
   1573                {
   1574                  /* Disable the I2S DMA tx Stream/Channel */
   1575                  if (HAL_OK != HAL_DMA_Abort(hi2s->hdmatx))
   \      0x180   0x6BA0             LDR      R0,[R4, #+56]
   \      0x182   0x.... 0x....      BL       HAL_DMA_Abort
   \      0x186   0x2800             CMP      R0,#+0
   \      0x188   0xD005             BEQ.N    ??HAL_I2S_DMAStop_21
   1576                  {
   1577                    SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_DMA);
   \      0x18A   0x6C60             LDR      R0,[R4, #+68]
   \      0x18C   0xF050 0x0008      ORRS     R0,R0,#0x8
   \      0x190   0x6460             STR      R0,[R4, #+68]
   1578                    errorcode = HAL_ERROR;
   \      0x192   0x2001             MOVS     R0,#+1
   \      0x194   0x0006             MOVS     R6,R0
   1579                  }
   1580                }
   1581          
   1582                tickstart = HAL_GetTick();
   \                     ??HAL_I2S_DMAStop_21: (+1)
   \      0x196   0x.... 0x....      BL       HAL_GetTick
   \      0x19A   0x0005             MOVS     R5,R0
   1583          
   1584                /* Wait until TXE flag is set */
   1585                while (__HAL_I2SEXT_GET_FLAG(hi2s, I2S_FLAG_TXE) != SET)
   \                     ??HAL_I2S_DMAStop_22: (+1)
   \      0x19C   0x....             LDR.N    R7,??DataTable3_2
   \      0x19E   0x6820             LDR      R0,[R4, #+0]
   \      0x1A0   0x42B8             CMP      R0,R7
   \      0x1A2   0xD101             BNE.N    ??HAL_I2S_DMAStop_23
   \      0x1A4   0x....             LDR.N    R0,??DataTable3_3
   \      0x1A6   0xE001             B.N      ??HAL_I2S_DMAStop_24
   \                     ??HAL_I2S_DMAStop_23: (+1)
   \      0x1A8   0xF05F 0x2040      MOVS     R0,#+1073758208
   \                     ??HAL_I2S_DMAStop_24: (+1)
   \      0x1AC   0x6880             LDR      R0,[R0, #+8]
   \      0x1AE   0x0780             LSLS     R0,R0,#+30
   \      0x1B0   0xD40E             BMI.N    ??HAL_I2S_DMAStop_25
   1586                {
   1587                  if (((HAL_GetTick() - tickstart) > I2S_TIMEOUT_FLAG))
   \      0x1B2   0x.... 0x....      BL       HAL_GetTick
   \      0x1B6   0x1B40             SUBS     R0,R0,R5
   \      0x1B8   0x2865             CMP      R0,#+101
   \      0x1BA   0xD3EF             BCC.N    ??HAL_I2S_DMAStop_22
   1588                  {
   1589                    /* Set the error code */
   1590                    SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_TIMEOUT);
   \      0x1BC   0x6C60             LDR      R0,[R4, #+68]
   \      0x1BE   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x1C2   0x6460             STR      R0,[R4, #+68]
   1591          
   1592                    /* Set the I2S State ready */
   1593                    hi2s->State = HAL_I2S_STATE_READY;
   \      0x1C4   0x2001             MOVS     R0,#+1
   \      0x1C6   0xF884 0x0041      STRB     R0,[R4, #+65]
   1594                    errorcode   = HAL_ERROR;
   \      0x1CA   0x2001             MOVS     R0,#+1
   \      0x1CC   0x0006             MOVS     R6,R0
   \      0x1CE   0xE7E5             B.N      ??HAL_I2S_DMAStop_22
   1595                  }
   1596                }
   1597          
   1598                /* Wait until BSY flag is Reset */
   1599                while (__HAL_I2SEXT_GET_FLAG(hi2s, I2S_FLAG_BSY) != RESET)
   \                     ??HAL_I2S_DMAStop_25: (+1)
   \      0x1D0   0x6820             LDR      R0,[R4, #+0]
   \      0x1D2   0x42B8             CMP      R0,R7
   \      0x1D4   0xD101             BNE.N    ??HAL_I2S_DMAStop_26
   \      0x1D6   0x....             LDR.N    R0,??DataTable3_3
   \      0x1D8   0xE001             B.N      ??HAL_I2S_DMAStop_27
   \                     ??HAL_I2S_DMAStop_26: (+1)
   \      0x1DA   0xF05F 0x2040      MOVS     R0,#+1073758208
   \                     ??HAL_I2S_DMAStop_27: (+1)
   \      0x1DE   0x6880             LDR      R0,[R0, #+8]
   \      0x1E0   0x0600             LSLS     R0,R0,#+24
   \      0x1E2   0xD50E             BPL.N    ??HAL_I2S_DMAStop_28
   1600                {
   1601                  if (((HAL_GetTick() - tickstart) > I2S_TIMEOUT_FLAG))
   \      0x1E4   0x.... 0x....      BL       HAL_GetTick
   \      0x1E8   0x1B40             SUBS     R0,R0,R5
   \      0x1EA   0x2865             CMP      R0,#+101
   \      0x1EC   0xD3F0             BCC.N    ??HAL_I2S_DMAStop_25
   1602                  {
   1603                    /* Set the error code */
   1604                    SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_TIMEOUT);
   \      0x1EE   0x6C60             LDR      R0,[R4, #+68]
   \      0x1F0   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x1F4   0x6460             STR      R0,[R4, #+68]
   1605          
   1606                    /* Set the I2S State ready */
   1607                    hi2s->State = HAL_I2S_STATE_READY;
   \      0x1F6   0x2001             MOVS     R0,#+1
   \      0x1F8   0xF884 0x0041      STRB     R0,[R4, #+65]
   1608                    errorcode   = HAL_ERROR;
   \      0x1FC   0x2001             MOVS     R0,#+1
   \      0x1FE   0x0006             MOVS     R6,R0
   \      0x200   0xE7E6             B.N      ??HAL_I2S_DMAStop_25
   1609                  }
   1610                }
   1611          
   1612                /* Disable I2Sext peripheral */
   1613                __HAL_I2SEXT_DISABLE(hi2s);
   \                     ??HAL_I2S_DMAStop_28: (+1)
   \      0x202   0x6820             LDR      R0,[R4, #+0]
   \      0x204   0x42B8             CMP      R0,R7
   \      0x206   0xD101             BNE.N    ??HAL_I2S_DMAStop_29
   \      0x208   0x....             LDR.N    R0,??DataTable3_3
   \      0x20A   0xE001             B.N      ??HAL_I2S_DMAStop_30
   \                     ??HAL_I2S_DMAStop_29: (+1)
   \      0x20C   0xF05F 0x2040      MOVS     R0,#+1073758208
   \                     ??HAL_I2S_DMAStop_30: (+1)
   \      0x210   0x69C1             LDR      R1,[R0, #+28]
   \      0x212   0xF431 0x6180      BICS     R1,R1,#0x400
   \      0x216   0x61C1             STR      R1,[R0, #+28]
   1614          
   1615                /* Clear UDR flag */
   1616                __HAL_I2SEXT_CLEAR_UDRFLAG(hi2s);
   \      0x218   0x2000             MOVS     R0,#+0
   \      0x21A   0x9000             STR      R0,[SP, #+0]
   \      0x21C   0x6820             LDR      R0,[R4, #+0]
   \      0x21E   0x42B8             CMP      R0,R7
   \      0x220   0xD101             BNE.N    ??HAL_I2S_DMAStop_31
   \      0x222   0x....             LDR.N    R0,??DataTable3_3
   \      0x224   0xE001             B.N      ??HAL_I2S_DMAStop_32
   \                     ??HAL_I2S_DMAStop_31: (+1)
   \      0x226   0xF05F 0x2040      MOVS     R0,#+1073758208
   \                     ??HAL_I2S_DMAStop_32: (+1)
   \      0x22A   0x6880             LDR      R0,[R0, #+8]
   \      0x22C   0x9000             STR      R0,[SP, #+0]
   \      0x22E   0x9800             LDR      R0,[SP, #+0]
   1617          
   1618                /* Disable the I2SxEXT DMA request */
   1619                CLEAR_BIT(I2SxEXT(hi2s->Instance)->CR2, SPI_CR2_TXDMAEN);
   \      0x230   0x6820             LDR      R0,[R4, #+0]
   \      0x232   0x42B8             CMP      R0,R7
   \      0x234   0xD101             BNE.N    ??HAL_I2S_DMAStop_33
   \      0x236   0x....             LDR.N    R0,??DataTable3_3
   \      0x238   0xE001             B.N      ??HAL_I2S_DMAStop_34
   \                     ??HAL_I2S_DMAStop_33: (+1)
   \      0x23A   0xF05F 0x2040      MOVS     R0,#+1073758208
   \                     ??HAL_I2S_DMAStop_34: (+1)
   \      0x23E   0x6841             LDR      R1,[R0, #+4]
   \      0x240   0xF031 0x0102      BICS     R1,R1,#0x2
   \      0x244   0x6041             STR      R1,[R0, #+4]
   1620              }
   1621          #endif /* SPI_I2S_FULLDUPLEX_SUPPORT */
   1622          
   1623              /* Disable I2S peripheral */
   1624              __HAL_I2S_DISABLE(hi2s);
   \                     ??HAL_I2S_DMAStop_20: (+1)
   \      0x246   0x6820             LDR      R0,[R4, #+0]
   \      0x248   0x69C0             LDR      R0,[R0, #+28]
   \      0x24A   0xF430 0x6080      BICS     R0,R0,#0x400
   \      0x24E   0x6821             LDR      R1,[R4, #+0]
   \      0x250   0x61C8             STR      R0,[R1, #+28]
   1625          
   1626              /* Clear OVR flag */
   1627              __HAL_I2S_CLEAR_OVRFLAG(hi2s);
   \      0x252   0x2000             MOVS     R0,#+0
   \      0x254   0x9000             STR      R0,[SP, #+0]
   \      0x256   0x6820             LDR      R0,[R4, #+0]
   \      0x258   0x68C0             LDR      R0,[R0, #+12]
   \      0x25A   0x9000             STR      R0,[SP, #+0]
   \      0x25C   0x6820             LDR      R0,[R4, #+0]
   \      0x25E   0x6880             LDR      R0,[R0, #+8]
   \      0x260   0x9000             STR      R0,[SP, #+0]
   \      0x262   0x9800             LDR      R0,[SP, #+0]
   1628          
   1629              /* Disable the I2S Rx DMA request */
   1630              CLEAR_BIT(hi2s->Instance->CR2, SPI_CR2_RXDMAEN);
   \      0x264   0x6820             LDR      R0,[R4, #+0]
   \      0x266   0x6840             LDR      R0,[R0, #+4]
   \      0x268   0x0840             LSRS     R0,R0,#+1
   \      0x26A   0x0040             LSLS     R0,R0,#+1
   \      0x26C   0x6821             LDR      R1,[R4, #+0]
   \      0x26E   0x6048             STR      R0,[R1, #+4]
   1631          
   1632              if (hi2s->Init.Mode == I2S_MODE_SLAVE_RX)
   \      0x270   0x6860             LDR      R0,[R4, #+4]
   \      0x272   0xF5B0 0x7F80      CMP      R0,#+256
   \      0x276   0xD109             BNE.N    ??HAL_I2S_DMAStop_35
   1633              {
   1634                /* Set the error code */
   1635                SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_BUSY_LINE_RX);
   \      0x278   0x6C60             LDR      R0,[R4, #+68]
   \      0x27A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \      0x27E   0x6460             STR      R0,[R4, #+68]
   1636          
   1637                /* Set the I2S State ready */
   1638                hi2s->State = HAL_I2S_STATE_READY;
   \      0x280   0x2001             MOVS     R0,#+1
   \      0x282   0xF884 0x0041      STRB     R0,[R4, #+65]
   1639                errorcode = HAL_ERROR;
   \      0x286   0x2001             MOVS     R0,#+1
   \      0x288   0x0006             MOVS     R6,R0
   \      0x28A   0xE001             B.N      ??HAL_I2S_DMAStop_5
   1640              }
   1641              else
   1642              {
   1643                /* Read DR to Flush RX Data */
   1644                READ_REG((hi2s->Instance)->DR);
   \                     ??HAL_I2S_DMAStop_35: (+1)
   \      0x28C   0x6820             LDR      R0,[R4, #+0]
   \      0x28E   0x68C0             LDR      R0,[R0, #+12]
   1645              }
   1646            }
   1647          
   1648            hi2s->State = HAL_I2S_STATE_READY;
   \                     ??HAL_I2S_DMAStop_5: (+1)
   \      0x290   0x2001             MOVS     R0,#+1
   \      0x292   0xF884 0x0041      STRB     R0,[R4, #+65]
   1649          
   1650            return errorcode;
   \      0x296   0x0030             MOVS     R0,R6
   \      0x298   0xB2C0             UXTB     R0,R0
   \      0x29A   0xBDF2             POP      {R1,R4-R7,PC}
   1651          }
   1652          
   1653          /**
   1654            * @brief  This function handles I2S interrupt request.
   1655            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   1656            *         the configuration information for I2S module
   1657            * @retval None
   1658            */

   \                                 In section .text, align 2, keep-with-next
   1659          void HAL_I2S_IRQHandler(I2S_HandleTypeDef *hi2s)
   1660          {
   \                     HAL_I2S_IRQHandler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1661            /* Call the IrqHandler ISR set during HAL_I2S_INIT */
   1662            hi2s->IrqHandlerISR(hi2s);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x6B61             LDR      R1,[R4, #+52]
   \        0x8   0x4788             BLX      R1
   1663          }
   \        0xA   0xBD10             POP      {R4,PC}
   1664          
   1665          /**
   1666            * @brief  Tx Transfer Half completed callbacks
   1667            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   1668            *         the configuration information for I2S module
   1669            * @retval None
   1670            */

   \                                 In section .text, align 2
   1671          __weak void HAL_I2S_TxHalfCpltCallback(I2S_HandleTypeDef *hi2s)
   1672          {
   1673            /* Prevent unused argument(s) compilation warning */
   1674            UNUSED(hi2s);
   1675          
   1676            /* NOTE : This function Should not be modified, when the callback is needed,
   1677                      the HAL_I2S_TxHalfCpltCallback could be implemented in the user file
   1678             */
   1679          }
   \                     HAL_I2S_TxHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   1680          
   1681          /**
   1682            * @brief  Tx Transfer completed callbacks
   1683            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   1684            *         the configuration information for I2S module
   1685            * @retval None
   1686            */

   \                                 In section .text, align 2
   1687          __weak void HAL_I2S_TxCpltCallback(I2S_HandleTypeDef *hi2s)
   1688          {
   1689            /* Prevent unused argument(s) compilation warning */
   1690            UNUSED(hi2s);
   1691          
   1692            /* NOTE : This function Should not be modified, when the callback is needed,
   1693                      the HAL_I2S_TxCpltCallback could be implemented in the user file
   1694             */
   1695          }
   \                     HAL_I2S_TxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   1696          
   1697          /**
   1698            * @brief  Rx Transfer half completed callbacks
   1699            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   1700            *         the configuration information for I2S module
   1701            * @retval None
   1702            */

   \                                 In section .text, align 2
   1703          __weak void HAL_I2S_RxHalfCpltCallback(I2S_HandleTypeDef *hi2s)
   1704          {
   1705            /* Prevent unused argument(s) compilation warning */
   1706            UNUSED(hi2s);
   1707          
   1708            /* NOTE : This function Should not be modified, when the callback is needed,
   1709                      the HAL_I2S_RxHalfCpltCallback could be implemented in the user file
   1710             */
   1711          }
   \                     HAL_I2S_RxHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   1712          
   1713          /**
   1714            * @brief  Rx Transfer completed callbacks
   1715            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   1716            *         the configuration information for I2S module
   1717            * @retval None
   1718            */

   \                                 In section .text, align 2
   1719          __weak void HAL_I2S_RxCpltCallback(I2S_HandleTypeDef *hi2s)
   1720          {
   1721            /* Prevent unused argument(s) compilation warning */
   1722            UNUSED(hi2s);
   1723          
   1724            /* NOTE : This function Should not be modified, when the callback is needed,
   1725                      the HAL_I2S_RxCpltCallback could be implemented in the user file
   1726             */
   1727          }
   \                     HAL_I2S_RxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   1728          
   1729          /**
   1730            * @brief  I2S error callbacks
   1731            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   1732            *         the configuration information for I2S module
   1733            * @retval None
   1734            */

   \                                 In section .text, align 2
   1735          __weak void HAL_I2S_ErrorCallback(I2S_HandleTypeDef *hi2s)
   1736          {
   1737            /* Prevent unused argument(s) compilation warning */
   1738            UNUSED(hi2s);
   1739          
   1740            /* NOTE : This function Should not be modified, when the callback is needed,
   1741                      the HAL_I2S_ErrorCallback could be implemented in the user file
   1742             */
   1743          }
   \                     HAL_I2S_ErrorCallback: (+1)
   \        0x0   0x4770             BX       LR
   1744          
   1745          /**
   1746            * @}
   1747            */
   1748          
   1749          /** @defgroup I2S_Exported_Functions_Group3 Peripheral State and Errors functions
   1750            *  @brief   Peripheral State functions
   1751            *
   1752          @verbatim
   1753           ===============================================================================
   1754                                ##### Peripheral State and Errors functions #####
   1755           ===============================================================================
   1756              [..]
   1757              This subsection permits to get in run-time the status of the peripheral
   1758              and the data flow.
   1759          
   1760          @endverbatim
   1761            * @{
   1762            */
   1763          
   1764          /**
   1765            * @brief  Return the I2S state
   1766            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   1767            *         the configuration information for I2S module
   1768            * @retval HAL state
   1769            */

   \                                 In section .text, align 2, keep-with-next
   1770          HAL_I2S_StateTypeDef HAL_I2S_GetState(I2S_HandleTypeDef *hi2s)
   1771          {
   1772            return hi2s->State;
   \                     HAL_I2S_GetState: (+1)
   \        0x0   0xF890 0x0041      LDRB     R0,[R0, #+65]
   \        0x4   0x4770             BX       LR
   1773          }
   1774          
   1775          /**
   1776            * @brief  Return the I2S error code
   1777            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   1778            *         the configuration information for I2S module
   1779            * @retval I2S Error Code
   1780            */

   \                                 In section .text, align 2, keep-with-next
   1781          uint32_t HAL_I2S_GetError(I2S_HandleTypeDef *hi2s)
   1782          {
   1783            return hi2s->ErrorCode;
   \                     HAL_I2S_GetError: (+1)
   \        0x0   0x6C40             LDR      R0,[R0, #+68]
   \        0x2   0x4770             BX       LR
   1784          }
   1785          /**
   1786            * @}
   1787            */
   1788          
   1789          /**
   1790            * @}
   1791            */
   1792          
   1793          /** @addtogroup I2S_Private_Functions I2S Private Functions
   1794            * @{
   1795            */
   1796          /**
   1797            * @brief  DMA I2S transmit process complete callback
   1798            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   1799            *                the configuration information for the specified DMA module.
   1800            * @retval None
   1801            */

   \                                 In section .text, align 4, keep-with-next
   1802          static void I2S_DMATxCplt(DMA_HandleTypeDef *hdma)
   1803          {
   \                     I2S_DMATxCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1804            I2S_HandleTypeDef *hi2s = (I2S_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   1805          
   1806            /* if DMA is configured in DMA_NORMAL Mode */
   1807            if (hdma->Init.Mode == DMA_NORMAL)
   \        0x6   0x69E0             LDR      R0,[R4, #+28]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD10A             BNE.N    ??I2S_DMATxCplt_0
   1808            {
   1809              /* Disable Tx DMA Request */
   1810              CLEAR_BIT(hi2s->Instance->CR2, SPI_CR2_TXDMAEN);
   \        0xC   0x6828             LDR      R0,[R5, #+0]
   \        0xE   0x6840             LDR      R0,[R0, #+4]
   \       0x10   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x14   0x6829             LDR      R1,[R5, #+0]
   \       0x16   0x6048             STR      R0,[R1, #+4]
   1811          
   1812              hi2s->TxXferCount = 0U;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x8568             STRH     R0,[R5, #+42]
   1813              hi2s->State = HAL_I2S_STATE_READY;
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xF885 0x0041      STRB     R0,[R5, #+65]
   1814            }
   1815            /* Call user Tx complete callback */
   1816          #if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
   1817            hi2s->TxCpltCallback(hi2s);
   1818          #else
   1819            HAL_I2S_TxCpltCallback(hi2s);
   \                     ??I2S_DMATxCplt_0: (+1)
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0x.... 0x....      BL       HAL_I2S_TxCpltCallback
   1820          #endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
   1821          }
   \       0x28   0xBD31             POP      {R0,R4,R5,PC}
   1822          
   1823          /**
   1824            * @brief  DMA I2S transmit process half complete callback
   1825            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   1826            *                the configuration information for the specified DMA module.
   1827            * @retval None
   1828            */

   \                                 In section .text, align 4, keep-with-next
   1829          static void I2S_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
   1830          {
   \                     I2S_DMATxHalfCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1831            I2S_HandleTypeDef *hi2s = (I2S_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   1832          
   1833            /* Call user Tx half complete callback */
   1834          #if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
   1835            hi2s->TxHalfCpltCallback(hi2s);
   1836          #else
   1837            HAL_I2S_TxHalfCpltCallback(hi2s);
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x.... 0x....      BL       HAL_I2S_TxHalfCpltCallback
   1838          #endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
   1839          }
   \        0xC   0xBD31             POP      {R0,R4,R5,PC}
   1840          
   1841          /**
   1842            * @brief  DMA I2S receive process complete callback
   1843            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   1844            *                the configuration information for the specified DMA module.
   1845            * @retval None
   1846            */

   \                                 In section .text, align 4, keep-with-next
   1847          static void I2S_DMARxCplt(DMA_HandleTypeDef *hdma)
   1848          {
   \                     I2S_DMARxCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1849            I2S_HandleTypeDef *hi2s = (I2S_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   1850          
   1851            /* if DMA is configured in DMA_NORMAL Mode */
   1852            if (hdma->Init.Mode == DMA_NORMAL)
   \        0x6   0x69E0             LDR      R0,[R4, #+28]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD10A             BNE.N    ??I2S_DMARxCplt_0
   1853            {
   1854              /* Disable Rx DMA Request */
   1855              CLEAR_BIT(hi2s->Instance->CR2, SPI_CR2_RXDMAEN);
   \        0xC   0x6828             LDR      R0,[R5, #+0]
   \        0xE   0x6840             LDR      R0,[R0, #+4]
   \       0x10   0x0840             LSRS     R0,R0,#+1
   \       0x12   0x0040             LSLS     R0,R0,#+1
   \       0x14   0x6829             LDR      R1,[R5, #+0]
   \       0x16   0x6048             STR      R0,[R1, #+4]
   1856              hi2s->RxXferCount = 0U;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x8668             STRH     R0,[R5, #+50]
   1857              hi2s->State = HAL_I2S_STATE_READY;
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xF885 0x0041      STRB     R0,[R5, #+65]
   1858            }
   1859            /* Call user Rx complete callback */
   1860          #if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
   1861            hi2s->RxCpltCallback(hi2s);
   1862          #else
   1863            HAL_I2S_RxCpltCallback(hi2s);
   \                     ??I2S_DMARxCplt_0: (+1)
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0x.... 0x....      BL       HAL_I2S_RxCpltCallback
   1864          #endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
   1865          }
   \       0x28   0xBD31             POP      {R0,R4,R5,PC}
   1866          
   1867          /**
   1868            * @brief  DMA I2S receive process half complete callback
   1869            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   1870            *                the configuration information for the specified DMA module.
   1871            * @retval None
   1872            */

   \                                 In section .text, align 4, keep-with-next
   1873          static void I2S_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   1874          {
   \                     I2S_DMARxHalfCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1875            I2S_HandleTypeDef *hi2s = (I2S_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   1876          
   1877            /* Call user Rx half complete callback */
   1878          #if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
   1879            hi2s->RxHalfCpltCallback(hi2s);
   1880          #else
   1881            HAL_I2S_RxHalfCpltCallback(hi2s);
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x.... 0x....      BL       HAL_I2S_RxHalfCpltCallback
   1882          #endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
   1883          }
   \        0xC   0xBD31             POP      {R0,R4,R5,PC}
   1884          
   1885          /**
   1886            * @brief  DMA I2S communication error callback
   1887            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   1888            *                the configuration information for the specified DMA module.
   1889            * @retval None
   1890            */

   \                                 In section .text, align 4, keep-with-next
   1891          static void I2S_DMAError(DMA_HandleTypeDef *hdma)
   1892          {
   \                     I2S_DMAError: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1893            I2S_HandleTypeDef *hi2s = (I2S_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   1894          
   1895            /* Disable Rx and Tx DMA Request */
   1896            CLEAR_BIT(hi2s->Instance->CR2, (SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN));
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0x6840             LDR      R0,[R0, #+4]
   \        0xA   0x0880             LSRS     R0,R0,#+2
   \        0xC   0x0080             LSLS     R0,R0,#+2
   \        0xE   0x6829             LDR      R1,[R5, #+0]
   \       0x10   0x6048             STR      R0,[R1, #+4]
   1897            hi2s->TxXferCount = 0U;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x8568             STRH     R0,[R5, #+42]
   1898            hi2s->RxXferCount = 0U;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x8668             STRH     R0,[R5, #+50]
   1899          
   1900            hi2s->State = HAL_I2S_STATE_READY;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xF885 0x0041      STRB     R0,[R5, #+65]
   1901          
   1902            /* Set the error code and execute error callback*/
   1903            SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_DMA);
   \       0x20   0x6C68             LDR      R0,[R5, #+68]
   \       0x22   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0x26   0x6468             STR      R0,[R5, #+68]
   1904            /* Call user error callback */
   1905          #if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
   1906            hi2s->ErrorCallback(hi2s);
   1907          #else
   1908            HAL_I2S_ErrorCallback(hi2s);
   \       0x28   0x0028             MOVS     R0,R5
   \       0x2A   0x.... 0x....      BL       HAL_I2S_ErrorCallback
   1909          #endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
   1910          }
   \       0x2E   0xBD31             POP      {R0,R4,R5,PC}
   1911          
   1912          /**
   1913            * @brief  Transmit an amount of data in non-blocking mode with Interrupt
   1914            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   1915            *         the configuration information for I2S module
   1916            * @retval None
   1917            */

   \                                 In section .text, align 2, keep-with-next
   1918          static void I2S_Transmit_IT(I2S_HandleTypeDef *hi2s)
   1919          {
   \                     I2S_Transmit_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1920            /* Transmit data */
   1921            hi2s->Instance->DR = (*hi2s->pTxBuffPtr);
   \        0x4   0x6A60             LDR      R0,[R4, #+36]
   \        0x6   0x8800             LDRH     R0,[R0, #+0]
   \        0x8   0x6821             LDR      R1,[R4, #+0]
   \        0xA   0x60C8             STR      R0,[R1, #+12]
   1922            hi2s->pTxBuffPtr++;
   \        0xC   0x6A60             LDR      R0,[R4, #+36]
   \        0xE   0x1C80             ADDS     R0,R0,#+2
   \       0x10   0x6260             STR      R0,[R4, #+36]
   1923            hi2s->TxXferCount--;
   \       0x12   0x8D60             LDRH     R0,[R4, #+42]
   \       0x14   0x1E40             SUBS     R0,R0,#+1
   \       0x16   0x8560             STRH     R0,[R4, #+42]
   1924          
   1925            if (hi2s->TxXferCount == 0U)
   \       0x18   0x8D60             LDRH     R0,[R4, #+42]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD10B             BNE.N    ??I2S_Transmit_IT_0
   1926            {
   1927              /* Disable TXE and ERR interrupt */
   1928              __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6840             LDR      R0,[R0, #+4]
   \       0x22   0xF030 0x00A0      BICS     R0,R0,#0xA0
   \       0x26   0x6821             LDR      R1,[R4, #+0]
   \       0x28   0x6048             STR      R0,[R1, #+4]
   1929          
   1930              hi2s->State = HAL_I2S_STATE_READY;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xF884 0x0041      STRB     R0,[R4, #+65]
   1931              /* Call user Tx complete callback */
   1932          #if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
   1933              hi2s->TxCpltCallback(hi2s);
   1934          #else
   1935              HAL_I2S_TxCpltCallback(hi2s);
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       HAL_I2S_TxCpltCallback
   1936          #endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
   1937            }
   1938          }
   \                     ??I2S_Transmit_IT_0: (+1)
   \       0x36   0xBD10             POP      {R4,PC}
   1939          
   1940          /**
   1941            * @brief  Receive an amount of data in non-blocking mode with Interrupt
   1942            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   1943            *         the configuration information for I2S module
   1944            * @retval None
   1945            */

   \                                 In section .text, align 2, keep-with-next
   1946          static void I2S_Receive_IT(I2S_HandleTypeDef *hi2s)
   1947          {
   \                     I2S_Receive_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1948            /* Receive data */
   1949            (*hi2s->pRxBuffPtr) = (uint16_t)hi2s->Instance->DR;
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C0             LDR      R0,[R0, #+12]
   \        0x8   0x6AE1             LDR      R1,[R4, #+44]
   \        0xA   0x8008             STRH     R0,[R1, #+0]
   1950            hi2s->pRxBuffPtr++;
   \        0xC   0x6AE0             LDR      R0,[R4, #+44]
   \        0xE   0x1C80             ADDS     R0,R0,#+2
   \       0x10   0x62E0             STR      R0,[R4, #+44]
   1951            hi2s->RxXferCount--;
   \       0x12   0x8E60             LDRH     R0,[R4, #+50]
   \       0x14   0x1E40             SUBS     R0,R0,#+1
   \       0x16   0x8660             STRH     R0,[R4, #+50]
   1952          
   1953            if (hi2s->RxXferCount == 0U)
   \       0x18   0x8E60             LDRH     R0,[R4, #+50]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD10B             BNE.N    ??I2S_Receive_IT_0
   1954            {
   1955              /* Disable RXNE and ERR interrupt */
   1956              __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6840             LDR      R0,[R0, #+4]
   \       0x22   0xF030 0x0060      BICS     R0,R0,#0x60
   \       0x26   0x6821             LDR      R1,[R4, #+0]
   \       0x28   0x6048             STR      R0,[R1, #+4]
   1957          
   1958              hi2s->State = HAL_I2S_STATE_READY;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xF884 0x0041      STRB     R0,[R4, #+65]
   1959              /* Call user Rx complete callback */
   1960          #if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
   1961              hi2s->RxCpltCallback(hi2s);
   1962          #else
   1963              HAL_I2S_RxCpltCallback(hi2s);
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       HAL_I2S_RxCpltCallback
   1964          #endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
   1965            }
   1966          }
   \                     ??I2S_Receive_IT_0: (+1)
   \       0x36   0xBD10             POP      {R4,PC}
   1967          
   1968          /**
   1969            * @brief  This function handles I2S interrupt request.
   1970            * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
   1971            *         the configuration information for I2S module
   1972            * @retval None
   1973            */

   \                                 In section .text, align 4, keep-with-next
   1974          static void I2S_IRQHandler(I2S_HandleTypeDef *hi2s)
   1975          {
   \                     I2S_IRQHandler: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1976            __IO uint32_t i2ssr = hi2s->Instance->SR;
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6880             LDR      R0,[R0, #+8]
   \        0x8   0x9000             STR      R0,[SP, #+0]
   1977          
   1978            if (hi2s->State == HAL_I2S_STATE_BUSY_RX)
   \        0xA   0xF894 0x0041      LDRB     R0,[R4, #+65]
   \        0xE   0x2804             CMP      R0,#+4
   \       0x10   0xD129             BNE.N    ??I2S_IRQHandler_0
   1979            {
   1980              /* I2S in mode Receiver ------------------------------------------------*/
   1981              if (((i2ssr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_RXNE) != RESET))
   \       0x12   0x9800             LDR      R0,[SP, #+0]
   \       0x14   0x07C0             LSLS     R0,R0,#+31
   \       0x16   0xD506             BPL.N    ??I2S_IRQHandler_1
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x6840             LDR      R0,[R0, #+4]
   \       0x1C   0x0640             LSLS     R0,R0,#+25
   \       0x1E   0xD502             BPL.N    ??I2S_IRQHandler_1
   1982              {
   1983                I2S_Receive_IT(hi2s);
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       I2S_Receive_IT
   1984              }
   1985          
   1986              /* I2S Overrun error interrupt occurred -------------------------------------*/
   1987              if (((i2ssr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
   \                     ??I2S_IRQHandler_1: (+1)
   \       0x26   0x9800             LDR      R0,[SP, #+0]
   \       0x28   0x0640             LSLS     R0,R0,#+25
   \       0x2A   0xD51C             BPL.N    ??I2S_IRQHandler_0
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6840             LDR      R0,[R0, #+4]
   \       0x30   0x0680             LSLS     R0,R0,#+26
   \       0x32   0xD518             BPL.N    ??I2S_IRQHandler_0
   1988              {
   1989                /* Disable RXNE and ERR interrupt */
   1990                __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x6840             LDR      R0,[R0, #+4]
   \       0x38   0xF030 0x0060      BICS     R0,R0,#0x60
   \       0x3C   0x6821             LDR      R1,[R4, #+0]
   \       0x3E   0x6048             STR      R0,[R1, #+4]
   1991          
   1992                /* Clear Overrun flag */
   1993                __HAL_I2S_CLEAR_OVRFLAG(hi2s);
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x9001             STR      R0,[SP, #+4]
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0x9001             STR      R0,[SP, #+4]
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x6880             LDR      R0,[R0, #+8]
   \       0x4E   0x9001             STR      R0,[SP, #+4]
   \       0x50   0x9801             LDR      R0,[SP, #+4]
   1994          
   1995                /* Set the I2S State ready */
   1996                hi2s->State = HAL_I2S_STATE_READY;
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0xF884 0x0041      STRB     R0,[R4, #+65]
   1997          
   1998          
   1999                /* Set the error code and execute error callback*/
   2000                SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
   \       0x58   0x6C60             LDR      R0,[R4, #+68]
   \       0x5A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x5E   0x6460             STR      R0,[R4, #+68]
   2001                /* Call user error callback */
   2002          #if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
   2003                hi2s->ErrorCallback(hi2s);
   2004          #else
   2005                HAL_I2S_ErrorCallback(hi2s);
   \       0x60   0x0020             MOVS     R0,R4
   \       0x62   0x.... 0x....      BL       HAL_I2S_ErrorCallback
   2006          #endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
   2007              }
   2008            }
   2009          
   2010            if (hi2s->State == HAL_I2S_STATE_BUSY_TX)
   \                     ??I2S_IRQHandler_0: (+1)
   \       0x66   0xF894 0x0041      LDRB     R0,[R4, #+65]
   \       0x6A   0x2803             CMP      R0,#+3
   \       0x6C   0xD126             BNE.N    ??I2S_IRQHandler_2
   2011            {
   2012              /* I2S in mode Transmitter -----------------------------------------------*/
   2013              if (((i2ssr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_TXE) != RESET))
   \       0x6E   0x9800             LDR      R0,[SP, #+0]
   \       0x70   0x0780             LSLS     R0,R0,#+30
   \       0x72   0xD506             BPL.N    ??I2S_IRQHandler_3
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x6840             LDR      R0,[R0, #+4]
   \       0x78   0x0600             LSLS     R0,R0,#+24
   \       0x7A   0xD502             BPL.N    ??I2S_IRQHandler_3
   2014              {
   2015                I2S_Transmit_IT(hi2s);
   \       0x7C   0x0020             MOVS     R0,R4
   \       0x7E   0x.... 0x....      BL       I2S_Transmit_IT
   2016              }
   2017          
   2018              /* I2S Underrun error interrupt occurred --------------------------------*/
   2019              if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
   \                     ??I2S_IRQHandler_3: (+1)
   \       0x82   0x9800             LDR      R0,[SP, #+0]
   \       0x84   0x0700             LSLS     R0,R0,#+28
   \       0x86   0xD519             BPL.N    ??I2S_IRQHandler_2
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6840             LDR      R0,[R0, #+4]
   \       0x8C   0x0680             LSLS     R0,R0,#+26
   \       0x8E   0xD515             BPL.N    ??I2S_IRQHandler_2
   2020              {
   2021                /* Disable TXE and ERR interrupt */
   2022                __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
   \       0x90   0x6820             LDR      R0,[R4, #+0]
   \       0x92   0x6840             LDR      R0,[R0, #+4]
   \       0x94   0xF030 0x00A0      BICS     R0,R0,#0xA0
   \       0x98   0x6821             LDR      R1,[R4, #+0]
   \       0x9A   0x6048             STR      R0,[R1, #+4]
   2023          
   2024                /* Clear Underrun flag */
   2025                __HAL_I2S_CLEAR_UDRFLAG(hi2s);
   \       0x9C   0x2000             MOVS     R0,#+0
   \       0x9E   0x9001             STR      R0,[SP, #+4]
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x6880             LDR      R0,[R0, #+8]
   \       0xA4   0x9001             STR      R0,[SP, #+4]
   \       0xA6   0x9801             LDR      R0,[SP, #+4]
   2026          
   2027                /* Set the I2S State ready */
   2028                hi2s->State = HAL_I2S_STATE_READY;
   \       0xA8   0x2001             MOVS     R0,#+1
   \       0xAA   0xF884 0x0041      STRB     R0,[R4, #+65]
   2029          
   2030                /* Set the error code and execute error callback*/
   2031                SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
   \       0xAE   0x6C60             LDR      R0,[R4, #+68]
   \       0xB0   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0xB4   0x6460             STR      R0,[R4, #+68]
   2032                /* Call user error callback */
   2033          #if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
   2034                hi2s->ErrorCallback(hi2s);
   2035          #else
   2036                HAL_I2S_ErrorCallback(hi2s);
   \       0xB6   0x0020             MOVS     R0,R4
   \       0xB8   0x.... 0x....      BL       HAL_I2S_ErrorCallback
   2037          #endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
   2038              }
   2039            }
   2040          }
   \                     ??I2S_IRQHandler_2: (+1)
   \       0xBC   0xBD13             POP      {R0,R1,R4,PC}
   2041          
   2042          /**
   2043            * @brief  This function handles I2S Communication Timeout.
   2044            * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
   2045            *         the configuration information for I2S module
   2046            * @param  Flag Flag checked
   2047            * @param  State Value of the flag expected
   2048            * @param  Timeout Duration of the timeout
   2049            * @retval HAL status
   2050            */

   \                                 In section .text, align 2, keep-with-next
   2051          static HAL_StatusTypeDef I2S_WaitFlagStateUntilTimeout(I2S_HandleTypeDef *hi2s, uint32_t Flag, FlagStatus State,
   2052                                                                 uint32_t Timeout)
   2053          {
   \                     I2S_WaitFlagStateUntilTimeout: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x001C             MOVS     R4,R3
   2054            uint32_t tickstart;
   2055          
   2056            /* Get tick */
   2057            tickstart = HAL_GetTick();
   \        0xC   0x.... 0x....      BL       HAL_GetTick
   \       0x10   0x0007             MOVS     R7,R0
   2058          
   2059            /* Wait until flag is set to status*/
   2060            while (((__HAL_I2S_GET_FLAG(hi2s, Flag)) ? SET : RESET) != State)
   \                     ??I2S_WaitFlagStateUntilTimeout_0: (+1)
   \       0x12   0x6828             LDR      R0,[R5, #+0]
   \       0x14   0x6880             LDR      R0,[R0, #+8]
   \       0x16   0x4030             ANDS     R0,R6,R0
   \       0x18   0x42B0             CMP      R0,R6
   \       0x1A   0xD101             BNE.N    ??I2S_WaitFlagStateUntilTimeout_1
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE000             B.N      ??I2S_WaitFlagStateUntilTimeout_2
   \                     ??I2S_WaitFlagStateUntilTimeout_1: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
   \                     ??I2S_WaitFlagStateUntilTimeout_2: (+1)
   \       0x22   0x4641             MOV      R1,R8
   \       0x24   0xB2C9             UXTB     R1,R1
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD011             BEQ.N    ??I2S_WaitFlagStateUntilTimeout_3
   2061            {
   2062              if (Timeout != HAL_MAX_DELAY)
   \       0x2A   0xF114 0x0F01      CMN      R4,#+1
   \       0x2E   0xD0F0             BEQ.N    ??I2S_WaitFlagStateUntilTimeout_0
   2063              {
   2064                if (((HAL_GetTick() - tickstart) >= Timeout) || (Timeout == 0U))
   \       0x30   0x.... 0x....      BL       HAL_GetTick
   \       0x34   0x1BC0             SUBS     R0,R0,R7
   \       0x36   0x42A0             CMP      R0,R4
   \       0x38   0xD201             BCS.N    ??I2S_WaitFlagStateUntilTimeout_4
   \       0x3A   0x2C00             CMP      R4,#+0
   \       0x3C   0xD1E9             BNE.N    ??I2S_WaitFlagStateUntilTimeout_0
   2065                {
   2066                  /* Set the I2S State ready */
   2067                  hi2s->State = HAL_I2S_STATE_READY;
   \                     ??I2S_WaitFlagStateUntilTimeout_4: (+1)
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0xF885 0x0041      STRB     R0,[R5, #+65]
   2068          
   2069                  /* Process Unlocked */
   2070                  __HAL_UNLOCK(hi2s);
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xF885 0x0040      STRB     R0,[R5, #+64]
   2071          
   2072                  return HAL_TIMEOUT;
   \       0x4A   0x2003             MOVS     R0,#+3
   \       0x4C   0xE000             B.N      ??I2S_WaitFlagStateUntilTimeout_5
   2073                }
   2074              }
   2075            }
   2076            return HAL_OK;
   \                     ??I2S_WaitFlagStateUntilTimeout_3: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \                     ??I2S_WaitFlagStateUntilTimeout_5: (+1)
   \       0x50   0xE8BD 0x81F0      POP      {R4-R8,PC}
   2077          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0xFFFF'F040        DC32     0xfffff040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     HAL_I2SEx_FullDuplex_IRQHandler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x4000'3800        DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x4000'3400        DC32     0x40003400
   2078          
   2079          /**
   2080            * @}
   2081            */
   2082          
   2083          /**
   2084            * @}
   2085            */
   2086          
   2087          /**
   2088            * @}
   2089            */
   2090          
   2091          #endif /* HAL_I2S_MODULE_ENABLED */
   2092          
   2093          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_I2S_DMAPause
       0   HAL_I2S_DMAResume
      24   HAL_I2S_DMAStop
        24   -> HAL_DMA_Abort
        24   -> HAL_GetTick
        24   -> I2S_WaitFlagStateUntilTimeout
       8   HAL_I2S_DeInit
         8   -> HAL_I2S_MspDeInit
       0   HAL_I2S_ErrorCallback
       0   HAL_I2S_GetError
       0   HAL_I2S_GetState
       8   HAL_I2S_IRQHandler
         8   -- Indirect call
      32   HAL_I2S_Init
        32   -> HAL_I2S_MspInit
        32   -> HAL_RCCEx_GetPeriphCLKFreq
       0   HAL_I2S_MspDeInit
       0   HAL_I2S_MspInit
      32   HAL_I2S_Receive
        32   -> I2S_WaitFlagStateUntilTimeout
      24   HAL_I2S_Receive_DMA
        24   -> HAL_DMA_Start_IT
       8   HAL_I2S_Receive_IT
       0   HAL_I2S_RxCpltCallback
       0   HAL_I2S_RxHalfCpltCallback
      32   HAL_I2S_Transmit
        32   -> I2S_WaitFlagStateUntilTimeout
      24   HAL_I2S_Transmit_DMA
        24   -> HAL_DMA_Start_IT
       8   HAL_I2S_Transmit_IT
       0   HAL_I2S_TxCpltCallback
       0   HAL_I2S_TxHalfCpltCallback
      16   I2S_DMAError
        16   -> HAL_I2S_ErrorCallback
      16   I2S_DMARxCplt
        16   -> HAL_I2S_RxCpltCallback
      16   I2S_DMARxHalfCplt
        16   -> HAL_I2S_RxHalfCpltCallback
      16   I2S_DMATxCplt
        16   -> HAL_I2S_TxCpltCallback
      16   I2S_DMATxHalfCplt
        16   -> HAL_I2S_TxHalfCpltCallback
      16   I2S_IRQHandler
        16   -> HAL_I2S_ErrorCallback
        16   -> I2S_Receive_IT
        16   -> I2S_Transmit_IT
       8   I2S_Receive_IT
         8   -> HAL_I2S_RxCpltCallback
       8   I2S_Transmit_IT
         8   -> HAL_I2S_TxCpltCallback
      24   I2S_WaitFlagStateUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
     122  HAL_I2S_DMAPause
     180  HAL_I2S_DMAResume
     668  HAL_I2S_DMAStop
      56  HAL_I2S_DeInit
       2  HAL_I2S_ErrorCallback
       4  HAL_I2S_GetError
       6  HAL_I2S_GetState
      12  HAL_I2S_IRQHandler
     436  HAL_I2S_Init
       2  HAL_I2S_MspDeInit
       2  HAL_I2S_MspInit
     284  HAL_I2S_Receive
     252  HAL_I2S_Receive_DMA
     142  HAL_I2S_Receive_IT
       2  HAL_I2S_RxCpltCallback
       2  HAL_I2S_RxHalfCpltCallback
     342  HAL_I2S_Transmit
     220  HAL_I2S_Transmit_DMA
     142  HAL_I2S_Transmit_IT
       2  HAL_I2S_TxCpltCallback
       2  HAL_I2S_TxHalfCpltCallback
      48  I2S_DMAError
      42  I2S_DMARxCplt
      14  I2S_DMARxHalfCplt
      42  I2S_DMATxCplt
      14  I2S_DMATxHalfCplt
     190  I2S_IRQHandler
      56  I2S_Receive_IT
      56  I2S_Transmit_IT
      84  I2S_WaitFlagStateUntilTimeout

 
 3'442 bytes in section .text
 
 3'428 bytes of CODE memory (+ 14 bytes shared)

Errors: none
Warnings: none
