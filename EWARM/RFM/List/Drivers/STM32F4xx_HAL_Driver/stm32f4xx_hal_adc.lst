###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         21/Sep/2022  13:06:22
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_adc.c
#    Command line      =
#        -f
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_adc.o.rsp
#        (C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_adc.c
#        -D USE_HAL_DRIVER -D STM32F407xx -lC
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver
#        -o
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/App\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Core/Inc\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Include\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/display\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Library\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_adc.o.d
#    Locale            =  C
#    List file         =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_adc.lst
#    Object file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_adc.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_adc.c
      4            * @author  MCD Application Team
      5            * @brief   This file provides firmware functions to manage the following 
      6            *          functionalities of the Analog to Digital Convertor (ADC) peripheral:
      7            *           + Initialization and de-initialization functions
      8            *           + IO operation functions
      9            *           + State and errors functions
     10            *         
     11            @verbatim
     12            ==============================================================================
     13                              ##### ADC Peripheral features #####
     14            ==============================================================================
     15            [..] 
     16            (#) 12-bit, 10-bit, 8-bit or 6-bit configurable resolution.
     17            (#) Interrupt generation at the end of conversion, end of injected conversion,  
     18                and in case of analog watchdog or overrun events
     19            (#) Single and continuous conversion modes.
     20            (#) Scan mode for automatic conversion of channel 0 to channel x.
     21            (#) Data alignment with in-built data coherency.
     22            (#) Channel-wise programmable sampling time.
     23            (#) External trigger option with configurable polarity for both regular and 
     24                injected conversion.
     25            (#) Dual/Triple mode (on devices with 2 ADCs or more).
     26            (#) Configurable DMA data storage in Dual/Triple ADC mode. 
     27            (#) Configurable delay between conversions in Dual/Triple interleaved mode.
     28            (#) ADC conversion type (refer to the datasheets).
     29            (#) ADC supply requirements: 2.4 V to 3.6 V at full speed and down to 1.8 V at 
     30                slower speed.
     31            (#) ADC input range: VREF(minus) = VIN = VREF(plus).
     32            (#) DMA request generation during regular channel conversion.
     33          
     34          
     35                               ##### How to use this driver #####
     36            ==============================================================================
     37            [..]
     38            (#)Initialize the ADC low level resources by implementing the HAL_ADC_MspInit():
     39                 (##) Enable the ADC interface clock using __HAL_RCC_ADC_CLK_ENABLE()
     40                 (##) ADC pins configuration
     41                       (+++) Enable the clock for the ADC GPIOs using the following function:
     42                             __HAL_RCC_GPIOx_CLK_ENABLE()  
     43                       (+++) Configure these ADC pins in analog mode using HAL_GPIO_Init() 
     44                 (##) In case of using interrupts (e.g. HAL_ADC_Start_IT())
     45                       (+++) Configure the ADC interrupt priority using HAL_NVIC_SetPriority()
     46                       (+++) Enable the ADC IRQ handler using HAL_NVIC_EnableIRQ()
     47                       (+++) In ADC IRQ handler, call HAL_ADC_IRQHandler()
     48                 (##) In case of using DMA to control data transfer (e.g. HAL_ADC_Start_DMA())
     49                       (+++) Enable the DMAx interface clock using __HAL_RCC_DMAx_CLK_ENABLE()
     50                       (+++) Configure and enable two DMA streams stream for managing data
     51                           transfer from peripheral to memory (output stream)
     52                       (+++) Associate the initialized DMA handle to the CRYP DMA handle
     53                           using  __HAL_LINKDMA()
     54                       (+++) Configure the priority and enable the NVIC for the transfer complete
     55                           interrupt on the two DMA Streams. The output stream should have higher
     56                           priority than the input stream.
     57                                 
     58              *** Configuration of ADC, groups regular/injected, channels parameters ***
     59            ==============================================================================
     60            [..]
     61            (#) Configure the ADC parameters (resolution, data alignment, ...)
     62                and regular group parameters (conversion trigger, sequencer, ...)
     63                using function HAL_ADC_Init().
     64          
     65            (#) Configure the channels for regular group parameters (channel number, 
     66                channel rank into sequencer, ..., into regular group)
     67                using function HAL_ADC_ConfigChannel().
     68          
     69            (#) Optionally, configure the injected group parameters (conversion trigger, 
     70                sequencer, ..., of injected group)
     71                and the channels for injected group parameters (channel number, 
     72                channel rank into sequencer, ..., into injected group)
     73                using function HAL_ADCEx_InjectedConfigChannel().
     74          
     75            (#) Optionally, configure the analog watchdog parameters (channels
     76                monitored, thresholds, ...) using function HAL_ADC_AnalogWDGConfig().
     77          
     78            (#) Optionally, for devices with several ADC instances: configure the 
     79                multimode parameters using function HAL_ADCEx_MultiModeConfigChannel().
     80          
     81                                 *** Execution of ADC conversions ***
     82            ==============================================================================
     83            [..]  
     84            (#) ADC driver can be used among three modes: polling, interruption,
     85                transfer by DMA.    
     86          
     87               *** Polling mode IO operation ***
     88               =================================
     89               [..]    
     90                 (+) Start the ADC peripheral using HAL_ADC_Start() 
     91                 (+) Wait for end of conversion using HAL_ADC_PollForConversion(), at this stage
     92                     user can specify the value of timeout according to his end application      
     93                 (+) To read the ADC converted values, use the HAL_ADC_GetValue() function.
     94                 (+) Stop the ADC peripheral using HAL_ADC_Stop()
     95                 
     96               *** Interrupt mode IO operation ***    
     97               ===================================
     98               [..]    
     99                 (+) Start the ADC peripheral using HAL_ADC_Start_IT() 
    100                 (+) Use HAL_ADC_IRQHandler() called under ADC_IRQHandler() Interrupt subroutine
    101                 (+) At ADC end of conversion HAL_ADC_ConvCpltCallback() function is executed and user can 
    102                     add his own code by customization of function pointer HAL_ADC_ConvCpltCallback 
    103                 (+) In case of ADC Error, HAL_ADC_ErrorCallback() function is executed and user can 
    104                     add his own code by customization of function pointer HAL_ADC_ErrorCallback
    105                 (+) Stop the ADC peripheral using HAL_ADC_Stop_IT()     
    106          
    107               *** DMA mode IO operation ***    
    108               ==============================
    109               [..]    
    110                 (+) Start the ADC peripheral using HAL_ADC_Start_DMA(), at this stage the user specify the length 
    111                     of data to be transferred at each end of conversion 
    112                 (+) At The end of data transfer by HAL_ADC_ConvCpltCallback() function is executed and user can 
    113                     add his own code by customization of function pointer HAL_ADC_ConvCpltCallback 
    114                 (+) In case of transfer Error, HAL_ADC_ErrorCallback() function is executed and user can 
    115                     add his own code by customization of function pointer HAL_ADC_ErrorCallback
    116                 (+) Stop the ADC peripheral using HAL_ADC_Stop_DMA()
    117                              
    118               *** ADC HAL driver macros list ***
    119               ============================================= 
    120               [..]
    121                 Below the list of most used macros in ADC HAL driver.
    122                 
    123                (+) __HAL_ADC_ENABLE : Enable the ADC peripheral
    124                (+) __HAL_ADC_DISABLE : Disable the ADC peripheral
    125                (+) __HAL_ADC_ENABLE_IT: Enable the ADC end of conversion interrupt
    126                (+) __HAL_ADC_DISABLE_IT: Disable the ADC end of conversion interrupt
    127                (+) __HAL_ADC_GET_IT_SOURCE: Check if the specified ADC interrupt source is enabled or disabled
    128                (+) __HAL_ADC_CLEAR_FLAG: Clear the ADC's pending flags
    129                (+) __HAL_ADC_GET_FLAG: Get the selected ADC's flag status
    130                (+) ADC_GET_RESOLUTION: Return resolution bits in CR1 register 
    131                
    132               [..] 
    133                 (@) You can refer to the ADC HAL driver header file for more useful macros 
    134          
    135                                *** Deinitialization of ADC ***
    136            ==============================================================================
    137            [..]
    138            (#) Disable the ADC interface
    139               (++) ADC clock can be hard reset and disabled at RCC top level.
    140               (++) Hard reset of ADC peripherals
    141                    using macro __HAL_RCC_ADC_FORCE_RESET(), __HAL_RCC_ADC_RELEASE_RESET().
    142               (++) ADC clock disable using the equivalent macro/functions as configuration step.
    143                         (+++) Example:
    144                             Into HAL_ADC_MspDeInit() (recommended code location) or with
    145                             other device clock parameters configuration:
    146                         (+++) HAL_RCC_GetOscConfig(&RCC_OscInitStructure);
    147                         (+++) RCC_OscInitStructure.OscillatorType = RCC_OSCILLATORTYPE_HSI;
    148                         (+++) RCC_OscInitStructure.HSIState = RCC_HSI_OFF; (if not used for system clock)
    149                         (+++) HAL_RCC_OscConfig(&RCC_OscInitStructure);
    150          
    151            (#) ADC pins configuration
    152               (++) Disable the clock for the ADC GPIOs using macro __HAL_RCC_GPIOx_CLK_DISABLE()
    153          
    154            (#) Optionally, in case of usage of ADC with interruptions:
    155               (++) Disable the NVIC for ADC using function HAL_NVIC_DisableIRQ(ADCx_IRQn)
    156          
    157            (#) Optionally, in case of usage of DMA:
    158                  (++) Deinitialize the DMA using function HAL_DMA_DeInit().
    159                  (++) Disable the NVIC for DMA using function HAL_NVIC_DisableIRQ(DMAx_Channelx_IRQn)   
    160                                *** Callback registration ***
    161            ==============================================================================
    162              [..]
    163          
    164               The compilation flag USE_HAL_ADC_REGISTER_CALLBACKS, when set to 1,
    165               allows the user to configure dynamically the driver callbacks.
    166               Use Functions @ref HAL_ADC_RegisterCallback()
    167               to register an interrupt callback.
    168              [..]
    169          
    170               Function @ref HAL_ADC_RegisterCallback() allows to register following callbacks:
    171                 (+) ConvCpltCallback               : ADC conversion complete callback
    172                 (+) ConvHalfCpltCallback           : ADC conversion DMA half-transfer callback
    173                 (+) LevelOutOfWindowCallback       : ADC analog watchdog 1 callback
    174                 (+) ErrorCallback                  : ADC error callback
    175                 (+) InjectedConvCpltCallback       : ADC group injected conversion complete callback
    176                 (+) InjectedQueueOverflowCallback  : ADC group injected context queue overflow callback
    177                 (+) LevelOutOfWindow2Callback      : ADC analog watchdog 2 callback
    178                 (+) LevelOutOfWindow3Callback      : ADC analog watchdog 3 callback
    179                 (+) EndOfSamplingCallback          : ADC end of sampling callback
    180                 (+) MspInitCallback                : ADC Msp Init callback
    181                 (+) MspDeInitCallback              : ADC Msp DeInit callback
    182               This function takes as parameters the HAL peripheral handle, the Callback ID
    183               and a pointer to the user callback function.
    184              [..]
    185          
    186               Use function @ref HAL_ADC_UnRegisterCallback to reset a callback to the default
    187               weak function.
    188              [..]
    189          
    190               @ref HAL_ADC_UnRegisterCallback takes as parameters the HAL peripheral handle,
    191               and the Callback ID.
    192               This function allows to reset following callbacks:
    193                 (+) ConvCpltCallback               : ADC conversion complete callback
    194                 (+) ConvHalfCpltCallback           : ADC conversion DMA half-transfer callback
    195                 (+) LevelOutOfWindowCallback       : ADC analog watchdog 1 callback
    196                 (+) ErrorCallback                  : ADC error callback
    197                 (+) InjectedConvCpltCallback       : ADC group injected conversion complete callback
    198                 (+) InjectedQueueOverflowCallback  : ADC group injected context queue overflow callback
    199                 (+) LevelOutOfWindow2Callback      : ADC analog watchdog 2 callback
    200                 (+) LevelOutOfWindow3Callback      : ADC analog watchdog 3 callback
    201                 (+) EndOfSamplingCallback          : ADC end of sampling callback
    202                 (+) MspInitCallback                : ADC Msp Init callback
    203                 (+) MspDeInitCallback              : ADC Msp DeInit callback
    204               [..]
    205          
    206               By default, after the @ref HAL_ADC_Init() and when the state is @ref HAL_ADC_STATE_RESET
    207               all callbacks are set to the corresponding weak functions:
    208               examples @ref HAL_ADC_ConvCpltCallback(), @ref HAL_ADC_ErrorCallback().
    209               Exception done for MspInit and MspDeInit functions that are
    210               reset to the legacy weak functions in the @ref HAL_ADC_Init()/ @ref HAL_ADC_DeInit() only when
    211               these callbacks are null (not registered beforehand).
    212              [..]
    213          
    214               If MspInit or MspDeInit are not null, the @ref HAL_ADC_Init()/ @ref HAL_ADC_DeInit()
    215               keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
    216               [..]
    217          
    218               Callbacks can be registered/unregistered in @ref HAL_ADC_STATE_READY state only.
    219               Exception done MspInit/MspDeInit functions that can be registered/unregistered
    220               in @ref HAL_ADC_STATE_READY or @ref HAL_ADC_STATE_RESET state,
    221               thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    222              [..]
    223          
    224               Then, the user first registers the MspInit/MspDeInit user callbacks
    225               using @ref HAL_ADC_RegisterCallback() before calling @ref HAL_ADC_DeInit()
    226               or @ref HAL_ADC_Init() function.
    227               [..]
    228          
    229               When the compilation flag USE_HAL_ADC_REGISTER_CALLBACKS is set to 0 or
    230               not defined, the callback registration feature is not available and all callbacks
    231               are set to the corresponding weak functions.
    232          
    233              @endverbatim
    234            ******************************************************************************
    235            * @attention
    236            *
    237            * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
    238            * All rights reserved.</center></h2>
    239            *
    240            * This software component is licensed by ST under BSD 3-Clause license,
    241            * the "License"; You may not use this file except in compliance with the
    242            * License. You may obtain a copy of the License at:
    243            *                        opensource.org/licenses/BSD-3-Clause
    244            *
    245            ******************************************************************************
    246            */ 
    247          
    248          /* Includes ------------------------------------------------------------------*/
    249          #include "stm32f4xx_hal.h"
    250          
    251          /** @addtogroup STM32F4xx_HAL_Driver
    252            * @{
    253            */
    254          
    255          /** @defgroup ADC ADC
    256            * @brief ADC driver modules
    257            * @{
    258            */ 
    259          
    260          #ifdef HAL_ADC_MODULE_ENABLED
    261              
    262          /* Private typedef -----------------------------------------------------------*/
    263          /* Private define ------------------------------------------------------------*/
    264          /* Private macro -------------------------------------------------------------*/
    265          /* Private variables ---------------------------------------------------------*/
    266          /** @addtogroup ADC_Private_Functions
    267            * @{
    268            */
    269          /* Private function prototypes -----------------------------------------------*/
    270          static void ADC_Init(ADC_HandleTypeDef* hadc);
    271          static void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma);
    272          static void ADC_DMAError(DMA_HandleTypeDef *hdma);
    273          static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma);
    274          /**
    275            * @}
    276            */
    277          /* Exported functions --------------------------------------------------------*/
    278          /** @defgroup ADC_Exported_Functions ADC Exported Functions
    279            * @{
    280            */
    281          
    282          /** @defgroup ADC_Exported_Functions_Group1 Initialization and de-initialization functions 
    283           *  @brief    Initialization and Configuration functions 
    284           *
    285          @verbatim    
    286           ===============================================================================
    287                        ##### Initialization and de-initialization functions #####
    288           ===============================================================================
    289              [..]  This section provides functions allowing to:
    290                (+) Initialize and configure the ADC. 
    291                (+) De-initialize the ADC. 
    292                   
    293          @endverbatim
    294            * @{
    295            */
    296          
    297          /**
    298            * @brief  Initializes the ADCx peripheral according to the specified parameters 
    299            *         in the ADC_InitStruct and initializes the ADC MSP.
    300            *           
    301            * @note   This function is used to configure the global features of the ADC ( 
    302            *         ClockPrescaler, Resolution, Data Alignment and number of conversion), however,
    303            *         the rest of the configuration parameters are specific to the regular
    304            *         channels group (scan mode activation, continuous mode activation,
    305            *         External trigger source and edge, DMA continuous request after the  
    306            *         last transfer and End of conversion selection).
    307            *             
    308            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
    309            *         the configuration information for the specified ADC.  
    310            * @retval HAL status
    311            */

   \                                 In section .text, align 2, keep-with-next
    312          HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
    313          {
   \                     HAL_ADC_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    314            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
    315            
    316            /* Check ADC handle */
    317            if(hadc == NULL)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??HAL_ADC_Init_0
    318            {
    319              return HAL_ERROR;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE029             B.N      ??HAL_ADC_Init_1
    320            }
    321            
    322            /* Check the parameters */
    323            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    324            assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
    325            assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
    326            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ScanConvMode));
    327            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
    328            assert_param(IS_ADC_EXT_TRIG(hadc->Init.ExternalTrigConv));
    329            assert_param(IS_ADC_DATA_ALIGN(hadc->Init.DataAlign));
    330            assert_param(IS_ADC_REGULAR_LENGTH(hadc->Init.NbrOfConversion));
    331            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DMAContinuousRequests));
    332            assert_param(IS_ADC_EOCSelection(hadc->Init.EOCSelection));
    333            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
    334            
    335            if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
   \                     ??HAL_ADC_Init_0: (+1)
   \        0xE   0x6AA0             LDR      R0,[R4, #+40]
   \       0x10   0x.... 0x....      LDR.W    R1,??DataTable7
   \       0x14   0x4288             CMP      R0,R1
    336            {
    337              assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
    338            }
    339            
    340            if(hadc->State == HAL_ADC_STATE_RESET)
   \                     ??HAL_ADC_Init_2: (+1)
   \       0x16   0x6C20             LDR      R0,[R4, #+64]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD107             BNE.N    ??HAL_ADC_Init_3
    341            {
    342          #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    343              /* Init the ADC Callback settings */
    344              hadc->ConvCpltCallback              = HAL_ADC_ConvCpltCallback;                 /* Legacy weak callback */
    345              hadc->ConvHalfCpltCallback          = HAL_ADC_ConvHalfCpltCallback;             /* Legacy weak callback */
    346              hadc->LevelOutOfWindowCallback      = HAL_ADC_LevelOutOfWindowCallback;         /* Legacy weak callback */
    347              hadc->ErrorCallback                 = HAL_ADC_ErrorCallback;                    /* Legacy weak callback */
    348              hadc->InjectedConvCpltCallback      = HAL_ADCEx_InjectedConvCpltCallback;       /* Legacy weak callback */
    349              if (hadc->MspInitCallback == NULL)
    350              {
    351                hadc->MspInitCallback = HAL_ADC_MspInit; /* Legacy weak MspInit  */
    352              }
    353          
    354              /* Init the low level hardware */
    355              hadc->MspInitCallback(hadc);
    356          #else
    357              /* Init the low level hardware */
    358              HAL_ADC_MspInit(hadc);
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x.... 0x....      BL       HAL_ADC_MspInit
    359          #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
    360          
    361              /* Initialize ADC error code */
    362              ADC_CLEAR_ERRORCODE(hadc);
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x6460             STR      R0,[R4, #+68]
    363              
    364              /* Allocate lock resource and initialize it */
    365              hadc->Lock = HAL_UNLOCKED;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xF884 0x003C      STRB     R0,[R4, #+60]
    366            }
    367            
    368            /* Configuration of ADC parameters if previous preliminary actions are      */ 
    369            /* correctly completed.                                                     */
    370            if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
   \                     ??HAL_ADC_Init_3: (+1)
   \       0x2C   0x6C20             LDR      R0,[R4, #+64]
   \       0x2E   0x06C0             LSLS     R0,R0,#+27
   \       0x30   0xD410             BMI.N    ??HAL_ADC_Init_4
    371            {
    372              /* Set ADC state */
    373              ADC_STATE_CLR_SET(hadc->State,
    374                                HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
    375                                HAL_ADC_STATE_BUSY_INTERNAL);
   \       0x32   0x6C20             LDR      R0,[R4, #+64]
   \       0x34   0xF430 0x5088      BICS     R0,R0,#0x1100
   \       0x38   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x3C   0x6420             STR      R0,[R4, #+64]
    376              
    377              /* Set ADC parameters */
    378              ADC_Init(hadc);
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0x.... 0x....      BL       ADC_Init
    379              
    380              /* Set ADC error code to none */
    381              ADC_CLEAR_ERRORCODE(hadc);
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0x6460             STR      R0,[R4, #+68]
    382              
    383              /* Set the ADC state */
    384              ADC_STATE_CLR_SET(hadc->State,
    385                                HAL_ADC_STATE_BUSY_INTERNAL,
    386                                HAL_ADC_STATE_READY);
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0x6C21             LDR      R1,[R4, #+64]
   \       0x4C   0xF360 0x0101      BFI      R1,R0,#+0,#+2
   \       0x50   0x6421             STR      R1,[R4, #+64]
   \       0x52   0xE001             B.N      ??HAL_ADC_Init_5
    387            }
    388            else
    389            {
    390              tmp_hal_status = HAL_ERROR;
   \                     ??HAL_ADC_Init_4: (+1)
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0x0005             MOVS     R5,R0
    391            }
    392            
    393            /* Release Lock */
    394            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Init_5: (+1)
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xF884 0x003C      STRB     R0,[R4, #+60]
    395          
    396            /* Return function status */
    397            return tmp_hal_status;
   \       0x5E   0x0028             MOVS     R0,R5
   \       0x60   0xB2C0             UXTB     R0,R0
   \                     ??HAL_ADC_Init_1: (+1)
   \       0x62   0xBD32             POP      {R1,R4,R5,PC}
    398          }
    399          
    400          /**
    401            * @brief  Deinitializes the ADCx peripheral registers to their default reset values. 
    402            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
    403            *         the configuration information for the specified ADC.  
    404            * @retval HAL status
    405            */

   \                                 In section .text, align 2, keep-with-next
    406          HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef* hadc)
    407          {
   \                     HAL_ADC_DeInit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    408            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
    409            
    410            /* Check ADC handle */
    411            if(hadc == NULL)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??HAL_ADC_DeInit_0
    412            {
    413              return HAL_ERROR;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE019             B.N      ??HAL_ADC_DeInit_1
    414            }
    415            
    416            /* Check the parameters */
    417            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    418            
    419            /* Set ADC state */
    420            SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
   \                     ??HAL_ADC_DeInit_0: (+1)
   \        0xE   0x6C20             LDR      R0,[R4, #+64]
   \       0x10   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x14   0x6420             STR      R0,[R4, #+64]
    421            
    422            /* Stop potential conversion on going, on regular and injected groups */
    423            /* Disable ADC peripheral */
    424            __HAL_ADC_DISABLE(hadc);
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6880             LDR      R0,[R0, #+8]
   \       0x1A   0x0840             LSRS     R0,R0,#+1
   \       0x1C   0x0040             LSLS     R0,R0,#+1
   \       0x1E   0x6821             LDR      R1,[R4, #+0]
   \       0x20   0x6088             STR      R0,[R1, #+8]
    425            
    426            /* Configuration of ADC parameters if previous preliminary actions are      */ 
    427            /* correctly completed.                                                     */
    428            if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6880             LDR      R0,[R0, #+8]
   \       0x26   0x07C0             LSLS     R0,R0,#+31
   \       0x28   0xD406             BMI.N    ??HAL_ADC_DeInit_2
    429            {
    430          #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    431            if (hadc->MspDeInitCallback == NULL)
    432            {
    433              hadc->MspDeInitCallback = HAL_ADC_MspDeInit; /* Legacy weak MspDeInit  */
    434            }
    435          
    436            /* DeInit the low level hardware: RCC clock, NVIC */
    437            hadc->MspDeInitCallback(hadc);
    438          #else
    439            /* DeInit the low level hardware: RCC clock, NVIC */
    440            HAL_ADC_MspDeInit(hadc);
   \       0x2A   0x0020             MOVS     R0,R4
   \       0x2C   0x.... 0x....      BL       HAL_ADC_MspDeInit
    441          #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
    442              
    443              /* Set ADC error code to none */
    444              ADC_CLEAR_ERRORCODE(hadc);
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x6460             STR      R0,[R4, #+68]
    445              
    446              /* Set ADC state */
    447              hadc->State = HAL_ADC_STATE_RESET;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x6420             STR      R0,[R4, #+64]
    448            }
    449            
    450            /* Process unlocked */
    451            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_DeInit_2: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xF884 0x003C      STRB     R0,[R4, #+60]
    452            
    453            /* Return function status */
    454            return tmp_hal_status;
   \       0x3E   0x0028             MOVS     R0,R5
   \       0x40   0xB2C0             UXTB     R0,R0
   \                     ??HAL_ADC_DeInit_1: (+1)
   \       0x42   0xBD32             POP      {R1,R4,R5,PC}
    455          }
    456          
    457          #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    458          /**
    459            * @brief  Register a User ADC Callback
    460            *         To be used instead of the weak predefined callback
    461            * @param  hadc Pointer to a ADC_HandleTypeDef structure that contains
    462            *                the configuration information for the specified ADC.
    463            * @param  CallbackID ID of the callback to be registered
    464            *         This parameter can be one of the following values:
    465            *          @arg @ref HAL_ADC_CONVERSION_COMPLETE_CB_ID      ADC conversion complete callback ID
    466            *          @arg @ref HAL_ADC_CONVERSION_HALF_CB_ID          ADC conversion DMA half-transfer callback ID
    467            *          @arg @ref HAL_ADC_LEVEL_OUT_OF_WINDOW_1_CB_ID    ADC analog watchdog 1 callback ID
    468            *          @arg @ref HAL_ADC_ERROR_CB_ID                    ADC error callback ID
    469            *          @arg @ref HAL_ADC_INJ_CONVERSION_COMPLETE_CB_ID  ADC group injected conversion complete callback ID
    470            *          @arg @ref HAL_ADC_MSPINIT_CB_ID                  ADC Msp Init callback ID
    471            *          @arg @ref HAL_ADC_MSPDEINIT_CB_ID                ADC Msp DeInit callback ID
    472            * @param  pCallback pointer to the Callback function
    473            * @retval HAL status
    474            */
    475          HAL_StatusTypeDef HAL_ADC_RegisterCallback(ADC_HandleTypeDef *hadc, HAL_ADC_CallbackIDTypeDef CallbackID, pADC_CallbackTypeDef pCallback)
    476          {
    477            HAL_StatusTypeDef status = HAL_OK;
    478          
    479            if (pCallback == NULL)
    480            {
    481              /* Update the error code */
    482              hadc->ErrorCode |= HAL_ADC_ERROR_INVALID_CALLBACK;
    483          
    484              return HAL_ERROR;
    485            }
    486          
    487            if ((hadc->State & HAL_ADC_STATE_READY) != 0UL)
    488            {
    489              switch (CallbackID)
    490              {
    491                case HAL_ADC_CONVERSION_COMPLETE_CB_ID :
    492                  hadc->ConvCpltCallback = pCallback;
    493                  break;
    494          
    495                case HAL_ADC_CONVERSION_HALF_CB_ID :
    496                  hadc->ConvHalfCpltCallback = pCallback;
    497                  break;
    498          
    499                case HAL_ADC_LEVEL_OUT_OF_WINDOW_1_CB_ID :
    500                  hadc->LevelOutOfWindowCallback = pCallback;
    501                  break;
    502          
    503                case HAL_ADC_ERROR_CB_ID :
    504                  hadc->ErrorCallback = pCallback;
    505                  break;
    506          
    507                case HAL_ADC_INJ_CONVERSION_COMPLETE_CB_ID :
    508                  hadc->InjectedConvCpltCallback = pCallback;
    509                  break;
    510          
    511                case HAL_ADC_MSPINIT_CB_ID :
    512                  hadc->MspInitCallback = pCallback;
    513                  break;
    514          
    515                case HAL_ADC_MSPDEINIT_CB_ID :
    516                  hadc->MspDeInitCallback = pCallback;
    517                  break;
    518          
    519                default :
    520                  /* Update the error code */
    521                  hadc->ErrorCode |= HAL_ADC_ERROR_INVALID_CALLBACK;
    522          
    523                  /* Return error status */
    524                  status = HAL_ERROR;
    525                  break;
    526              }
    527            }
    528            else if (HAL_ADC_STATE_RESET == hadc->State)
    529            {
    530              switch (CallbackID)
    531              {
    532                case HAL_ADC_MSPINIT_CB_ID :
    533                  hadc->MspInitCallback = pCallback;
    534                  break;
    535          
    536                case HAL_ADC_MSPDEINIT_CB_ID :
    537                  hadc->MspDeInitCallback = pCallback;
    538                  break;
    539          
    540                default :
    541                  /* Update the error code */
    542                  hadc->ErrorCode |= HAL_ADC_ERROR_INVALID_CALLBACK;
    543          
    544                  /* Return error status */
    545                  status = HAL_ERROR;
    546                  break;
    547              }
    548            }
    549            else
    550            {
    551              /* Update the error code */
    552              hadc->ErrorCode |= HAL_ADC_ERROR_INVALID_CALLBACK;
    553          
    554              /* Return error status */
    555              status =  HAL_ERROR;
    556            }
    557          
    558            return status;
    559          }
    560          
    561          /**
    562            * @brief  Unregister a ADC Callback
    563            *         ADC callback is redirected to the weak predefined callback
    564            * @param  hadc Pointer to a ADC_HandleTypeDef structure that contains
    565            *                the configuration information for the specified ADC.
    566            * @param  CallbackID ID of the callback to be unregistered
    567            *         This parameter can be one of the following values:
    568            *          @arg @ref HAL_ADC_CONVERSION_COMPLETE_CB_ID      ADC conversion complete callback ID
    569            *          @arg @ref HAL_ADC_CONVERSION_HALF_CB_ID          ADC conversion DMA half-transfer callback ID
    570            *          @arg @ref HAL_ADC_LEVEL_OUT_OF_WINDOW_1_CB_ID    ADC analog watchdog 1 callback ID
    571            *          @arg @ref HAL_ADC_ERROR_CB_ID                    ADC error callback ID
    572            *          @arg @ref HAL_ADC_INJ_CONVERSION_COMPLETE_CB_ID  ADC group injected conversion complete callback ID
    573            *          @arg @ref HAL_ADC_MSPINIT_CB_ID                  ADC Msp Init callback ID
    574            *          @arg @ref HAL_ADC_MSPDEINIT_CB_ID                ADC Msp DeInit callback ID
    575            * @retval HAL status
    576            */
    577          HAL_StatusTypeDef HAL_ADC_UnRegisterCallback(ADC_HandleTypeDef *hadc, HAL_ADC_CallbackIDTypeDef CallbackID)
    578          {
    579            HAL_StatusTypeDef status = HAL_OK;
    580          
    581            if ((hadc->State & HAL_ADC_STATE_READY) != 0UL)
    582            {
    583              switch (CallbackID)
    584              {
    585                case HAL_ADC_CONVERSION_COMPLETE_CB_ID :
    586                  hadc->ConvCpltCallback = HAL_ADC_ConvCpltCallback;
    587                  break;
    588          
    589                case HAL_ADC_CONVERSION_HALF_CB_ID :
    590                  hadc->ConvHalfCpltCallback = HAL_ADC_ConvHalfCpltCallback;
    591                  break;
    592          
    593                case HAL_ADC_LEVEL_OUT_OF_WINDOW_1_CB_ID :
    594                  hadc->LevelOutOfWindowCallback = HAL_ADC_LevelOutOfWindowCallback;
    595                  break;
    596          
    597                case HAL_ADC_ERROR_CB_ID :
    598                  hadc->ErrorCallback = HAL_ADC_ErrorCallback;
    599                  break;
    600          
    601                case HAL_ADC_INJ_CONVERSION_COMPLETE_CB_ID :
    602                  hadc->InjectedConvCpltCallback = HAL_ADCEx_InjectedConvCpltCallback;
    603                  break;
    604          
    605                case HAL_ADC_MSPINIT_CB_ID :
    606                  hadc->MspInitCallback = HAL_ADC_MspInit; /* Legacy weak MspInit              */
    607                  break;
    608          
    609                case HAL_ADC_MSPDEINIT_CB_ID :
    610                  hadc->MspDeInitCallback = HAL_ADC_MspDeInit; /* Legacy weak MspDeInit            */
    611                  break;
    612          
    613                default :
    614                  /* Update the error code */
    615                  hadc->ErrorCode |= HAL_ADC_ERROR_INVALID_CALLBACK;
    616          
    617                  /* Return error status */
    618                  status =  HAL_ERROR;
    619                  break;
    620              }
    621            }
    622            else if (HAL_ADC_STATE_RESET == hadc->State)
    623            {
    624              switch (CallbackID)
    625              {
    626                case HAL_ADC_MSPINIT_CB_ID :
    627                  hadc->MspInitCallback = HAL_ADC_MspInit;                   /* Legacy weak MspInit              */
    628                  break;
    629          
    630                case HAL_ADC_MSPDEINIT_CB_ID :
    631                  hadc->MspDeInitCallback = HAL_ADC_MspDeInit;               /* Legacy weak MspDeInit            */
    632                  break;
    633          
    634                default :
    635                  /* Update the error code */
    636                  hadc->ErrorCode |= HAL_ADC_ERROR_INVALID_CALLBACK;
    637          
    638                  /* Return error status */
    639                  status =  HAL_ERROR;
    640                  break;
    641              }
    642            }
    643            else
    644            {
    645              /* Update the error code */
    646              hadc->ErrorCode |= HAL_ADC_ERROR_INVALID_CALLBACK;
    647          
    648              /* Return error status */
    649              status =  HAL_ERROR;
    650            }
    651          
    652            return status;
    653          }
    654          
    655          #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
    656          
    657          /**
    658            * @brief  Initializes the ADC MSP.
    659            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
    660            *         the configuration information for the specified ADC.  
    661            * @retval None
    662            */

   \                                 In section .text, align 2
    663          __weak void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
    664          {
    665            /* Prevent unused argument(s) compilation warning */
    666            UNUSED(hadc);
    667            /* NOTE : This function Should not be modified, when the callback is needed,
    668                      the HAL_ADC_MspInit could be implemented in the user file
    669             */ 
    670          }
   \                     HAL_ADC_MspInit: (+1)
   \        0x0   0x4770             BX       LR
    671          
    672          /**
    673            * @brief  DeInitializes the ADC MSP.
    674            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
    675            *         the configuration information for the specified ADC.  
    676            * @retval None
    677            */

   \                                 In section .text, align 2
    678          __weak void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
    679          {
    680            /* Prevent unused argument(s) compilation warning */
    681            UNUSED(hadc);
    682            /* NOTE : This function Should not be modified, when the callback is needed,
    683                      the HAL_ADC_MspDeInit could be implemented in the user file
    684             */ 
    685          }
   \                     HAL_ADC_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
    686          
    687          /**
    688            * @}
    689            */
    690          
    691          /** @defgroup ADC_Exported_Functions_Group2 IO operation functions
    692           *  @brief    IO operation functions 
    693           *
    694          @verbatim   
    695           ===============================================================================
    696                       ##### IO operation functions #####
    697           ===============================================================================  
    698              [..]  This section provides functions allowing to:
    699                (+) Start conversion of regular channel.
    700                (+) Stop conversion of regular channel.
    701                (+) Start conversion of regular channel and enable interrupt.
    702                (+) Stop conversion of regular channel and disable interrupt.
    703                (+) Start conversion of regular channel and enable DMA transfer.
    704                (+) Stop conversion of regular channel and disable DMA transfer.
    705                (+) Handle ADC interrupt request. 
    706                         
    707          @endverbatim
    708            * @{
    709            */
    710          
    711          /**
    712            * @brief  Enables ADC and starts conversion of the regular channels.
    713            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
    714            *         the configuration information for the specified ADC.
    715            * @retval HAL status
    716            */

   \                                 In section .text, align 2, keep-with-next
    717          HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
    718          {
   \                     HAL_ADC_Start: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x0002             MOVS     R2,R0
    719            __IO uint32_t counter = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
    720            ADC_Common_TypeDef *tmpADC_Common;
    721            
    722            /* Check the parameters */
    723            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
    724            assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)); 
    725            
    726            /* Process locked */
    727            __HAL_LOCK(hadc);
   \        0x8   0xF892 0x003C      LDRB     R0,[R2, #+60]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE.N    ??HAL_ADC_Start_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE082             B.N      ??HAL_ADC_Start_1
   \                     ??HAL_ADC_Start_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xF882 0x003C      STRB     R0,[R2, #+60]
    728            
    729            /* Enable the ADC peripheral */
    730            /* Check if ADC peripheral is disabled in order to enable it and wait during 
    731            Tstab time the ADC's stabilization */
    732            if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
   \       0x1A   0x6810             LDR      R0,[R2, #+0]
   \       0x1C   0x6880             LDR      R0,[R0, #+8]
   \       0x1E   0x07C0             LSLS     R0,R0,#+31
   \       0x20   0xD416             BMI.N    ??HAL_ADC_Start_2
    733            {  
    734              /* Enable the Peripheral */
    735              __HAL_ADC_ENABLE(hadc);
   \       0x22   0x6810             LDR      R0,[R2, #+0]
   \       0x24   0x6880             LDR      R0,[R0, #+8]
   \       0x26   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x2A   0x6813             LDR      R3,[R2, #+0]
   \       0x2C   0x6098             STR      R0,[R3, #+8]
    736              
    737              /* Delay for ADC stabilization time */
    738              /* Compute number of CPU cycles to wait for */
    739              counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \       0x32   0x6800             LDR      R0,[R0, #+0]
   \       0x34   0x.... 0x....      LDR.W    R3,??DataTable7_2
   \       0x38   0xFBB0 0xF3F3      UDIV     R3,R0,R3
   \       0x3C   0x2003             MOVS     R0,#+3
   \       0x3E   0x4343             MULS     R3,R0,R3
   \       0x40   0x9300             STR      R3,[SP, #+0]
    740              while(counter != 0U)
   \                     ??HAL_ADC_Start_3: (+1)
   \       0x42   0x9800             LDR      R0,[SP, #+0]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD003             BEQ.N    ??HAL_ADC_Start_2
    741              {
    742                counter--;
   \       0x48   0x9800             LDR      R0,[SP, #+0]
   \       0x4A   0x1E40             SUBS     R0,R0,#+1
   \       0x4C   0x9000             STR      R0,[SP, #+0]
   \       0x4E   0xE7F8             B.N      ??HAL_ADC_Start_3
    743              }
    744            }
    745            
    746            /* Start conversion if ADC is effectively enabled */
    747            if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
   \                     ??HAL_ADC_Start_2: (+1)
   \       0x50   0x6810             LDR      R0,[R2, #+0]
   \       0x52   0x6880             LDR      R0,[R0, #+8]
   \       0x54   0x07C0             LSLS     R0,R0,#+31
   \       0x56   0xD55F             BPL.N    ??HAL_ADC_Start_4
    748            {
    749              /* Set ADC state                                                          */
    750              /* - Clear state bitfield related to regular group conversion results     */
    751              /* - Set state bitfield related to regular group operation                */
    752              ADC_STATE_CLR_SET(hadc->State,
    753                                HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR,
    754                                HAL_ADC_STATE_REG_BUSY);
   \       0x58   0x6C13             LDR      R3,[R2, #+64]
   \       0x5A   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \       0x5E   0x4003             ANDS     R3,R0,R3
   \       0x60   0xF453 0x7380      ORRS     R3,R3,#0x100
   \       0x64   0x6413             STR      R3,[R2, #+64]
    755              
    756              /* If conversions on group regular are also triggering group injected,    */
    757              /* update ADC state.                                                      */
    758              if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
   \       0x66   0x6810             LDR      R0,[R2, #+0]
   \       0x68   0x6840             LDR      R0,[R0, #+4]
   \       0x6A   0x0540             LSLS     R0,R0,#+21
   \       0x6C   0xD504             BPL.N    ??HAL_ADC_Start_5
    759              {
    760                ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
   \       0x6E   0x2001             MOVS     R0,#+1
   \       0x70   0x6C13             LDR      R3,[R2, #+64]
   \       0x72   0xF360 0x330D      BFI      R3,R0,#+12,#+2
   \       0x76   0x6413             STR      R3,[R2, #+64]
    761              }
    762              
    763              /* State machine update: Check if an injected conversion is ongoing */
    764              if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \                     ??HAL_ADC_Start_5: (+1)
   \       0x78   0x6C10             LDR      R0,[R2, #+64]
   \       0x7A   0x04C0             LSLS     R0,R0,#+19
   \       0x7C   0xD504             BPL.N    ??HAL_ADC_Start_6
    765              {
    766                /* Reset ADC error code fields related to conversions on group regular */
    767                CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
   \       0x7E   0x6C50             LDR      R0,[R2, #+68]
   \       0x80   0xF030 0x0006      BICS     R0,R0,#0x6
   \       0x84   0x6450             STR      R0,[R2, #+68]
   \       0x86   0xE001             B.N      ??HAL_ADC_Start_7
    768              }
    769              else
    770              {
    771                /* Reset ADC all error code fields */
    772                ADC_CLEAR_ERRORCODE(hadc);
   \                     ??HAL_ADC_Start_6: (+1)
   \       0x88   0x2000             MOVS     R0,#+0
   \       0x8A   0x6450             STR      R0,[R2, #+68]
    773              } 
    774          
    775              /* Process unlocked */
    776              /* Unlock before starting ADC conversions: in case of potential           */
    777              /* interruption, to let the process to ADC IRQ Handler.                   */
    778              __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Start_7: (+1)
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0xF882 0x003C      STRB     R0,[R2, #+60]
    779          
    780              /* Pointer to the common control register to which is belonging hadc    */
    781              /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
    782              /* control register)                                                    */
    783              tmpADC_Common = ADC_COMMON_REGISTER(hadc);
   \       0x92   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \       0x96   0x0001             MOVS     R1,R0
    784          
    785              /* Clear regular group conversion flag and overrun flag */
    786              /* (To ensure of no unknown state from potential previous ADC operations) */
    787              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
   \       0x98   0xF07F 0x0022      MVNS     R0,#+34
   \       0x9C   0x6813             LDR      R3,[R2, #+0]
   \       0x9E   0x6018             STR      R0,[R3, #+0]
    788              
    789              /* Check if Multimode enabled */
    790              if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
   \       0xA0   0x6848             LDR      R0,[R1, #+4]
   \       0xA2   0xF010 0x0F1F      TST      R0,#0x1F
   \       0xA6   0xD127             BNE.N    ??HAL_ADC_Start_8
    791              {
    792          #if defined(ADC2) && defined(ADC3)
    793                if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
    794                                            || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
   \       0xA8   0x6810             LDR      R0,[R2, #+0]
   \       0xAA   0x.... 0x....      LDR.W    R3,??DataTable7_5
   \       0xAE   0x4298             CMP      R0,R3
   \       0xB0   0xD016             BEQ.N    ??HAL_ADC_Start_9
   \       0xB2   0x6810             LDR      R0,[R2, #+0]
   \       0xB4   0x.... 0x....      LDR.W    R3,??DataTable7_6
   \       0xB8   0x4298             CMP      R0,R3
   \       0xBA   0xD105             BNE.N    ??HAL_ADC_Start_10
   \       0xBC   0x.... 0x....      LDR.W    R0,??DataTable7_7
   \       0xC0   0x6800             LDR      R0,[R0, #+0]
   \       0xC2   0xF010 0x0F1F      TST      R0,#0x1F
   \       0xC6   0xD00B             BEQ.N    ??HAL_ADC_Start_9
   \                     ??HAL_ADC_Start_10: (+1)
   \       0xC8   0x6810             LDR      R0,[R2, #+0]
   \       0xCA   0x.... 0x....      LDR.W    R3,??DataTable7_8
   \       0xCE   0x4298             CMP      R0,R3
   \       0xD0   0xD122             BNE.N    ??HAL_ADC_Start_4
   \       0xD2   0x.... 0x....      LDR.W    R0,??DataTable7_7
   \       0xD6   0x6800             LDR      R0,[R0, #+0]
   \       0xD8   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \       0xDC   0x2810             CMP      R0,#+16
   \       0xDE   0xD21B             BCS.N    ??HAL_ADC_Start_4
    795                {
    796          #endif /* ADC2 || ADC3 */
    797                  /* if no external trigger present enable software conversion of regular channels */
    798                  if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
   \                     ??HAL_ADC_Start_9: (+1)
   \       0xE0   0x6810             LDR      R0,[R2, #+0]
   \       0xE2   0x6880             LDR      R0,[R0, #+8]
   \       0xE4   0xF010 0x5F40      TST      R0,#0x30000000
   \       0xE8   0xD116             BNE.N    ??HAL_ADC_Start_4
    799                  {
    800                    /* Enable the selected ADC software conversion for regular group */
    801                    hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
   \       0xEA   0x6810             LDR      R0,[R2, #+0]
   \       0xEC   0x6880             LDR      R0,[R0, #+8]
   \       0xEE   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \       0xF2   0x6813             LDR      R3,[R2, #+0]
   \       0xF4   0x6098             STR      R0,[R3, #+8]
   \       0xF6   0xE00F             B.N      ??HAL_ADC_Start_4
    802                  }
    803          #if defined(ADC2) && defined(ADC3)
    804                }
    805          #endif /* ADC2 || ADC3 */
    806              }
    807              else
    808              {
    809                /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
    810                if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
   \                     ??HAL_ADC_Start_8: (+1)
   \       0xF8   0x6810             LDR      R0,[R2, #+0]
   \       0xFA   0x.... 0x....      LDR.W    R3,??DataTable7_5
   \       0xFE   0x4298             CMP      R0,R3
   \      0x100   0xD10A             BNE.N    ??HAL_ADC_Start_4
   \      0x102   0x6810             LDR      R0,[R2, #+0]
   \      0x104   0x6880             LDR      R0,[R0, #+8]
   \      0x106   0xF010 0x5F40      TST      R0,#0x30000000
   \      0x10A   0xD105             BNE.N    ??HAL_ADC_Start_4
    811                {
    812                  /* Enable the selected ADC software conversion for regular group */
    813                    hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
   \      0x10C   0x6810             LDR      R0,[R2, #+0]
   \      0x10E   0x6880             LDR      R0,[R0, #+8]
   \      0x110   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \      0x114   0x6813             LDR      R3,[R2, #+0]
   \      0x116   0x6098             STR      R0,[R3, #+8]
    814                }
    815              }
    816            }
    817            
    818            /* Return function status */
    819            return HAL_OK;
   \                     ??HAL_ADC_Start_4: (+1)
   \      0x118   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADC_Start_1: (+1)
   \      0x11A   0xB001             ADD      SP,SP,#+4
   \      0x11C   0x4770             BX       LR
    820          }
    821          
    822          /**
    823            * @brief  Disables ADC and stop conversion of regular channels.
    824            * 
    825            * @note   Caution: This function will stop also injected channels.  
    826            *
    827            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
    828            *         the configuration information for the specified ADC.
    829            *
    830            * @retval HAL status.
    831            */

   \                                 In section .text, align 2, keep-with-next
    832          HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc)
    833          {
   \                     HAL_ADC_Stop: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    834            /* Check the parameters */
    835            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    836            
    837            /* Process locked */
    838            __HAL_LOCK(hadc);
   \        0x2   0xF891 0x003C      LDRB     R0,[R1, #+60]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD101             BNE.N    ??HAL_ADC_Stop_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xE016             B.N      ??HAL_ADC_Stop_1
   \                     ??HAL_ADC_Stop_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF881 0x003C      STRB     R0,[R1, #+60]
    839            
    840            /* Stop potential conversion on going, on regular and injected groups */
    841            /* Disable ADC peripheral */
    842            __HAL_ADC_DISABLE(hadc);
   \       0x14   0x6808             LDR      R0,[R1, #+0]
   \       0x16   0x6880             LDR      R0,[R0, #+8]
   \       0x18   0x0840             LSRS     R0,R0,#+1
   \       0x1A   0x0040             LSLS     R0,R0,#+1
   \       0x1C   0x680A             LDR      R2,[R1, #+0]
   \       0x1E   0x6090             STR      R0,[R2, #+8]
    843            
    844            /* Check if ADC is effectively disabled */
    845            if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
   \       0x20   0x6808             LDR      R0,[R1, #+0]
   \       0x22   0x6880             LDR      R0,[R0, #+8]
   \       0x24   0x07C0             LSLS     R0,R0,#+31
   \       0x26   0xD405             BMI.N    ??HAL_ADC_Stop_2
    846            {
    847              /* Set ADC state */
    848              ADC_STATE_CLR_SET(hadc->State,
    849                                HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
    850                                HAL_ADC_STATE_READY);
   \       0x28   0x6C08             LDR      R0,[R1, #+64]
   \       0x2A   0xF430 0x5088      BICS     R0,R0,#0x1100
   \       0x2E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x32   0x6408             STR      R0,[R1, #+64]
    851            }
    852            
    853            /* Process unlocked */
    854            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Stop_2: (+1)
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF881 0x003C      STRB     R0,[R1, #+60]
    855            
    856            /* Return function status */
    857            return HAL_OK;
   \       0x3A   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADC_Stop_1: (+1)
   \       0x3C   0x4770             BX       LR
    858          }
    859          
    860          /**
    861            * @brief  Poll for regular conversion complete
    862            * @note   ADC conversion flags EOS (end of sequence) and EOC (end of
    863            *         conversion) are cleared by this function.
    864            * @note   This function cannot be used in a particular setup: ADC configured 
    865            *         in DMA mode and polling for end of each conversion (ADC init
    866            *         parameter "EOCSelection" set to ADC_EOC_SINGLE_CONV).
    867            *         In this case, DMA resets the flag EOC and polling cannot be
    868            *         performed on each conversion. Nevertheless, polling can still 
    869            *         be performed on the complete sequence.
    870            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
    871            *         the configuration information for the specified ADC.
    872            * @param  Timeout Timeout value in millisecond.  
    873            * @retval HAL status
    874            */

   \                                 In section .text, align 2, keep-with-next
    875          HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
    876          {
   \                     HAL_ADC_PollForConversion: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
    877            uint32_t tickstart = 0U;
   \        0x6   0x2600             MOVS     R6,#+0
    878           
    879            /* Verification that ADC configuration is compliant with polling for      */
    880            /* each conversion:                                                       */
    881            /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
    882            /* several ranks and polling for end of each conversion.                  */
    883            /* For code simplicity sake, this particular case is generalized to       */
    884            /* ADC configured in DMA mode and polling for end of each conversion.     */
    885            if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_EOCS) &&
    886                HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_DMA)    )
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x6880             LDR      R0,[R0, #+8]
   \        0xC   0x0540             LSLS     R0,R0,#+21
   \        0xE   0xD50C             BPL.N    ??HAL_ADC_PollForConversion_0
   \       0x10   0x6828             LDR      R0,[R5, #+0]
   \       0x12   0x6880             LDR      R0,[R0, #+8]
   \       0x14   0x05C0             LSLS     R0,R0,#+23
   \       0x16   0xD508             BPL.N    ??HAL_ADC_PollForConversion_0
    887            {
    888              /* Update ADC state machine to error */
    889              SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
   \       0x18   0x6C28             LDR      R0,[R5, #+64]
   \       0x1A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x1E   0x6428             STR      R0,[R5, #+64]
    890              
    891              /* Process unlocked */
    892              __HAL_UNLOCK(hadc);
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xF885 0x003C      STRB     R0,[R5, #+60]
    893              
    894              return HAL_ERROR;
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xE03E             B.N      ??HAL_ADC_PollForConversion_1
    895            }
    896          
    897            /* Get tick */ 
    898            tickstart = HAL_GetTick();
   \                     ??HAL_ADC_PollForConversion_0: (+1)
   \       0x2A   0x.... 0x....      BL       HAL_GetTick
   \       0x2E   0x0007             MOVS     R7,R0
    899          
    900            /* Check End of conversion flag */
    901            while(!(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC)))
   \                     ??HAL_ADC_PollForConversion_2: (+1)
   \       0x30   0x6828             LDR      R0,[R5, #+0]
   \       0x32   0x6800             LDR      R0,[R0, #+0]
   \       0x34   0x0780             LSLS     R0,R0,#+30
   \       0x36   0xD412             BMI.N    ??HAL_ADC_PollForConversion_3
    902            {
    903              /* Check if timeout is disabled (set to infinite wait) */
    904              if(Timeout != HAL_MAX_DELAY)
   \       0x38   0xF114 0x0F01      CMN      R4,#+1
   \       0x3C   0xD0F8             BEQ.N    ??HAL_ADC_PollForConversion_2
    905              {
    906                if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
   \       0x3E   0x2C00             CMP      R4,#+0
   \       0x40   0xD004             BEQ.N    ??HAL_ADC_PollForConversion_4
   \       0x42   0x.... 0x....      BL       HAL_GetTick
   \       0x46   0x1BC0             SUBS     R0,R0,R7
   \       0x48   0x4284             CMP      R4,R0
   \       0x4A   0xD2F1             BCS.N    ??HAL_ADC_PollForConversion_2
    907                {
    908                  /* Update ADC state machine to timeout */
    909                  SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
   \                     ??HAL_ADC_PollForConversion_4: (+1)
   \       0x4C   0x6C28             LDR      R0,[R5, #+64]
   \       0x4E   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x52   0x6428             STR      R0,[R5, #+64]
    910                  
    911                  /* Process unlocked */
    912                  __HAL_UNLOCK(hadc);
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xF885 0x003C      STRB     R0,[R5, #+60]
    913                  
    914                  return HAL_TIMEOUT;
   \       0x5A   0x2003             MOVS     R0,#+3
   \       0x5C   0xE024             B.N      ??HAL_ADC_PollForConversion_1
    915                }
    916              }
    917            }
    918            
    919            /* Clear regular group conversion flag */
    920            __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
   \                     ??HAL_ADC_PollForConversion_3: (+1)
   \       0x5E   0xF07F 0x0012      MVNS     R0,#+18
   \       0x62   0x6829             LDR      R1,[R5, #+0]
   \       0x64   0x6008             STR      R0,[R1, #+0]
    921            
    922            /* Update ADC state machine */
    923            SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
   \       0x66   0x6C28             LDR      R0,[R5, #+64]
   \       0x68   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0x6C   0x6428             STR      R0,[R5, #+64]
    924            
    925            /* Determine whether any further conversion upcoming on group regular       */
    926            /* by external trigger, continuous mode or scan sequence on going.          */
    927            /* Note: On STM32F4, there is no independent flag of end of sequence.       */
    928            /*       The test of scan sequence on going is done either with scan        */
    929            /*       sequence disabled or with end of conversion flag set to            */
    930            /*       of end of sequence.                                                */
    931            if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
    932               (hadc->Init.ContinuousConvMode == DISABLE)            &&
    933               (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) ||
    934                HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
   \       0x6E   0x6828             LDR      R0,[R5, #+0]
   \       0x70   0x6880             LDR      R0,[R0, #+8]
   \       0x72   0xF010 0x5F40      TST      R0,#0x30000000
   \       0x76   0xD116             BNE.N    ??HAL_ADC_PollForConversion_5
   \       0x78   0x7E28             LDRB     R0,[R5, #+24]
   \       0x7A   0x2800             CMP      R0,#+0
   \       0x7C   0xD113             BNE.N    ??HAL_ADC_PollForConversion_5
   \       0x7E   0x6828             LDR      R0,[R5, #+0]
   \       0x80   0x6AC0             LDR      R0,[R0, #+44]
   \       0x82   0xF410 0x0F70      TST      R0,#0xF00000
   \       0x86   0xD003             BEQ.N    ??HAL_ADC_PollForConversion_6
   \       0x88   0x6828             LDR      R0,[R5, #+0]
   \       0x8A   0x6880             LDR      R0,[R0, #+8]
   \       0x8C   0x0540             LSLS     R0,R0,#+21
   \       0x8E   0xD40A             BMI.N    ??HAL_ADC_PollForConversion_5
    935            {
    936              /* Set ADC state */
    937              CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
   \                     ??HAL_ADC_PollForConversion_6: (+1)
   \       0x90   0x6C28             LDR      R0,[R5, #+64]
   \       0x92   0xF430 0x7080      BICS     R0,R0,#0x100
   \       0x96   0x6428             STR      R0,[R5, #+64]
    938              
    939              if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \       0x98   0x6C28             LDR      R0,[R5, #+64]
   \       0x9A   0x04C0             LSLS     R0,R0,#+19
   \       0x9C   0xD403             BMI.N    ??HAL_ADC_PollForConversion_5
    940              { 
    941                SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   \       0x9E   0x6C28             LDR      R0,[R5, #+64]
   \       0xA0   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xA4   0x6428             STR      R0,[R5, #+64]
    942              }
    943            }
    944            
    945            /* Return ADC state */
    946            return HAL_OK;
   \                     ??HAL_ADC_PollForConversion_5: (+1)
   \       0xA6   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADC_PollForConversion_1: (+1)
   \       0xA8   0xBDF2             POP      {R1,R4-R7,PC}
    947          }
    948          
    949          /**
    950            * @brief  Poll for conversion event
    951            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
    952            *         the configuration information for the specified ADC.
    953            * @param  EventType the ADC event type.
    954            *          This parameter can be one of the following values:
    955            *            @arg ADC_AWD_EVENT: ADC Analog watch Dog event.
    956            *            @arg ADC_OVR_EVENT: ADC Overrun event.
    957            * @param  Timeout Timeout value in millisecond.   
    958            * @retval HAL status
    959            */

   \                                 In section .text, align 2, keep-with-next
    960          HAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef* hadc, uint32_t EventType, uint32_t Timeout)
    961          {
   \                     HAL_ADC_PollForEvent: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0014             MOVS     R4,R2
    962            uint32_t tickstart = 0U;
   \        0xA   0xF05F 0x0800      MOVS     R8,#+0
    963            
    964            /* Check the parameters */
    965            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    966            assert_param(IS_ADC_EVENT_TYPE(EventType));
    967          
    968            /* Get tick */
    969            tickstart = HAL_GetTick();
   \        0xE   0x.... 0x....      BL       HAL_GetTick
   \       0x12   0x0007             MOVS     R7,R0
    970          
    971            /* Check selected event flag */
    972            while(!(__HAL_ADC_GET_FLAG(hadc,EventType)))
   \                     ??HAL_ADC_PollForEvent_0: (+1)
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x4030             ANDS     R0,R6,R0
   \       0x1A   0x42B0             CMP      R0,R6
   \       0x1C   0xD012             BEQ.N    ??HAL_ADC_PollForEvent_1
    973            {
    974              /* Check for the Timeout */
    975              if(Timeout != HAL_MAX_DELAY)
   \       0x1E   0xF114 0x0F01      CMN      R4,#+1
   \       0x22   0xD0F7             BEQ.N    ??HAL_ADC_PollForEvent_0
    976              {
    977                if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
   \       0x24   0x2C00             CMP      R4,#+0
   \       0x26   0xD004             BEQ.N    ??HAL_ADC_PollForEvent_2
   \       0x28   0x.... 0x....      BL       HAL_GetTick
   \       0x2C   0x1BC0             SUBS     R0,R0,R7
   \       0x2E   0x4284             CMP      R4,R0
   \       0x30   0xD2F0             BCS.N    ??HAL_ADC_PollForEvent_0
    978                {
    979                  /* Update ADC state machine to timeout */
    980                  SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
   \                     ??HAL_ADC_PollForEvent_2: (+1)
   \       0x32   0x6C28             LDR      R0,[R5, #+64]
   \       0x34   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x38   0x6428             STR      R0,[R5, #+64]
    981                  
    982                  /* Process unlocked */
    983                  __HAL_UNLOCK(hadc);
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xF885 0x003C      STRB     R0,[R5, #+60]
    984                  
    985                  return HAL_TIMEOUT;
   \       0x40   0x2003             MOVS     R0,#+3
   \       0x42   0xE017             B.N      ??HAL_ADC_PollForEvent_3
    986                }
    987              }
    988            }
    989            
    990            /* Analog watchdog (level out of window) event */
    991            if(EventType == ADC_AWD_EVENT)
   \                     ??HAL_ADC_PollForEvent_1: (+1)
   \       0x44   0x2E01             CMP      R6,#+1
   \       0x46   0xD108             BNE.N    ??HAL_ADC_PollForEvent_4
    992            {
    993              /* Set ADC state */
    994              SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
   \       0x48   0x6C28             LDR      R0,[R5, #+64]
   \       0x4A   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \       0x4E   0x6428             STR      R0,[R5, #+64]
    995                
    996              /* Clear ADC analog watchdog flag */
    997              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
   \       0x50   0xF07F 0x0001      MVNS     R0,#+1
   \       0x54   0x6829             LDR      R1,[R5, #+0]
   \       0x56   0x6008             STR      R0,[R1, #+0]
   \       0x58   0xE00B             B.N      ??HAL_ADC_PollForEvent_5
    998            }
    999            /* Overrun event */
   1000            else
   1001            {
   1002              /* Set ADC state */
   1003              SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);
   \                     ??HAL_ADC_PollForEvent_4: (+1)
   \       0x5A   0x6C28             LDR      R0,[R5, #+64]
   \       0x5C   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0x60   0x6428             STR      R0,[R5, #+64]
   1004              /* Set ADC error code to overrun */
   1005              SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
   \       0x62   0x6C68             LDR      R0,[R5, #+68]
   \       0x64   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x68   0x6468             STR      R0,[R5, #+68]
   1006              
   1007              /* Clear ADC overrun flag */
   1008              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
   \       0x6A   0xF07F 0x0020      MVNS     R0,#+32
   \       0x6E   0x6829             LDR      R1,[R5, #+0]
   \       0x70   0x6008             STR      R0,[R1, #+0]
   1009            }
   1010            
   1011            /* Return ADC state */
   1012            return HAL_OK;
   \                     ??HAL_ADC_PollForEvent_5: (+1)
   \       0x72   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADC_PollForEvent_3: (+1)
   \       0x74   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1013          }
   1014          
   1015          
   1016          /**
   1017            * @brief  Enables the interrupt and starts ADC conversion of regular channels.
   1018            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
   1019            *         the configuration information for the specified ADC.
   1020            * @retval HAL status.
   1021            */

   \                                 In section .text, align 2, keep-with-next
   1022          HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc)
   1023          {
   \                     HAL_ADC_Start_IT: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x0002             MOVS     R2,R0
   1024            __IO uint32_t counter = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
   1025            ADC_Common_TypeDef *tmpADC_Common;
   1026            
   1027            /* Check the parameters */
   1028            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
   1029            assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)); 
   1030            
   1031            /* Process locked */
   1032            __HAL_LOCK(hadc);
   \        0x8   0xF892 0x003C      LDRB     R0,[R2, #+60]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE.N    ??HAL_ADC_Start_IT_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE08A             B.N      ??HAL_ADC_Start_IT_1
   \                     ??HAL_ADC_Start_IT_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xF882 0x003C      STRB     R0,[R2, #+60]
   1033            
   1034            /* Enable the ADC peripheral */
   1035            /* Check if ADC peripheral is disabled in order to enable it and wait during 
   1036            Tstab time the ADC's stabilization */
   1037            if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
   \       0x1A   0x6810             LDR      R0,[R2, #+0]
   \       0x1C   0x6880             LDR      R0,[R0, #+8]
   \       0x1E   0x07C0             LSLS     R0,R0,#+31
   \       0x20   0xD416             BMI.N    ??HAL_ADC_Start_IT_2
   1038            {  
   1039              /* Enable the Peripheral */
   1040              __HAL_ADC_ENABLE(hadc);
   \       0x22   0x6810             LDR      R0,[R2, #+0]
   \       0x24   0x6880             LDR      R0,[R0, #+8]
   \       0x26   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x2A   0x6813             LDR      R3,[R2, #+0]
   \       0x2C   0x6098             STR      R0,[R3, #+8]
   1041              
   1042              /* Delay for ADC stabilization time */
   1043              /* Compute number of CPU cycles to wait for */
   1044              counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
   \       0x2E   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \       0x32   0x6800             LDR      R0,[R0, #+0]
   \       0x34   0x.... 0x....      LDR.W    R3,??DataTable7_2
   \       0x38   0xFBB0 0xF3F3      UDIV     R3,R0,R3
   \       0x3C   0x2003             MOVS     R0,#+3
   \       0x3E   0x4343             MULS     R3,R0,R3
   \       0x40   0x9300             STR      R3,[SP, #+0]
   1045              while(counter != 0U)
   \                     ??HAL_ADC_Start_IT_3: (+1)
   \       0x42   0x9800             LDR      R0,[SP, #+0]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD003             BEQ.N    ??HAL_ADC_Start_IT_2
   1046              {
   1047                counter--;
   \       0x48   0x9800             LDR      R0,[SP, #+0]
   \       0x4A   0x1E40             SUBS     R0,R0,#+1
   \       0x4C   0x9000             STR      R0,[SP, #+0]
   \       0x4E   0xE7F8             B.N      ??HAL_ADC_Start_IT_3
   1048              }
   1049            }
   1050            
   1051            /* Start conversion if ADC is effectively enabled */
   1052            if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
   \                     ??HAL_ADC_Start_IT_2: (+1)
   \       0x50   0x6810             LDR      R0,[R2, #+0]
   \       0x52   0x6880             LDR      R0,[R0, #+8]
   \       0x54   0x07C0             LSLS     R0,R0,#+31
   \       0x56   0xD567             BPL.N    ??HAL_ADC_Start_IT_4
   1053            {
   1054              /* Set ADC state                                                          */
   1055              /* - Clear state bitfield related to regular group conversion results     */
   1056              /* - Set state bitfield related to regular group operation                */
   1057              ADC_STATE_CLR_SET(hadc->State,
   1058                                HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR,
   1059                                HAL_ADC_STATE_REG_BUSY);
   \       0x58   0x6C13             LDR      R3,[R2, #+64]
   \       0x5A   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \       0x5E   0x4003             ANDS     R3,R0,R3
   \       0x60   0xF453 0x7380      ORRS     R3,R3,#0x100
   \       0x64   0x6413             STR      R3,[R2, #+64]
   1060              
   1061              /* If conversions on group regular are also triggering group injected,    */
   1062              /* update ADC state.                                                      */
   1063              if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
   \       0x66   0x6810             LDR      R0,[R2, #+0]
   \       0x68   0x6840             LDR      R0,[R0, #+4]
   \       0x6A   0x0540             LSLS     R0,R0,#+21
   \       0x6C   0xD504             BPL.N    ??HAL_ADC_Start_IT_5
   1064              {
   1065                ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
   \       0x6E   0x2001             MOVS     R0,#+1
   \       0x70   0x6C13             LDR      R3,[R2, #+64]
   \       0x72   0xF360 0x330D      BFI      R3,R0,#+12,#+2
   \       0x76   0x6413             STR      R3,[R2, #+64]
   1066              }
   1067              
   1068              /* State machine update: Check if an injected conversion is ongoing */
   1069              if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \                     ??HAL_ADC_Start_IT_5: (+1)
   \       0x78   0x6C10             LDR      R0,[R2, #+64]
   \       0x7A   0x04C0             LSLS     R0,R0,#+19
   \       0x7C   0xD504             BPL.N    ??HAL_ADC_Start_IT_6
   1070              {
   1071                /* Reset ADC error code fields related to conversions on group regular */
   1072                CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
   \       0x7E   0x6C50             LDR      R0,[R2, #+68]
   \       0x80   0xF030 0x0006      BICS     R0,R0,#0x6
   \       0x84   0x6450             STR      R0,[R2, #+68]
   \       0x86   0xE001             B.N      ??HAL_ADC_Start_IT_7
   1073              }
   1074              else
   1075              {
   1076                /* Reset ADC all error code fields */
   1077                ADC_CLEAR_ERRORCODE(hadc);
   \                     ??HAL_ADC_Start_IT_6: (+1)
   \       0x88   0x2000             MOVS     R0,#+0
   \       0x8A   0x6450             STR      R0,[R2, #+68]
   1078              }
   1079          
   1080              /* Process unlocked */
   1081              /* Unlock before starting ADC conversions: in case of potential           */
   1082              /* interruption, to let the process to ADC IRQ Handler.                   */
   1083              __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Start_IT_7: (+1)
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0xF882 0x003C      STRB     R0,[R2, #+60]
   1084          
   1085              /* Pointer to the common control register to which is belonging hadc    */
   1086              /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
   1087              /* control register)                                                    */
   1088              tmpADC_Common = ADC_COMMON_REGISTER(hadc);
   \       0x92   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \       0x96   0x0001             MOVS     R1,R0
   1089          
   1090              /* Clear regular group conversion flag and overrun flag */
   1091              /* (To ensure of no unknown state from potential previous ADC operations) */
   1092              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
   \       0x98   0xF07F 0x0022      MVNS     R0,#+34
   \       0x9C   0x6813             LDR      R3,[R2, #+0]
   \       0x9E   0x6018             STR      R0,[R3, #+0]
   1093              
   1094              /* Enable end of conversion interrupt for regular group */
   1095              __HAL_ADC_ENABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_OVR));
   \       0xA0   0x6810             LDR      R0,[R2, #+0]
   \       0xA2   0x6840             LDR      R0,[R0, #+4]
   \       0xA4   0xF040 0x6080      ORR      R0,R0,#0x4000000
   \       0xA8   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0xAC   0x6813             LDR      R3,[R2, #+0]
   \       0xAE   0x6058             STR      R0,[R3, #+4]
   1096              
   1097              /* Check if Multimode enabled */
   1098              if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
   \       0xB0   0x6848             LDR      R0,[R1, #+4]
   \       0xB2   0xF010 0x0F1F      TST      R0,#0x1F
   \       0xB6   0xD127             BNE.N    ??HAL_ADC_Start_IT_8
   1099              {
   1100          #if defined(ADC2) && defined(ADC3)
   1101                if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
   1102                                            || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
   \       0xB8   0x6810             LDR      R0,[R2, #+0]
   \       0xBA   0x.... 0x....      LDR.W    R3,??DataTable7_5
   \       0xBE   0x4298             CMP      R0,R3
   \       0xC0   0xD016             BEQ.N    ??HAL_ADC_Start_IT_9
   \       0xC2   0x6810             LDR      R0,[R2, #+0]
   \       0xC4   0x.... 0x....      LDR.W    R3,??DataTable7_6
   \       0xC8   0x4298             CMP      R0,R3
   \       0xCA   0xD105             BNE.N    ??HAL_ADC_Start_IT_10
   \       0xCC   0x.... 0x....      LDR.W    R0,??DataTable7_7
   \       0xD0   0x6800             LDR      R0,[R0, #+0]
   \       0xD2   0xF010 0x0F1F      TST      R0,#0x1F
   \       0xD6   0xD00B             BEQ.N    ??HAL_ADC_Start_IT_9
   \                     ??HAL_ADC_Start_IT_10: (+1)
   \       0xD8   0x6810             LDR      R0,[R2, #+0]
   \       0xDA   0x.... 0x....      LDR.W    R3,??DataTable7_8
   \       0xDE   0x4298             CMP      R0,R3
   \       0xE0   0xD122             BNE.N    ??HAL_ADC_Start_IT_4
   \       0xE2   0x.... 0x....      LDR.W    R0,??DataTable7_7
   \       0xE6   0x6800             LDR      R0,[R0, #+0]
   \       0xE8   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \       0xEC   0x2810             CMP      R0,#+16
   \       0xEE   0xD21B             BCS.N    ??HAL_ADC_Start_IT_4
   1103                {
   1104          #endif /* ADC2 || ADC3 */
   1105                  /* if no external trigger present enable software conversion of regular channels */
   1106                  if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
   \                     ??HAL_ADC_Start_IT_9: (+1)
   \       0xF0   0x6810             LDR      R0,[R2, #+0]
   \       0xF2   0x6880             LDR      R0,[R0, #+8]
   \       0xF4   0xF010 0x5F40      TST      R0,#0x30000000
   \       0xF8   0xD116             BNE.N    ??HAL_ADC_Start_IT_4
   1107                  {
   1108                    /* Enable the selected ADC software conversion for regular group */
   1109                    hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
   \       0xFA   0x6810             LDR      R0,[R2, #+0]
   \       0xFC   0x6880             LDR      R0,[R0, #+8]
   \       0xFE   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \      0x102   0x6813             LDR      R3,[R2, #+0]
   \      0x104   0x6098             STR      R0,[R3, #+8]
   \      0x106   0xE00F             B.N      ??HAL_ADC_Start_IT_4
   1110                  }
   1111          #if defined(ADC2) && defined(ADC3)
   1112                }
   1113          #endif /* ADC2 || ADC3 */
   1114              }
   1115              else
   1116              {
   1117                /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
   1118                if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
   \                     ??HAL_ADC_Start_IT_8: (+1)
   \      0x108   0x6810             LDR      R0,[R2, #+0]
   \      0x10A   0x.... 0x....      LDR.W    R3,??DataTable7_5
   \      0x10E   0x4298             CMP      R0,R3
   \      0x110   0xD10A             BNE.N    ??HAL_ADC_Start_IT_4
   \      0x112   0x6810             LDR      R0,[R2, #+0]
   \      0x114   0x6880             LDR      R0,[R0, #+8]
   \      0x116   0xF010 0x5F40      TST      R0,#0x30000000
   \      0x11A   0xD105             BNE.N    ??HAL_ADC_Start_IT_4
   1119                {
   1120                  /* Enable the selected ADC software conversion for regular group */
   1121                    hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
   \      0x11C   0x6810             LDR      R0,[R2, #+0]
   \      0x11E   0x6880             LDR      R0,[R0, #+8]
   \      0x120   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \      0x124   0x6813             LDR      R3,[R2, #+0]
   \      0x126   0x6098             STR      R0,[R3, #+8]
   1122                }
   1123              }
   1124            }
   1125            
   1126            /* Return function status */
   1127            return HAL_OK;
   \                     ??HAL_ADC_Start_IT_4: (+1)
   \      0x128   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADC_Start_IT_1: (+1)
   \      0x12A   0xB001             ADD      SP,SP,#+4
   \      0x12C   0x4770             BX       LR
   1128          }
   1129          
   1130          /**
   1131            * @brief  Disables the interrupt and stop ADC conversion of regular channels.
   1132            * 
   1133            * @note   Caution: This function will stop also injected channels.  
   1134            *
   1135            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
   1136            *         the configuration information for the specified ADC.
   1137            * @retval HAL status.
   1138            */

   \                                 In section .text, align 2, keep-with-next
   1139          HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc)
   1140          {
   \                     HAL_ADC_Stop_IT: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   1141            /* Check the parameters */
   1142            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1143            
   1144            /* Process locked */
   1145            __HAL_LOCK(hadc);
   \        0x2   0xF891 0x003C      LDRB     R0,[R1, #+60]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD101             BNE.N    ??HAL_ADC_Stop_IT_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xE01D             B.N      ??HAL_ADC_Stop_IT_1
   \                     ??HAL_ADC_Stop_IT_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF881 0x003C      STRB     R0,[R1, #+60]
   1146            
   1147            /* Stop potential conversion on going, on regular and injected groups */
   1148            /* Disable ADC peripheral */
   1149            __HAL_ADC_DISABLE(hadc);
   \       0x14   0x6808             LDR      R0,[R1, #+0]
   \       0x16   0x6880             LDR      R0,[R0, #+8]
   \       0x18   0x0840             LSRS     R0,R0,#+1
   \       0x1A   0x0040             LSLS     R0,R0,#+1
   \       0x1C   0x680A             LDR      R2,[R1, #+0]
   \       0x1E   0x6090             STR      R0,[R2, #+8]
   1150            
   1151            /* Check if ADC is effectively disabled */
   1152            if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
   \       0x20   0x6808             LDR      R0,[R1, #+0]
   \       0x22   0x6880             LDR      R0,[R0, #+8]
   \       0x24   0x07C0             LSLS     R0,R0,#+31
   \       0x26   0xD40C             BMI.N    ??HAL_ADC_Stop_IT_2
   1153            {
   1154            	/* Disable ADC end of conversion interrupt for regular group */
   1155              __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_EOC | ADC_IT_OVR));
   \       0x28   0x6808             LDR      R0,[R1, #+0]
   \       0x2A   0x6842             LDR      R2,[R0, #+4]
   \       0x2C   0x.... 0x....      LDR.W    R0,??DataTable7_9
   \       0x30   0x4002             ANDS     R2,R0,R2
   \       0x32   0x6808             LDR      R0,[R1, #+0]
   \       0x34   0x6042             STR      R2,[R0, #+4]
   1156          
   1157              /* Set ADC state */
   1158              ADC_STATE_CLR_SET(hadc->State,
   1159                                HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
   1160                                HAL_ADC_STATE_READY);
   \       0x36   0x6C08             LDR      R0,[R1, #+64]
   \       0x38   0xF430 0x5088      BICS     R0,R0,#0x1100
   \       0x3C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x40   0x6408             STR      R0,[R1, #+64]
   1161            }
   1162            
   1163            /* Process unlocked */
   1164            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Stop_IT_2: (+1)
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xF881 0x003C      STRB     R0,[R1, #+60]
   1165            
   1166            /* Return function status */
   1167            return HAL_OK;
   \       0x48   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADC_Stop_IT_1: (+1)
   \       0x4A   0x4770             BX       LR
   1168          }
   1169          
   1170          /**
   1171            * @brief  Handles ADC interrupt request  
   1172            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
   1173            *         the configuration information for the specified ADC.
   1174            * @retval None
   1175            */

   \                                 In section .text, align 2, keep-with-next
   1176          void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
   1177          {
   \                     HAL_ADC_IRQHandler: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
   1178            uint32_t tmp1 = 0U, tmp2 = 0U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x2100             MOVS     R1,#+0
   1179            
   1180            /* Check the parameters */
   1181            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
   1182            assert_param(IS_ADC_REGULAR_LENGTH(hadc->Init.NbrOfConversion));
   1183            assert_param(IS_ADC_EOCSelection(hadc->Init.EOCSelection));
   1184            
   1185            tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC);
   \        0xA   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \        0xE   0x6814             LDR      R4,[R2, #+0]
   \       0x10   0x0864             LSRS     R4,R4,#+1
   \       0x12   0xF014 0x0401      ANDS     R4,R4,#0x1
   1186            tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC);
   \       0x16   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \       0x1A   0x6855             LDR      R5,[R2, #+4]
   \       0x1C   0x096D             LSRS     R5,R5,#+5
   \       0x1E   0xF015 0x0501      ANDS     R5,R5,#0x1
   1187            /* Check End of conversion flag for regular channels */
   1188            if(tmp1 && tmp2)
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD040             BEQ.N    ??HAL_ADC_IRQHandler_0
   \       0x26   0x2D00             CMP      R5,#+0
   \       0x28   0xD03E             BEQ.N    ??HAL_ADC_IRQHandler_0
   1189            {
   1190              /* Update state machine on conversion status if not in error state */
   1191              if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
   \       0x2A   0xF8D8 0x0040      LDR      R0,[R8, #+64]
   \       0x2E   0x06C0             LSLS     R0,R0,#+27
   \       0x30   0xD405             BMI.N    ??HAL_ADC_IRQHandler_1
   1192              {
   1193                /* Set ADC state */
   1194                SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
   \       0x32   0xF8D8 0x0040      LDR      R0,[R8, #+64]
   \       0x36   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0x3A   0xF8C8 0x0040      STR      R0,[R8, #+64]
   1195              }
   1196              
   1197              /* Determine whether any further conversion upcoming on group regular   */
   1198              /* by external trigger, continuous mode or scan sequence on going.      */
   1199              /* Note: On STM32F4, there is no independent flag of end of sequence.   */
   1200              /*       The test of scan sequence on going is done either with scan    */
   1201              /*       sequence disabled or with end of conversion flag set to        */
   1202              /*       of end of sequence.                                            */
   1203              if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
   1204                 (hadc->Init.ContinuousConvMode == DISABLE)            &&
   1205                 (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
   1206                  HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
   \                     ??HAL_ADC_IRQHandler_1: (+1)
   \       0x3E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x42   0x6880             LDR      R0,[R0, #+8]
   \       0x44   0xF010 0x5F40      TST      R0,#0x30000000
   \       0x48   0xD126             BNE.N    ??HAL_ADC_IRQHandler_2
   \       0x4A   0xF898 0x0018      LDRB     R0,[R8, #+24]
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD122             BNE.N    ??HAL_ADC_IRQHandler_2
   \       0x52   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x56   0x6AC0             LDR      R0,[R0, #+44]
   \       0x58   0xF410 0x0F70      TST      R0,#0xF00000
   \       0x5C   0xD004             BEQ.N    ??HAL_ADC_IRQHandler_3
   \       0x5E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x62   0x6880             LDR      R0,[R0, #+8]
   \       0x64   0x0540             LSLS     R0,R0,#+21
   \       0x66   0xD417             BMI.N    ??HAL_ADC_IRQHandler_2
   1207              {
   1208                /* Disable ADC end of single conversion interrupt on group regular */
   1209                /* Note: Overrun interrupt was enabled with EOC interrupt in          */
   1210                /* HAL_ADC_Start_IT(), but is not disabled here because can be used   */
   1211                /* by overrun IRQ process below.                                      */
   1212                __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
   \                     ??HAL_ADC_IRQHandler_3: (+1)
   \       0x68   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0x6C   0x6840             LDR      R0,[R0, #+4]
   \       0x6E   0xF030 0x0020      BICS     R0,R0,#0x20
   \       0x72   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0x76   0x6048             STR      R0,[R1, #+4]
   1213                
   1214                /* Set ADC state */
   1215                CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
   \       0x78   0xF8D8 0x0040      LDR      R0,[R8, #+64]
   \       0x7C   0xF430 0x7080      BICS     R0,R0,#0x100
   \       0x80   0xF8C8 0x0040      STR      R0,[R8, #+64]
   1216                
   1217                if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \       0x84   0xF8D8 0x0040      LDR      R0,[R8, #+64]
   \       0x88   0x04C0             LSLS     R0,R0,#+19
   \       0x8A   0xD405             BMI.N    ??HAL_ADC_IRQHandler_2
   1218                {
   1219                  SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   \       0x8C   0xF8D8 0x0040      LDR      R0,[R8, #+64]
   \       0x90   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x94   0xF8C8 0x0040      STR      R0,[R8, #+64]
   1220                }
   1221              }
   1222              
   1223              /* Conversion complete callback */
   1224          #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
   1225              hadc->ConvCpltCallback(hadc);
   1226          #else
   1227              HAL_ADC_ConvCpltCallback(hadc);
   \                     ??HAL_ADC_IRQHandler_2: (+1)
   \       0x98   0x4640             MOV      R0,R8
   \       0x9A   0x.... 0x....      BL       HAL_ADC_ConvCpltCallback
   1228          #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
   1229              
   1230              /* Clear regular group conversion flag */
   1231              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
   \       0x9E   0xF07F 0x0012      MVNS     R0,#+18
   \       0xA2   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \       0xA6   0x6008             STR      R0,[R1, #+0]
   1232            }
   1233            
   1234            tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC);
   \                     ??HAL_ADC_IRQHandler_0: (+1)
   \       0xA8   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xAC   0x6806             LDR      R6,[R0, #+0]
   \       0xAE   0x08B6             LSRS     R6,R6,#+2
   \       0xB0   0xF016 0x0601      ANDS     R6,R6,#0x1
   1235            tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC);                               
   \       0xB4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xB8   0x6847             LDR      R7,[R0, #+4]
   \       0xBA   0x09FF             LSRS     R7,R7,#+7
   \       0xBC   0xF017 0x0701      ANDS     R7,R7,#0x1
   1236            /* Check End of conversion flag for injected channels */
   1237            if(tmp1 && tmp2)
   \       0xC0   0x2E00             CMP      R6,#+0
   \       0xC2   0xD04B             BEQ.N    ??HAL_ADC_IRQHandler_4
   \       0xC4   0x2F00             CMP      R7,#+0
   \       0xC6   0xD049             BEQ.N    ??HAL_ADC_IRQHandler_4
   1238            {
   1239              /* Update state machine on conversion status if not in error state */
   1240              if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
   \       0xC8   0xF8D8 0x0040      LDR      R0,[R8, #+64]
   \       0xCC   0x06C0             LSLS     R0,R0,#+27
   \       0xCE   0xD405             BMI.N    ??HAL_ADC_IRQHandler_5
   1241              {
   1242                /* Set ADC state */
   1243                SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
   \       0xD0   0xF8D8 0x0040      LDR      R0,[R8, #+64]
   \       0xD4   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \       0xD8   0xF8C8 0x0040      STR      R0,[R8, #+64]
   1244              }
   1245          
   1246              /* Determine whether any further conversion upcoming on group injected  */
   1247              /* by external trigger, scan sequence on going or by automatic injected */
   1248              /* conversion from group regular (same conditions as group regular      */
   1249              /* interruption disabling above).                                       */
   1250              if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                    &&
   1251                 (HAL_IS_BIT_CLR(hadc->Instance->JSQR, ADC_JSQR_JL)  ||
   1252                  HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)    ) &&
   1253                 (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&
   1254                  (ADC_IS_SOFTWARE_START_REGULAR(hadc)       &&
   1255                  (hadc->Init.ContinuousConvMode == DISABLE)   )       )   )
   \                     ??HAL_ADC_IRQHandler_5: (+1)
   \       0xDC   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xE0   0x6880             LDR      R0,[R0, #+8]
   \       0xE2   0xF410 0x1F40      TST      R0,#0x300000
   \       0xE6   0xD131             BNE.N    ??HAL_ADC_IRQHandler_6
   \       0xE8   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xEC   0x6B80             LDR      R0,[R0, #+56]
   \       0xEE   0xF410 0x1F40      TST      R0,#0x300000
   \       0xF2   0xD004             BEQ.N    ??HAL_ADC_IRQHandler_7
   \       0xF4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \       0xF8   0x6880             LDR      R0,[R0, #+8]
   \       0xFA   0x0540             LSLS     R0,R0,#+21
   \       0xFC   0xD426             BMI.N    ??HAL_ADC_IRQHandler_6
   \                     ??HAL_ADC_IRQHandler_7: (+1)
   \       0xFE   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x102   0x6840             LDR      R0,[R0, #+4]
   \      0x104   0x0540             LSLS     R0,R0,#+21
   \      0x106   0xD421             BMI.N    ??HAL_ADC_IRQHandler_6
   \      0x108   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x10C   0x6880             LDR      R0,[R0, #+8]
   \      0x10E   0xF010 0x5F40      TST      R0,#0x30000000
   \      0x112   0xD11B             BNE.N    ??HAL_ADC_IRQHandler_6
   \      0x114   0xF898 0x0018      LDRB     R0,[R8, #+24]
   \      0x118   0x2800             CMP      R0,#+0
   \      0x11A   0xD117             BNE.N    ??HAL_ADC_IRQHandler_6
   1256              {
   1257                /* Disable ADC end of single conversion interrupt on group injected */
   1258                __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
   \      0x11C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x120   0x6840             LDR      R0,[R0, #+4]
   \      0x122   0xF030 0x0080      BICS     R0,R0,#0x80
   \      0x126   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \      0x12A   0x6048             STR      R0,[R1, #+4]
   1259                
   1260                /* Set ADC state */
   1261                CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);   
   \      0x12C   0xF8D8 0x0040      LDR      R0,[R8, #+64]
   \      0x130   0xF430 0x5080      BICS     R0,R0,#0x1000
   \      0x134   0xF8C8 0x0040      STR      R0,[R8, #+64]
   1262          
   1263                if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
   \      0x138   0xF8D8 0x0040      LDR      R0,[R8, #+64]
   \      0x13C   0x05C0             LSLS     R0,R0,#+23
   \      0x13E   0xD405             BMI.N    ??HAL_ADC_IRQHandler_6
   1264                { 
   1265                  SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   \      0x140   0xF8D8 0x0040      LDR      R0,[R8, #+64]
   \      0x144   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x148   0xF8C8 0x0040      STR      R0,[R8, #+64]
   1266                }
   1267              }
   1268          
   1269              /* Conversion complete callback */ 
   1270              /* Conversion complete callback */ 
   1271          #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
   1272                hadc->InjectedConvCpltCallback(hadc);
   1273          #else
   1274                HAL_ADCEx_InjectedConvCpltCallback(hadc);
   \                     ??HAL_ADC_IRQHandler_6: (+1)
   \      0x14C   0x4640             MOV      R0,R8
   \      0x14E   0x.... 0x....      BL       HAL_ADCEx_InjectedConvCpltCallback
   1275          #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
   1276              
   1277              /* Clear injected group conversion flag */
   1278              __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JSTRT | ADC_FLAG_JEOC));
   \      0x152   0xF07F 0x000C      MVNS     R0,#+12
   \      0x156   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \      0x15A   0x6008             STR      R0,[R1, #+0]
   1279            }
   1280            
   1281            tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD);
   \                     ??HAL_ADC_IRQHandler_4: (+1)
   \      0x15C   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x160   0x6804             LDR      R4,[R0, #+0]
   \      0x162   0xF014 0x0401      ANDS     R4,R4,#0x1
   1282            tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD);                          
   \      0x166   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x16A   0x6845             LDR      R5,[R0, #+4]
   \      0x16C   0x09AD             LSRS     R5,R5,#+6
   \      0x16E   0xF015 0x0501      ANDS     R5,R5,#0x1
   1283            /* Check Analog watchdog flag */
   1284            if(tmp1 && tmp2)
   \      0x172   0x2C00             CMP      R4,#+0
   \      0x174   0xD014             BEQ.N    ??HAL_ADC_IRQHandler_8
   \      0x176   0x2D00             CMP      R5,#+0
   \      0x178   0xD012             BEQ.N    ??HAL_ADC_IRQHandler_8
   1285            {
   1286              if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD))
   \      0x17A   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x17E   0x6800             LDR      R0,[R0, #+0]
   \      0x180   0x07C0             LSLS     R0,R0,#+31
   \      0x182   0xD50D             BPL.N    ??HAL_ADC_IRQHandler_8
   1287              {
   1288                /* Set ADC state */
   1289                SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
   \      0x184   0xF8D8 0x0040      LDR      R0,[R8, #+64]
   \      0x188   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \      0x18C   0xF8C8 0x0040      STR      R0,[R8, #+64]
   1290                
   1291                /* Level out of window callback */
   1292          #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
   1293                hadc->LevelOutOfWindowCallback(hadc);
   1294          #else
   1295                HAL_ADC_LevelOutOfWindowCallback(hadc);
   \      0x190   0x4640             MOV      R0,R8
   \      0x192   0x.... 0x....      BL       HAL_ADC_LevelOutOfWindowCallback
   1296          #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
   1297                
   1298                /* Clear the ADC analog watchdog flag */
   1299                __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
   \      0x196   0xF07F 0x0001      MVNS     R0,#+1
   \      0x19A   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \      0x19E   0x6008             STR      R0,[R1, #+0]
   1300              }
   1301            }
   1302            
   1303            tmp1 = __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_OVR);
   \                     ??HAL_ADC_IRQHandler_8: (+1)
   \      0x1A0   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x1A4   0x6806             LDR      R6,[R0, #+0]
   \      0x1A6   0x0976             LSRS     R6,R6,#+5
   \      0x1A8   0xF016 0x0601      ANDS     R6,R6,#0x1
   1304            tmp2 = __HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_OVR);
   \      0x1AC   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x1B0   0x6847             LDR      R7,[R0, #+4]
   \      0x1B2   0x0EBF             LSRS     R7,R7,#+26
   \      0x1B4   0xF017 0x0701      ANDS     R7,R7,#0x1
   1305            /* Check Overrun flag */
   1306            if(tmp1 && tmp2)
   \      0x1B8   0x2E00             CMP      R6,#+0
   \      0x1BA   0xD012             BEQ.N    ??HAL_ADC_IRQHandler_9
   \      0x1BC   0x2F00             CMP      R7,#+0
   \      0x1BE   0xD010             BEQ.N    ??HAL_ADC_IRQHandler_9
   1307            {
   1308              /* Note: On STM32F4, ADC overrun can be set through other parameters    */
   1309              /*       refer to description of parameter "EOCSelection" for more      */
   1310              /*       details.                                                       */
   1311              
   1312              /* Set ADC error code to overrun */
   1313              SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
   \      0x1C0   0xF8D8 0x0044      LDR      R0,[R8, #+68]
   \      0x1C4   0xF050 0x0002      ORRS     R0,R0,#0x2
   \      0x1C8   0xF8C8 0x0044      STR      R0,[R8, #+68]
   1314              
   1315              /* Clear ADC overrun flag */
   1316              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
   \      0x1CC   0xF07F 0x0420      MVNS     R4,#+32
   \      0x1D0   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x1D4   0x6004             STR      R4,[R0, #+0]
   1317              
   1318              /* Error callback */ 
   1319          #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
   1320                hadc->ErrorCallback(hadc);
   1321          #else
   1322                HAL_ADC_ErrorCallback(hadc);
   \      0x1D6   0x4640             MOV      R0,R8
   \      0x1D8   0x.... 0x....      BL       HAL_ADC_ErrorCallback
   1323          #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
   1324              
   1325              /* Clear the Overrun flag */
   1326              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
   \      0x1DC   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \      0x1E0   0x6004             STR      R4,[R0, #+0]
   1327            }
   1328          }
   \                     ??HAL_ADC_IRQHandler_9: (+1)
   \      0x1E2   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1329          
   1330          /**
   1331            * @brief  Enables ADC DMA request after last transfer (Single-ADC mode) and enables ADC peripheral  
   1332            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
   1333            *         the configuration information for the specified ADC.
   1334            * @param  pData The destination Buffer address.
   1335            * @param  Length The length of data to be transferred from ADC peripheral to memory.
   1336            * @retval HAL status
   1337            */

   \                                 In section .text, align 2, keep-with-next
   1338          HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
   1339          {
   \                     HAL_ADC_Start_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0017             MOVS     R7,R2
   1340            __IO uint32_t counter = 0U;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9000             STR      R0,[SP, #+0]
   1341            ADC_Common_TypeDef *tmpADC_Common;
   1342            
   1343            /* Check the parameters */
   1344            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
   1345            assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)); 
   1346            
   1347            /* Process locked */
   1348            __HAL_LOCK(hadc);
   \        0xC   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD101             BNE.N    ??HAL_ADC_Start_DMA_0
   \       0x14   0x2002             MOVS     R0,#+2
   \       0x16   0xE0A3             B.N      ??HAL_ADC_Start_DMA_1
   \                     ??HAL_ADC_Start_DMA_0: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xF885 0x003C      STRB     R0,[R5, #+60]
   1349            
   1350            /* Enable the ADC peripheral */
   1351            /* Check if ADC peripheral is disabled in order to enable it and wait during 
   1352            Tstab time the ADC's stabilization */
   1353            if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
   \       0x1E   0x6828             LDR      R0,[R5, #+0]
   \       0x20   0x6880             LDR      R0,[R0, #+8]
   \       0x22   0x07C0             LSLS     R0,R0,#+31
   \       0x24   0xD416             BMI.N    ??HAL_ADC_Start_DMA_2
   1354            {  
   1355              /* Enable the Peripheral */
   1356              __HAL_ADC_ENABLE(hadc);
   \       0x26   0x6828             LDR      R0,[R5, #+0]
   \       0x28   0x6880             LDR      R0,[R0, #+8]
   \       0x2A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x2E   0x6829             LDR      R1,[R5, #+0]
   \       0x30   0x6088             STR      R0,[R1, #+8]
   1357              
   1358              /* Delay for ADC stabilization time */
   1359              /* Compute number of CPU cycles to wait for */
   1360              counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \       0x36   0x6800             LDR      R0,[R0, #+0]
   \       0x38   0x.... 0x....      LDR.W    R1,??DataTable7_2
   \       0x3C   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x40   0x2003             MOVS     R0,#+3
   \       0x42   0x4341             MULS     R1,R0,R1
   \       0x44   0x9100             STR      R1,[SP, #+0]
   1361              while(counter != 0U)
   \                     ??HAL_ADC_Start_DMA_3: (+1)
   \       0x46   0x9800             LDR      R0,[SP, #+0]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD003             BEQ.N    ??HAL_ADC_Start_DMA_2
   1362              {
   1363                counter--;
   \       0x4C   0x9800             LDR      R0,[SP, #+0]
   \       0x4E   0x1E40             SUBS     R0,R0,#+1
   \       0x50   0x9000             STR      R0,[SP, #+0]
   \       0x52   0xE7F8             B.N      ??HAL_ADC_Start_DMA_3
   1364              }
   1365            }
   1366            
   1367            /* Start conversion if ADC is effectively enabled */
   1368            if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
   \                     ??HAL_ADC_Start_DMA_2: (+1)
   \       0x54   0x6828             LDR      R0,[R5, #+0]
   \       0x56   0x6880             LDR      R0,[R0, #+8]
   \       0x58   0x07C0             LSLS     R0,R0,#+31
   \       0x5A   0xF140 0x8080      BPL.W    ??HAL_ADC_Start_DMA_4
   1369            {
   1370              /* Set ADC state                                                          */
   1371              /* - Clear state bitfield related to regular group conversion results     */
   1372              /* - Set state bitfield related to regular group operation                */
   1373              ADC_STATE_CLR_SET(hadc->State,
   1374                                HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR,
   1375                                HAL_ADC_STATE_REG_BUSY);
   \       0x5E   0x6C29             LDR      R1,[R5, #+64]
   \       0x60   0x.... 0x....      LDR.W    R0,??DataTable7_3
   \       0x64   0x4001             ANDS     R1,R0,R1
   \       0x66   0xF451 0x7180      ORRS     R1,R1,#0x100
   \       0x6A   0x6429             STR      R1,[R5, #+64]
   1376              
   1377              /* If conversions on group regular are also triggering group injected,    */
   1378              /* update ADC state.                                                      */
   1379              if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
   \       0x6C   0x6828             LDR      R0,[R5, #+0]
   \       0x6E   0x6840             LDR      R0,[R0, #+4]
   \       0x70   0x0540             LSLS     R0,R0,#+21
   \       0x72   0xD504             BPL.N    ??HAL_ADC_Start_DMA_5
   1380              {
   1381                ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
   \       0x74   0x2001             MOVS     R0,#+1
   \       0x76   0x6C29             LDR      R1,[R5, #+64]
   \       0x78   0xF360 0x310D      BFI      R1,R0,#+12,#+2
   \       0x7C   0x6429             STR      R1,[R5, #+64]
   1382              }
   1383              
   1384              /* State machine update: Check if an injected conversion is ongoing */
   1385              if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \                     ??HAL_ADC_Start_DMA_5: (+1)
   \       0x7E   0x6C28             LDR      R0,[R5, #+64]
   \       0x80   0x04C0             LSLS     R0,R0,#+19
   \       0x82   0xD504             BPL.N    ??HAL_ADC_Start_DMA_6
   1386              {
   1387                /* Reset ADC error code fields related to conversions on group regular */
   1388                CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
   \       0x84   0x6C68             LDR      R0,[R5, #+68]
   \       0x86   0xF030 0x0006      BICS     R0,R0,#0x6
   \       0x8A   0x6468             STR      R0,[R5, #+68]
   \       0x8C   0xE001             B.N      ??HAL_ADC_Start_DMA_7
   1389              }
   1390              else
   1391              {
   1392                /* Reset ADC all error code fields */
   1393                ADC_CLEAR_ERRORCODE(hadc);
   \                     ??HAL_ADC_Start_DMA_6: (+1)
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0x6468             STR      R0,[R5, #+68]
   1394              }
   1395          
   1396              /* Process unlocked */
   1397              /* Unlock before starting ADC conversions: in case of potential           */
   1398              /* interruption, to let the process to ADC IRQ Handler.                   */
   1399              __HAL_UNLOCK(hadc);   
   \                     ??HAL_ADC_Start_DMA_7: (+1)
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0xF885 0x003C      STRB     R0,[R5, #+60]
   1400          
   1401              /* Pointer to the common control register to which is belonging hadc    */
   1402              /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
   1403              /* control register)                                                    */
   1404              tmpADC_Common = ADC_COMMON_REGISTER(hadc);
   \       0x98   0x.... 0x....      LDR.W    R0,??DataTable7_4
   \       0x9C   0x0004             MOVS     R4,R0
   1405          
   1406              /* Set the DMA transfer complete callback */
   1407              hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
   \       0x9E   0x.... 0x....      ADR.W    R0,ADC_DMAConvCplt
   \       0xA2   0x6BA9             LDR      R1,[R5, #+56]
   \       0xA4   0x63C8             STR      R0,[R1, #+60]
   1408          
   1409              /* Set the DMA half transfer complete callback */
   1410              hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
   \       0xA6   0x.... 0x....      ADR.W    R0,ADC_DMAHalfConvCplt
   \       0xAA   0x6BA9             LDR      R1,[R5, #+56]
   \       0xAC   0x6408             STR      R0,[R1, #+64]
   1411              
   1412              /* Set the DMA error callback */
   1413              hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
   \       0xAE   0x.... 0x....      ADR.W    R0,ADC_DMAError
   \       0xB2   0x6BA9             LDR      R1,[R5, #+56]
   \       0xB4   0x64C8             STR      R0,[R1, #+76]
   1414          
   1415              
   1416              /* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC     */
   1417              /* start (in case of SW start):                                           */
   1418              
   1419              /* Clear regular group conversion flag and overrun flag */
   1420              /* (To ensure of no unknown state from potential previous ADC operations) */
   1421              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);
   \       0xB6   0xF07F 0x0022      MVNS     R0,#+34
   \       0xBA   0x6829             LDR      R1,[R5, #+0]
   \       0xBC   0x6008             STR      R0,[R1, #+0]
   1422          
   1423              /* Enable ADC overrun interrupt */
   1424              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
   \       0xBE   0x6828             LDR      R0,[R5, #+0]
   \       0xC0   0x6840             LDR      R0,[R0, #+4]
   \       0xC2   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \       0xC6   0x6829             LDR      R1,[R5, #+0]
   \       0xC8   0x6048             STR      R0,[R1, #+4]
   1425              
   1426              /* Enable ADC DMA mode */
   1427              hadc->Instance->CR2 |= ADC_CR2_DMA;
   \       0xCA   0x6828             LDR      R0,[R5, #+0]
   \       0xCC   0x6880             LDR      R0,[R0, #+8]
   \       0xCE   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0xD2   0x6829             LDR      R1,[R5, #+0]
   \       0xD4   0x6088             STR      R0,[R1, #+8]
   1428              
   1429              /* Start the DMA channel */
   1430              HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
   \       0xD6   0x003B             MOVS     R3,R7
   \       0xD8   0x0032             MOVS     R2,R6
   \       0xDA   0x6828             LDR      R0,[R5, #+0]
   \       0xDC   0xF110 0x014C      ADDS     R1,R0,#+76
   \       0xE0   0x6BA8             LDR      R0,[R5, #+56]
   \       0xE2   0x.... 0x....      BL       HAL_DMA_Start_IT
   1431              
   1432              /* Check if Multimode enabled */
   1433              if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
   \       0xE6   0x6860             LDR      R0,[R4, #+4]
   \       0xE8   0xF010 0x0F1F      TST      R0,#0x1F
   \       0xEC   0xD127             BNE.N    ??HAL_ADC_Start_DMA_8
   1434              {
   1435          #if defined(ADC2) && defined(ADC3)
   1436                if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
   1437                                            || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
   \       0xEE   0x6828             LDR      R0,[R5, #+0]
   \       0xF0   0x.... 0x....      LDR.W    R1,??DataTable7_5
   \       0xF4   0x4288             CMP      R0,R1
   \       0xF6   0xD016             BEQ.N    ??HAL_ADC_Start_DMA_9
   \       0xF8   0x6828             LDR      R0,[R5, #+0]
   \       0xFA   0x.... 0x....      LDR.W    R1,??DataTable7_6
   \       0xFE   0x4288             CMP      R0,R1
   \      0x100   0xD105             BNE.N    ??HAL_ADC_Start_DMA_10
   \      0x102   0x.... 0x....      LDR.W    R0,??DataTable7_7
   \      0x106   0x6800             LDR      R0,[R0, #+0]
   \      0x108   0xF010 0x0F1F      TST      R0,#0x1F
   \      0x10C   0xD00B             BEQ.N    ??HAL_ADC_Start_DMA_9
   \                     ??HAL_ADC_Start_DMA_10: (+1)
   \      0x10E   0x6828             LDR      R0,[R5, #+0]
   \      0x110   0x.... 0x....      LDR.W    R1,??DataTable7_8
   \      0x114   0x4288             CMP      R0,R1
   \      0x116   0xD122             BNE.N    ??HAL_ADC_Start_DMA_4
   \      0x118   0x.... 0x....      LDR.W    R0,??DataTable7_7
   \      0x11C   0x6800             LDR      R0,[R0, #+0]
   \      0x11E   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \      0x122   0x2810             CMP      R0,#+16
   \      0x124   0xD21B             BCS.N    ??HAL_ADC_Start_DMA_4
   1438                {
   1439          #endif /* ADC2 || ADC3 */
   1440                  /* if no external trigger present enable software conversion of regular channels */
   1441                  if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
   \                     ??HAL_ADC_Start_DMA_9: (+1)
   \      0x126   0x6828             LDR      R0,[R5, #+0]
   \      0x128   0x6880             LDR      R0,[R0, #+8]
   \      0x12A   0xF010 0x5F40      TST      R0,#0x30000000
   \      0x12E   0xD116             BNE.N    ??HAL_ADC_Start_DMA_4
   1442                  {
   1443                    /* Enable the selected ADC software conversion for regular group */
   1444                    hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
   \      0x130   0x6828             LDR      R0,[R5, #+0]
   \      0x132   0x6880             LDR      R0,[R0, #+8]
   \      0x134   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \      0x138   0x6829             LDR      R1,[R5, #+0]
   \      0x13A   0x6088             STR      R0,[R1, #+8]
   \      0x13C   0xE00F             B.N      ??HAL_ADC_Start_DMA_4
   1445                  }
   1446          #if defined(ADC2) && defined(ADC3)
   1447                }
   1448          #endif /* ADC2 || ADC3 */
   1449              }
   1450              else
   1451              {
   1452                /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
   1453                if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
   \                     ??HAL_ADC_Start_DMA_8: (+1)
   \      0x13E   0x6828             LDR      R0,[R5, #+0]
   \      0x140   0x.... 0x....      LDR.W    R1,??DataTable7_5
   \      0x144   0x4288             CMP      R0,R1
   \      0x146   0xD10A             BNE.N    ??HAL_ADC_Start_DMA_4
   \      0x148   0x6828             LDR      R0,[R5, #+0]
   \      0x14A   0x6880             LDR      R0,[R0, #+8]
   \      0x14C   0xF010 0x5F40      TST      R0,#0x30000000
   \      0x150   0xD105             BNE.N    ??HAL_ADC_Start_DMA_4
   1454                {
   1455                  /* Enable the selected ADC software conversion for regular group */
   1456                    hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
   \      0x152   0x6828             LDR      R0,[R5, #+0]
   \      0x154   0x6880             LDR      R0,[R0, #+8]
   \      0x156   0xF050 0x4080      ORRS     R0,R0,#0x40000000
   \      0x15A   0x6829             LDR      R1,[R5, #+0]
   \      0x15C   0x6088             STR      R0,[R1, #+8]
   1457                }
   1458              }
   1459            }
   1460            
   1461            /* Return function status */
   1462            return HAL_OK;
   \                     ??HAL_ADC_Start_DMA_4: (+1)
   \      0x15E   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADC_Start_DMA_1: (+1)
   \      0x160   0xBDF2             POP      {R1,R4-R7,PC}
   1463          }
   1464          
   1465          /**
   1466            * @brief  Disables ADC DMA (Single-ADC mode) and disables ADC peripheral    
   1467            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
   1468            *         the configuration information for the specified ADC.
   1469            * @retval HAL status
   1470            */

   \                                 In section .text, align 2, keep-with-next
   1471          HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc)
   1472          {
   \                     HAL_ADC_Stop_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1473            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
   1474            
   1475            /* Check the parameters */
   1476            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1477            
   1478            /* Process locked */
   1479            __HAL_LOCK(hadc);
   \        0x6   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE.N    ??HAL_ADC_Stop_DMA_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE027             B.N      ??HAL_ADC_Stop_DMA_1
   \                     ??HAL_ADC_Stop_DMA_0: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xF884 0x003C      STRB     R0,[R4, #+60]
   1480            
   1481            /* Stop potential conversion on going, on regular and injected groups */
   1482            /* Disable ADC peripheral */
   1483            __HAL_ADC_DISABLE(hadc);
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x6880             LDR      R0,[R0, #+8]
   \       0x1C   0x0840             LSRS     R0,R0,#+1
   \       0x1E   0x0040             LSLS     R0,R0,#+1
   \       0x20   0x6821             LDR      R1,[R4, #+0]
   \       0x22   0x6088             STR      R0,[R1, #+8]
   1484            
   1485            /* Check if ADC is effectively disabled */
   1486            if(HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_ADON))
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x6880             LDR      R0,[R0, #+8]
   \       0x28   0x07C0             LSLS     R0,R0,#+31
   \       0x2A   0xD415             BMI.N    ??HAL_ADC_Stop_DMA_2
   1487            {
   1488              /* Disable the selected ADC DMA mode */
   1489              hadc->Instance->CR2 &= ~ADC_CR2_DMA;
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6880             LDR      R0,[R0, #+8]
   \       0x30   0xF430 0x7080      BICS     R0,R0,#0x100
   \       0x34   0x6821             LDR      R1,[R4, #+0]
   \       0x36   0x6088             STR      R0,[R1, #+8]
   1490              
   1491              /* Disable the DMA channel (in case of DMA in circular mode or stop while */
   1492              /* DMA transfer is on going)                                              */
   1493              tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
   \       0x38   0x6BA0             LDR      R0,[R4, #+56]
   \       0x3A   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x3E   0x0005             MOVS     R5,R0
   1494              
   1495              /* Disable ADC overrun interrupt */
   1496              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_OVR);
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x6840             LDR      R0,[R0, #+4]
   \       0x44   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \       0x48   0x6821             LDR      R1,[R4, #+0]
   \       0x4A   0x6048             STR      R0,[R1, #+4]
   1497              
   1498              /* Set ADC state */
   1499              ADC_STATE_CLR_SET(hadc->State,
   1500                                HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
   1501                                HAL_ADC_STATE_READY);
   \       0x4C   0x6C20             LDR      R0,[R4, #+64]
   \       0x4E   0xF430 0x5088      BICS     R0,R0,#0x1100
   \       0x52   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x56   0x6420             STR      R0,[R4, #+64]
   1502            }
   1503            
   1504            /* Process unlocked */
   1505            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_Stop_DMA_2: (+1)
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xF884 0x003C      STRB     R0,[R4, #+60]
   1506            
   1507            /* Return function status */
   1508            return tmp_hal_status;
   \       0x5E   0x0028             MOVS     R0,R5
   \       0x60   0xB2C0             UXTB     R0,R0
   \                     ??HAL_ADC_Stop_DMA_1: (+1)
   \       0x62   0xBD32             POP      {R1,R4,R5,PC}
   1509          }
   1510          
   1511          /**
   1512            * @brief  Gets the converted value from data register of regular channel.
   1513            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
   1514            *         the configuration information for the specified ADC.
   1515            * @retval Converted value
   1516            */

   \                                 In section .text, align 2, keep-with-next
   1517          uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
   1518          {       
   1519            /* Return the selected ADC converted value */ 
   1520            return hadc->Instance->DR;
   \                     HAL_ADC_GetValue: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x6CC0             LDR      R0,[R0, #+76]
   \        0x4   0x4770             BX       LR
   1521          }
   1522          
   1523          /**
   1524            * @brief  Regular conversion complete callback in non blocking mode 
   1525            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
   1526            *         the configuration information for the specified ADC.
   1527            * @retval None
   1528            */

   \                                 In section .text, align 2
   1529          __weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
   1530          {
   1531            /* Prevent unused argument(s) compilation warning */
   1532            UNUSED(hadc);
   1533            /* NOTE : This function Should not be modified, when the callback is needed,
   1534                      the HAL_ADC_ConvCpltCallback could be implemented in the user file
   1535             */
   1536          }
   \                     HAL_ADC_ConvCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   1537          
   1538          /**
   1539            * @brief  Regular conversion half DMA transfer callback in non blocking mode 
   1540            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
   1541            *         the configuration information for the specified ADC.
   1542            * @retval None
   1543            */

   \                                 In section .text, align 2
   1544          __weak void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc)
   1545          {
   1546            /* Prevent unused argument(s) compilation warning */
   1547            UNUSED(hadc);
   1548            /* NOTE : This function Should not be modified, when the callback is needed,
   1549                      the HAL_ADC_ConvHalfCpltCallback could be implemented in the user file
   1550             */
   1551          }
   \                     HAL_ADC_ConvHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   1552          
   1553          /**
   1554            * @brief  Analog watchdog callback in non blocking mode 
   1555            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
   1556            *         the configuration information for the specified ADC.
   1557            * @retval None
   1558            */

   \                                 In section .text, align 2
   1559          __weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)
   1560          {
   1561            /* Prevent unused argument(s) compilation warning */
   1562            UNUSED(hadc);
   1563            /* NOTE : This function Should not be modified, when the callback is needed,
   1564                      the HAL_ADC_LevelOoutOfWindowCallback could be implemented in the user file
   1565             */
   1566          }
   \                     HAL_ADC_LevelOutOfWindowCallback: (+1)
   \        0x0   0x4770             BX       LR
   1567          
   1568          /**
   1569            * @brief  Error ADC callback.
   1570            * @note   In case of error due to overrun when using ADC with DMA transfer 
   1571            *         (HAL ADC handle paramater "ErrorCode" to state "HAL_ADC_ERROR_OVR"):
   1572            *         - Reinitialize the DMA using function "HAL_ADC_Stop_DMA()".
   1573            *         - If needed, restart a new ADC conversion using function
   1574            *           "HAL_ADC_Start_DMA()"
   1575            *           (this function is also clearing overrun flag)
   1576            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
   1577            *         the configuration information for the specified ADC.
   1578            * @retval None
   1579            */

   \                                 In section .text, align 2
   1580          __weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
   1581          {
   1582            /* Prevent unused argument(s) compilation warning */
   1583            UNUSED(hadc);
   1584            /* NOTE : This function Should not be modified, when the callback is needed,
   1585                      the HAL_ADC_ErrorCallback could be implemented in the user file
   1586             */
   1587          }
   \                     HAL_ADC_ErrorCallback: (+1)
   \        0x0   0x4770             BX       LR
   1588          
   1589          /**
   1590            * @}
   1591            */
   1592            
   1593          /** @defgroup ADC_Exported_Functions_Group3 Peripheral Control functions
   1594           *  @brief   	Peripheral Control functions 
   1595           *
   1596          @verbatim   
   1597           ===============================================================================
   1598                       ##### Peripheral Control functions #####
   1599           ===============================================================================  
   1600              [..]  This section provides functions allowing to:
   1601                (+) Configure regular channels. 
   1602                (+) Configure injected channels.
   1603                (+) Configure multimode.
   1604                (+) Configure the analog watch dog.
   1605                
   1606          @endverbatim
   1607            * @{
   1608            */
   1609          
   1610            /**
   1611            * @brief  Configures for the selected ADC regular channel its corresponding
   1612            *         rank in the sequencer and its sample time.
   1613            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
   1614            *         the configuration information for the specified ADC.
   1615            * @param  sConfig ADC configuration structure. 
   1616            * @retval HAL status
   1617            */

   \                                 In section .text, align 2, keep-with-next
   1618          HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
   1619          {
   \                     HAL_ADC_ConfigChannel: (+1)
   \        0x0   0xB438             PUSH     {R3-R5}
   \        0x2   0x0002             MOVS     R2,R0
   1620            __IO uint32_t counter = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
   1621            ADC_Common_TypeDef *tmpADC_Common;
   1622            
   1623            /* Check the parameters */
   1624            assert_param(IS_ADC_CHANNEL(sConfig->Channel));
   1625            assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
   1626            assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
   1627            
   1628            /* Process locked */
   1629            __HAL_LOCK(hadc);
   \        0x8   0xF892 0x003C      LDRB     R0,[R2, #+60]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE.N    ??HAL_ADC_ConfigChannel_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE0B1             B.N      ??HAL_ADC_ConfigChannel_1
   \                     ??HAL_ADC_ConfigChannel_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xF882 0x003C      STRB     R0,[R2, #+60]
   1630              
   1631            /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
   1632            if (sConfig->Channel > ADC_CHANNEL_9)
   \       0x1A   0x6808             LDR      R0,[R1, #+0]
   \       0x1C   0x280A             CMP      R0,#+10
   \       0x1E   0xD318             BCC.N    ??HAL_ADC_ConfigChannel_2
   1633            {
   1634              /* Clear the old sample time */
   1635              hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
   \       0x20   0x6810             LDR      R0,[R2, #+0]
   \       0x22   0x68C3             LDR      R3,[R0, #+12]
   \       0x24   0x2407             MOVS     R4,#+7
   \       0x26   0x6808             LDR      R0,[R1, #+0]
   \       0x28   0x380A             SUBS     R0,R0,#+10
   \       0x2A   0x2503             MOVS     R5,#+3
   \       0x2C   0xFB10 0xF005      SMULBB   R0,R0,R5
   \       0x30   0x4084             LSLS     R4,R4,R0
   \       0x32   0x43A3             BICS     R3,R3,R4
   \       0x34   0x6810             LDR      R0,[R2, #+0]
   \       0x36   0x60C3             STR      R3,[R0, #+12]
   1636              
   1637              /* Set the new sample time */
   1638              hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
   \       0x38   0x6810             LDR      R0,[R2, #+0]
   \       0x3A   0x68C3             LDR      R3,[R0, #+12]
   \       0x3C   0x688C             LDR      R4,[R1, #+8]
   \       0x3E   0x6808             LDR      R0,[R1, #+0]
   \       0x40   0x380A             SUBS     R0,R0,#+10
   \       0x42   0x2503             MOVS     R5,#+3
   \       0x44   0xFB10 0xF005      SMULBB   R0,R0,R5
   \       0x48   0x4084             LSLS     R4,R4,R0
   \       0x4A   0x4323             ORRS     R3,R4,R3
   \       0x4C   0x6810             LDR      R0,[R2, #+0]
   \       0x4E   0x60C3             STR      R3,[R0, #+12]
   \       0x50   0xE013             B.N      ??HAL_ADC_ConfigChannel_3
   1639            }
   1640            else /* ADC_Channel include in ADC_Channel_[0..9] */
   1641            {
   1642              /* Clear the old sample time */
   1643              hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
   \                     ??HAL_ADC_ConfigChannel_2: (+1)
   \       0x52   0x6810             LDR      R0,[R2, #+0]
   \       0x54   0x6903             LDR      R3,[R0, #+16]
   \       0x56   0x2407             MOVS     R4,#+7
   \       0x58   0x680D             LDR      R5,[R1, #+0]
   \       0x5A   0x2003             MOVS     R0,#+3
   \       0x5C   0x4345             MULS     R5,R0,R5
   \       0x5E   0x40AC             LSLS     R4,R4,R5
   \       0x60   0x43A3             BICS     R3,R3,R4
   \       0x62   0x6810             LDR      R0,[R2, #+0]
   \       0x64   0x6103             STR      R3,[R0, #+16]
   1644              
   1645              /* Set the new sample time */
   1646              hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
   \       0x66   0x6810             LDR      R0,[R2, #+0]
   \       0x68   0x6903             LDR      R3,[R0, #+16]
   \       0x6A   0x688C             LDR      R4,[R1, #+8]
   \       0x6C   0x680D             LDR      R5,[R1, #+0]
   \       0x6E   0x2003             MOVS     R0,#+3
   \       0x70   0x4345             MULS     R5,R0,R5
   \       0x72   0x40AC             LSLS     R4,R4,R5
   \       0x74   0x4323             ORRS     R3,R4,R3
   \       0x76   0x6810             LDR      R0,[R2, #+0]
   \       0x78   0x6103             STR      R3,[R0, #+16]
   1647            }
   1648            
   1649            /* For Rank 1 to 6 */
   1650            if (sConfig->Rank < 7U)
   \                     ??HAL_ADC_ConfigChannel_3: (+1)
   \       0x7A   0x6848             LDR      R0,[R1, #+4]
   \       0x7C   0x2807             CMP      R0,#+7
   \       0x7E   0xD218             BCS.N    ??HAL_ADC_ConfigChannel_4
   1651            {
   1652              /* Clear the old SQx bits for the selected rank */
   1653              hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
   \       0x80   0x6810             LDR      R0,[R2, #+0]
   \       0x82   0x6B43             LDR      R3,[R0, #+52]
   \       0x84   0x241F             MOVS     R4,#+31
   \       0x86   0x6848             LDR      R0,[R1, #+4]
   \       0x88   0x1E40             SUBS     R0,R0,#+1
   \       0x8A   0x2505             MOVS     R5,#+5
   \       0x8C   0xFB10 0xF005      SMULBB   R0,R0,R5
   \       0x90   0x4084             LSLS     R4,R4,R0
   \       0x92   0x43A3             BICS     R3,R3,R4
   \       0x94   0x6810             LDR      R0,[R2, #+0]
   \       0x96   0x6343             STR      R3,[R0, #+52]
   1654              
   1655              /* Set the SQx bits for the selected rank */
   1656              hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
   \       0x98   0x6810             LDR      R0,[R2, #+0]
   \       0x9A   0x6B43             LDR      R3,[R0, #+52]
   \       0x9C   0x880C             LDRH     R4,[R1, #+0]
   \       0x9E   0x6848             LDR      R0,[R1, #+4]
   \       0xA0   0x1E40             SUBS     R0,R0,#+1
   \       0xA2   0x2505             MOVS     R5,#+5
   \       0xA4   0xFB10 0xF005      SMULBB   R0,R0,R5
   \       0xA8   0x4084             LSLS     R4,R4,R0
   \       0xAA   0x4323             ORRS     R3,R4,R3
   \       0xAC   0x6810             LDR      R0,[R2, #+0]
   \       0xAE   0x6343             STR      R3,[R0, #+52]
   \       0xB0   0xE033             B.N      ??HAL_ADC_ConfigChannel_5
   1657            }
   1658            /* For Rank 7 to 12 */
   1659            else if (sConfig->Rank < 13U)
   \                     ??HAL_ADC_ConfigChannel_4: (+1)
   \       0xB2   0x6848             LDR      R0,[R1, #+4]
   \       0xB4   0x280D             CMP      R0,#+13
   \       0xB6   0xD218             BCS.N    ??HAL_ADC_ConfigChannel_6
   1660            {
   1661              /* Clear the old SQx bits for the selected rank */
   1662              hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
   \       0xB8   0x6810             LDR      R0,[R2, #+0]
   \       0xBA   0x6B03             LDR      R3,[R0, #+48]
   \       0xBC   0x241F             MOVS     R4,#+31
   \       0xBE   0x6848             LDR      R0,[R1, #+4]
   \       0xC0   0x1FC0             SUBS     R0,R0,#+7
   \       0xC2   0x2505             MOVS     R5,#+5
   \       0xC4   0xFB10 0xF005      SMULBB   R0,R0,R5
   \       0xC8   0x4084             LSLS     R4,R4,R0
   \       0xCA   0x43A3             BICS     R3,R3,R4
   \       0xCC   0x6810             LDR      R0,[R2, #+0]
   \       0xCE   0x6303             STR      R3,[R0, #+48]
   1663              
   1664              /* Set the SQx bits for the selected rank */
   1665              hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
   \       0xD0   0x6810             LDR      R0,[R2, #+0]
   \       0xD2   0x6B03             LDR      R3,[R0, #+48]
   \       0xD4   0x880C             LDRH     R4,[R1, #+0]
   \       0xD6   0x6848             LDR      R0,[R1, #+4]
   \       0xD8   0x1FC0             SUBS     R0,R0,#+7
   \       0xDA   0x2505             MOVS     R5,#+5
   \       0xDC   0xFB10 0xF005      SMULBB   R0,R0,R5
   \       0xE0   0x4084             LSLS     R4,R4,R0
   \       0xE2   0x4323             ORRS     R3,R4,R3
   \       0xE4   0x6810             LDR      R0,[R2, #+0]
   \       0xE6   0x6303             STR      R3,[R0, #+48]
   \       0xE8   0xE017             B.N      ??HAL_ADC_ConfigChannel_5
   1666            }
   1667            /* For Rank 13 to 16 */
   1668            else
   1669            {
   1670              /* Clear the old SQx bits for the selected rank */
   1671              hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
   \                     ??HAL_ADC_ConfigChannel_6: (+1)
   \       0xEA   0x6810             LDR      R0,[R2, #+0]
   \       0xEC   0x6AC3             LDR      R3,[R0, #+44]
   \       0xEE   0x241F             MOVS     R4,#+31
   \       0xF0   0x6848             LDR      R0,[R1, #+4]
   \       0xF2   0x380D             SUBS     R0,R0,#+13
   \       0xF4   0x2505             MOVS     R5,#+5
   \       0xF6   0xFB10 0xF005      SMULBB   R0,R0,R5
   \       0xFA   0x4084             LSLS     R4,R4,R0
   \       0xFC   0x43A3             BICS     R3,R3,R4
   \       0xFE   0x6810             LDR      R0,[R2, #+0]
   \      0x100   0x62C3             STR      R3,[R0, #+44]
   1672              
   1673              /* Set the SQx bits for the selected rank */
   1674              hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
   \      0x102   0x6810             LDR      R0,[R2, #+0]
   \      0x104   0x6AC3             LDR      R3,[R0, #+44]
   \      0x106   0x880C             LDRH     R4,[R1, #+0]
   \      0x108   0x6848             LDR      R0,[R1, #+4]
   \      0x10A   0x380D             SUBS     R0,R0,#+13
   \      0x10C   0x2505             MOVS     R5,#+5
   \      0x10E   0xFB10 0xF005      SMULBB   R0,R0,R5
   \      0x112   0x4084             LSLS     R4,R4,R0
   \      0x114   0x4323             ORRS     R3,R4,R3
   \      0x116   0x6810             LDR      R0,[R2, #+0]
   \      0x118   0x62C3             STR      R3,[R0, #+44]
   1675            }
   1676          
   1677              /* Pointer to the common control register to which is belonging hadc    */
   1678              /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
   1679              /* control register)                                                    */
   1680              tmpADC_Common = ADC_COMMON_REGISTER(hadc);
   \                     ??HAL_ADC_ConfigChannel_5: (+1)
   \      0x11A   0x....             LDR.N    R3,??DataTable7_4
   1681          
   1682            /* if ADC1 Channel_18 is selected for VBAT Channel ennable VBATE */
   1683            if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
   \      0x11C   0x....             LDR.N    R0,??DataTable7_5
   \      0x11E   0x6814             LDR      R4,[R2, #+0]
   \      0x120   0x4284             CMP      R4,R0
   \      0x122   0xD106             BNE.N    ??HAL_ADC_ConfigChannel_7
   \      0x124   0x680C             LDR      R4,[R1, #+0]
   \      0x126   0x2C12             CMP      R4,#+18
   \      0x128   0xD103             BNE.N    ??HAL_ADC_ConfigChannel_7
   1684            {
   1685              /* Disable the TEMPSENSOR channel in case of using board with multiplixed ADC_CHANNEL_VBAT & ADC_CHANNEL_TEMPSENSOR*/    
   1686              if ((uint16_t)ADC_CHANNEL_TEMPSENSOR == (uint16_t)ADC_CHANNEL_VBAT)
   1687              {
   1688                tmpADC_Common->CCR &= ~ADC_CCR_TSVREFE;
   1689              }
   1690              /* Enable the VBAT channel*/
   1691              tmpADC_Common->CCR |= ADC_CCR_VBATE;
   \      0x12A   0x685C             LDR      R4,[R3, #+4]
   \      0x12C   0xF454 0x0480      ORRS     R4,R4,#0x400000
   \      0x130   0x605C             STR      R4,[R3, #+4]
   1692            }
   1693            
   1694            /* if ADC1 Channel_16 or Channel_18 is selected for Temperature sensor or 
   1695               Channel_17 is selected for VREFINT enable TSVREFE */
   1696            if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
   \                     ??HAL_ADC_ConfigChannel_7: (+1)
   \      0x132   0x6814             LDR      R4,[R2, #+0]
   \      0x134   0x4284             CMP      R4,R0
   \      0x136   0xD11B             BNE.N    ??HAL_ADC_ConfigChannel_8
   \      0x138   0x6808             LDR      R0,[R1, #+0]
   \      0x13A   0x2810             CMP      R0,#+16
   \      0x13C   0xD002             BEQ.N    ??HAL_ADC_ConfigChannel_9
   \      0x13E   0x6808             LDR      R0,[R1, #+0]
   \      0x140   0x2811             CMP      R0,#+17
   \      0x142   0xD115             BNE.N    ??HAL_ADC_ConfigChannel_8
   1697            {
   1698              /* Disable the VBAT channel in case of using board with multiplixed ADC_CHANNEL_VBAT & ADC_CHANNEL_TEMPSENSOR*/
   1699              if ((uint16_t)ADC_CHANNEL_TEMPSENSOR == (uint16_t)ADC_CHANNEL_VBAT)
   1700              {
   1701                tmpADC_Common->CCR &= ~ADC_CCR_VBATE;
   1702              }
   1703              /* Enable the Temperature sensor and VREFINT channel*/
   1704              tmpADC_Common->CCR |= ADC_CCR_TSVREFE;
   \                     ??HAL_ADC_ConfigChannel_9: (+1)
   \      0x144   0x6858             LDR      R0,[R3, #+4]
   \      0x146   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \      0x14A   0x6058             STR      R0,[R3, #+4]
   1705              
   1706              if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
   \      0x14C   0x6808             LDR      R0,[R1, #+0]
   \      0x14E   0x2810             CMP      R0,#+16
   \      0x150   0xD10E             BNE.N    ??HAL_ADC_ConfigChannel_8
   1707              {
   1708                /* Delay for temperature sensor stabilization time */
   1709                /* Compute number of CPU cycles to wait for */
   1710                counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
   \      0x152   0x....             LDR.N    R0,??DataTable7_1
   \      0x154   0x6800             LDR      R0,[R0, #+0]
   \      0x156   0x....             LDR.N    R4,??DataTable7_2
   \      0x158   0xFBB0 0xF4F4      UDIV     R4,R0,R4
   \      0x15C   0x200A             MOVS     R0,#+10
   \      0x15E   0x4344             MULS     R4,R0,R4
   \      0x160   0x9400             STR      R4,[SP, #+0]
   1711                while(counter != 0U)
   \                     ??HAL_ADC_ConfigChannel_10: (+1)
   \      0x162   0x9800             LDR      R0,[SP, #+0]
   \      0x164   0x2800             CMP      R0,#+0
   \      0x166   0xD003             BEQ.N    ??HAL_ADC_ConfigChannel_8
   1712                {
   1713                  counter--;
   \      0x168   0x9800             LDR      R0,[SP, #+0]
   \      0x16A   0x1E40             SUBS     R0,R0,#+1
   \      0x16C   0x9000             STR      R0,[SP, #+0]
   \      0x16E   0xE7F8             B.N      ??HAL_ADC_ConfigChannel_10
   1714                }
   1715              }
   1716            }
   1717            
   1718            /* Process unlocked */
   1719            __HAL_UNLOCK(hadc);
   \                     ??HAL_ADC_ConfigChannel_8: (+1)
   \      0x170   0x2000             MOVS     R0,#+0
   \      0x172   0xF882 0x003C      STRB     R0,[R2, #+60]
   1720            
   1721            /* Return function status */
   1722            return HAL_OK;
   \      0x176   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADC_ConfigChannel_1: (+1)
   \      0x178   0xBC32             POP      {R1,R4,R5}
   \      0x17A   0x4770             BX       LR
   1723          }
   1724          
   1725          /**
   1726            * @brief  Configures the analog watchdog.
   1727            * @note Analog watchdog thresholds can be modified while ADC conversion
   1728            * is on going.
   1729            * In this case, some constraints must be taken into account:
   1730            * The programmed threshold values are effective from the next
   1731            * ADC EOC (end of unitary conversion).
   1732            * Considering that registers write delay may happen due to
   1733            * bus activity, this might cause an uncertainty on the
   1734            * effective timing of the new programmed threshold values.
   1735            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
   1736            *         the configuration information for the specified ADC.
   1737            * @param  AnalogWDGConfig  pointer to an ADC_AnalogWDGConfTypeDef structure 
   1738            *         that contains the configuration information of ADC analog watchdog.
   1739            * @retval HAL status	  
   1740            */

   \                                 In section .text, align 2, keep-with-next
   1741          HAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef* hadc, ADC_AnalogWDGConfTypeDef* AnalogWDGConfig)
   1742          {
   \                     HAL_ADC_AnalogWDGConfig: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   1743          #ifdef USE_FULL_ASSERT  
   1744            uint32_t tmp = 0U;
   1745          #endif /* USE_FULL_ASSERT  */  
   1746            
   1747            /* Check the parameters */
   1748            assert_param(IS_ADC_ANALOG_WATCHDOG(AnalogWDGConfig->WatchdogMode));
   1749            assert_param(IS_ADC_CHANNEL(AnalogWDGConfig->Channel));
   1750            assert_param(IS_FUNCTIONAL_STATE(AnalogWDGConfig->ITMode));
   1751          
   1752          #ifdef USE_FULL_ASSERT  
   1753            tmp = ADC_GET_RESOLUTION(hadc);
   1754            assert_param(IS_ADC_RANGE(tmp, AnalogWDGConfig->HighThreshold));
   1755            assert_param(IS_ADC_RANGE(tmp, AnalogWDGConfig->LowThreshold));
   1756          #endif /* USE_FULL_ASSERT  */
   1757            
   1758            /* Process locked */
   1759            __HAL_LOCK(hadc);
   \        0x2   0xF892 0x003C      LDRB     R0,[R2, #+60]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD101             BNE.N    ??HAL_ADC_AnalogWDGConfig_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xE034             B.N      ??HAL_ADC_AnalogWDGConfig_1
   \                     ??HAL_ADC_AnalogWDGConfig_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF882 0x003C      STRB     R0,[R2, #+60]
   1760            
   1761            if(AnalogWDGConfig->ITMode == ENABLE)
   \       0x14   0x7C08             LDRB     R0,[R1, #+16]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD106             BNE.N    ??HAL_ADC_AnalogWDGConfig_2
   1762            {
   1763              /* Enable the ADC Analog watchdog interrupt */
   1764              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_AWD);
   \       0x1A   0x6810             LDR      R0,[R2, #+0]
   \       0x1C   0x6840             LDR      R0,[R0, #+4]
   \       0x1E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x22   0x6813             LDR      R3,[R2, #+0]
   \       0x24   0x6058             STR      R0,[R3, #+4]
   \       0x26   0xE005             B.N      ??HAL_ADC_AnalogWDGConfig_3
   1765            }
   1766            else
   1767            {
   1768              /* Disable the ADC Analog watchdog interrupt */
   1769              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_AWD);
   \                     ??HAL_ADC_AnalogWDGConfig_2: (+1)
   \       0x28   0x6810             LDR      R0,[R2, #+0]
   \       0x2A   0x6840             LDR      R0,[R0, #+4]
   \       0x2C   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x30   0x6813             LDR      R3,[R2, #+0]
   \       0x32   0x6058             STR      R0,[R3, #+4]
   1770            }
   1771            
   1772            /* Clear AWDEN, JAWDEN and AWDSGL bits */
   1773            hadc->Instance->CR1 &=  ~(ADC_CR1_AWDSGL | ADC_CR1_JAWDEN | ADC_CR1_AWDEN);
   \                     ??HAL_ADC_AnalogWDGConfig_3: (+1)
   \       0x34   0x6810             LDR      R0,[R2, #+0]
   \       0x36   0x6843             LDR      R3,[R0, #+4]
   \       0x38   0x....             LDR.N    R0,??DataTable7_10
   \       0x3A   0x4003             ANDS     R3,R0,R3
   \       0x3C   0x6810             LDR      R0,[R2, #+0]
   \       0x3E   0x6043             STR      R3,[R0, #+4]
   1774            
   1775            /* Set the analog watchdog enable mode */
   1776            hadc->Instance->CR1 |= AnalogWDGConfig->WatchdogMode;
   \       0x40   0x6810             LDR      R0,[R2, #+0]
   \       0x42   0x6843             LDR      R3,[R0, #+4]
   \       0x44   0x6808             LDR      R0,[R1, #+0]
   \       0x46   0x4303             ORRS     R3,R0,R3
   \       0x48   0x6810             LDR      R0,[R2, #+0]
   \       0x4A   0x6043             STR      R3,[R0, #+4]
   1777            
   1778            /* Set the high threshold */
   1779            hadc->Instance->HTR = AnalogWDGConfig->HighThreshold;
   \       0x4C   0x6848             LDR      R0,[R1, #+4]
   \       0x4E   0x6813             LDR      R3,[R2, #+0]
   \       0x50   0x6258             STR      R0,[R3, #+36]
   1780            
   1781            /* Set the low threshold */
   1782            hadc->Instance->LTR = AnalogWDGConfig->LowThreshold;
   \       0x52   0x6888             LDR      R0,[R1, #+8]
   \       0x54   0x6813             LDR      R3,[R2, #+0]
   \       0x56   0x6298             STR      R0,[R3, #+40]
   1783            
   1784            /* Clear the Analog watchdog channel select bits */
   1785            hadc->Instance->CR1 &= ~ADC_CR1_AWDCH;
   \       0x58   0x6810             LDR      R0,[R2, #+0]
   \       0x5A   0x6840             LDR      R0,[R0, #+4]
   \       0x5C   0x0940             LSRS     R0,R0,#+5
   \       0x5E   0x0140             LSLS     R0,R0,#+5
   \       0x60   0x6813             LDR      R3,[R2, #+0]
   \       0x62   0x6058             STR      R0,[R3, #+4]
   1786            
   1787            /* Set the Analog watchdog channel */
   1788            hadc->Instance->CR1 |= (uint32_t)((uint16_t)(AnalogWDGConfig->Channel));
   \       0x64   0x6810             LDR      R0,[R2, #+0]
   \       0x66   0x6843             LDR      R3,[R0, #+4]
   \       0x68   0x8988             LDRH     R0,[R1, #+12]
   \       0x6A   0x4303             ORRS     R3,R0,R3
   \       0x6C   0x6810             LDR      R0,[R2, #+0]
   \       0x6E   0x6043             STR      R3,[R0, #+4]
   1789            
   1790            /* Process unlocked */
   1791            __HAL_UNLOCK(hadc);
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0xF882 0x003C      STRB     R0,[R2, #+60]
   1792            
   1793            /* Return function status */
   1794            return HAL_OK;
   \       0x76   0x2000             MOVS     R0,#+0
   \                     ??HAL_ADC_AnalogWDGConfig_1: (+1)
   \       0x78   0x4770             BX       LR
   1795          }
   1796          
   1797          /**
   1798            * @}
   1799            */
   1800          
   1801          /** @defgroup ADC_Exported_Functions_Group4 ADC Peripheral State functions
   1802           *  @brief   ADC Peripheral State functions 
   1803           *
   1804          @verbatim   
   1805           ===============================================================================
   1806                      ##### Peripheral State and errors functions #####
   1807           ===============================================================================  
   1808              [..]
   1809              This subsection provides functions allowing to
   1810                (+) Check the ADC state
   1811                (+) Check the ADC Error
   1812                   
   1813          @endverbatim
   1814            * @{
   1815            */
   1816            
   1817          /**
   1818            * @brief  return the ADC state
   1819            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
   1820            *         the configuration information for the specified ADC.
   1821            * @retval HAL state
   1822            */

   \                                 In section .text, align 2, keep-with-next
   1823          uint32_t HAL_ADC_GetState(ADC_HandleTypeDef* hadc)
   1824          {
   1825            /* Return ADC state */
   1826            return hadc->State;
   \                     HAL_ADC_GetState: (+1)
   \        0x0   0x6C00             LDR      R0,[R0, #+64]
   \        0x2   0x4770             BX       LR
   1827          }
   1828          
   1829          /**
   1830            * @brief  Return the ADC error code
   1831            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
   1832            *         the configuration information for the specified ADC.
   1833            * @retval ADC Error Code
   1834            */

   \                                 In section .text, align 2, keep-with-next
   1835          uint32_t HAL_ADC_GetError(ADC_HandleTypeDef *hadc)
   1836          {
   1837            return hadc->ErrorCode;
   \                     HAL_ADC_GetError: (+1)
   \        0x0   0x6C40             LDR      R0,[R0, #+68]
   \        0x2   0x4770             BX       LR
   1838          }
   1839          
   1840          /**
   1841            * @}
   1842            */
   1843          
   1844          /** @addtogroup ADC_Private_Functions
   1845            * @{
   1846            */
   1847          
   1848          /**
   1849            * @brief  Initializes the ADCx peripheral according to the specified parameters 
   1850            *         in the ADC_InitStruct without initializing the ADC MSP.       
   1851            * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
   1852            *         the configuration information for the specified ADC.  
   1853            * @retval None
   1854            */

   \                                 In section .text, align 2, keep-with-next
   1855          static void ADC_Init(ADC_HandleTypeDef* hadc)
   1856          {
   1857            ADC_Common_TypeDef *tmpADC_Common;
   1858            
   1859            /* Set ADC parameters */
   1860            /* Pointer to the common control register to which is belonging hadc    */
   1861            /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
   1862            /* control register)                                                    */
   1863            tmpADC_Common = ADC_COMMON_REGISTER(hadc);
   \                     ADC_Init: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable7_4
   1864            
   1865            /* Set the ADC clock prescaler */
   1866            tmpADC_Common->CCR &= ~(ADC_CCR_ADCPRE);
   \        0x2   0x6851             LDR      R1,[R2, #+4]
   \        0x4   0xF431 0x3140      BICS     R1,R1,#0x30000
   \        0x8   0x6051             STR      R1,[R2, #+4]
   1867            tmpADC_Common->CCR |=  hadc->Init.ClockPrescaler;
   \        0xA   0x6853             LDR      R3,[R2, #+4]
   \        0xC   0x6841             LDR      R1,[R0, #+4]
   \        0xE   0x430B             ORRS     R3,R1,R3
   \       0x10   0x6053             STR      R3,[R2, #+4]
   1868            
   1869            /* Set ADC scan mode */
   1870            hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
   \       0x12   0x6801             LDR      R1,[R0, #+0]
   \       0x14   0x6849             LDR      R1,[R1, #+4]
   \       0x16   0xF431 0x7180      BICS     R1,R1,#0x100
   \       0x1A   0x6803             LDR      R3,[R0, #+0]
   \       0x1C   0x6059             STR      R1,[R3, #+4]
   1871            hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
   \       0x1E   0x6801             LDR      R1,[R0, #+0]
   \       0x20   0x6849             LDR      R1,[R1, #+4]
   \       0x22   0x6903             LDR      R3,[R0, #+16]
   \       0x24   0xEA51 0x2103      ORRS     R1,R1,R3, LSL #+8
   \       0x28   0x6803             LDR      R3,[R0, #+0]
   \       0x2A   0x6059             STR      R1,[R3, #+4]
   1872            
   1873            /* Set ADC resolution */
   1874            hadc->Instance->CR1 &= ~(ADC_CR1_RES);
   \       0x2C   0x6801             LDR      R1,[R0, #+0]
   \       0x2E   0x6849             LDR      R1,[R1, #+4]
   \       0x30   0xF031 0x7140      BICS     R1,R1,#0x3000000
   \       0x34   0x6803             LDR      R3,[R0, #+0]
   \       0x36   0x6059             STR      R1,[R3, #+4]
   1875            hadc->Instance->CR1 |=  hadc->Init.Resolution;
   \       0x38   0x6801             LDR      R1,[R0, #+0]
   \       0x3A   0x684B             LDR      R3,[R1, #+4]
   \       0x3C   0x6881             LDR      R1,[R0, #+8]
   \       0x3E   0x430B             ORRS     R3,R1,R3
   \       0x40   0x6801             LDR      R1,[R0, #+0]
   \       0x42   0x604B             STR      R3,[R1, #+4]
   1876            
   1877            /* Set ADC data alignment */
   1878            hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
   \       0x44   0x6801             LDR      R1,[R0, #+0]
   \       0x46   0x6889             LDR      R1,[R1, #+8]
   \       0x48   0xF431 0x6100      BICS     R1,R1,#0x800
   \       0x4C   0x6803             LDR      R3,[R0, #+0]
   \       0x4E   0x6099             STR      R1,[R3, #+8]
   1879            hadc->Instance->CR2 |= hadc->Init.DataAlign;
   \       0x50   0x6801             LDR      R1,[R0, #+0]
   \       0x52   0x688B             LDR      R3,[R1, #+8]
   \       0x54   0x68C1             LDR      R1,[R0, #+12]
   \       0x56   0x430B             ORRS     R3,R1,R3
   \       0x58   0x6801             LDR      R1,[R0, #+0]
   \       0x5A   0x608B             STR      R3,[R1, #+8]
   1880            
   1881            /* Enable external trigger if trigger selection is different of software  */
   1882            /* start.                                                                 */
   1883            /* Note: This configuration keeps the hardware feature of parameter       */
   1884            /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
   1885            /*       software start.                                                  */
   1886            if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
   \       0x5C   0x6A81             LDR      R1,[R0, #+40]
   \       0x5E   0x....             LDR.N    R3,??DataTable7
   \       0x60   0x4299             CMP      R1,R3
   \       0x62   0xD018             BEQ.N    ??ADC_Init_0
   1887            {
   1888              /* Select external trigger to start conversion */
   1889              hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
   \       0x64   0x6801             LDR      R1,[R0, #+0]
   \       0x66   0x6889             LDR      R1,[R1, #+8]
   \       0x68   0xF031 0x6170      BICS     R1,R1,#0xF000000
   \       0x6C   0x6803             LDR      R3,[R0, #+0]
   \       0x6E   0x6099             STR      R1,[R3, #+8]
   1890              hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
   \       0x70   0x6801             LDR      R1,[R0, #+0]
   \       0x72   0x688B             LDR      R3,[R1, #+8]
   \       0x74   0x6A81             LDR      R1,[R0, #+40]
   \       0x76   0x430B             ORRS     R3,R1,R3
   \       0x78   0x6801             LDR      R1,[R0, #+0]
   \       0x7A   0x608B             STR      R3,[R1, #+8]
   1891              
   1892              /* Select external trigger polarity */
   1893              hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
   \       0x7C   0x6801             LDR      R1,[R0, #+0]
   \       0x7E   0x6889             LDR      R1,[R1, #+8]
   \       0x80   0xF031 0x5140      BICS     R1,R1,#0x30000000
   \       0x84   0x6803             LDR      R3,[R0, #+0]
   \       0x86   0x6099             STR      R1,[R3, #+8]
   1894              hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
   \       0x88   0x6801             LDR      R1,[R0, #+0]
   \       0x8A   0x688B             LDR      R3,[R1, #+8]
   \       0x8C   0x6AC1             LDR      R1,[R0, #+44]
   \       0x8E   0x430B             ORRS     R3,R1,R3
   \       0x90   0x6801             LDR      R1,[R0, #+0]
   \       0x92   0x608B             STR      R3,[R1, #+8]
   \       0x94   0xE00B             B.N      ??ADC_Init_1
   1895            }
   1896            else
   1897            {
   1898              /* Reset the external trigger */
   1899              hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
   \                     ??ADC_Init_0: (+1)
   \       0x96   0x6801             LDR      R1,[R0, #+0]
   \       0x98   0x6889             LDR      R1,[R1, #+8]
   \       0x9A   0xF031 0x6170      BICS     R1,R1,#0xF000000
   \       0x9E   0x6803             LDR      R3,[R0, #+0]
   \       0xA0   0x6099             STR      R1,[R3, #+8]
   1900              hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
   \       0xA2   0x6801             LDR      R1,[R0, #+0]
   \       0xA4   0x6889             LDR      R1,[R1, #+8]
   \       0xA6   0xF031 0x5140      BICS     R1,R1,#0x30000000
   \       0xAA   0x6803             LDR      R3,[R0, #+0]
   \       0xAC   0x6099             STR      R1,[R3, #+8]
   1901            }
   1902            
   1903            /* Enable or disable ADC continuous conversion mode */
   1904            hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
   \                     ??ADC_Init_1: (+1)
   \       0xAE   0x6801             LDR      R1,[R0, #+0]
   \       0xB0   0x6889             LDR      R1,[R1, #+8]
   \       0xB2   0xF031 0x0102      BICS     R1,R1,#0x2
   \       0xB6   0x6803             LDR      R3,[R0, #+0]
   \       0xB8   0x6099             STR      R1,[R3, #+8]
   1905            hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode);
   \       0xBA   0x6801             LDR      R1,[R0, #+0]
   \       0xBC   0x6889             LDR      R1,[R1, #+8]
   \       0xBE   0x7E03             LDRB     R3,[R0, #+24]
   \       0xC0   0xEA51 0x0143      ORRS     R1,R1,R3, LSL #+1
   \       0xC4   0x6803             LDR      R3,[R0, #+0]
   \       0xC6   0x6099             STR      R1,[R3, #+8]
   1906            
   1907            if(hadc->Init.DiscontinuousConvMode != DISABLE)
   \       0xC8   0xF890 0x1020      LDRB     R1,[R0, #+32]
   \       0xCC   0x2900             CMP      R1,#+0
   \       0xCE   0xD014             BEQ.N    ??ADC_Init_2
   1908            {
   1909              assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
   1910            
   1911              /* Enable the selected ADC regular discontinuous mode */
   1912              hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
   \       0xD0   0x6801             LDR      R1,[R0, #+0]
   \       0xD2   0x6849             LDR      R1,[R1, #+4]
   \       0xD4   0xF451 0x6100      ORRS     R1,R1,#0x800
   \       0xD8   0x6803             LDR      R3,[R0, #+0]
   \       0xDA   0x6059             STR      R1,[R3, #+4]
   1913              
   1914              /* Set the number of channels to be converted in discontinuous mode */
   1915              hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
   \       0xDC   0x6801             LDR      R1,[R0, #+0]
   \       0xDE   0x6849             LDR      R1,[R1, #+4]
   \       0xE0   0xF431 0x4160      BICS     R1,R1,#0xE000
   \       0xE4   0x6803             LDR      R3,[R0, #+0]
   \       0xE6   0x6059             STR      R1,[R3, #+4]
   1916              hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
   \       0xE8   0x6801             LDR      R1,[R0, #+0]
   \       0xEA   0x6849             LDR      R1,[R1, #+4]
   \       0xEC   0x6A43             LDR      R3,[R0, #+36]
   \       0xEE   0x1E5B             SUBS     R3,R3,#+1
   \       0xF0   0xEA51 0x3143      ORRS     R1,R1,R3, LSL #+13
   \       0xF4   0x6803             LDR      R3,[R0, #+0]
   \       0xF6   0x6059             STR      R1,[R3, #+4]
   \       0xF8   0xE005             B.N      ??ADC_Init_3
   1917            }
   1918            else
   1919            {
   1920              /* Disable the selected ADC regular discontinuous mode */
   1921              hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
   \                     ??ADC_Init_2: (+1)
   \       0xFA   0x6801             LDR      R1,[R0, #+0]
   \       0xFC   0x6849             LDR      R1,[R1, #+4]
   \       0xFE   0xF431 0x6100      BICS     R1,R1,#0x800
   \      0x102   0x6803             LDR      R3,[R0, #+0]
   \      0x104   0x6059             STR      R1,[R3, #+4]
   1922            }
   1923            
   1924            /* Set ADC number of conversion */
   1925            hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
   \                     ??ADC_Init_3: (+1)
   \      0x106   0x6801             LDR      R1,[R0, #+0]
   \      0x108   0x6AC9             LDR      R1,[R1, #+44]
   \      0x10A   0xF431 0x0170      BICS     R1,R1,#0xF00000
   \      0x10E   0x6803             LDR      R3,[R0, #+0]
   \      0x110   0x62D9             STR      R1,[R3, #+44]
   1926            hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
   \      0x112   0x6801             LDR      R1,[R0, #+0]
   \      0x114   0x6AC9             LDR      R1,[R1, #+44]
   \      0x116   0x69C3             LDR      R3,[R0, #+28]
   \      0x118   0x1E5B             SUBS     R3,R3,#+1
   \      0x11A   0xEA51 0x5103      ORRS     R1,R1,R3, LSL #+20
   \      0x11E   0x6803             LDR      R3,[R0, #+0]
   \      0x120   0x62D9             STR      R1,[R3, #+44]
   1927            
   1928            /* Enable or disable ADC DMA continuous request */
   1929            hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
   \      0x122   0x6801             LDR      R1,[R0, #+0]
   \      0x124   0x6889             LDR      R1,[R1, #+8]
   \      0x126   0xF431 0x7100      BICS     R1,R1,#0x200
   \      0x12A   0x6803             LDR      R3,[R0, #+0]
   \      0x12C   0x6099             STR      R1,[R3, #+8]
   1930            hadc->Instance->CR2 |= ADC_CR2_DMAContReq((uint32_t)hadc->Init.DMAContinuousRequests);
   \      0x12E   0x6801             LDR      R1,[R0, #+0]
   \      0x130   0x6889             LDR      R1,[R1, #+8]
   \      0x132   0xF890 0x3030      LDRB     R3,[R0, #+48]
   \      0x136   0xEA51 0x2143      ORRS     R1,R1,R3, LSL #+9
   \      0x13A   0x6803             LDR      R3,[R0, #+0]
   \      0x13C   0x6099             STR      R1,[R3, #+8]
   1931            
   1932            /* Enable or disable ADC end of conversion selection */
   1933            hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
   \      0x13E   0x6801             LDR      R1,[R0, #+0]
   \      0x140   0x6889             LDR      R1,[R1, #+8]
   \      0x142   0xF431 0x6180      BICS     R1,R1,#0x400
   \      0x146   0x6803             LDR      R3,[R0, #+0]
   \      0x148   0x6099             STR      R1,[R3, #+8]
   1934            hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
   \      0x14A   0x6801             LDR      R1,[R0, #+0]
   \      0x14C   0x6889             LDR      R1,[R1, #+8]
   \      0x14E   0x6943             LDR      R3,[R0, #+20]
   \      0x150   0xEA51 0x2183      ORRS     R1,R1,R3, LSL #+10
   \      0x154   0x6803             LDR      R3,[R0, #+0]
   \      0x156   0x6099             STR      R1,[R3, #+8]
   1935          }
   \      0x158   0x4770             BX       LR
   1936          
   1937          /**
   1938            * @brief  DMA transfer complete callback. 
   1939            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   1940            *                the configuration information for the specified DMA module.
   1941            * @retval None
   1942            */

   \                                 In section .text, align 4, keep-with-next
   1943          static void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)   
   1944          {
   \                     ADC_DMAConvCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1945            /* Retrieve ADC handle corresponding to current DMA handle */
   1946            ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   1947            
   1948            /* Update state machine on conversion status if not in error state */
   1949            if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
   \        0x6   0x6C28             LDR      R0,[R5, #+64]
   \        0x8   0xF010 0x0F50      TST      R0,#0x50
   \        0xC   0xD129             BNE.N    ??ADC_DMAConvCplt_0
   1950            {
   1951              /* Update ADC state machine */
   1952              SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
   \        0xE   0x6C28             LDR      R0,[R5, #+64]
   \       0x10   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0x14   0x6428             STR      R0,[R5, #+64]
   1953              
   1954              /* Determine whether any further conversion upcoming on group regular   */
   1955              /* by external trigger, continuous mode or scan sequence on going.      */
   1956              /* Note: On STM32F4, there is no independent flag of end of sequence.   */
   1957              /*       The test of scan sequence on going is done either with scan    */
   1958              /*       sequence disabled or with end of conversion flag set to        */
   1959              /*       of end of sequence.                                            */
   1960              if(ADC_IS_SOFTWARE_START_REGULAR(hadc)                   &&
   1961                 (hadc->Init.ContinuousConvMode == DISABLE)            &&
   1962                 (HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L) || 
   1963                  HAL_IS_BIT_CLR(hadc->Instance->CR2, ADC_CR2_EOCS)  )   )
   \       0x16   0x6828             LDR      R0,[R5, #+0]
   \       0x18   0x6880             LDR      R0,[R0, #+8]
   \       0x1A   0xF010 0x5F40      TST      R0,#0x30000000
   \       0x1E   0xD11C             BNE.N    ??ADC_DMAConvCplt_1
   \       0x20   0x7E28             LDRB     R0,[R5, #+24]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD119             BNE.N    ??ADC_DMAConvCplt_1
   \       0x26   0x6828             LDR      R0,[R5, #+0]
   \       0x28   0x6AC0             LDR      R0,[R0, #+44]
   \       0x2A   0xF410 0x0F70      TST      R0,#0xF00000
   \       0x2E   0xD003             BEQ.N    ??ADC_DMAConvCplt_2
   \       0x30   0x6828             LDR      R0,[R5, #+0]
   \       0x32   0x6880             LDR      R0,[R0, #+8]
   \       0x34   0x0540             LSLS     R0,R0,#+21
   \       0x36   0xD410             BMI.N    ??ADC_DMAConvCplt_1
   1964              {
   1965                /* Disable ADC end of single conversion interrupt on group regular */
   1966                /* Note: Overrun interrupt was enabled with EOC interrupt in          */
   1967                /* HAL_ADC_Start_IT(), but is not disabled here because can be used   */
   1968                /* by overrun IRQ process below.                                      */
   1969                __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
   \                     ??ADC_DMAConvCplt_2: (+1)
   \       0x38   0x6828             LDR      R0,[R5, #+0]
   \       0x3A   0x6840             LDR      R0,[R0, #+4]
   \       0x3C   0xF030 0x0020      BICS     R0,R0,#0x20
   \       0x40   0x6829             LDR      R1,[R5, #+0]
   \       0x42   0x6048             STR      R0,[R1, #+4]
   1970                
   1971                /* Set ADC state */
   1972                CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
   \       0x44   0x6C28             LDR      R0,[R5, #+64]
   \       0x46   0xF430 0x7080      BICS     R0,R0,#0x100
   \       0x4A   0x6428             STR      R0,[R5, #+64]
   1973                
   1974                if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   \       0x4C   0x6C28             LDR      R0,[R5, #+64]
   \       0x4E   0x04C0             LSLS     R0,R0,#+19
   \       0x50   0xD403             BMI.N    ??ADC_DMAConvCplt_1
   1975                {
   1976                  SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   \       0x52   0x6C28             LDR      R0,[R5, #+64]
   \       0x54   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x58   0x6428             STR      R0,[R5, #+64]
   1977                }
   1978              }
   1979              
   1980              /* Conversion complete callback */
   1981          #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
   1982              hadc->ConvCpltCallback(hadc);
   1983          #else
   1984              HAL_ADC_ConvCpltCallback(hadc);
   \                     ??ADC_DMAConvCplt_1: (+1)
   \       0x5A   0x0028             MOVS     R0,R5
   \       0x5C   0x.... 0x....      BL       HAL_ADC_ConvCpltCallback
   \       0x60   0xE00A             B.N      ??ADC_DMAConvCplt_3
   1985          #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
   1986            }
   1987            else /* DMA and-or internal error occurred */
   1988            {
   1989              if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) != 0UL)
   \                     ??ADC_DMAConvCplt_0: (+1)
   \       0x62   0x6C28             LDR      R0,[R5, #+64]
   \       0x64   0x06C0             LSLS     R0,R0,#+27
   \       0x66   0xD503             BPL.N    ??ADC_DMAConvCplt_4
   1990              {
   1991                /* Call HAL ADC Error Callback function */
   1992          #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
   1993                hadc->ErrorCallback(hadc);
   1994          #else
   1995                HAL_ADC_ErrorCallback(hadc);
   \       0x68   0x0028             MOVS     R0,R5
   \       0x6A   0x.... 0x....      BL       HAL_ADC_ErrorCallback
   \       0x6E   0xE003             B.N      ??ADC_DMAConvCplt_3
   1996          #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
   1997              }
   1998          	else
   1999          	{
   2000                /* Call DMA error callback */
   2001                hadc->DMA_Handle->XferErrorCallback(hdma);
   \                     ??ADC_DMAConvCplt_4: (+1)
   \       0x70   0x0020             MOVS     R0,R4
   \       0x72   0x6BA9             LDR      R1,[R5, #+56]
   \       0x74   0x6CC9             LDR      R1,[R1, #+76]
   \       0x76   0x4788             BLX      R1
   2002              }
   2003            }
   2004          }
   \                     ??ADC_DMAConvCplt_3: (+1)
   \       0x78   0xBD31             POP      {R0,R4,R5,PC}
   2005          
   2006          /**
   2007            * @brief  DMA half transfer complete callback. 
   2008            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2009            *                the configuration information for the specified DMA module.
   2010            * @retval None
   2011            */

   \                                 In section .text, align 4, keep-with-next
   2012          static void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
   2013          {
   \                     ADC_DMAHalfConvCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2014            ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2015             /* Half conversion callback */
   2016          #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
   2017            hadc->ConvHalfCpltCallback(hadc);
   2018          #else
   2019            HAL_ADC_ConvHalfCpltCallback(hadc);
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x.... 0x....      BL       HAL_ADC_ConvHalfCpltCallback
   2020          #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
   2021          }
   \        0xC   0xBD31             POP      {R0,R4,R5,PC}
   2022          
   2023          /**
   2024            * @brief  DMA error callback 
   2025            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2026            *                the configuration information for the specified DMA module.
   2027            * @retval None
   2028            */

   \                                 In section .text, align 4, keep-with-next
   2029          static void ADC_DMAError(DMA_HandleTypeDef *hdma)   
   2030          {
   \                     ADC_DMAError: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2031            ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2032            hadc->State= HAL_ADC_STATE_ERROR_DMA;
   \        0x6   0x2040             MOVS     R0,#+64
   \        0x8   0x6428             STR      R0,[R5, #+64]
   2033            /* Set ADC error code to DMA error */
   2034            hadc->ErrorCode |= HAL_ADC_ERROR_DMA;
   \        0xA   0x6C68             LDR      R0,[R5, #+68]
   \        0xC   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x10   0x6468             STR      R0,[R5, #+68]
   2035             /* Error callback */
   2036          #if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
   2037            hadc->ErrorCallback(hadc);
   2038          #else
   2039            HAL_ADC_ErrorCallback(hadc);
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0x.... 0x....      BL       HAL_ADC_ErrorCallback
   2040          #endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
   2041          }
   \       0x18   0xBD31             POP      {R0,R4,R5,PC}

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x0F00'0001        DC32     0xf000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x000F'4240        DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0xFFFF'F9FE        DC32     0xfffff9fe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \        0x0   0x4001'2300        DC32     0x40012300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \        0x0   0x4001'2000        DC32     0x40012000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \        0x0   0x4001'2100        DC32     0x40012100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \        0x0   0x4001'2304        DC32     0x40012304

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \        0x0   0x4001'2200        DC32     0x40012200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \        0x0   0xFBFF'FFDF        DC32     0xfbffffdf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \        0x0   0xFF3F'FDFF        DC32     0xff3ffdff
   2042          
   2043          /**
   2044            * @}
   2045            */
   2046          
   2047          /**
   2048            * @}
   2049            */
   2050          
   2051          #endif /* HAL_ADC_MODULE_ENABLED */
   2052          /**
   2053            * @}
   2054            */ 
   2055          
   2056          /**
   2057            * @}
   2058            */ 
   2059          
   2060          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ADC_DMAConvCplt
        16   -- Indirect call
        16   -> HAL_ADC_ConvCpltCallback
        16   -> HAL_ADC_ErrorCallback
      16   ADC_DMAError
        16   -> HAL_ADC_ErrorCallback
      16   ADC_DMAHalfConvCplt
        16   -> HAL_ADC_ConvHalfCpltCallback
       0   ADC_Init
       0   HAL_ADC_AnalogWDGConfig
      12   HAL_ADC_ConfigChannel
       0   HAL_ADC_ConvCpltCallback
       0   HAL_ADC_ConvHalfCpltCallback
      16   HAL_ADC_DeInit
        16   -> HAL_ADC_MspDeInit
       0   HAL_ADC_ErrorCallback
       0   HAL_ADC_GetError
       0   HAL_ADC_GetState
       0   HAL_ADC_GetValue
      24   HAL_ADC_IRQHandler
        24   -> HAL_ADCEx_InjectedConvCpltCallback
        24   -> HAL_ADC_ConvCpltCallback
        24   -> HAL_ADC_ErrorCallback
        24   -> HAL_ADC_LevelOutOfWindowCallback
      16   HAL_ADC_Init
        16   -> ADC_Init
        16   -> HAL_ADC_MspInit
       0   HAL_ADC_LevelOutOfWindowCallback
       0   HAL_ADC_MspDeInit
       0   HAL_ADC_MspInit
      24   HAL_ADC_PollForConversion
        24   -> HAL_GetTick
      24   HAL_ADC_PollForEvent
        24   -> HAL_GetTick
       4   HAL_ADC_Start
      24   HAL_ADC_Start_DMA
        24   -> HAL_DMA_Start_IT
       4   HAL_ADC_Start_IT
       0   HAL_ADC_Stop
      16   HAL_ADC_Stop_DMA
        16   -> HAL_DMA_Abort
       0   HAL_ADC_Stop_IT


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
     122  ADC_DMAConvCplt
      26  ADC_DMAError
      14  ADC_DMAHalfConvCplt
     346  ADC_Init
     122  HAL_ADC_AnalogWDGConfig
     380  HAL_ADC_ConfigChannel
       2  HAL_ADC_ConvCpltCallback
       2  HAL_ADC_ConvHalfCpltCallback
      68  HAL_ADC_DeInit
       2  HAL_ADC_ErrorCallback
       4  HAL_ADC_GetError
       4  HAL_ADC_GetState
       6  HAL_ADC_GetValue
     486  HAL_ADC_IRQHandler
     100  HAL_ADC_Init
       2  HAL_ADC_LevelOutOfWindowCallback
       2  HAL_ADC_MspDeInit
       2  HAL_ADC_MspInit
     170  HAL_ADC_PollForConversion
     120  HAL_ADC_PollForEvent
     286  HAL_ADC_Start
     354  HAL_ADC_Start_DMA
     302  HAL_ADC_Start_IT
      62  HAL_ADC_Stop
     100  HAL_ADC_Stop_DMA
      76  HAL_ADC_Stop_IT

 
 3'204 bytes in section .text
 
 3'192 bytes of CODE memory (+ 12 bytes shared)

Errors: none
Warnings: none
