###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         27/Sep/2022  19:40:25
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_pcd.c
#    Command line      =
#        -f
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_pcd.o.rsp
#        (C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_pcd.c
#        -D USE_HAL_DRIVER -D STM32F407xx -lC
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver
#        -o
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/App\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Core/Inc\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Include\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/display\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Library\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_pcd.o.d
#    Locale            =  C
#    List file         =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_pcd.lst
#    Object file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_pcd.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_pcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_pcd.c
      4            * @author  MCD Application Team
      5            * @brief   PCD HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the USB Peripheral Controller:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *           + Peripheral Control functions
     11            *           + Peripheral State functions
     12            *
     13            @verbatim
     14            ==============================================================================
     15                              ##### How to use this driver #####
     16            ==============================================================================
     17              [..]
     18                The PCD HAL driver can be used as follows:
     19          
     20               (#) Declare a PCD_HandleTypeDef handle structure, for example:
     21                   PCD_HandleTypeDef  hpcd;
     22          
     23               (#) Fill parameters of Init structure in HCD handle
     24          
     25               (#) Call HAL_PCD_Init() API to initialize the PCD peripheral (Core, Device core, ...)
     26          
     27               (#) Initialize the PCD low level resources through the HAL_PCD_MspInit() API:
     28                   (##) Enable the PCD/USB Low Level interface clock using
     29                        (+++) __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
     30                        (+++) __HAL_RCC_USB_OTG_HS_CLK_ENABLE(); (For High Speed Mode)
     31          
     32                   (##) Initialize the related GPIO clocks
     33                   (##) Configure PCD pin-out
     34                   (##) Configure PCD NVIC interrupt
     35          
     36               (#)Associate the Upper USB device stack to the HAL PCD Driver:
     37                   (##) hpcd.pData = pdev;
     38          
     39               (#)Enable PCD transmission and reception:
     40                   (##) HAL_PCD_Start();
     41          
     42            @endverbatim
     43            ******************************************************************************
     44            * @attention
     45            *
     46            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
     47            * All rights reserved.</center></h2>
     48            *
     49            * This software component is licensed by ST under BSD 3-Clause license,
     50            * the "License"; You may not use this file except in compliance with the
     51            * License. You may obtain a copy of the License at:
     52            *                        opensource.org/licenses/BSD-3-Clause
     53            *
     54            ******************************************************************************
     55            */
     56          
     57          /* Includes ------------------------------------------------------------------*/
     58          #include "stm32f4xx_hal.h"
     59          
     60          /** @addtogroup STM32F4xx_HAL_Driver
     61            * @{
     62            */
     63          
     64          /** @defgroup PCD PCD
     65            * @brief PCD HAL module driver
     66            * @{
     67            */
     68          
     69          #ifdef HAL_PCD_MODULE_ENABLED
     70          
     71          #if defined (USB_OTG_FS) || defined (USB_OTG_HS)
     72          
     73          /* Private types -------------------------------------------------------------*/
     74          /* Private variables ---------------------------------------------------------*/
     75          /* Private constants ---------------------------------------------------------*/
     76          /* Private macros ------------------------------------------------------------*/
     77          /** @defgroup PCD_Private_Macros PCD Private Macros
     78            * @{
     79            */
     80          #define PCD_MIN(a, b)  (((a) < (b)) ? (a) : (b))
     81          #define PCD_MAX(a, b)  (((a) > (b)) ? (a) : (b))
     82          /**
     83            * @}
     84            */
     85          
     86          /* Private functions prototypes ----------------------------------------------*/
     87          /** @defgroup PCD_Private_Functions PCD Private Functions
     88            * @{
     89            */
     90          #if defined (USB_OTG_FS) || defined (USB_OTG_HS)
     91          static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum);
     92          static HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum);
     93          static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum);
     94          #endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */
     95          /**
     96            * @}
     97            */
     98          
     99          /* Exported functions --------------------------------------------------------*/
    100          /** @defgroup PCD_Exported_Functions PCD Exported Functions
    101            * @{
    102            */
    103          
    104          /** @defgroup PCD_Exported_Functions_Group1 Initialization and de-initialization functions
    105            *  @brief    Initialization and Configuration functions
    106            *
    107          @verbatim
    108           ===============================================================================
    109                      ##### Initialization and de-initialization functions #####
    110           ===============================================================================
    111              [..]  This section provides functions allowing to:
    112          
    113          @endverbatim
    114            * @{
    115            */
    116          
    117          /**
    118            * @brief  Initializes the PCD according to the specified
    119            *         parameters in the PCD_InitTypeDef and initialize the associated handle.
    120            * @param  hpcd PCD handle
    121            * @retval HAL status
    122            */

   \                                 In section .text, align 2, keep-with-next
    123          HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
    124          {
   \                     HAL_PCD_Init: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB08A             SUB      SP,SP,#+40
   \        0x4   0x0004             MOVS     R4,R0
    125            USB_OTG_GlobalTypeDef *USBx;
    126            uint8_t i;
    127          
    128            /* Check the PCD handle allocation */
    129            if (hpcd == NULL)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE.N    ??HAL_PCD_Init_0
    130            {
    131              return HAL_ERROR;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE0B0             B.N      ??HAL_PCD_Init_1
    132            }
    133          
    134            /* Check the parameters */
    135            assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));
    136          
    137            USBx = hpcd->Instance;
   \                     ??HAL_PCD_Init_0: (+1)
   \        0xE   0x6826             LDR      R6,[R4, #+0]
    138          
    139            if (hpcd->State == HAL_PCD_STATE_RESET)
   \       0x10   0xF894 0x03BD      LDRB     R0,[R4, #+957]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD105             BNE.N    ??HAL_PCD_Init_2
    140            {
    141              /* Allocate lock resource and initialize it */
    142              hpcd->Lock = HAL_UNLOCKED;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xF884 0x03BC      STRB     R0,[R4, #+956]
    143          
    144          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
    145              hpcd->SOFCallback = HAL_PCD_SOFCallback;
    146              hpcd->SetupStageCallback = HAL_PCD_SetupStageCallback;
    147              hpcd->ResetCallback = HAL_PCD_ResetCallback;
    148              hpcd->SuspendCallback = HAL_PCD_SuspendCallback;
    149              hpcd->ResumeCallback = HAL_PCD_ResumeCallback;
    150              hpcd->ConnectCallback = HAL_PCD_ConnectCallback;
    151              hpcd->DisconnectCallback = HAL_PCD_DisconnectCallback;
    152              hpcd->DataOutStageCallback = HAL_PCD_DataOutStageCallback;
    153              hpcd->DataInStageCallback = HAL_PCD_DataInStageCallback;
    154              hpcd->ISOOUTIncompleteCallback = HAL_PCD_ISOOUTIncompleteCallback;
    155              hpcd->ISOINIncompleteCallback = HAL_PCD_ISOINIncompleteCallback;
    156              hpcd->LPMCallback = HAL_PCDEx_LPM_Callback;
    157              hpcd->BCDCallback = HAL_PCDEx_BCD_Callback;
    158          
    159              if (hpcd->MspInitCallback == NULL)
    160              {
    161                hpcd->MspInitCallback = HAL_PCD_MspInit;
    162              }
    163          
    164              /* Init the low level hardware */
    165              hpcd->MspInitCallback(hpcd);
    166          #else
    167              /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    168              HAL_PCD_MspInit(hpcd);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       HAL_PCD_MspInit
    169          #endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
    170            }
    171          
    172            hpcd->State = HAL_PCD_STATE_BUSY;
   \                     ??HAL_PCD_Init_2: (+1)
   \       0x24   0x2003             MOVS     R0,#+3
   \       0x26   0xF884 0x03BD      STRB     R0,[R4, #+957]
    173          
    174            /* Disable DMA mode for FS instance */
    175            if ((USBx->CID & (0x1U << 8)) == 0U)
   \       0x2A   0x6BF0             LDR      R0,[R6, #+60]
   \       0x2C   0x05C0             LSLS     R0,R0,#+23
   \       0x2E   0xD401             BMI.N    ??HAL_PCD_Init_3
    176            {
    177              hpcd->Init.dma_enable = 0U;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x6120             STR      R0,[R4, #+16]
    178            }
    179          
    180            /* Disable the Interrupts */
    181            __HAL_PCD_DISABLE(hpcd);
   \                     ??HAL_PCD_Init_3: (+1)
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x.... 0x....      BL       USB_DisableGlobalInt
    182          
    183            /*Init the Core (common init.) */
    184            if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
   \       0x3A   0x1D21             ADDS     R1,R4,#+4
   \       0x3C   0xB083             SUB      SP,SP,#+12
   \       0x3E   0x4668             MOV      R0,SP
   \       0x40   0x2234             MOVS     R2,#+52
   \       0x42   0x.... 0x....      BL       __aeabi_memcpy4
   \       0x46   0xBC0E             POP      {R1-R3}
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x.... 0x....      BL       USB_CoreInit
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD004             BEQ.N    ??HAL_PCD_Init_4
    185            {
    186              hpcd->State = HAL_PCD_STATE_ERROR;
   \       0x52   0x2002             MOVS     R0,#+2
   \       0x54   0xF884 0x03BD      STRB     R0,[R4, #+957]
    187              return HAL_ERROR;
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0xE089             B.N      ??HAL_PCD_Init_1
    188            }
    189          
    190            /* Force Device Mode*/
    191            (void)USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE);
   \                     ??HAL_PCD_Init_4: (+1)
   \       0x5C   0x2100             MOVS     R1,#+0
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x.... 0x....      BL       USB_SetCurrentMode
    192          
    193            /* Init endpoints structures */
    194            for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
   \       0x64   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_Init_5: (+1)
   \       0x66   0x0001             MOVS     R1,R0
   \       0x68   0xB2C9             UXTB     R1,R1
   \       0x6A   0x6862             LDR      R2,[R4, #+4]
   \       0x6C   0x4291             CMP      R1,R2
   \       0x6E   0xD231             BCS.N    ??HAL_PCD_Init_6
    195            {
    196              /* Init ep structure */
    197              hpcd->IN_ep[i].is_in = 1U;
   \       0x70   0x211C             MOVS     R1,#+28
   \       0x72   0x0002             MOVS     R2,R0
   \       0x74   0xB2D2             UXTB     R2,R2
   \       0x76   0x434A             MULS     R2,R1,R2
   \       0x78   0x4422             ADD      R2,R4,R2
   \       0x7A   0x2301             MOVS     R3,#+1
   \       0x7C   0xF882 0x303D      STRB     R3,[R2, #+61]
    198              hpcd->IN_ep[i].num = i;
   \       0x80   0x0002             MOVS     R2,R0
   \       0x82   0xB2D2             UXTB     R2,R2
   \       0x84   0x434A             MULS     R2,R1,R2
   \       0x86   0x4422             ADD      R2,R4,R2
   \       0x88   0xF882 0x003C      STRB     R0,[R2, #+60]
    199              hpcd->IN_ep[i].tx_fifo_num = i;
   \       0x8C   0x0002             MOVS     R2,R0
   \       0x8E   0xB2D2             UXTB     R2,R2
   \       0x90   0x434A             MULS     R2,R1,R2
   \       0x92   0x4422             ADD      R2,R4,R2
   \       0x94   0x0003             MOVS     R3,R0
   \       0x96   0xB2DB             UXTB     R3,R3
   \       0x98   0xF8A2 0x3042      STRH     R3,[R2, #+66]
    200              /* Control until ep is activated */
    201              hpcd->IN_ep[i].type = EP_TYPE_CTRL;
   \       0x9C   0x0002             MOVS     R2,R0
   \       0x9E   0xB2D2             UXTB     R2,R2
   \       0xA0   0x434A             MULS     R2,R1,R2
   \       0xA2   0x4422             ADD      R2,R4,R2
   \       0xA4   0x2300             MOVS     R3,#+0
   \       0xA6   0xF882 0x303F      STRB     R3,[R2, #+63]
    202              hpcd->IN_ep[i].maxpacket = 0U;
   \       0xAA   0x0002             MOVS     R2,R0
   \       0xAC   0xB2D2             UXTB     R2,R2
   \       0xAE   0x434A             MULS     R2,R1,R2
   \       0xB0   0x4422             ADD      R2,R4,R2
   \       0xB2   0x2300             MOVS     R3,#+0
   \       0xB4   0x6453             STR      R3,[R2, #+68]
    203              hpcd->IN_ep[i].xfer_buff = 0U;
   \       0xB6   0x0002             MOVS     R2,R0
   \       0xB8   0xB2D2             UXTB     R2,R2
   \       0xBA   0x434A             MULS     R2,R1,R2
   \       0xBC   0x4422             ADD      R2,R4,R2
   \       0xBE   0x2300             MOVS     R3,#+0
   \       0xC0   0x6493             STR      R3,[R2, #+72]
    204              hpcd->IN_ep[i].xfer_len = 0U;
   \       0xC2   0x0002             MOVS     R2,R0
   \       0xC4   0xB2D2             UXTB     R2,R2
   \       0xC6   0xFB01 0xF102      MUL      R1,R1,R2
   \       0xCA   0x4421             ADD      R1,R4,R1
   \       0xCC   0x2200             MOVS     R2,#+0
   \       0xCE   0x650A             STR      R2,[R1, #+80]
    205            }
   \       0xD0   0x1C40             ADDS     R0,R0,#+1
   \       0xD2   0xE7C8             B.N      ??HAL_PCD_Init_5
    206          
    207            for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
   \                     ??HAL_PCD_Init_6: (+1)
   \       0xD4   0x2500             MOVS     R5,#+0
   \                     ??HAL_PCD_Init_7: (+1)
   \       0xD6   0x0028             MOVS     R0,R5
   \       0xD8   0xB2C0             UXTB     R0,R0
   \       0xDA   0x6861             LDR      R1,[R4, #+4]
   \       0xDC   0x4288             CMP      R0,R1
   \       0xDE   0xD22C             BCS.N    ??HAL_PCD_Init_8
    208            {
    209              hpcd->OUT_ep[i].is_in = 0U;
   \       0xE0   0x201C             MOVS     R0,#+28
   \       0xE2   0x0029             MOVS     R1,R5
   \       0xE4   0xB2C9             UXTB     R1,R1
   \       0xE6   0x4341             MULS     R1,R0,R1
   \       0xE8   0x4421             ADD      R1,R4,R1
   \       0xEA   0x2200             MOVS     R2,#+0
   \       0xEC   0xF881 0x21FD      STRB     R2,[R1, #+509]
    210              hpcd->OUT_ep[i].num = i;
   \       0xF0   0x0029             MOVS     R1,R5
   \       0xF2   0xB2C9             UXTB     R1,R1
   \       0xF4   0x4341             MULS     R1,R0,R1
   \       0xF6   0x4421             ADD      R1,R4,R1
   \       0xF8   0xF881 0x51FC      STRB     R5,[R1, #+508]
    211              /* Control until ep is activated */
    212              hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
   \       0xFC   0x0029             MOVS     R1,R5
   \       0xFE   0xB2C9             UXTB     R1,R1
   \      0x100   0x4341             MULS     R1,R0,R1
   \      0x102   0x4421             ADD      R1,R4,R1
   \      0x104   0x2200             MOVS     R2,#+0
   \      0x106   0xF881 0x21FF      STRB     R2,[R1, #+511]
    213              hpcd->OUT_ep[i].maxpacket = 0U;
   \      0x10A   0x0029             MOVS     R1,R5
   \      0x10C   0xB2C9             UXTB     R1,R1
   \      0x10E   0x4341             MULS     R1,R0,R1
   \      0x110   0x4421             ADD      R1,R4,R1
   \      0x112   0x2200             MOVS     R2,#+0
   \      0x114   0xF8C1 0x2204      STR      R2,[R1, #+516]
    214              hpcd->OUT_ep[i].xfer_buff = 0U;
   \      0x118   0x0029             MOVS     R1,R5
   \      0x11A   0xB2C9             UXTB     R1,R1
   \      0x11C   0x4341             MULS     R1,R0,R1
   \      0x11E   0x4421             ADD      R1,R4,R1
   \      0x120   0x2200             MOVS     R2,#+0
   \      0x122   0xF8C1 0x2208      STR      R2,[R1, #+520]
    215              hpcd->OUT_ep[i].xfer_len = 0U;
   \      0x126   0x0029             MOVS     R1,R5
   \      0x128   0xB2C9             UXTB     R1,R1
   \      0x12A   0xFB00 0xF001      MUL      R0,R0,R1
   \      0x12E   0x4420             ADD      R0,R4,R0
   \      0x130   0x2100             MOVS     R1,#+0
   \      0x132   0xF8C0 0x1210      STR      R1,[R0, #+528]
    216            }
   \      0x136   0x1C6D             ADDS     R5,R5,#+1
   \      0x138   0xE7CD             B.N      ??HAL_PCD_Init_7
    217          
    218            /* Init Device */
    219            if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
   \                     ??HAL_PCD_Init_8: (+1)
   \      0x13A   0x1D21             ADDS     R1,R4,#+4
   \      0x13C   0xB083             SUB      SP,SP,#+12
   \      0x13E   0x4668             MOV      R0,SP
   \      0x140   0x2234             MOVS     R2,#+52
   \      0x142   0x.... 0x....      BL       __aeabi_memcpy4
   \      0x146   0xBC0E             POP      {R1-R3}
   \      0x148   0x6820             LDR      R0,[R4, #+0]
   \      0x14A   0x.... 0x....      BL       USB_DevInit
   \      0x14E   0x2800             CMP      R0,#+0
   \      0x150   0xD004             BEQ.N    ??HAL_PCD_Init_9
    220            {
    221              hpcd->State = HAL_PCD_STATE_ERROR;
   \      0x152   0x2002             MOVS     R0,#+2
   \      0x154   0xF884 0x03BD      STRB     R0,[R4, #+957]
    222              return HAL_ERROR;
   \      0x158   0x2001             MOVS     R0,#+1
   \      0x15A   0xE009             B.N      ??HAL_PCD_Init_1
    223            }
    224          
    225            hpcd->USB_Address = 0U;
   \                     ??HAL_PCD_Init_9: (+1)
   \      0x15C   0x2000             MOVS     R0,#+0
   \      0x15E   0xF884 0x0038      STRB     R0,[R4, #+56]
    226            hpcd->State = HAL_PCD_STATE_READY;
   \      0x162   0x2001             MOVS     R0,#+1
   \      0x164   0xF884 0x03BD      STRB     R0,[R4, #+957]
    227            #if defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
    228            /* Activate LPM */
    229            if (hpcd->Init.lpm_enable == 1U)
    230            {
    231              (void)HAL_PCDEx_ActivateLPM(hpcd);
    232            }
    233          #endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */
    234            (void)USB_DevDisconnect(hpcd->Instance);
   \      0x168   0x6820             LDR      R0,[R4, #+0]
   \      0x16A   0x.... 0x....      BL       USB_DevDisconnect
    235          
    236            return HAL_OK;
   \      0x16E   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_Init_1: (+1)
   \      0x170   0xB00A             ADD      SP,SP,#+40
   \      0x172   0xBD70             POP      {R4-R6,PC}
    237          }
    238          
    239          /**
    240            * @brief  DeInitializes the PCD peripheral.
    241            * @param  hpcd PCD handle
    242            * @retval HAL status
    243            */

   \                                 In section .text, align 2, keep-with-next
    244          HAL_StatusTypeDef HAL_PCD_DeInit(PCD_HandleTypeDef *hpcd)
    245          {
   \                     HAL_PCD_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    246            /* Check the PCD handle allocation */
    247            if (hpcd == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_PCD_DeInit_0
    248            {
    249              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE010             B.N      ??HAL_PCD_DeInit_1
    250            }
    251          
    252            hpcd->State = HAL_PCD_STATE_BUSY;
   \                     ??HAL_PCD_DeInit_0: (+1)
   \        0xC   0x2003             MOVS     R0,#+3
   \        0xE   0xF884 0x03BD      STRB     R0,[R4, #+957]
    253          
    254            /* Stop Device */
    255            if (USB_StopDevice(hpcd->Instance) != HAL_OK)
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x.... 0x....      BL       USB_StopDevice
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD001             BEQ.N    ??HAL_PCD_DeInit_2
    256            {
    257              return HAL_ERROR;
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE006             B.N      ??HAL_PCD_DeInit_1
    258            }
    259          
    260          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
    261            if (hpcd->MspDeInitCallback == NULL)
    262            {
    263              hpcd->MspDeInitCallback = HAL_PCD_MspDeInit; /* Legacy weak MspDeInit  */
    264            }
    265          
    266            /* DeInit the low level hardware */
    267            hpcd->MspDeInitCallback(hpcd);
    268          #else
    269            /* DeInit the low level hardware: CLOCK, NVIC.*/
    270            HAL_PCD_MspDeInit(hpcd);
   \                     ??HAL_PCD_DeInit_2: (+1)
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x.... 0x....      BL       HAL_PCD_MspDeInit
    271          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
    272          
    273            hpcd->State = HAL_PCD_STATE_RESET;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xF884 0x03BD      STRB     R0,[R4, #+957]
    274          
    275            return HAL_OK;
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_DeInit_1: (+1)
   \       0x2E   0xBD10             POP      {R4,PC}
    276          }
    277          
    278          /**
    279            * @brief  Initializes the PCD MSP.
    280            * @param  hpcd PCD handle
    281            * @retval None
    282            */

   \                                 In section .text, align 2
    283          __weak void HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd)
    284          {
    285            /* Prevent unused argument(s) compilation warning */
    286            UNUSED(hpcd);
    287          
    288            /* NOTE : This function should not be modified, when the callback is needed,
    289                      the HAL_PCD_MspInit could be implemented in the user file
    290             */
    291          }
   \                     HAL_PCD_MspInit: (+1)
   \        0x0   0x4770             BX       LR
    292          
    293          /**
    294            * @brief  DeInitializes PCD MSP.
    295            * @param  hpcd PCD handle
    296            * @retval None
    297            */

   \                                 In section .text, align 2
    298          __weak void HAL_PCD_MspDeInit(PCD_HandleTypeDef *hpcd)
    299          {
    300            /* Prevent unused argument(s) compilation warning */
    301            UNUSED(hpcd);
    302          
    303            /* NOTE : This function should not be modified, when the callback is needed,
    304                      the HAL_PCD_MspDeInit could be implemented in the user file
    305             */
    306          }
   \                     HAL_PCD_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
    307          
    308          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
    309          /**
    310            * @brief  Register a User USB PCD Callback
    311            *         To be used instead of the weak predefined callback
    312            * @param  hpcd USB PCD handle
    313            * @param  CallbackID ID of the callback to be registered
    314            *         This parameter can be one of the following values:
    315            *          @arg @ref HAL_PCD_SOF_CB_ID USB PCD SOF callback ID
    316            *          @arg @ref HAL_PCD_SETUPSTAGE_CB_ID USB PCD Setup callback ID
    317            *          @arg @ref HAL_PCD_RESET_CB_ID USB PCD Reset callback ID
    318            *          @arg @ref HAL_PCD_SUSPEND_CB_ID USB PCD Suspend callback ID
    319            *          @arg @ref HAL_PCD_RESUME_CB_ID USB PCD Resume callback ID
    320            *          @arg @ref HAL_PCD_CONNECT_CB_ID USB PCD Connect callback ID
    321            *          @arg @ref HAL_PCD_DISCONNECT_CB_ID OTG PCD Disconnect callback ID
    322            *          @arg @ref HAL_PCD_MSPINIT_CB_ID MspDeInit callback ID
    323            *          @arg @ref HAL_PCD_MSPDEINIT_CB_ID MspDeInit callback ID
    324            * @param  pCallback pointer to the Callback function
    325            * @retval HAL status
    326            */
    327          HAL_StatusTypeDef HAL_PCD_RegisterCallback(PCD_HandleTypeDef *hpcd,
    328                                                     HAL_PCD_CallbackIDTypeDef CallbackID,
    329                                                     pPCD_CallbackTypeDef pCallback)
    330          {
    331            HAL_StatusTypeDef status = HAL_OK;
    332          
    333            if (pCallback == NULL)
    334            {
    335              /* Update the error code */
    336              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    337              return HAL_ERROR;
    338            }
    339            /* Process locked */
    340            __HAL_LOCK(hpcd);
    341          
    342            if (hpcd->State == HAL_PCD_STATE_READY)
    343            {
    344              switch (CallbackID)
    345              {
    346                case HAL_PCD_SOF_CB_ID :
    347                  hpcd->SOFCallback = pCallback;
    348                  break;
    349          
    350                case HAL_PCD_SETUPSTAGE_CB_ID :
    351                  hpcd->SetupStageCallback = pCallback;
    352                  break;
    353          
    354                case HAL_PCD_RESET_CB_ID :
    355                  hpcd->ResetCallback = pCallback;
    356                  break;
    357          
    358                case HAL_PCD_SUSPEND_CB_ID :
    359                  hpcd->SuspendCallback = pCallback;
    360                  break;
    361          
    362                case HAL_PCD_RESUME_CB_ID :
    363                  hpcd->ResumeCallback = pCallback;
    364                  break;
    365          
    366                case HAL_PCD_CONNECT_CB_ID :
    367                  hpcd->ConnectCallback = pCallback;
    368                  break;
    369          
    370                case HAL_PCD_DISCONNECT_CB_ID :
    371                  hpcd->DisconnectCallback = pCallback;
    372                  break;
    373          
    374                case HAL_PCD_MSPINIT_CB_ID :
    375                  hpcd->MspInitCallback = pCallback;
    376                  break;
    377          
    378                case HAL_PCD_MSPDEINIT_CB_ID :
    379                  hpcd->MspDeInitCallback = pCallback;
    380                  break;
    381          
    382                default :
    383                  /* Update the error code */
    384                  hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    385                  /* Return error status */
    386                  status =  HAL_ERROR;
    387                  break;
    388              }
    389            }
    390            else if (hpcd->State == HAL_PCD_STATE_RESET)
    391            {
    392              switch (CallbackID)
    393              {
    394                case HAL_PCD_MSPINIT_CB_ID :
    395                  hpcd->MspInitCallback = pCallback;
    396                  break;
    397          
    398                case HAL_PCD_MSPDEINIT_CB_ID :
    399                  hpcd->MspDeInitCallback = pCallback;
    400                  break;
    401          
    402                default :
    403                  /* Update the error code */
    404                  hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    405                  /* Return error status */
    406                  status =  HAL_ERROR;
    407                  break;
    408              }
    409            }
    410            else
    411            {
    412              /* Update the error code */
    413              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    414              /* Return error status */
    415              status =  HAL_ERROR;
    416            }
    417          
    418            /* Release Lock */
    419            __HAL_UNLOCK(hpcd);
    420            return status;
    421          }
    422          
    423          /**
    424            * @brief  Unregister an USB PCD Callback
    425            *         USB PCD callabck is redirected to the weak predefined callback
    426            * @param  hpcd USB PCD handle
    427            * @param  CallbackID ID of the callback to be unregistered
    428            *         This parameter can be one of the following values:
    429            *          @arg @ref HAL_PCD_SOF_CB_ID USB PCD SOF callback ID
    430            *          @arg @ref HAL_PCD_SETUPSTAGE_CB_ID USB PCD Setup callback ID
    431            *          @arg @ref HAL_PCD_RESET_CB_ID USB PCD Reset callback ID
    432            *          @arg @ref HAL_PCD_SUSPEND_CB_ID USB PCD Suspend callback ID
    433            *          @arg @ref HAL_PCD_RESUME_CB_ID USB PCD Resume callback ID
    434            *          @arg @ref HAL_PCD_CONNECT_CB_ID USB PCD Connect callback ID
    435            *          @arg @ref HAL_PCD_DISCONNECT_CB_ID OTG PCD Disconnect callback ID
    436            *          @arg @ref HAL_PCD_MSPINIT_CB_ID MspDeInit callback ID
    437            *          @arg @ref HAL_PCD_MSPDEINIT_CB_ID MspDeInit callback ID
    438            * @retval HAL status
    439            */
    440          HAL_StatusTypeDef HAL_PCD_UnRegisterCallback(PCD_HandleTypeDef *hpcd, HAL_PCD_CallbackIDTypeDef CallbackID)
    441          {
    442            HAL_StatusTypeDef status = HAL_OK;
    443          
    444            /* Process locked */
    445            __HAL_LOCK(hpcd);
    446          
    447            /* Setup Legacy weak Callbacks  */
    448            if (hpcd->State == HAL_PCD_STATE_READY)
    449            {
    450              switch (CallbackID)
    451              {
    452                case HAL_PCD_SOF_CB_ID :
    453                  hpcd->SOFCallback = HAL_PCD_SOFCallback;
    454                  break;
    455          
    456                case HAL_PCD_SETUPSTAGE_CB_ID :
    457                  hpcd->SetupStageCallback = HAL_PCD_SetupStageCallback;
    458                  break;
    459          
    460                case HAL_PCD_RESET_CB_ID :
    461                  hpcd->ResetCallback = HAL_PCD_ResetCallback;
    462                  break;
    463          
    464                case HAL_PCD_SUSPEND_CB_ID :
    465                  hpcd->SuspendCallback = HAL_PCD_SuspendCallback;
    466                  break;
    467          
    468                case HAL_PCD_RESUME_CB_ID :
    469                  hpcd->ResumeCallback = HAL_PCD_ResumeCallback;
    470                  break;
    471          
    472                case HAL_PCD_CONNECT_CB_ID :
    473                  hpcd->ConnectCallback = HAL_PCD_ConnectCallback;
    474                  break;
    475          
    476                case HAL_PCD_DISCONNECT_CB_ID :
    477                  hpcd->DisconnectCallback = HAL_PCD_DisconnectCallback;
    478                  break;
    479          
    480                case HAL_PCD_MSPINIT_CB_ID :
    481                  hpcd->MspInitCallback = HAL_PCD_MspInit;
    482                  break;
    483          
    484                case HAL_PCD_MSPDEINIT_CB_ID :
    485                  hpcd->MspDeInitCallback = HAL_PCD_MspDeInit;
    486                  break;
    487          
    488                default :
    489                  /* Update the error code */
    490                  hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    491          
    492                  /* Return error status */
    493                  status =  HAL_ERROR;
    494                  break;
    495              }
    496            }
    497            else if (hpcd->State == HAL_PCD_STATE_RESET)
    498            {
    499              switch (CallbackID)
    500              {
    501                case HAL_PCD_MSPINIT_CB_ID :
    502                  hpcd->MspInitCallback = HAL_PCD_MspInit;
    503                  break;
    504          
    505                case HAL_PCD_MSPDEINIT_CB_ID :
    506                  hpcd->MspDeInitCallback = HAL_PCD_MspDeInit;
    507                  break;
    508          
    509                default :
    510                  /* Update the error code */
    511                  hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    512          
    513                  /* Return error status */
    514                  status =  HAL_ERROR;
    515                  break;
    516              }
    517            }
    518            else
    519            {
    520              /* Update the error code */
    521              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    522          
    523              /* Return error status */
    524              status =  HAL_ERROR;
    525            }
    526          
    527            /* Release Lock */
    528            __HAL_UNLOCK(hpcd);
    529            return status;
    530          }
    531          
    532          /**
    533            * @brief  Register USB PCD Data OUT Stage Callback
    534            *         To be used instead of the weak HAL_PCD_DataOutStageCallback() predefined callback
    535            * @param  hpcd PCD handle
    536            * @param  pCallback pointer to the USB PCD Data OUT Stage Callback function
    537            * @retval HAL status
    538            */
    539          HAL_StatusTypeDef HAL_PCD_RegisterDataOutStageCallback(PCD_HandleTypeDef *hpcd,
    540                                                                 pPCD_DataOutStageCallbackTypeDef pCallback)
    541          {
    542            HAL_StatusTypeDef status = HAL_OK;
    543          
    544            if (pCallback == NULL)
    545            {
    546              /* Update the error code */
    547              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    548          
    549              return HAL_ERROR;
    550            }
    551          
    552            /* Process locked */
    553            __HAL_LOCK(hpcd);
    554          
    555            if (hpcd->State == HAL_PCD_STATE_READY)
    556            {
    557              hpcd->DataOutStageCallback = pCallback;
    558            }
    559            else
    560            {
    561              /* Update the error code */
    562              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    563          
    564              /* Return error status */
    565              status =  HAL_ERROR;
    566            }
    567          
    568            /* Release Lock */
    569            __HAL_UNLOCK(hpcd);
    570          
    571            return status;
    572          }
    573          
    574          /**
    575            * @brief  Unregister the USB PCD Data OUT Stage Callback
    576            *         USB PCD Data OUT Stage Callback is redirected to the weak HAL_PCD_DataOutStageCallback() predefined callback
    577            * @param  hpcd PCD handle
    578            * @retval HAL status
    579            */
    580          HAL_StatusTypeDef HAL_PCD_UnRegisterDataOutStageCallback(PCD_HandleTypeDef *hpcd)
    581          {
    582            HAL_StatusTypeDef status = HAL_OK;
    583          
    584            /* Process locked */
    585            __HAL_LOCK(hpcd);
    586          
    587            if (hpcd->State == HAL_PCD_STATE_READY)
    588            {
    589              hpcd->DataOutStageCallback = HAL_PCD_DataOutStageCallback; /* Legacy weak DataOutStageCallback  */
    590            }
    591            else
    592            {
    593              /* Update the error code */
    594              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    595          
    596              /* Return error status */
    597              status =  HAL_ERROR;
    598            }
    599          
    600            /* Release Lock */
    601            __HAL_UNLOCK(hpcd);
    602          
    603            return status;
    604          }
    605          
    606          /**
    607            * @brief  Register USB PCD Data IN Stage Callback
    608            *         To be used instead of the weak HAL_PCD_DataInStageCallback() predefined callback
    609            * @param  hpcd PCD handle
    610            * @param  pCallback pointer to the USB PCD Data IN Stage Callback function
    611            * @retval HAL status
    612            */
    613          HAL_StatusTypeDef HAL_PCD_RegisterDataInStageCallback(PCD_HandleTypeDef *hpcd,
    614                                                                pPCD_DataInStageCallbackTypeDef pCallback)
    615          {
    616            HAL_StatusTypeDef status = HAL_OK;
    617          
    618            if (pCallback == NULL)
    619            {
    620              /* Update the error code */
    621              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    622          
    623              return HAL_ERROR;
    624            }
    625          
    626            /* Process locked */
    627            __HAL_LOCK(hpcd);
    628          
    629            if (hpcd->State == HAL_PCD_STATE_READY)
    630            {
    631              hpcd->DataInStageCallback = pCallback;
    632            }
    633            else
    634            {
    635              /* Update the error code */
    636              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    637          
    638              /* Return error status */
    639              status =  HAL_ERROR;
    640            }
    641          
    642            /* Release Lock */
    643            __HAL_UNLOCK(hpcd);
    644          
    645            return status;
    646          }
    647          
    648          /**
    649            * @brief  Unregister the USB PCD Data IN Stage Callback
    650            *         USB PCD Data OUT Stage Callback is redirected to the weak HAL_PCD_DataInStageCallback() predefined callback
    651            * @param  hpcd PCD handle
    652            * @retval HAL status
    653            */
    654          HAL_StatusTypeDef HAL_PCD_UnRegisterDataInStageCallback(PCD_HandleTypeDef *hpcd)
    655          {
    656            HAL_StatusTypeDef status = HAL_OK;
    657          
    658            /* Process locked */
    659            __HAL_LOCK(hpcd);
    660          
    661            if (hpcd->State == HAL_PCD_STATE_READY)
    662            {
    663              hpcd->DataInStageCallback = HAL_PCD_DataInStageCallback; /* Legacy weak DataInStageCallback  */
    664            }
    665            else
    666            {
    667              /* Update the error code */
    668              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    669          
    670              /* Return error status */
    671              status =  HAL_ERROR;
    672            }
    673          
    674            /* Release Lock */
    675            __HAL_UNLOCK(hpcd);
    676          
    677            return status;
    678          }
    679          
    680          /**
    681            * @brief  Register USB PCD Iso OUT incomplete Callback
    682            *         To be used instead of the weak HAL_PCD_ISOOUTIncompleteCallback() predefined callback
    683            * @param  hpcd PCD handle
    684            * @param  pCallback pointer to the USB PCD Iso OUT incomplete Callback function
    685            * @retval HAL status
    686            */
    687          HAL_StatusTypeDef HAL_PCD_RegisterIsoOutIncpltCallback(PCD_HandleTypeDef *hpcd,
    688                                                                 pPCD_IsoOutIncpltCallbackTypeDef pCallback)
    689          {
    690            HAL_StatusTypeDef status = HAL_OK;
    691          
    692            if (pCallback == NULL)
    693            {
    694              /* Update the error code */
    695              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    696          
    697              return HAL_ERROR;
    698            }
    699          
    700            /* Process locked */
    701            __HAL_LOCK(hpcd);
    702          
    703            if (hpcd->State == HAL_PCD_STATE_READY)
    704            {
    705              hpcd->ISOOUTIncompleteCallback = pCallback;
    706            }
    707            else
    708            {
    709              /* Update the error code */
    710              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    711          
    712              /* Return error status */
    713              status =  HAL_ERROR;
    714            }
    715          
    716            /* Release Lock */
    717            __HAL_UNLOCK(hpcd);
    718          
    719            return status;
    720          }
    721          
    722          /**
    723            * @brief  Unregister the USB PCD Iso OUT incomplete Callback
    724            *         USB PCD Iso OUT incomplete Callback is redirected to the weak HAL_PCD_ISOOUTIncompleteCallback() predefined callback
    725            * @param  hpcd PCD handle
    726            * @retval HAL status
    727            */
    728          HAL_StatusTypeDef HAL_PCD_UnRegisterIsoOutIncpltCallback(PCD_HandleTypeDef *hpcd)
    729          {
    730            HAL_StatusTypeDef status = HAL_OK;
    731          
    732            /* Process locked */
    733            __HAL_LOCK(hpcd);
    734          
    735            if (hpcd->State == HAL_PCD_STATE_READY)
    736            {
    737              hpcd->ISOOUTIncompleteCallback = HAL_PCD_ISOOUTIncompleteCallback; /* Legacy weak ISOOUTIncompleteCallback  */
    738            }
    739            else
    740            {
    741              /* Update the error code */
    742              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    743          
    744              /* Return error status */
    745              status =  HAL_ERROR;
    746            }
    747          
    748            /* Release Lock */
    749            __HAL_UNLOCK(hpcd);
    750          
    751            return status;
    752          }
    753          
    754          /**
    755            * @brief  Register USB PCD Iso IN incomplete Callback
    756            *         To be used instead of the weak HAL_PCD_ISOINIncompleteCallback() predefined callback
    757            * @param  hpcd PCD handle
    758            * @param  pCallback pointer to the USB PCD Iso IN incomplete Callback function
    759            * @retval HAL status
    760            */
    761          HAL_StatusTypeDef HAL_PCD_RegisterIsoInIncpltCallback(PCD_HandleTypeDef *hpcd,
    762                                                                pPCD_IsoInIncpltCallbackTypeDef pCallback)
    763          {
    764            HAL_StatusTypeDef status = HAL_OK;
    765          
    766            if (pCallback == NULL)
    767            {
    768              /* Update the error code */
    769              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    770          
    771              return HAL_ERROR;
    772            }
    773          
    774            /* Process locked */
    775            __HAL_LOCK(hpcd);
    776          
    777            if (hpcd->State == HAL_PCD_STATE_READY)
    778            {
    779              hpcd->ISOINIncompleteCallback = pCallback;
    780            }
    781            else
    782            {
    783              /* Update the error code */
    784              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    785          
    786              /* Return error status */
    787              status =  HAL_ERROR;
    788            }
    789          
    790            /* Release Lock */
    791            __HAL_UNLOCK(hpcd);
    792          
    793            return status;
    794          }
    795          
    796          /**
    797            * @brief  Unregister the USB PCD Iso IN incomplete Callback
    798            *         USB PCD Iso IN incomplete Callback is redirected to the weak HAL_PCD_ISOINIncompleteCallback() predefined callback
    799            * @param  hpcd PCD handle
    800            * @retval HAL status
    801            */
    802          HAL_StatusTypeDef HAL_PCD_UnRegisterIsoInIncpltCallback(PCD_HandleTypeDef *hpcd)
    803          {
    804            HAL_StatusTypeDef status = HAL_OK;
    805          
    806            /* Process locked */
    807            __HAL_LOCK(hpcd);
    808          
    809            if (hpcd->State == HAL_PCD_STATE_READY)
    810            {
    811              hpcd->ISOINIncompleteCallback = HAL_PCD_ISOINIncompleteCallback; /* Legacy weak ISOINIncompleteCallback  */
    812            }
    813            else
    814            {
    815              /* Update the error code */
    816              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    817          
    818              /* Return error status */
    819              status =  HAL_ERROR;
    820            }
    821          
    822            /* Release Lock */
    823            __HAL_UNLOCK(hpcd);
    824          
    825            return status;
    826          }
    827          
    828          /**
    829            * @brief  Register USB PCD BCD Callback
    830            *         To be used instead of the weak HAL_PCDEx_BCD_Callback() predefined callback
    831            * @param  hpcd PCD handle
    832            * @param  pCallback pointer to the USB PCD BCD Callback function
    833            * @retval HAL status
    834            */
    835          HAL_StatusTypeDef HAL_PCD_RegisterBcdCallback(PCD_HandleTypeDef *hpcd, pPCD_BcdCallbackTypeDef pCallback)
    836          {
    837            HAL_StatusTypeDef status = HAL_OK;
    838          
    839            if (pCallback == NULL)
    840            {
    841              /* Update the error code */
    842              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    843          
    844              return HAL_ERROR;
    845            }
    846          
    847            /* Process locked */
    848            __HAL_LOCK(hpcd);
    849          
    850            if (hpcd->State == HAL_PCD_STATE_READY)
    851            {
    852              hpcd->BCDCallback = pCallback;
    853            }
    854            else
    855            {
    856              /* Update the error code */
    857              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    858          
    859              /* Return error status */
    860              status =  HAL_ERROR;
    861            }
    862          
    863            /* Release Lock */
    864            __HAL_UNLOCK(hpcd);
    865          
    866            return status;
    867          }
    868          
    869          /**
    870            * @brief  Unregister the USB PCD BCD Callback
    871            *         USB BCD Callback is redirected to the weak HAL_PCDEx_BCD_Callback() predefined callback
    872            * @param  hpcd PCD handle
    873            * @retval HAL status
    874            */
    875          HAL_StatusTypeDef HAL_PCD_UnRegisterBcdCallback(PCD_HandleTypeDef *hpcd)
    876          {
    877            HAL_StatusTypeDef status = HAL_OK;
    878          
    879            /* Process locked */
    880            __HAL_LOCK(hpcd);
    881          
    882            if (hpcd->State == HAL_PCD_STATE_READY)
    883            {
    884              hpcd->BCDCallback = HAL_PCDEx_BCD_Callback; /* Legacy weak HAL_PCDEx_BCD_Callback  */
    885            }
    886            else
    887            {
    888              /* Update the error code */
    889              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    890          
    891              /* Return error status */
    892              status =  HAL_ERROR;
    893            }
    894          
    895            /* Release Lock */
    896            __HAL_UNLOCK(hpcd);
    897          
    898            return status;
    899          }
    900          
    901          /**
    902            * @brief  Register USB PCD LPM Callback
    903            *         To be used instead of the weak HAL_PCDEx_LPM_Callback() predefined callback
    904            * @param  hpcd PCD handle
    905            * @param  pCallback pointer to the USB PCD LPM Callback function
    906            * @retval HAL status
    907            */
    908          HAL_StatusTypeDef HAL_PCD_RegisterLpmCallback(PCD_HandleTypeDef *hpcd, pPCD_LpmCallbackTypeDef pCallback)
    909          {
    910            HAL_StatusTypeDef status = HAL_OK;
    911          
    912            if (pCallback == NULL)
    913            {
    914              /* Update the error code */
    915              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    916          
    917              return HAL_ERROR;
    918            }
    919          
    920            /* Process locked */
    921            __HAL_LOCK(hpcd);
    922          
    923            if (hpcd->State == HAL_PCD_STATE_READY)
    924            {
    925              hpcd->LPMCallback = pCallback;
    926            }
    927            else
    928            {
    929              /* Update the error code */
    930              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    931          
    932              /* Return error status */
    933              status =  HAL_ERROR;
    934            }
    935          
    936            /* Release Lock */
    937            __HAL_UNLOCK(hpcd);
    938          
    939            return status;
    940          }
    941          
    942          /**
    943            * @brief  Unregister the USB PCD LPM Callback
    944            *         USB LPM Callback is redirected to the weak HAL_PCDEx_LPM_Callback() predefined callback
    945            * @param  hpcd PCD handle
    946            * @retval HAL status
    947            */
    948          HAL_StatusTypeDef HAL_PCD_UnRegisterLpmCallback(PCD_HandleTypeDef *hpcd)
    949          {
    950            HAL_StatusTypeDef status = HAL_OK;
    951          
    952            /* Process locked */
    953            __HAL_LOCK(hpcd);
    954          
    955            if (hpcd->State == HAL_PCD_STATE_READY)
    956            {
    957              hpcd->LPMCallback = HAL_PCDEx_LPM_Callback; /* Legacy weak HAL_PCDEx_LPM_Callback  */
    958            }
    959            else
    960            {
    961              /* Update the error code */
    962              hpcd->ErrorCode |= HAL_PCD_ERROR_INVALID_CALLBACK;
    963          
    964              /* Return error status */
    965              status =  HAL_ERROR;
    966            }
    967          
    968            /* Release Lock */
    969            __HAL_UNLOCK(hpcd);
    970          
    971            return status;
    972          }
    973          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
    974          
    975          /**
    976            * @}
    977            */
    978          
    979          /** @defgroup PCD_Exported_Functions_Group2 Input and Output operation functions
    980            *  @brief   Data transfers functions
    981            *
    982          @verbatim
    983           ===============================================================================
    984                                ##### IO operation functions #####
    985           ===============================================================================
    986              [..]
    987              This subsection provides a set of functions allowing to manage the PCD data
    988              transfers.
    989          
    990          @endverbatim
    991            * @{
    992            */
    993          
    994          /**
    995            * @brief  Start the USB device
    996            * @param  hpcd PCD handle
    997            * @retval HAL status
    998            */

   \                                 In section .text, align 2, keep-with-next
    999          HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
   1000          {
   \                     HAL_PCD_Start: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1001            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   \        0x4   0x6825             LDR      R5,[R4, #+0]
   1002          
   1003            __HAL_LOCK(hpcd);
   \        0x6   0xF894 0x03BC      LDRB     R0,[R4, #+956]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE.N    ??HAL_PCD_Start_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE016             B.N      ??HAL_PCD_Start_1
   \                     ??HAL_PCD_Start_0: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1004          
   1005            if ((hpcd->Init.battery_charging_enable == 1U) &&
   1006                (hpcd->Init.phy_itface != USB_OTG_ULPI_PHY))
   \       0x18   0x6AA0             LDR      R0,[R4, #+40]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD106             BNE.N    ??HAL_PCD_Start_2
   \       0x1E   0x69A0             LDR      R0,[R4, #+24]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD003             BEQ.N    ??HAL_PCD_Start_2
   1007            {
   1008              /* Enable USB Transceiver */
   1009              USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
   \       0x24   0x6BA8             LDR      R0,[R5, #+56]
   \       0x26   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \       0x2A   0x63A8             STR      R0,[R5, #+56]
   1010            }
   1011          
   1012            __HAL_PCD_ENABLE(hpcd);
   \                     ??HAL_PCD_Start_2: (+1)
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x.... 0x....      BL       USB_EnableGlobalInt
   1013            (void)USB_DevConnect(hpcd->Instance);
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x.... 0x....      BL       USB_DevConnect
   1014            __HAL_UNLOCK(hpcd);
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1015          
   1016            return HAL_OK;
   \       0x3E   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_Start_1: (+1)
   \       0x40   0xBD32             POP      {R1,R4,R5,PC}
   1017          }
   1018          
   1019          /**
   1020            * @brief  Stop the USB device.
   1021            * @param  hpcd PCD handle
   1022            * @retval HAL status
   1023            */

   \                                 In section .text, align 2, keep-with-next
   1024          HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd)
   1025          {
   \                     HAL_PCD_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1026            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   \        0x4   0x6825             LDR      R5,[R4, #+0]
   1027          
   1028            __HAL_LOCK(hpcd);
   \        0x6   0xF894 0x03BC      LDRB     R0,[R4, #+956]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE.N    ??HAL_PCD_Stop_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE01A             B.N      ??HAL_PCD_Stop_1
   \                     ??HAL_PCD_Stop_0: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1029            __HAL_PCD_DISABLE(hpcd);
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x.... 0x....      BL       USB_DisableGlobalInt
   1030            (void)USB_DevDisconnect(hpcd->Instance);
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x.... 0x....      BL       USB_DevDisconnect
   1031          
   1032            (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
   \       0x24   0x2110             MOVS     R1,#+16
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x.... 0x....      BL       USB_FlushTxFifo
   1033          
   1034            if ((hpcd->Init.battery_charging_enable == 1U) &&
   1035                (hpcd->Init.phy_itface != USB_OTG_ULPI_PHY))
   \       0x2C   0x6AA0             LDR      R0,[R4, #+40]
   \       0x2E   0x2801             CMP      R0,#+1
   \       0x30   0xD106             BNE.N    ??HAL_PCD_Stop_2
   \       0x32   0x69A0             LDR      R0,[R4, #+24]
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xD003             BEQ.N    ??HAL_PCD_Stop_2
   1036            {
   1037              /* Disable USB Transceiver */
   1038              USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   \       0x38   0x6BA8             LDR      R0,[R5, #+56]
   \       0x3A   0xF430 0x3080      BICS     R0,R0,#0x10000
   \       0x3E   0x63A8             STR      R0,[R5, #+56]
   1039            }
   1040            __HAL_UNLOCK(hpcd);
   \                     ??HAL_PCD_Stop_2: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1041          
   1042            return HAL_OK;
   \       0x46   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_Stop_1: (+1)
   \       0x48   0xBD32             POP      {R1,R4,R5,PC}
   1043          }
   1044          
   1045          #if defined (USB_OTG_FS) || defined (USB_OTG_HS)
   1046          /**
   1047            * @brief  Handles PCD interrupt request.
   1048            * @param  hpcd PCD handle
   1049            * @retval HAL status
   1050            */

   \                                 In section .text, align 2, keep-with-next
   1051          void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
   1052          {
   \                     HAL_PCD_IRQHandler: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4681             MOV      R9,R0
   1053            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   \        0x6   0xF8D9 0xA000      LDR      R10,[R9, #+0]
   1054            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0xA   0x46D3             MOV      R11,R10
   1055            uint32_t i, ep_intr, epint, epnum;
   1056            uint32_t fifoemptymsk, temp;
   1057            USB_OTG_EPTypeDef *ep;
   1058          
   1059            /* ensure that we are in device mode */
   1060            if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
   \        0xC   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x10   0x.... 0x....      BL       USB_GetMode
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xF040 0x8297      BNE.W    ??HAL_PCD_IRQHandler_0
   1061            {
   1062              /* avoid spurious interrupt */
   1063              if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
   \       0x1A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x1E   0x.... 0x....      BL       USB_ReadInterrupts
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xF000 0x8290      BEQ.W    ??HAL_PCD_IRQHandler_1
   1064              {
   1065                return;
   1066              }
   1067          
   1068              if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
   \                     ??HAL_PCD_IRQHandler_2: (+1)
   \       0x28   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x2C   0x.... 0x....      BL       USB_ReadInterrupts
   \       0x30   0x0780             LSLS     R0,R0,#+30
   \       0x32   0xD507             BPL.N    ??HAL_PCD_IRQHandler_3
   1069              {
   1070                /* incorrect mode, acknowledge the interrupt */
   1071                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
   \       0x34   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x38   0x6940             LDR      R0,[R0, #+20]
   \       0x3A   0xF010 0x0002      ANDS     R0,R0,#0x2
   \       0x3E   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \       0x42   0x6148             STR      R0,[R1, #+20]
   1072              }
   1073          
   1074              /* Handle RxQLevel Interrupt */
   1075              if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
   \                     ??HAL_PCD_IRQHandler_3: (+1)
   \       0x44   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x48   0x.... 0x....      BL       USB_ReadInterrupts
   \       0x4C   0x06C0             LSLS     R0,R0,#+27
   \       0x4E   0xD54D             BPL.N    ??HAL_PCD_IRQHandler_4
   1076              {
   1077                USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
   \       0x50   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0x54   0x6980             LDR      R0,[R0, #+24]
   \       0x56   0xF030 0x0010      BICS     R0,R0,#0x10
   \       0x5A   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \       0x5E   0x6188             STR      R0,[R1, #+24]
   1078          
   1079                temp = USBx->GRXSTSP;
   \       0x60   0xF8DA 0x0020      LDR      R0,[R10, #+32]
   \       0x64   0x4680             MOV      R8,R0
   1080          
   1081                ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
   \       0x66   0xF018 0x010F      ANDS     R1,R8,#0xF
   \       0x6A   0x201C             MOVS     R0,#+28
   \       0x6C   0x4341             MULS     R1,R0,R1
   \       0x6E   0xEB09 0x0001      ADD      R0,R9,R1
   \       0x72   0xF510 0x70FE      ADDS     R0,R0,#+508
   \       0x76   0x9000             STR      R0,[SP, #+0]
   1082          
   1083                if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
   \       0x78   0xF3C8 0x4043      UBFX     R0,R8,#+17,#+4
   \       0x7C   0x2802             CMP      R0,#+2
   \       0x7E   0xD11C             BNE.N    ??HAL_PCD_IRQHandler_5
   1084                {
   1085                  if ((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
   \       0x80   0xF647 0x70F0      MOVW     R0,#+32752
   \       0x84   0xEA18 0x0F00      TST      R8,R0
   \       0x88   0xD028             BEQ.N    ??HAL_PCD_IRQHandler_6
   1086                  {
   1087                    (void)USB_ReadPacket(USBx, ep->xfer_buff,
   1088                                         (uint16_t)((temp & USB_OTG_GRXSTSP_BCNT) >> 4));
   \       0x8A   0x4640             MOV      R0,R8
   \       0x8C   0xF3C0 0x120A      UBFX     R2,R0,#+4,#+11
   \       0x90   0xB292             UXTH     R2,R2
   \       0x92   0x9800             LDR      R0,[SP, #+0]
   \       0x94   0x68C1             LDR      R1,[R0, #+12]
   \       0x96   0x4650             MOV      R0,R10
   \       0x98   0x.... 0x....      BL       USB_ReadPacket
   1089          
   1090                    ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
   \       0x9C   0x9800             LDR      R0,[SP, #+0]
   \       0x9E   0x68C0             LDR      R0,[R0, #+12]
   \       0xA0   0xF3C8 0x110A      UBFX     R1,R8,#+4,#+11
   \       0xA4   0x4408             ADD      R0,R0,R1
   \       0xA6   0x9900             LDR      R1,[SP, #+0]
   \       0xA8   0x60C8             STR      R0,[R1, #+12]
   1091                    ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
   \       0xAA   0x9800             LDR      R0,[SP, #+0]
   \       0xAC   0x6981             LDR      R1,[R0, #+24]
   \       0xAE   0xF3C8 0x100A      UBFX     R0,R8,#+4,#+11
   \       0xB2   0x1841             ADDS     R1,R0,R1
   \       0xB4   0x9800             LDR      R0,[SP, #+0]
   \       0xB6   0x6181             STR      R1,[R0, #+24]
   \       0xB8   0xE010             B.N      ??HAL_PCD_IRQHandler_6
   1092                  }
   1093                }
   1094                else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)
   \                     ??HAL_PCD_IRQHandler_5: (+1)
   \       0xBA   0xF3C8 0x4043      UBFX     R0,R8,#+17,#+4
   \       0xBE   0x2806             CMP      R0,#+6
   \       0xC0   0xD10C             BNE.N    ??HAL_PCD_IRQHandler_6
   1095                {
   1096                  (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
   \       0xC2   0x2208             MOVS     R2,#+8
   \       0xC4   0xF519 0x7171      ADDS     R1,R9,#+964
   \       0xC8   0x4650             MOV      R0,R10
   \       0xCA   0x.... 0x....      BL       USB_ReadPacket
   1097                  ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
   \       0xCE   0x9800             LDR      R0,[SP, #+0]
   \       0xD0   0x6981             LDR      R1,[R0, #+24]
   \       0xD2   0xF3C8 0x100A      UBFX     R0,R8,#+4,#+11
   \       0xD6   0x1841             ADDS     R1,R0,R1
   \       0xD8   0x9800             LDR      R0,[SP, #+0]
   \       0xDA   0x6181             STR      R1,[R0, #+24]
   1098                }
   1099                else
   1100                {
   1101                  /* ... */
   1102                }
   1103                USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
   \                     ??HAL_PCD_IRQHandler_6: (+1)
   \       0xDC   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xE0   0x6980             LDR      R0,[R0, #+24]
   \       0xE2   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xE6   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \       0xEA   0x6188             STR      R0,[R1, #+24]
   1104              }
   1105          
   1106              if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
   \                     ??HAL_PCD_IRQHandler_4: (+1)
   \       0xEC   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \       0xF0   0x.... 0x....      BL       USB_ReadInterrupts
   \       0xF4   0x0300             LSLS     R0,R0,#+12
   \       0xF6   0xD545             BPL.N    ??HAL_PCD_IRQHandler_7
   1107              {
   1108                epnum = 0U;
   \       0xF8   0x2000             MOVS     R0,#+0
   \       0xFA   0x0005             MOVS     R5,R0
   1109          
   1110                /* Read in the device interrupt bits */
   1111                ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
   \       0xFC   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x100   0x.... 0x....      BL       USB_ReadDevAllOutEpInterrupt
   \      0x104   0x0004             MOVS     R4,R0
   1112          
   1113                while (ep_intr != 0U)
   \                     ??HAL_PCD_IRQHandler_8: (+1)
   \      0x106   0x2C00             CMP      R4,#+0
   \      0x108   0xD03C             BEQ.N    ??HAL_PCD_IRQHandler_7
   1114                {
   1115                  if ((ep_intr & 0x1U) != 0U)
   \      0x10A   0x07E0             LSLS     R0,R4,#+31
   \      0x10C   0xD537             BPL.N    ??HAL_PCD_IRQHandler_9
   1116                  {
   1117                    epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
   \      0x10E   0x0029             MOVS     R1,R5
   \      0x110   0xB2C9             UXTB     R1,R1
   \      0x112   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x116   0x.... 0x....      BL       USB_ReadDevOutEPInterrupt
   \      0x11A   0x0007             MOVS     R7,R0
   1118          
   1119                    if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
   \      0x11C   0x07F8             LSLS     R0,R7,#+31
   \      0x11E   0xD509             BPL.N    ??HAL_PCD_IRQHandler_10
   1120                    {
   1121                      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
   \      0x120   0xEB1B 0x1045      ADDS     R0,R11,R5, LSL #+5
   \      0x124   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x128   0x2101             MOVS     R1,#+1
   \      0x12A   0x6081             STR      R1,[R0, #+8]
   1122                      (void)PCD_EP_OutXfrComplete_int(hpcd, epnum);
   \      0x12C   0x0029             MOVS     R1,R5
   \      0x12E   0x4648             MOV      R0,R9
   \      0x130   0x.... 0x....      BL       PCD_EP_OutXfrComplete_int
   1123                    }
   1124          
   1125                    if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
   \                     ??HAL_PCD_IRQHandler_10: (+1)
   \      0x134   0x0738             LSLS     R0,R7,#+28
   \      0x136   0xD509             BPL.N    ??HAL_PCD_IRQHandler_11
   1126                    {
   1127                      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
   \      0x138   0xEB1B 0x1045      ADDS     R0,R11,R5, LSL #+5
   \      0x13C   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x140   0x2108             MOVS     R1,#+8
   \      0x142   0x6081             STR      R1,[R0, #+8]
   1128                      /* Class B setup phase done for previous decoded setup */
   1129                      (void)PCD_EP_OutSetupPacket_int(hpcd, epnum);
   \      0x144   0x0029             MOVS     R1,R5
   \      0x146   0x4648             MOV      R0,R9
   \      0x148   0x.... 0x....      BL       PCD_EP_OutSetupPacket_int
   1130                    }
   1131          
   1132                    if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
   \                     ??HAL_PCD_IRQHandler_11: (+1)
   \      0x14C   0x06F8             LSLS     R0,R7,#+27
   \      0x14E   0xD505             BPL.N    ??HAL_PCD_IRQHandler_12
   1133                    {
   1134                      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
   \      0x150   0xEB1B 0x1045      ADDS     R0,R11,R5, LSL #+5
   \      0x154   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x158   0x2110             MOVS     R1,#+16
   \      0x15A   0x6081             STR      R1,[R0, #+8]
   1135                    }
   1136          
   1137                    /* Clear Status Phase Received interrupt */
   1138                    if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
   \                     ??HAL_PCD_IRQHandler_12: (+1)
   \      0x15C   0x06B8             LSLS     R0,R7,#+26
   \      0x15E   0xD505             BPL.N    ??HAL_PCD_IRQHandler_13
   1139                    {
   1140                      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
   \      0x160   0xEB1B 0x1045      ADDS     R0,R11,R5, LSL #+5
   \      0x164   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x168   0x2120             MOVS     R1,#+32
   \      0x16A   0x6081             STR      R1,[R0, #+8]
   1141                    }
   1142          
   1143                    /* Clear OUT NAK interrupt */
   1144                    if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
   \                     ??HAL_PCD_IRQHandler_13: (+1)
   \      0x16C   0x04B8             LSLS     R0,R7,#+18
   \      0x16E   0xD506             BPL.N    ??HAL_PCD_IRQHandler_9
   1145                    {
   1146                      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
   \      0x170   0xEB1B 0x1045      ADDS     R0,R11,R5, LSL #+5
   \      0x174   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x178   0xF44F 0x5100      MOV      R1,#+8192
   \      0x17C   0x6081             STR      R1,[R0, #+8]
   1147                    }
   1148                  }
   1149                  epnum++;
   \                     ??HAL_PCD_IRQHandler_9: (+1)
   \      0x17E   0x1C6D             ADDS     R5,R5,#+1
   1150                  ep_intr >>= 1U;
   \      0x180   0x0864             LSRS     R4,R4,#+1
   \      0x182   0xE7C0             B.N      ??HAL_PCD_IRQHandler_8
   1151                }
   1152              }
   1153          
   1154              if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
   \                     ??HAL_PCD_IRQHandler_7: (+1)
   \      0x184   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x188   0x.... 0x....      BL       USB_ReadInterrupts
   \      0x18C   0x0340             LSLS     R0,R0,#+13
   \      0x18E   0xD575             BPL.N    ??HAL_PCD_IRQHandler_14
   1155              {
   1156                /* Read in the device interrupt bits */
   1157                ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
   \      0x190   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x194   0x.... 0x....      BL       USB_ReadDevAllInEpInterrupt
   \      0x198   0x0004             MOVS     R4,R0
   1158          
   1159                epnum = 0U;
   \      0x19A   0x2000             MOVS     R0,#+0
   \      0x19C   0x0005             MOVS     R5,R0
   1160          
   1161                while (ep_intr != 0U)
   \                     ??HAL_PCD_IRQHandler_15: (+1)
   \      0x19E   0x2C00             CMP      R4,#+0
   \      0x1A0   0xD06C             BEQ.N    ??HAL_PCD_IRQHandler_14
   1162                {
   1163                  if ((ep_intr & 0x1U) != 0U) /* In ITR */
   \      0x1A2   0x07E0             LSLS     R0,R4,#+31
   \      0x1A4   0xD567             BPL.N    ??HAL_PCD_IRQHandler_16
   1164                  {
   1165                    epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
   \      0x1A6   0x0029             MOVS     R1,R5
   \      0x1A8   0xB2C9             UXTB     R1,R1
   \      0x1AA   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x1AE   0x.... 0x....      BL       USB_ReadDevInEPInterrupt
   \      0x1B2   0x0007             MOVS     R7,R0
   1166          
   1167                    if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
   \      0x1B4   0x07F8             LSLS     R0,R7,#+31
   \      0x1B6   0xD538             BPL.N    ??HAL_PCD_IRQHandler_17
   1168                    {
   1169                      fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
   \      0x1B8   0x2101             MOVS     R1,#+1
   \      0x1BA   0xF015 0x000F      ANDS     R0,R5,#0xF
   \      0x1BE   0x4081             LSLS     R1,R1,R0
   \      0x1C0   0x9101             STR      R1,[SP, #+4]
   1170                      USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
   \      0x1C2   0xF51B 0x6000      ADDS     R0,R11,#+2048
   \      0x1C6   0x6B41             LDR      R1,[R0, #+52]
   \      0x1C8   0x9801             LDR      R0,[SP, #+4]
   \      0x1CA   0x4381             BICS     R1,R1,R0
   \      0x1CC   0xF51B 0x6000      ADDS     R0,R11,#+2048
   \      0x1D0   0x6341             STR      R1,[R0, #+52]
   1171          
   1172                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
   \      0x1D2   0xEB1B 0x1045      ADDS     R0,R11,R5, LSL #+5
   \      0x1D6   0xF510 0x6010      ADDS     R0,R0,#+2304
   \      0x1DA   0x2101             MOVS     R1,#+1
   \      0x1DC   0x6081             STR      R1,[R0, #+8]
   1173          
   1174                      if (hpcd->Init.dma_enable == 1U)
   \      0x1DE   0xF8D9 0x0010      LDR      R0,[R9, #+16]
   \      0x1E2   0x2801             CMP      R0,#+1
   \      0x1E4   0xD11C             BNE.N    ??HAL_PCD_IRQHandler_18
   1175                      {
   1176                        hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
   \      0x1E6   0x201C             MOVS     R0,#+28
   \      0x1E8   0xFB00 0xF105      MUL      R1,R0,R5
   \      0x1EC   0x4449             ADD      R1,R9,R1
   \      0x1EE   0x6C89             LDR      R1,[R1, #+72]
   \      0x1F0   0xFB00 0xF205      MUL      R2,R0,R5
   \      0x1F4   0x444A             ADD      R2,R9,R2
   \      0x1F6   0x6C52             LDR      R2,[R2, #+68]
   \      0x1F8   0x4411             ADD      R1,R1,R2
   \      0x1FA   0xFB00 0xF205      MUL      R2,R0,R5
   \      0x1FE   0x444A             ADD      R2,R9,R2
   \      0x200   0x6491             STR      R1,[R2, #+72]
   1177          
   1178                        /* this is ZLP, so prepare EP0 for next setup */
   1179                        if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
   \      0x202   0x2D00             CMP      R5,#+0
   \      0x204   0xD10C             BNE.N    ??HAL_PCD_IRQHandler_18
   \      0x206   0xFB00 0xF005      MUL      R0,R0,R5
   \      0x20A   0x4448             ADD      R0,R9,R0
   \      0x20C   0x6D00             LDR      R0,[R0, #+80]
   \      0x20E   0x2800             CMP      R0,#+0
   \      0x210   0xD106             BNE.N    ??HAL_PCD_IRQHandler_18
   1180                        {
   1181                          /* prepare to rx more setup packets */
   1182                          (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
   \      0x212   0xF519 0x7271      ADDS     R2,R9,#+964
   \      0x216   0x2101             MOVS     R1,#+1
   \      0x218   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x21C   0x.... 0x....      BL       USB_EP0_OutStart
   1183                        }
   1184                      }
   1185          
   1186          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
   1187                      hpcd->DataInStageCallback(hpcd, (uint8_t)epnum);
   1188          #else
   1189                      HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
   \                     ??HAL_PCD_IRQHandler_18: (+1)
   \      0x220   0x0029             MOVS     R1,R5
   \      0x222   0xB2C9             UXTB     R1,R1
   \      0x224   0x4648             MOV      R0,R9
   \      0x226   0x.... 0x....      BL       HAL_PCD_DataInStageCallback
   1190          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
   1191                    }
   1192                    if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
   \                     ??HAL_PCD_IRQHandler_17: (+1)
   \      0x22A   0x0738             LSLS     R0,R7,#+28
   \      0x22C   0xD505             BPL.N    ??HAL_PCD_IRQHandler_19
   1193                    {
   1194                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
   \      0x22E   0xEB1B 0x1045      ADDS     R0,R11,R5, LSL #+5
   \      0x232   0xF510 0x6010      ADDS     R0,R0,#+2304
   \      0x236   0x2108             MOVS     R1,#+8
   \      0x238   0x6081             STR      R1,[R0, #+8]
   1195                    }
   1196                    if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
   \                     ??HAL_PCD_IRQHandler_19: (+1)
   \      0x23A   0x06F8             LSLS     R0,R7,#+27
   \      0x23C   0xD505             BPL.N    ??HAL_PCD_IRQHandler_20
   1197                    {
   1198                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
   \      0x23E   0xEB1B 0x1045      ADDS     R0,R11,R5, LSL #+5
   \      0x242   0xF510 0x6010      ADDS     R0,R0,#+2304
   \      0x246   0x2110             MOVS     R1,#+16
   \      0x248   0x6081             STR      R1,[R0, #+8]
   1199                    }
   1200                    if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
   \                     ??HAL_PCD_IRQHandler_20: (+1)
   \      0x24A   0x0678             LSLS     R0,R7,#+25
   \      0x24C   0xD505             BPL.N    ??HAL_PCD_IRQHandler_21
   1201                    {
   1202                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
   \      0x24E   0xEB1B 0x1045      ADDS     R0,R11,R5, LSL #+5
   \      0x252   0xF510 0x6010      ADDS     R0,R0,#+2304
   \      0x256   0x2140             MOVS     R1,#+64
   \      0x258   0x6081             STR      R1,[R0, #+8]
   1203                    }
   1204                    if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
   \                     ??HAL_PCD_IRQHandler_21: (+1)
   \      0x25A   0x07B8             LSLS     R0,R7,#+30
   \      0x25C   0xD505             BPL.N    ??HAL_PCD_IRQHandler_22
   1205                    {
   1206                      CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
   \      0x25E   0xEB1B 0x1045      ADDS     R0,R11,R5, LSL #+5
   \      0x262   0xF510 0x6010      ADDS     R0,R0,#+2304
   \      0x266   0x2102             MOVS     R1,#+2
   \      0x268   0x6081             STR      R1,[R0, #+8]
   1207                    }
   1208                    if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
   \                     ??HAL_PCD_IRQHandler_22: (+1)
   \      0x26A   0x0638             LSLS     R0,R7,#+24
   \      0x26C   0xD503             BPL.N    ??HAL_PCD_IRQHandler_16
   1209                    {
   1210                      (void)PCD_WriteEmptyTxFifo(hpcd, epnum);
   \      0x26E   0x0029             MOVS     R1,R5
   \      0x270   0x4648             MOV      R0,R9
   \      0x272   0x.... 0x....      BL       PCD_WriteEmptyTxFifo
   1211                    }
   1212                  }
   1213                  epnum++;
   \                     ??HAL_PCD_IRQHandler_16: (+1)
   \      0x276   0x1C6D             ADDS     R5,R5,#+1
   1214                  ep_intr >>= 1U;
   \      0x278   0x0864             LSRS     R4,R4,#+1
   \      0x27A   0xE790             B.N      ??HAL_PCD_IRQHandler_15
   1215                }
   1216              }
   1217          
   1218              /* Handle Resume Interrupt */
   1219              if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
   \                     ??HAL_PCD_IRQHandler_14: (+1)
   \      0x27C   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x280   0x.... 0x....      BL       USB_ReadInterrupts
   \      0x284   0x2800             CMP      R0,#+0
   \      0x286   0xD51E             BPL.N    ??HAL_PCD_IRQHandler_23
   1220              {
   1221                /* Clear the Remote Wake-up Signaling */
   1222                USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
   \      0x288   0xF51B 0x6000      ADDS     R0,R11,#+2048
   \      0x28C   0x6840             LDR      R0,[R0, #+4]
   \      0x28E   0x0840             LSRS     R0,R0,#+1
   \      0x290   0x0040             LSLS     R0,R0,#+1
   \      0x292   0xF51B 0x6100      ADDS     R1,R11,#+2048
   \      0x296   0x6048             STR      R0,[R1, #+4]
   1223          
   1224                if (hpcd->LPM_State == LPM_L1)
   \      0x298   0xF899 0x03F4      LDRB     R0,[R9, #+1012]
   \      0x29C   0x2801             CMP      R0,#+1
   \      0x29E   0xD107             BNE.N    ??HAL_PCD_IRQHandler_24
   1225                {
   1226                  hpcd->LPM_State = LPM_L0;
   \      0x2A0   0x2000             MOVS     R0,#+0
   \      0x2A2   0xF889 0x03F4      STRB     R0,[R9, #+1012]
   1227          
   1228          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
   1229                  hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);
   1230          #else
   1231                  HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
   \      0x2A6   0x2100             MOVS     R1,#+0
   \      0x2A8   0x4648             MOV      R0,R9
   \      0x2AA   0x.... 0x....      BL       HAL_PCDEx_LPM_Callback
   \      0x2AE   0xE002             B.N      ??HAL_PCD_IRQHandler_25
   1232          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
   1233                }
   1234                else
   1235                {
   1236          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
   1237                  hpcd->ResumeCallback(hpcd);
   1238          #else
   1239                  HAL_PCD_ResumeCallback(hpcd);
   \                     ??HAL_PCD_IRQHandler_24: (+1)
   \      0x2B0   0x4648             MOV      R0,R9
   \      0x2B2   0x.... 0x....      BL       HAL_PCD_ResumeCallback
   1240          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
   1241                }
   1242          
   1243                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
   \                     ??HAL_PCD_IRQHandler_25: (+1)
   \      0x2B6   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x2BA   0x6940             LDR      R0,[R0, #+20]
   \      0x2BC   0xF010 0x4000      ANDS     R0,R0,#0x80000000
   \      0x2C0   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \      0x2C4   0x6148             STR      R0,[R1, #+20]
   1244              }
   1245          
   1246              /* Handle Suspend Interrupt */
   1247              if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
   \                     ??HAL_PCD_IRQHandler_23: (+1)
   \      0x2C6   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x2CA   0x.... 0x....      BL       USB_ReadInterrupts
   \      0x2CE   0x0500             LSLS     R0,R0,#+20
   \      0x2D0   0xD50F             BPL.N    ??HAL_PCD_IRQHandler_26
   1248              {
   1249                if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
   \      0x2D2   0xF51B 0x6000      ADDS     R0,R11,#+2048
   \      0x2D6   0x6880             LDR      R0,[R0, #+8]
   \      0x2D8   0x07C0             LSLS     R0,R0,#+31
   \      0x2DA   0xD502             BPL.N    ??HAL_PCD_IRQHandler_27
   1250                {
   1251          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
   1252                  hpcd->SuspendCallback(hpcd);
   1253          #else
   1254                  HAL_PCD_SuspendCallback(hpcd);
   \      0x2DC   0x4648             MOV      R0,R9
   \      0x2DE   0x.... 0x....      BL       HAL_PCD_SuspendCallback
   1255          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
   1256                }
   1257                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
   \                     ??HAL_PCD_IRQHandler_27: (+1)
   \      0x2E2   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x2E6   0x6940             LDR      R0,[R0, #+20]
   \      0x2E8   0xF410 0x6000      ANDS     R0,R0,#0x800
   \      0x2EC   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \      0x2F0   0x6148             STR      R0,[R1, #+20]
   1258              }
   1259          #if defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx)
   1260              /* Handle LPM Interrupt */
   1261              if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT))
   1262              {
   1263                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_LPMINT);
   1264          
   1265                if (hpcd->LPM_State == LPM_L0)
   1266                {
   1267                  hpcd->LPM_State = LPM_L1;
   1268                  hpcd->BESL = (hpcd->Instance->GLPMCFG & USB_OTG_GLPMCFG_BESL) >> 2U;
   1269          
   1270          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
   1271                  hpcd->LPMCallback(hpcd, PCD_LPM_L1_ACTIVE);
   1272          #else
   1273                  HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L1_ACTIVE);
   1274          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
   1275                }
   1276                else
   1277                {
   1278          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
   1279                  hpcd->SuspendCallback(hpcd);
   1280          #else
   1281                  HAL_PCD_SuspendCallback(hpcd);
   1282          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
   1283                }
   1284              }
   1285          #endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */
   1286              /* Handle Reset Interrupt */
   1287              if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
   \                     ??HAL_PCD_IRQHandler_26: (+1)
   \      0x2F2   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x2F6   0x.... 0x....      BL       USB_ReadInterrupts
   \      0x2FA   0x04C0             LSLS     R0,R0,#+19
   \      0x2FC   0xF140 0x809B      BPL.W    ??HAL_PCD_IRQHandler_28
   1288              {
   1289                USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
   \      0x300   0xF51B 0x6000      ADDS     R0,R11,#+2048
   \      0x304   0x6840             LDR      R0,[R0, #+4]
   \      0x306   0x0840             LSRS     R0,R0,#+1
   \      0x308   0x0040             LSLS     R0,R0,#+1
   \      0x30A   0xF51B 0x6100      ADDS     R1,R11,#+2048
   \      0x30E   0x6048             STR      R0,[R1, #+4]
   1290                (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
   \      0x310   0x2110             MOVS     R1,#+16
   \      0x312   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x316   0x.... 0x....      BL       USB_FlushTxFifo
   1291          
   1292                for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
   \      0x31A   0x2000             MOVS     R0,#+0
   \      0x31C   0x0006             MOVS     R6,R0
   \                     ??HAL_PCD_IRQHandler_29: (+1)
   \      0x31E   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \      0x322   0x4286             CMP      R6,R0
   \      0x324   0xD23D             BCS.N    ??HAL_PCD_IRQHandler_30
   1293                {
   1294                  USBx_INEP(i)->DIEPINT = 0xFB7FU;
   \      0x326   0xF64F 0x307F      MOVW     R0,#+64383
   \      0x32A   0xEB1B 0x1146      ADDS     R1,R11,R6, LSL #+5
   \      0x32E   0xF511 0x6110      ADDS     R1,R1,#+2304
   \      0x332   0x6088             STR      R0,[R1, #+8]
   1295                  USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
   \      0x334   0xEB1B 0x1146      ADDS     R1,R11,R6, LSL #+5
   \      0x338   0xF511 0x6110      ADDS     R1,R1,#+2304
   \      0x33C   0x6809             LDR      R1,[R1, #+0]
   \      0x33E   0xF431 0x1100      BICS     R1,R1,#0x200000
   \      0x342   0xEB1B 0x1246      ADDS     R2,R11,R6, LSL #+5
   \      0x346   0xF512 0x6210      ADDS     R2,R2,#+2304
   \      0x34A   0x6011             STR      R1,[R2, #+0]
   1296                  USBx_INEP(i)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
   \      0x34C   0xEB1B 0x1146      ADDS     R1,R11,R6, LSL #+5
   \      0x350   0xF511 0x6110      ADDS     R1,R1,#+2304
   \      0x354   0x6809             LDR      R1,[R1, #+0]
   \      0x356   0xF051 0x6100      ORRS     R1,R1,#0x8000000
   \      0x35A   0xEB1B 0x1246      ADDS     R2,R11,R6, LSL #+5
   \      0x35E   0xF512 0x6210      ADDS     R2,R2,#+2304
   \      0x362   0x6011             STR      R1,[R2, #+0]
   1297                  USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
   \      0x364   0xEB1B 0x1146      ADDS     R1,R11,R6, LSL #+5
   \      0x368   0xF511 0x6130      ADDS     R1,R1,#+2816
   \      0x36C   0x6088             STR      R0,[R1, #+8]
   1298                  USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
   \      0x36E   0xEB1B 0x1046      ADDS     R0,R11,R6, LSL #+5
   \      0x372   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x376   0x6800             LDR      R0,[R0, #+0]
   \      0x378   0xF430 0x1000      BICS     R0,R0,#0x200000
   \      0x37C   0xEB1B 0x1146      ADDS     R1,R11,R6, LSL #+5
   \      0x380   0xF511 0x6130      ADDS     R1,R1,#+2816
   \      0x384   0x6008             STR      R0,[R1, #+0]
   1299                  USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
   \      0x386   0xEB1B 0x1046      ADDS     R0,R11,R6, LSL #+5
   \      0x38A   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x38E   0x6800             LDR      R0,[R0, #+0]
   \      0x390   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \      0x394   0xEB1B 0x1146      ADDS     R1,R11,R6, LSL #+5
   \      0x398   0xF511 0x6130      ADDS     R1,R1,#+2816
   \      0x39C   0x6008             STR      R0,[R1, #+0]
   1300                }
   \      0x39E   0x1C76             ADDS     R6,R6,#+1
   \      0x3A0   0xE7BD             B.N      ??HAL_PCD_IRQHandler_29
   1301                USBx_DEVICE->DAINTMSK |= 0x10001U;
   \                     ??HAL_PCD_IRQHandler_30: (+1)
   \      0x3A2   0xF51B 0x6000      ADDS     R0,R11,#+2048
   \      0x3A6   0x69C0             LDR      R0,[R0, #+28]
   \      0x3A8   0xF050 0x1001      ORRS     R0,R0,#0x10001
   \      0x3AC   0xF51B 0x6100      ADDS     R1,R11,#+2048
   \      0x3B0   0x61C8             STR      R0,[R1, #+28]
   1302          
   1303                if (hpcd->Init.use_dedicated_ep1 != 0U)
   \      0x3B2   0xF8D9 0x0030      LDR      R0,[R9, #+48]
   \      0x3B6   0x2800             CMP      R0,#+0
   \      0x3B8   0xD012             BEQ.N    ??HAL_PCD_IRQHandler_31
   1304                {
   1305                  USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
   1306                                             USB_OTG_DOEPMSK_XFRCM |
   1307                                             USB_OTG_DOEPMSK_EPDM;
   \      0x3BA   0xF51B 0x6000      ADDS     R0,R11,#+2048
   \      0x3BE   0xF8D0 0x0084      LDR      R0,[R0, #+132]
   \      0x3C2   0xF050 0x000B      ORRS     R0,R0,#0xB
   \      0x3C6   0xF51B 0x6100      ADDS     R1,R11,#+2048
   \      0x3CA   0xF8C1 0x0084      STR      R0,[R1, #+132]
   1308          
   1309                  USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
   1310                                            USB_OTG_DIEPMSK_XFRCM |
   1311                                            USB_OTG_DIEPMSK_EPDM;
   \      0x3CE   0xF51B 0x6000      ADDS     R0,R11,#+2048
   \      0x3D2   0x6C40             LDR      R0,[R0, #+68]
   \      0x3D4   0xF050 0x000B      ORRS     R0,R0,#0xB
   \      0x3D8   0xF51B 0x6100      ADDS     R1,R11,#+2048
   \      0x3DC   0x6448             STR      R0,[R1, #+68]
   \      0x3DE   0xE011             B.N      ??HAL_PCD_IRQHandler_32
   1312                }
   1313                else
   1314                {
   1315                  USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
   1316                                          USB_OTG_DOEPMSK_XFRCM |
   1317                                          USB_OTG_DOEPMSK_EPDM |
   1318                                          USB_OTG_DOEPMSK_OTEPSPRM |
   1319                                          USB_OTG_DOEPMSK_NAKM;
   \                     ??HAL_PCD_IRQHandler_31: (+1)
   \      0x3E0   0xF51B 0x6000      ADDS     R0,R11,#+2048
   \      0x3E4   0x6940             LDR      R0,[R0, #+20]
   \      0x3E6   0xF440 0x5000      ORR      R0,R0,#0x2000
   \      0x3EA   0xF050 0x002B      ORRS     R0,R0,#0x2B
   \      0x3EE   0xF51B 0x6100      ADDS     R1,R11,#+2048
   \      0x3F2   0x6148             STR      R0,[R1, #+20]
   1320          
   1321                  USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
   1322                                          USB_OTG_DIEPMSK_XFRCM |
   1323                                          USB_OTG_DIEPMSK_EPDM;
   \      0x3F4   0xF51B 0x6000      ADDS     R0,R11,#+2048
   \      0x3F8   0x6900             LDR      R0,[R0, #+16]
   \      0x3FA   0xF050 0x000B      ORRS     R0,R0,#0xB
   \      0x3FE   0xF51B 0x6100      ADDS     R1,R11,#+2048
   \      0x402   0x6108             STR      R0,[R1, #+16]
   1324                }
   1325          
   1326                /* Set Default Address to 0 */
   1327                USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
   \                     ??HAL_PCD_IRQHandler_32: (+1)
   \      0x404   0xF51B 0x6000      ADDS     R0,R11,#+2048
   \      0x408   0x6800             LDR      R0,[R0, #+0]
   \      0x40A   0xF430 0x60FE      BICS     R0,R0,#0x7F0
   \      0x40E   0xF51B 0x6100      ADDS     R1,R11,#+2048
   \      0x412   0x6008             STR      R0,[R1, #+0]
   1328          
   1329                /* setup EP0 to receive SETUP packets */
   1330                (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
   1331                                       (uint8_t *)hpcd->Setup);
   \      0x414   0xF519 0x7271      ADDS     R2,R9,#+964
   \      0x418   0xF8D9 0x1010      LDR      R1,[R9, #+16]
   \      0x41C   0xB2C9             UXTB     R1,R1
   \      0x41E   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x422   0x.... 0x....      BL       USB_EP0_OutStart
   1332          
   1333                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
   \      0x426   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x42A   0x6940             LDR      R0,[R0, #+20]
   \      0x42C   0xF410 0x5080      ANDS     R0,R0,#0x1000
   \      0x430   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \      0x434   0x6148             STR      R0,[R1, #+20]
   1334              }
   1335          
   1336              /* Handle Enumeration done Interrupt */
   1337              if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
   \                     ??HAL_PCD_IRQHandler_28: (+1)
   \      0x436   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x43A   0x.... 0x....      BL       USB_ReadInterrupts
   \      0x43E   0x0480             LSLS     R0,R0,#+18
   \      0x440   0xD51E             BPL.N    ??HAL_PCD_IRQHandler_33
   1338              {
   1339                (void)USB_ActivateSetup(hpcd->Instance);
   \      0x442   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x446   0x.... 0x....      BL       USB_ActivateSetup
   1340                hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
   \      0x44A   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x44E   0x.... 0x....      BL       USB_GetDevSpeed
   \      0x452   0xF8C9 0x000C      STR      R0,[R9, #+12]
   1341          
   1342                /* Set USB Turnaround time */
   1343                (void)USB_SetTurnaroundTime(hpcd->Instance,
   1344                                            HAL_RCC_GetHCLKFreq(),
   1345                                            (uint8_t)hpcd->Init.speed);
   \      0x456   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \      0x45A   0x0001             MOVS     R1,R0
   \      0x45C   0xF8D9 0x200C      LDR      R2,[R9, #+12]
   \      0x460   0xB2D2             UXTB     R2,R2
   \      0x462   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x466   0x.... 0x....      BL       USB_SetTurnaroundTime
   1346          
   1347          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
   1348                hpcd->ResetCallback(hpcd);
   1349          #else
   1350                HAL_PCD_ResetCallback(hpcd);
   \      0x46A   0x4648             MOV      R0,R9
   \      0x46C   0x.... 0x....      BL       HAL_PCD_ResetCallback
   1351          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
   1352          
   1353                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
   \      0x470   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x474   0x6940             LDR      R0,[R0, #+20]
   \      0x476   0xF410 0x5000      ANDS     R0,R0,#0x2000
   \      0x47A   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \      0x47E   0x6148             STR      R0,[R1, #+20]
   1354              }
   1355          
   1356              /* Handle SOF Interrupt */
   1357              if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
   \                     ??HAL_PCD_IRQHandler_33: (+1)
   \      0x480   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x484   0x.... 0x....      BL       USB_ReadInterrupts
   \      0x488   0x0700             LSLS     R0,R0,#+28
   \      0x48A   0xD50A             BPL.N    ??HAL_PCD_IRQHandler_34
   1358              {
   1359          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
   1360                hpcd->SOFCallback(hpcd);
   1361          #else
   1362                HAL_PCD_SOFCallback(hpcd);
   \      0x48C   0x4648             MOV      R0,R9
   \      0x48E   0x.... 0x....      BL       HAL_PCD_SOFCallback
   1363          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
   1364          
   1365                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
   \      0x492   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x496   0x6940             LDR      R0,[R0, #+20]
   \      0x498   0xF010 0x0008      ANDS     R0,R0,#0x8
   \      0x49C   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \      0x4A0   0x6148             STR      R0,[R1, #+20]
   1366              }
   1367          
   1368              /* Handle Incomplete ISO IN Interrupt */
   1369              if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
   \                     ??HAL_PCD_IRQHandler_34: (+1)
   \      0x4A2   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x4A6   0x.... 0x....      BL       USB_ReadInterrupts
   \      0x4AA   0x02C0             LSLS     R0,R0,#+11
   \      0x4AC   0xD50E             BPL.N    ??HAL_PCD_IRQHandler_35
   1370              {
   1371                /* Keep application checking the corresponding Iso IN endpoint
   1372                causing the incomplete Interrupt */
   1373                epnum = 0U;
   \      0x4AE   0x2000             MOVS     R0,#+0
   \      0x4B0   0x0005             MOVS     R5,R0
   1374          
   1375          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
   1376                hpcd->ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
   1377          #else
   1378                HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
   \      0x4B2   0x0029             MOVS     R1,R5
   \      0x4B4   0xB2C9             UXTB     R1,R1
   \      0x4B6   0x4648             MOV      R0,R9
   \      0x4B8   0x.... 0x....      BL       HAL_PCD_ISOINIncompleteCallback
   1379          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
   1380          
   1381                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
   \      0x4BC   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x4C0   0x6940             LDR      R0,[R0, #+20]
   \      0x4C2   0xF410 0x1080      ANDS     R0,R0,#0x100000
   \      0x4C6   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \      0x4CA   0x6148             STR      R0,[R1, #+20]
   1382              }
   1383          
   1384              /* Handle Incomplete ISO OUT Interrupt */
   1385              if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
   \                     ??HAL_PCD_IRQHandler_35: (+1)
   \      0x4CC   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x4D0   0x.... 0x....      BL       USB_ReadInterrupts
   \      0x4D4   0x0280             LSLS     R0,R0,#+10
   \      0x4D6   0xD50E             BPL.N    ??HAL_PCD_IRQHandler_36
   1386              {
   1387                /* Keep application checking the corresponding Iso OUT endpoint
   1388                causing the incomplete Interrupt */
   1389                epnum = 0U;
   \      0x4D8   0x2000             MOVS     R0,#+0
   \      0x4DA   0x0005             MOVS     R5,R0
   1390          
   1391          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
   1392                hpcd->ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
   1393          #else
   1394                HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
   \      0x4DC   0x0029             MOVS     R1,R5
   \      0x4DE   0xB2C9             UXTB     R1,R1
   \      0x4E0   0x4648             MOV      R0,R9
   \      0x4E2   0x.... 0x....      BL       HAL_PCD_ISOOUTIncompleteCallback
   1395          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
   1396          
   1397                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
   \      0x4E6   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x4EA   0x6940             LDR      R0,[R0, #+20]
   \      0x4EC   0xF410 0x1000      ANDS     R0,R0,#0x200000
   \      0x4F0   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \      0x4F4   0x6148             STR      R0,[R1, #+20]
   1398              }
   1399          
   1400              /* Handle Connection event Interrupt */
   1401              if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
   \                     ??HAL_PCD_IRQHandler_36: (+1)
   \      0x4F6   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x4FA   0x.... 0x....      BL       USB_ReadInterrupts
   \      0x4FE   0x0040             LSLS     R0,R0,#+1
   \      0x500   0xD50A             BPL.N    ??HAL_PCD_IRQHandler_37
   1402              {
   1403          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
   1404                hpcd->ConnectCallback(hpcd);
   1405          #else
   1406                HAL_PCD_ConnectCallback(hpcd);
   \      0x502   0x4648             MOV      R0,R9
   \      0x504   0x.... 0x....      BL       HAL_PCD_ConnectCallback
   1407          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
   1408          
   1409                __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
   \      0x508   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x50C   0x6940             LDR      R0,[R0, #+20]
   \      0x50E   0xF010 0x4080      ANDS     R0,R0,#0x40000000
   \      0x512   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \      0x516   0x6148             STR      R0,[R1, #+20]
   1410              }
   1411          
   1412              /* Handle Disconnection event Interrupt */
   1413              if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
   \                     ??HAL_PCD_IRQHandler_37: (+1)
   \      0x518   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x51C   0x.... 0x....      BL       USB_ReadInterrupts
   \      0x520   0x0740             LSLS     R0,R0,#+29
   \      0x522   0xD511             BPL.N    ??HAL_PCD_IRQHandler_0
   1414              {
   1415                temp = hpcd->Instance->GOTGINT;
   \      0x524   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x528   0x6840             LDR      R0,[R0, #+4]
   \      0x52A   0x4680             MOV      R8,R0
   1416          
   1417                if ((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
   \      0x52C   0xEA5F 0x7048      LSLS     R0,R8,#+29
   \      0x530   0xD502             BPL.N    ??HAL_PCD_IRQHandler_38
   1418                {
   1419          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
   1420                  hpcd->DisconnectCallback(hpcd);
   1421          #else
   1422                  HAL_PCD_DisconnectCallback(hpcd);
   \      0x532   0x4648             MOV      R0,R9
   \      0x534   0x.... 0x....      BL       HAL_PCD_DisconnectCallback
   1423          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
   1424                }
   1425                hpcd->Instance->GOTGINT |= temp;
   \                     ??HAL_PCD_IRQHandler_38: (+1)
   \      0x538   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \      0x53C   0x6840             LDR      R0,[R0, #+4]
   \      0x53E   0xEA58 0x0000      ORRS     R0,R8,R0
   \      0x542   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \      0x546   0x6048             STR      R0,[R1, #+4]
   1426              }
   1427            }
   1428          }
   \                     ??HAL_PCD_IRQHandler_0: (+1)
   \                     ??HAL_PCD_IRQHandler_1: (+1)
   \      0x548   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}
   1429          
   1430          
   1431          /**
   1432            * @brief  Handles PCD Wakeup interrupt request.
   1433            * @param  hpcd PCD handle
   1434            * @retval HAL status
   1435            */

   \                                 In section .text, align 2, keep-with-next
   1436          void HAL_PCD_WKUP_IRQHandler(PCD_HandleTypeDef *hpcd)
   1437          {
   1438            USB_OTG_GlobalTypeDef *USBx;
   1439          
   1440            USBx = hpcd->Instance;
   \                     HAL_PCD_WKUP_IRQHandler: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   1441          
   1442            if ((USBx->CID & (0x1U << 8)) == 0U)
   \        0x2   0x6BCA             LDR      R2,[R1, #+60]
   \        0x4   0x05D2             LSLS     R2,R2,#+23
   \        0x6   0xD405             BMI.N    ??HAL_PCD_WKUP_IRQHandler_0
   1443            {
   1444              /* Clear EXTI pending Bit */
   1445              __HAL_USB_OTG_FS_WAKEUP_EXTI_CLEAR_FLAG();
   \        0x8   0xF45F 0x2280      MOVS     R2,#+262144
   \        0xC   0x.... 0x....      LDR.W    R3,??DataTable3
   \       0x10   0x601A             STR      R2,[R3, #+0]
   \       0x12   0xE004             B.N      ??HAL_PCD_WKUP_IRQHandler_1
   1446            }
   1447            else
   1448            {
   1449              /* Clear EXTI pending Bit */
   1450              __HAL_USB_OTG_HS_WAKEUP_EXTI_CLEAR_FLAG();
   \                     ??HAL_PCD_WKUP_IRQHandler_0: (+1)
   \       0x14   0xF45F 0x1280      MOVS     R2,#+1048576
   \       0x18   0x.... 0x....      LDR.W    R3,??DataTable3
   \       0x1C   0x601A             STR      R2,[R3, #+0]
   1451            }
   1452          }
   \                     ??HAL_PCD_WKUP_IRQHandler_1: (+1)
   \       0x1E   0x4770             BX       LR
   1453          #endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */
   1454          
   1455          
   1456          /**
   1457            * @brief  Data OUT stage callback.
   1458            * @param  hpcd PCD handle
   1459            * @param  epnum endpoint number
   1460            * @retval None
   1461            */

   \                                 In section .text, align 2
   1462          __weak void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
   1463          {
   1464            /* Prevent unused argument(s) compilation warning */
   1465            UNUSED(hpcd);
   1466            UNUSED(epnum);
   1467          
   1468            /* NOTE : This function should not be modified, when the callback is needed,
   1469                      the HAL_PCD_DataOutStageCallback could be implemented in the user file
   1470             */
   1471          }
   \                     HAL_PCD_DataOutStageCallback: (+1)
   \        0x0   0x4770             BX       LR
   1472          
   1473          /**
   1474            * @brief  Data IN stage callback
   1475            * @param  hpcd PCD handle
   1476            * @param  epnum endpoint number
   1477            * @retval None
   1478            */

   \                                 In section .text, align 2
   1479          __weak void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
   1480          {
   1481            /* Prevent unused argument(s) compilation warning */
   1482            UNUSED(hpcd);
   1483            UNUSED(epnum);
   1484          
   1485            /* NOTE : This function should not be modified, when the callback is needed,
   1486                      the HAL_PCD_DataInStageCallback could be implemented in the user file
   1487             */
   1488          }
   \                     HAL_PCD_DataInStageCallback: (+1)
   \        0x0   0x4770             BX       LR
   1489          /**
   1490            * @brief  Setup stage callback
   1491            * @param  hpcd PCD handle
   1492            * @retval None
   1493            */

   \                                 In section .text, align 2
   1494          __weak void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
   1495          {
   1496            /* Prevent unused argument(s) compilation warning */
   1497            UNUSED(hpcd);
   1498          
   1499            /* NOTE : This function should not be modified, when the callback is needed,
   1500                      the HAL_PCD_SetupStageCallback could be implemented in the user file
   1501             */
   1502          }
   \                     HAL_PCD_SetupStageCallback: (+1)
   \        0x0   0x4770             BX       LR
   1503          
   1504          /**
   1505            * @brief  USB Start Of Frame callback.
   1506            * @param  hpcd PCD handle
   1507            * @retval None
   1508            */

   \                                 In section .text, align 2
   1509          __weak void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
   1510          {
   1511            /* Prevent unused argument(s) compilation warning */
   1512            UNUSED(hpcd);
   1513          
   1514            /* NOTE : This function should not be modified, when the callback is needed,
   1515                      the HAL_PCD_SOFCallback could be implemented in the user file
   1516             */
   1517          }
   \                     HAL_PCD_SOFCallback: (+1)
   \        0x0   0x4770             BX       LR
   1518          
   1519          /**
   1520            * @brief  USB Reset callback.
   1521            * @param  hpcd PCD handle
   1522            * @retval None
   1523            */

   \                                 In section .text, align 2
   1524          __weak void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
   1525          {
   1526            /* Prevent unused argument(s) compilation warning */
   1527            UNUSED(hpcd);
   1528          
   1529            /* NOTE : This function should not be modified, when the callback is needed,
   1530                      the HAL_PCD_ResetCallback could be implemented in the user file
   1531             */
   1532          }
   \                     HAL_PCD_ResetCallback: (+1)
   \        0x0   0x4770             BX       LR
   1533          
   1534          /**
   1535            * @brief  Suspend event callback.
   1536            * @param  hpcd PCD handle
   1537            * @retval None
   1538            */

   \                                 In section .text, align 2
   1539          __weak void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
   1540          {
   1541            /* Prevent unused argument(s) compilation warning */
   1542            UNUSED(hpcd);
   1543          
   1544            /* NOTE : This function should not be modified, when the callback is needed,
   1545                      the HAL_PCD_SuspendCallback could be implemented in the user file
   1546             */
   1547          }
   \                     HAL_PCD_SuspendCallback: (+1)
   \        0x0   0x4770             BX       LR
   1548          
   1549          /**
   1550            * @brief  Resume event callback.
   1551            * @param  hpcd PCD handle
   1552            * @retval None
   1553            */

   \                                 In section .text, align 2
   1554          __weak void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
   1555          {
   1556            /* Prevent unused argument(s) compilation warning */
   1557            UNUSED(hpcd);
   1558          
   1559            /* NOTE : This function should not be modified, when the callback is needed,
   1560                      the HAL_PCD_ResumeCallback could be implemented in the user file
   1561             */
   1562          }
   \                     HAL_PCD_ResumeCallback: (+1)
   \        0x0   0x4770             BX       LR
   1563          
   1564          /**
   1565            * @brief  Incomplete ISO OUT callback.
   1566            * @param  hpcd PCD handle
   1567            * @param  epnum endpoint number
   1568            * @retval None
   1569            */

   \                                 In section .text, align 2
   1570          __weak void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
   1571          {
   1572            /* Prevent unused argument(s) compilation warning */
   1573            UNUSED(hpcd);
   1574            UNUSED(epnum);
   1575          
   1576            /* NOTE : This function should not be modified, when the callback is needed,
   1577                      the HAL_PCD_ISOOUTIncompleteCallback could be implemented in the user file
   1578             */
   1579          }
   \                     HAL_PCD_ISOOUTIncompleteCallback: (+1)
   \        0x0   0x4770             BX       LR
   1580          
   1581          /**
   1582            * @brief  Incomplete ISO IN callback.
   1583            * @param  hpcd PCD handle
   1584            * @param  epnum endpoint number
   1585            * @retval None
   1586            */

   \                                 In section .text, align 2
   1587          __weak void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
   1588          {
   1589            /* Prevent unused argument(s) compilation warning */
   1590            UNUSED(hpcd);
   1591            UNUSED(epnum);
   1592          
   1593            /* NOTE : This function should not be modified, when the callback is needed,
   1594                      the HAL_PCD_ISOINIncompleteCallback could be implemented in the user file
   1595             */
   1596          }
   \                     HAL_PCD_ISOINIncompleteCallback: (+1)
   \        0x0   0x4770             BX       LR
   1597          
   1598          /**
   1599            * @brief  Connection event callback.
   1600            * @param  hpcd PCD handle
   1601            * @retval None
   1602            */

   \                                 In section .text, align 2
   1603          __weak void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
   1604          {
   1605            /* Prevent unused argument(s) compilation warning */
   1606            UNUSED(hpcd);
   1607          
   1608            /* NOTE : This function should not be modified, when the callback is needed,
   1609                      the HAL_PCD_ConnectCallback could be implemented in the user file
   1610             */
   1611          }
   \                     HAL_PCD_ConnectCallback: (+1)
   \        0x0   0x4770             BX       LR
   1612          
   1613          /**
   1614            * @brief  Disconnection event callback.
   1615            * @param  hpcd PCD handle
   1616            * @retval None
   1617            */

   \                                 In section .text, align 2
   1618          __weak void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
   1619          {
   1620            /* Prevent unused argument(s) compilation warning */
   1621            UNUSED(hpcd);
   1622          
   1623            /* NOTE : This function should not be modified, when the callback is needed,
   1624                      the HAL_PCD_DisconnectCallback could be implemented in the user file
   1625             */
   1626          }
   \                     HAL_PCD_DisconnectCallback: (+1)
   \        0x0   0x4770             BX       LR
   1627          
   1628          /**
   1629            * @}
   1630            */
   1631          
   1632          /** @defgroup PCD_Exported_Functions_Group3 Peripheral Control functions
   1633            *  @brief   management functions
   1634            *
   1635          @verbatim
   1636           ===============================================================================
   1637                                ##### Peripheral Control functions #####
   1638           ===============================================================================
   1639              [..]
   1640              This subsection provides a set of functions allowing to control the PCD data
   1641              transfers.
   1642          
   1643          @endverbatim
   1644            * @{
   1645            */
   1646          
   1647          /**
   1648            * @brief  Connect the USB device
   1649            * @param  hpcd PCD handle
   1650            * @retval HAL status
   1651            */

   \                                 In section .text, align 2, keep-with-next
   1652          HAL_StatusTypeDef HAL_PCD_DevConnect(PCD_HandleTypeDef *hpcd)
   1653          {
   \                     HAL_PCD_DevConnect: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1654          #if defined (USB_OTG_FS) || defined (USB_OTG_HS)
   1655            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   \        0x4   0x6825             LDR      R5,[R4, #+0]
   1656          #endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */
   1657          
   1658            __HAL_LOCK(hpcd);
   \        0x6   0xF894 0x03BC      LDRB     R0,[R4, #+956]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE.N    ??HAL_PCD_DevConnect_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE013             B.N      ??HAL_PCD_DevConnect_1
   \                     ??HAL_PCD_DevConnect_0: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1659          #if defined (USB_OTG_FS) || defined (USB_OTG_HS)
   1660            if ((hpcd->Init.battery_charging_enable == 1U) &&
   1661                (hpcd->Init.phy_itface != USB_OTG_ULPI_PHY))
   \       0x18   0x6AA0             LDR      R0,[R4, #+40]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD106             BNE.N    ??HAL_PCD_DevConnect_2
   \       0x1E   0x69A0             LDR      R0,[R4, #+24]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD003             BEQ.N    ??HAL_PCD_DevConnect_2
   1662            {
   1663              /* Enable USB Transceiver */
   1664              USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
   \       0x24   0x6BA8             LDR      R0,[R5, #+56]
   \       0x26   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \       0x2A   0x63A8             STR      R0,[R5, #+56]
   1665            }
   1666          #endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */
   1667            (void)USB_DevConnect(hpcd->Instance);
   \                     ??HAL_PCD_DevConnect_2: (+1)
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x.... 0x....      BL       USB_DevConnect
   1668            __HAL_UNLOCK(hpcd);
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1669          
   1670            return HAL_OK;
   \       0x38   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_DevConnect_1: (+1)
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}
   1671          }
   1672          
   1673          /**
   1674            * @brief  Disconnect the USB device.
   1675            * @param  hpcd PCD handle
   1676            * @retval HAL status
   1677            */

   \                                 In section .text, align 2, keep-with-next
   1678          HAL_StatusTypeDef HAL_PCD_DevDisconnect(PCD_HandleTypeDef *hpcd)
   1679          {
   \                     HAL_PCD_DevDisconnect: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1680          #if defined (USB_OTG_FS) || defined (USB_OTG_HS)
   1681            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   \        0x4   0x6825             LDR      R5,[R4, #+0]
   1682          #endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */
   1683          
   1684            __HAL_LOCK(hpcd);
   \        0x6   0xF894 0x03BC      LDRB     R0,[R4, #+956]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE.N    ??HAL_PCD_DevDisconnect_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE013             B.N      ??HAL_PCD_DevDisconnect_1
   \                     ??HAL_PCD_DevDisconnect_0: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1685            (void)USB_DevDisconnect(hpcd->Instance);
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x.... 0x....      BL       USB_DevDisconnect
   1686          
   1687          #if defined (USB_OTG_FS) || defined (USB_OTG_HS)
   1688            if ((hpcd->Init.battery_charging_enable == 1U) &&
   1689                (hpcd->Init.phy_itface != USB_OTG_ULPI_PHY))
   \       0x1E   0x6AA0             LDR      R0,[R4, #+40]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD106             BNE.N    ??HAL_PCD_DevDisconnect_2
   \       0x24   0x69A0             LDR      R0,[R4, #+24]
   \       0x26   0x2801             CMP      R0,#+1
   \       0x28   0xD003             BEQ.N    ??HAL_PCD_DevDisconnect_2
   1690            {
   1691              /* Disable USB Transceiver */
   1692              USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
   \       0x2A   0x6BA8             LDR      R0,[R5, #+56]
   \       0x2C   0xF430 0x3080      BICS     R0,R0,#0x10000
   \       0x30   0x63A8             STR      R0,[R5, #+56]
   1693            }
   1694          #endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */
   1695          
   1696            __HAL_UNLOCK(hpcd);
   \                     ??HAL_PCD_DevDisconnect_2: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1697          
   1698            return HAL_OK;
   \       0x38   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_DevDisconnect_1: (+1)
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}
   1699          }
   1700          
   1701          /**
   1702            * @brief  Set the USB Device address.
   1703            * @param  hpcd PCD handle
   1704            * @param  address new device address
   1705            * @retval HAL status
   1706            */

   \                                 In section .text, align 2, keep-with-next
   1707          HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
   1708          {
   \                     HAL_PCD_SetAddress: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1709            __HAL_LOCK(hpcd);
   \        0x6   0xF894 0x03BC      LDRB     R0,[R4, #+956]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE.N    ??HAL_PCD_SetAddress_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE00D             B.N      ??HAL_PCD_SetAddress_1
   \                     ??HAL_PCD_SetAddress_0: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1710            hpcd->USB_Address = address;
   \       0x18   0xF884 0x5038      STRB     R5,[R4, #+56]
   1711            (void)USB_SetDevAddress(hpcd->Instance, address);
   \       0x1C   0x0029             MOVS     R1,R5
   \       0x1E   0xB2C9             UXTB     R1,R1
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x.... 0x....      BL       USB_SetDevAddress
   1712            __HAL_UNLOCK(hpcd);
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1713          
   1714            return HAL_OK;
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_SetAddress_1: (+1)
   \       0x2E   0xBD32             POP      {R1,R4,R5,PC}
   1715          }
   1716          /**
   1717            * @brief  Open and configure an endpoint.
   1718            * @param  hpcd PCD handle
   1719            * @param  ep_addr endpoint address
   1720            * @param  ep_mps endpoint max packet size
   1721            * @param  ep_type endpoint type
   1722            * @retval HAL status
   1723            */

   \                                 In section .text, align 2, keep-with-next
   1724          HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr,
   1725                                            uint16_t ep_mps, uint8_t ep_type)
   1726          {
   \                     HAL_PCD_EP_Open: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1727            HAL_StatusTypeDef  ret = HAL_OK;
   \        0xC   0xF05F 0x0800      MOVS     R8,#+0
   1728            PCD_EPTypeDef *ep;
   1729          
   1730            if ((ep_addr & 0x80U) == 0x80U)
   \       0x10   0x0628             LSLS     R0,R5,#+24
   \       0x12   0xD50D             BPL.N    ??HAL_PCD_EP_Open_0
   1731            {
   1732              ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
   \       0x14   0x0029             MOVS     R1,R5
   \       0x16   0xB2C9             UXTB     R1,R1
   \       0x18   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x1C   0x201C             MOVS     R0,#+28
   \       0x1E   0x4341             MULS     R1,R0,R1
   \       0x20   0xEB04 0x0001      ADD      R0,R4,R1
   \       0x24   0xF110 0x093C      ADDS     R9,R0,#+60
   1733              ep->is_in = 1U;
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xF889 0x0001      STRB     R0,[R9, #+1]
   \       0x2E   0xE00C             B.N      ??HAL_PCD_EP_Open_1
   1734            }
   1735            else
   1736            {
   1737              ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
   \                     ??HAL_PCD_EP_Open_0: (+1)
   \       0x30   0x0029             MOVS     R1,R5
   \       0x32   0xB2C9             UXTB     R1,R1
   \       0x34   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x38   0x201C             MOVS     R0,#+28
   \       0x3A   0x4341             MULS     R1,R0,R1
   \       0x3C   0xEB04 0x0001      ADD      R0,R4,R1
   \       0x40   0xF510 0x79FE      ADDS     R9,R0,#+508
   1738              ep->is_in = 0U;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xF889 0x0001      STRB     R0,[R9, #+1]
   1739            }
   1740          
   1741            ep->num = ep_addr & EP_ADDR_MSK;
   \                     ??HAL_PCD_EP_Open_1: (+1)
   \       0x4A   0xF015 0x000F      ANDS     R0,R5,#0xF
   \       0x4E   0xF889 0x0000      STRB     R0,[R9, #+0]
   1742            ep->maxpacket = ep_mps;
   \       0x52   0x0030             MOVS     R0,R6
   \       0x54   0xB280             UXTH     R0,R0
   \       0x56   0xF8C9 0x0008      STR      R0,[R9, #+8]
   1743            ep->type = ep_type;
   \       0x5A   0xF889 0x7003      STRB     R7,[R9, #+3]
   1744          
   1745            if (ep->is_in != 0U)
   \       0x5E   0xF899 0x0001      LDRB     R0,[R9, #+1]
   \       0x62   0x2800             CMP      R0,#+0
   \       0x64   0xD003             BEQ.N    ??HAL_PCD_EP_Open_2
   1746            {
   1747              /* Assign a Tx FIFO */
   1748              ep->tx_fifo_num = ep->num;
   \       0x66   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \       0x6A   0xF8A9 0x0006      STRH     R0,[R9, #+6]
   1749            }
   1750            /* Set initial data PID. */
   1751            if (ep_type == EP_TYPE_BULK)
   \                     ??HAL_PCD_EP_Open_2: (+1)
   \       0x6E   0x0038             MOVS     R0,R7
   \       0x70   0xB2C0             UXTB     R0,R0
   \       0x72   0x2802             CMP      R0,#+2
   \       0x74   0xD102             BNE.N    ??HAL_PCD_EP_Open_3
   1752            {
   1753              ep->data_pid_start = 0U;
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xF889 0x0004      STRB     R0,[R9, #+4]
   1754            }
   1755          
   1756            __HAL_LOCK(hpcd);
   \                     ??HAL_PCD_EP_Open_3: (+1)
   \       0x7C   0xF894 0x03BC      LDRB     R0,[R4, #+956]
   \       0x80   0x2801             CMP      R0,#+1
   \       0x82   0xD101             BNE.N    ??HAL_PCD_EP_Open_4
   \       0x84   0x2002             MOVS     R0,#+2
   \       0x86   0xE00B             B.N      ??HAL_PCD_EP_Open_5
   \                     ??HAL_PCD_EP_Open_4: (+1)
   \       0x88   0x2001             MOVS     R0,#+1
   \       0x8A   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1757            (void)USB_ActivateEndpoint(hpcd->Instance, ep);
   \       0x8E   0x4649             MOV      R1,R9
   \       0x90   0x6820             LDR      R0,[R4, #+0]
   \       0x92   0x.... 0x....      BL       USB_ActivateEndpoint
   1758            __HAL_UNLOCK(hpcd);
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1759          
   1760            return ret;
   \       0x9C   0x4640             MOV      R0,R8
   \       0x9E   0xB2C0             UXTB     R0,R0
   \                     ??HAL_PCD_EP_Open_5: (+1)
   \       0xA0   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1761          }
   1762          
   1763          /**
   1764            * @brief  Deactivate an endpoint.
   1765            * @param  hpcd PCD handle
   1766            * @param  ep_addr endpoint address
   1767            * @retval HAL status
   1768            */

   \                                 In section .text, align 2, keep-with-next
   1769          HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
   1770          {
   \                     HAL_PCD_EP_Close: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1771            PCD_EPTypeDef *ep;
   1772          
   1773            if ((ep_addr & 0x80U) == 0x80U)
   \        0x6   0x0628             LSLS     R0,R5,#+24
   \        0x8   0xD50C             BPL.N    ??HAL_PCD_EP_Close_0
   1774            {
   1775              ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
   \        0xA   0x0029             MOVS     R1,R5
   \        0xC   0xB2C9             UXTB     R1,R1
   \        0xE   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x12   0x201C             MOVS     R0,#+28
   \       0x14   0x4341             MULS     R1,R0,R1
   \       0x16   0xEB04 0x0001      ADD      R0,R4,R1
   \       0x1A   0xF110 0x063C      ADDS     R6,R0,#+60
   1776              ep->is_in = 1U;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0x7070             STRB     R0,[R6, #+1]
   \       0x22   0xE00B             B.N      ??HAL_PCD_EP_Close_1
   1777            }
   1778            else
   1779            {
   1780              ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
   \                     ??HAL_PCD_EP_Close_0: (+1)
   \       0x24   0x0029             MOVS     R1,R5
   \       0x26   0xB2C9             UXTB     R1,R1
   \       0x28   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x2C   0x201C             MOVS     R0,#+28
   \       0x2E   0x4341             MULS     R1,R0,R1
   \       0x30   0xEB04 0x0001      ADD      R0,R4,R1
   \       0x34   0xF510 0x76FE      ADDS     R6,R0,#+508
   1781              ep->is_in = 0U;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x7070             STRB     R0,[R6, #+1]
   1782            }
   1783            ep->num   = ep_addr & EP_ADDR_MSK;
   \                     ??HAL_PCD_EP_Close_1: (+1)
   \       0x3C   0xF015 0x000F      ANDS     R0,R5,#0xF
   \       0x40   0x7030             STRB     R0,[R6, #+0]
   1784          
   1785            __HAL_LOCK(hpcd);
   \       0x42   0xF894 0x03BC      LDRB     R0,[R4, #+956]
   \       0x46   0x2801             CMP      R0,#+1
   \       0x48   0xD101             BNE.N    ??HAL_PCD_EP_Close_2
   \       0x4A   0x2002             MOVS     R0,#+2
   \       0x4C   0xE00A             B.N      ??HAL_PCD_EP_Close_3
   \                     ??HAL_PCD_EP_Close_2: (+1)
   \       0x4E   0x2001             MOVS     R0,#+1
   \       0x50   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1786            (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
   \       0x54   0x0031             MOVS     R1,R6
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x.... 0x....      BL       USB_DeactivateEndpoint
   1787            __HAL_UNLOCK(hpcd);
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1788            return HAL_OK;
   \       0x62   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_EP_Close_3: (+1)
   \       0x64   0xBD70             POP      {R4-R6,PC}
   1789          }
   1790          
   1791          
   1792          /**
   1793            * @brief  Receive an amount of data.
   1794            * @param  hpcd PCD handle
   1795            * @param  ep_addr endpoint address
   1796            * @param  pBuf pointer to the reception buffer
   1797            * @param  len amount of data to be received
   1798            * @retval HAL status
   1799            */

   \                                 In section .text, align 2, keep-with-next
   1800          HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
   1801          {
   \                     HAL_PCD_EP_Receive: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   1802            PCD_EPTypeDef *ep;
   1803          
   1804            ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
   \        0xC   0x0039             MOVS     R1,R7
   \        0xE   0xB2C9             UXTB     R1,R1
   \       0x10   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x14   0x201C             MOVS     R0,#+28
   \       0x16   0x4341             MULS     R1,R0,R1
   \       0x18   0xEB04 0x0001      ADD      R0,R4,R1
   \       0x1C   0xF510 0x78FE      ADDS     R8,R0,#+508
   1805          
   1806            /*setup and start the Xfer */
   1807            ep->xfer_buff = pBuf;
   \       0x20   0xF8C8 0x500C      STR      R5,[R8, #+12]
   1808            ep->xfer_len = len;
   \       0x24   0xF8C8 0x6014      STR      R6,[R8, #+20]
   1809            ep->xfer_count = 0U;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xF8C8 0x0018      STR      R0,[R8, #+24]
   1810            ep->is_in = 0U;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xF888 0x0001      STRB     R0,[R8, #+1]
   1811            ep->num = ep_addr & EP_ADDR_MSK;
   \       0x34   0xF017 0x000F      ANDS     R0,R7,#0xF
   \       0x38   0xF888 0x0000      STRB     R0,[R8, #+0]
   1812          
   1813            if (hpcd->Init.dma_enable == 1U)
   \       0x3C   0x6920             LDR      R0,[R4, #+16]
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD101             BNE.N    ??HAL_PCD_EP_Receive_0
   1814            {
   1815              ep->dma_addr = (uint32_t)pBuf;
   \       0x42   0xF8C8 0x5010      STR      R5,[R8, #+16]
   1816            }
   1817          
   1818            if ((ep_addr & EP_ADDR_MSK) == 0U)
   \                     ??HAL_PCD_EP_Receive_0: (+1)
   \       0x46   0xF017 0x0F0F      TST      R7,#0xF
   \       0x4A   0xD106             BNE.N    ??HAL_PCD_EP_Receive_1
   1819            {
   1820              (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
   \       0x4C   0x6922             LDR      R2,[R4, #+16]
   \       0x4E   0xB2D2             UXTB     R2,R2
   \       0x50   0x4641             MOV      R1,R8
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x.... 0x....      BL       USB_EP0StartXfer
   \       0x58   0xE005             B.N      ??HAL_PCD_EP_Receive_2
   1821            }
   1822            else
   1823            {
   1824              (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
   \                     ??HAL_PCD_EP_Receive_1: (+1)
   \       0x5A   0x6922             LDR      R2,[R4, #+16]
   \       0x5C   0xB2D2             UXTB     R2,R2
   \       0x5E   0x4641             MOV      R1,R8
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x.... 0x....      BL       USB_EPStartXfer
   1825            }
   1826          
   1827            return HAL_OK;
   \                     ??HAL_PCD_EP_Receive_2: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1828          }
   1829          
   1830          /**
   1831            * @brief  Get Received Data Size
   1832            * @param  hpcd PCD handle
   1833            * @param  ep_addr endpoint address
   1834            * @retval Data Size
   1835            */

   \                                 In section .text, align 2, keep-with-next
   1836          uint32_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
   1837          {
   1838            return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
   \                     HAL_PCD_EP_GetRxCount: (+1)
   \        0x0   0xB2C9             UXTB     R1,R1
   \        0x2   0xF011 0x010F      ANDS     R1,R1,#0xF
   \        0x6   0x221C             MOVS     R2,#+28
   \        0x8   0x4351             MULS     R1,R2,R1
   \        0xA   0x4408             ADD      R0,R0,R1
   \        0xC   0xF8D0 0x0214      LDR      R0,[R0, #+532]
   \       0x10   0x4770             BX       LR
   1839          }
   1840          /**
   1841            * @brief  Send an amount of data
   1842            * @param  hpcd PCD handle
   1843            * @param  ep_addr endpoint address
   1844            * @param  pBuf pointer to the transmission buffer
   1845            * @param  len amount of data to be sent
   1846            * @retval HAL status
   1847            */

   \                                 In section .text, align 2, keep-with-next
   1848          HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
   1849          {
   \                     HAL_PCD_EP_Transmit: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001E             MOVS     R6,R3
   1850            PCD_EPTypeDef *ep;
   1851          
   1852            ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
   \        0xC   0x0039             MOVS     R1,R7
   \        0xE   0xB2C9             UXTB     R1,R1
   \       0x10   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x14   0x201C             MOVS     R0,#+28
   \       0x16   0x4341             MULS     R1,R0,R1
   \       0x18   0xEB04 0x0001      ADD      R0,R4,R1
   \       0x1C   0xF110 0x083C      ADDS     R8,R0,#+60
   1853          
   1854            /*setup and start the Xfer */
   1855            ep->xfer_buff = pBuf;
   \       0x20   0xF8C8 0x500C      STR      R5,[R8, #+12]
   1856            ep->xfer_len = len;
   \       0x24   0xF8C8 0x6014      STR      R6,[R8, #+20]
   1857            ep->xfer_count = 0U;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xF8C8 0x0018      STR      R0,[R8, #+24]
   1858            ep->is_in = 1U;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xF888 0x0001      STRB     R0,[R8, #+1]
   1859            ep->num = ep_addr & EP_ADDR_MSK;
   \       0x34   0xF017 0x000F      ANDS     R0,R7,#0xF
   \       0x38   0xF888 0x0000      STRB     R0,[R8, #+0]
   1860          
   1861            if (hpcd->Init.dma_enable == 1U)
   \       0x3C   0x6920             LDR      R0,[R4, #+16]
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD101             BNE.N    ??HAL_PCD_EP_Transmit_0
   1862            {
   1863              ep->dma_addr = (uint32_t)pBuf;
   \       0x42   0xF8C8 0x5010      STR      R5,[R8, #+16]
   1864            }
   1865          
   1866            if ((ep_addr & EP_ADDR_MSK) == 0U)
   \                     ??HAL_PCD_EP_Transmit_0: (+1)
   \       0x46   0xF017 0x0F0F      TST      R7,#0xF
   \       0x4A   0xD106             BNE.N    ??HAL_PCD_EP_Transmit_1
   1867            {
   1868              (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
   \       0x4C   0x6922             LDR      R2,[R4, #+16]
   \       0x4E   0xB2D2             UXTB     R2,R2
   \       0x50   0x4641             MOV      R1,R8
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x.... 0x....      BL       USB_EP0StartXfer
   \       0x58   0xE005             B.N      ??HAL_PCD_EP_Transmit_2
   1869            }
   1870            else
   1871            {
   1872              (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
   \                     ??HAL_PCD_EP_Transmit_1: (+1)
   \       0x5A   0x6922             LDR      R2,[R4, #+16]
   \       0x5C   0xB2D2             UXTB     R2,R2
   \       0x5E   0x4641             MOV      R1,R8
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x.... 0x....      BL       USB_EPStartXfer
   1873            }
   1874          
   1875            return HAL_OK;
   \                     ??HAL_PCD_EP_Transmit_2: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xE8BD 0x81F0      POP      {R4-R8,PC}
   1876          }
   1877          
   1878          /**
   1879            * @brief  Set a STALL condition over an endpoint
   1880            * @param  hpcd PCD handle
   1881            * @param  ep_addr endpoint address
   1882            * @retval HAL status
   1883            */

   \                                 In section .text, align 2, keep-with-next
   1884          HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
   1885          {
   \                     HAL_PCD_EP_SetStall: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1886            PCD_EPTypeDef *ep;
   1887          
   1888            if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
   \        0x6   0x6860             LDR      R0,[R4, #+4]
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0xB2C9             UXTB     R1,R1
   \        0xC   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x10   0x4288             CMP      R0,R1
   \       0x12   0xD201             BCS.N    ??HAL_PCD_EP_SetStall_0
   1889            {
   1890              return HAL_ERROR;
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xE038             B.N      ??HAL_PCD_EP_SetStall_1
   1891            }
   1892          
   1893            if ((0x80U & ep_addr) == 0x80U)
   \                     ??HAL_PCD_EP_SetStall_0: (+1)
   \       0x18   0x0628             LSLS     R0,R5,#+24
   \       0x1A   0xD50C             BPL.N    ??HAL_PCD_EP_SetStall_2
   1894            {
   1895              ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
   \       0x1C   0x0029             MOVS     R1,R5
   \       0x1E   0xB2C9             UXTB     R1,R1
   \       0x20   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x24   0x201C             MOVS     R0,#+28
   \       0x26   0x4341             MULS     R1,R0,R1
   \       0x28   0xEB04 0x0001      ADD      R0,R4,R1
   \       0x2C   0xF110 0x063C      ADDS     R6,R0,#+60
   1896              ep->is_in = 1U;
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x7070             STRB     R0,[R6, #+1]
   \       0x34   0xE009             B.N      ??HAL_PCD_EP_SetStall_3
   1897            }
   1898            else
   1899            {
   1900              ep = &hpcd->OUT_ep[ep_addr];
   \                     ??HAL_PCD_EP_SetStall_2: (+1)
   \       0x36   0x0029             MOVS     R1,R5
   \       0x38   0xB2C9             UXTB     R1,R1
   \       0x3A   0x201C             MOVS     R0,#+28
   \       0x3C   0x4341             MULS     R1,R0,R1
   \       0x3E   0xEB04 0x0001      ADD      R0,R4,R1
   \       0x42   0xF510 0x76FE      ADDS     R6,R0,#+508
   1901              ep->is_in = 0U;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x7070             STRB     R0,[R6, #+1]
   1902            }
   1903          
   1904            ep->is_stall = 1U;
   \                     ??HAL_PCD_EP_SetStall_3: (+1)
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0x70B0             STRB     R0,[R6, #+2]
   1905            ep->num = ep_addr & EP_ADDR_MSK;
   \       0x4E   0xF015 0x000F      ANDS     R0,R5,#0xF
   \       0x52   0x7030             STRB     R0,[R6, #+0]
   1906          
   1907            __HAL_LOCK(hpcd);
   \       0x54   0xF894 0x03BC      LDRB     R0,[R4, #+956]
   \       0x58   0x2801             CMP      R0,#+1
   \       0x5A   0xD101             BNE.N    ??HAL_PCD_EP_SetStall_4
   \       0x5C   0x2002             MOVS     R0,#+2
   \       0x5E   0xE014             B.N      ??HAL_PCD_EP_SetStall_1
   \                     ??HAL_PCD_EP_SetStall_4: (+1)
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1908          
   1909            (void)USB_EPSetStall(hpcd->Instance, ep);
   \       0x66   0x0031             MOVS     R1,R6
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x.... 0x....      BL       USB_EPSetStall
   1910          
   1911            if ((ep_addr & EP_ADDR_MSK) == 0U)
   \       0x6E   0xF015 0x0F0F      TST      R5,#0xF
   \       0x72   0xD106             BNE.N    ??HAL_PCD_EP_SetStall_5
   1912            {
   1913              (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
   \       0x74   0xF514 0x7271      ADDS     R2,R4,#+964
   \       0x78   0x6921             LDR      R1,[R4, #+16]
   \       0x7A   0xB2C9             UXTB     R1,R1
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x.... 0x....      BL       USB_EP0_OutStart
   1914            }
   1915          
   1916            __HAL_UNLOCK(hpcd);
   \                     ??HAL_PCD_EP_SetStall_5: (+1)
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1917          
   1918            return HAL_OK;
   \       0x88   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_EP_SetStall_1: (+1)
   \       0x8A   0xBD70             POP      {R4-R6,PC}
   1919          }
   1920          
   1921          /**
   1922            * @brief  Clear a STALL condition over in an endpoint
   1923            * @param  hpcd PCD handle
   1924            * @param  ep_addr endpoint address
   1925            * @retval HAL status
   1926            */

   \                                 In section .text, align 2, keep-with-next
   1927          HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
   1928          {
   \                     HAL_PCD_EP_ClrStall: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1929            PCD_EPTypeDef *ep;
   1930          
   1931            if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
   \        0x6   0x6860             LDR      R0,[R4, #+4]
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0xB2C9             UXTB     R1,R1
   \        0xC   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x10   0x4288             CMP      R0,R1
   \       0x12   0xD201             BCS.N    ??HAL_PCD_EP_ClrStall_0
   1932            {
   1933              return HAL_ERROR;
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xE030             B.N      ??HAL_PCD_EP_ClrStall_1
   1934            }
   1935          
   1936            if ((0x80U & ep_addr) == 0x80U)
   \                     ??HAL_PCD_EP_ClrStall_0: (+1)
   \       0x18   0x0628             LSLS     R0,R5,#+24
   \       0x1A   0xD50C             BPL.N    ??HAL_PCD_EP_ClrStall_2
   1937            {
   1938              ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
   \       0x1C   0x0029             MOVS     R1,R5
   \       0x1E   0xB2C9             UXTB     R1,R1
   \       0x20   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x24   0x201C             MOVS     R0,#+28
   \       0x26   0x4341             MULS     R1,R0,R1
   \       0x28   0xEB04 0x0001      ADD      R0,R4,R1
   \       0x2C   0xF110 0x063C      ADDS     R6,R0,#+60
   1939              ep->is_in = 1U;
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x7070             STRB     R0,[R6, #+1]
   \       0x34   0xE00B             B.N      ??HAL_PCD_EP_ClrStall_3
   1940            }
   1941            else
   1942            {
   1943              ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
   \                     ??HAL_PCD_EP_ClrStall_2: (+1)
   \       0x36   0x0029             MOVS     R1,R5
   \       0x38   0xB2C9             UXTB     R1,R1
   \       0x3A   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x3E   0x201C             MOVS     R0,#+28
   \       0x40   0x4341             MULS     R1,R0,R1
   \       0x42   0xEB04 0x0001      ADD      R0,R4,R1
   \       0x46   0xF510 0x76FE      ADDS     R6,R0,#+508
   1944              ep->is_in = 0U;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0x7070             STRB     R0,[R6, #+1]
   1945            }
   1946          
   1947            ep->is_stall = 0U;
   \                     ??HAL_PCD_EP_ClrStall_3: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x70B0             STRB     R0,[R6, #+2]
   1948            ep->num = ep_addr & EP_ADDR_MSK;
   \       0x52   0xF015 0x000F      ANDS     R0,R5,#0xF
   \       0x56   0x7030             STRB     R0,[R6, #+0]
   1949          
   1950            __HAL_LOCK(hpcd);
   \       0x58   0xF894 0x03BC      LDRB     R0,[R4, #+956]
   \       0x5C   0x2801             CMP      R0,#+1
   \       0x5E   0xD101             BNE.N    ??HAL_PCD_EP_ClrStall_4
   \       0x60   0x2002             MOVS     R0,#+2
   \       0x62   0xE00A             B.N      ??HAL_PCD_EP_ClrStall_1
   \                     ??HAL_PCD_EP_ClrStall_4: (+1)
   \       0x64   0x2001             MOVS     R0,#+1
   \       0x66   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1951            (void)USB_EPClearStall(hpcd->Instance, ep);
   \       0x6A   0x0031             MOVS     R1,R6
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x.... 0x....      BL       USB_EPClearStall
   1952            __HAL_UNLOCK(hpcd);
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1953          
   1954            return HAL_OK;
   \       0x78   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_EP_ClrStall_1: (+1)
   \       0x7A   0xBD70             POP      {R4-R6,PC}
   1955          }
   1956          
   1957          /**
   1958            * @brief  Flush an endpoint
   1959            * @param  hpcd PCD handle
   1960            * @param  ep_addr endpoint address
   1961            * @retval HAL status
   1962            */

   \                                 In section .text, align 2, keep-with-next
   1963          HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
   1964          {
   \                     HAL_PCD_EP_Flush: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1965            __HAL_LOCK(hpcd);
   \        0x6   0xF894 0x03BC      LDRB     R0,[R4, #+956]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE.N    ??HAL_PCD_EP_Flush_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE013             B.N      ??HAL_PCD_EP_Flush_1
   \                     ??HAL_PCD_EP_Flush_0: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1966          
   1967            if ((ep_addr & 0x80U) == 0x80U)
   \       0x18   0x0628             LSLS     R0,R5,#+24
   \       0x1A   0xD507             BPL.N    ??HAL_PCD_EP_Flush_2
   1968            {
   1969              (void)USB_FlushTxFifo(hpcd->Instance, (uint32_t)ep_addr & EP_ADDR_MSK);
   \       0x1C   0x0029             MOVS     R1,R5
   \       0x1E   0xB2C9             UXTB     R1,R1
   \       0x20   0xF011 0x010F      ANDS     R1,R1,#0xF
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x.... 0x....      BL       USB_FlushTxFifo
   \       0x2A   0xE002             B.N      ??HAL_PCD_EP_Flush_3
   1970            }
   1971            else
   1972            {
   1973              (void)USB_FlushRxFifo(hpcd->Instance);
   \                     ??HAL_PCD_EP_Flush_2: (+1)
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x.... 0x....      BL       USB_FlushRxFifo
   1974            }
   1975          
   1976            __HAL_UNLOCK(hpcd);
   \                     ??HAL_PCD_EP_Flush_3: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xF884 0x03BC      STRB     R0,[R4, #+956]
   1977          
   1978            return HAL_OK;
   \       0x38   0x2000             MOVS     R0,#+0
   \                     ??HAL_PCD_EP_Flush_1: (+1)
   \       0x3A   0xBD32             POP      {R1,R4,R5,PC}
   1979          }
   1980          
   1981          /**
   1982            * @brief  Activate remote wakeup signalling
   1983            * @param  hpcd PCD handle
   1984            * @retval HAL status
   1985            */

   \                                 In section .text, align 2, keep-with-next
   1986          HAL_StatusTypeDef HAL_PCD_ActivateRemoteWakeup(PCD_HandleTypeDef *hpcd)
   1987          {
   \                     HAL_PCD_ActivateRemoteWakeup: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1988            return (USB_ActivateRemoteWakeup(hpcd->Instance));
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x.... 0x....      BL       USB_ActivateRemoteWakeup
   \        0xA   0xBD10             POP      {R4,PC}
   1989          }
   1990          
   1991          /**
   1992            * @brief  De-activate remote wakeup signalling.
   1993            * @param  hpcd PCD handle
   1994            * @retval HAL status
   1995            */

   \                                 In section .text, align 2, keep-with-next
   1996          HAL_StatusTypeDef HAL_PCD_DeActivateRemoteWakeup(PCD_HandleTypeDef *hpcd)
   1997          {
   \                     HAL_PCD_DeActivateRemoteWakeup: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1998            return (USB_DeActivateRemoteWakeup(hpcd->Instance));
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x.... 0x....      BL       USB_DeActivateRemoteWakeup
   \        0xA   0xBD10             POP      {R4,PC}
   1999          }
   2000          
   2001          /**
   2002            * @}
   2003            */
   2004          
   2005          /** @defgroup PCD_Exported_Functions_Group4 Peripheral State functions
   2006            *  @brief   Peripheral State functions
   2007            *
   2008          @verbatim
   2009           ===============================================================================
   2010                                ##### Peripheral State functions #####
   2011           ===============================================================================
   2012              [..]
   2013              This subsection permits to get in run-time the status of the peripheral
   2014              and the data flow.
   2015          
   2016          @endverbatim
   2017            * @{
   2018            */
   2019          
   2020          /**
   2021            * @brief  Return the PCD handle state.
   2022            * @param  hpcd PCD handle
   2023            * @retval HAL state
   2024            */

   \                                 In section .text, align 2, keep-with-next
   2025          PCD_StateTypeDef HAL_PCD_GetState(PCD_HandleTypeDef *hpcd)
   2026          {
   2027            return hpcd->State;
   \                     HAL_PCD_GetState: (+1)
   \        0x0   0xF890 0x03BD      LDRB     R0,[R0, #+957]
   \        0x4   0x4770             BX       LR
   2028          }
   2029          
   2030          /**
   2031            * @}
   2032            */
   2033          
   2034          /**
   2035            * @}
   2036            */
   2037          
   2038          /* Private functions ---------------------------------------------------------*/
   2039          /** @addtogroup PCD_Private_Functions
   2040            * @{
   2041            */
   2042          #if defined (USB_OTG_FS) || defined (USB_OTG_HS)
   2043          /**
   2044            * @brief  Check FIFO for the next packet to be loaded.
   2045            * @param  hpcd PCD handle
   2046            * @param  epnum endpoint number
   2047            * @retval HAL status
   2048            */

   \                                 In section .text, align 2, keep-with-next
   2049          static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
   2050          {
   \                     PCD_WriteEmptyTxFifo: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   2051            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   \        0x8   0xF8D5 0xB000      LDR      R11,[R5, #+0]
   2052            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0xC   0x465F             MOV      R7,R11
   2053            USB_OTG_EPTypeDef *ep;
   2054            uint32_t len;
   2055            uint32_t len32b;
   2056            uint32_t fifoemptymsk;
   2057          
   2058            ep = &hpcd->IN_ep[epnum];
   \        0xE   0x201C             MOVS     R0,#+28
   \       0x10   0xFB00 0xF006      MUL      R0,R0,R6
   \       0x14   0x4428             ADD      R0,R5,R0
   \       0x16   0xF110 0x083C      ADDS     R8,R0,#+60
   2059          
   2060            if (ep->xfer_count > ep->xfer_len)
   \       0x1A   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \       0x1E   0xF8D8 0x1018      LDR      R1,[R8, #+24]
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD201             BCS.N    ??PCD_WriteEmptyTxFifo_0
   2061            {
   2062              return HAL_ERROR;
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xE05E             B.N      ??PCD_WriteEmptyTxFifo_1
   2063            }
   2064          
   2065            len = ep->xfer_len - ep->xfer_count;
   \                     ??PCD_WriteEmptyTxFifo_0: (+1)
   \       0x2A   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \       0x2E   0xF8D8 0x9018      LDR      R9,[R8, #+24]
   \       0x32   0xEBB0 0x0909      SUBS     R9,R0,R9
   2066          
   2067            if (len > ep->maxpacket)
   \       0x36   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \       0x3A   0x4548             CMP      R0,R9
   \       0x3C   0xD202             BCS.N    ??PCD_WriteEmptyTxFifo_2
   2068            {
   2069              len = ep->maxpacket;
   \       0x3E   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \       0x42   0x4681             MOV      R9,R0
   2070            }
   2071          
   2072            len32b = (len + 3U) / 4U;
   \                     ??PCD_WriteEmptyTxFifo_2: (+1)
   \       0x44   0xF119 0x0A03      ADDS     R10,R9,#+3
   \       0x48   0xEA5F 0x0A9A      LSRS     R10,R10,#+2
   2073          
   2074            while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
   2075                   (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
   \                     ??PCD_WriteEmptyTxFifo_3: (+1)
   \       0x4C   0xEB17 0x1046      ADDS     R0,R7,R6, LSL #+5
   \       0x50   0xF510 0x6010      ADDS     R0,R0,#+2304
   \       0x54   0x6980             LDR      R0,[R0, #+24]
   \       0x56   0xB280             UXTH     R0,R0
   \       0x58   0x4550             CMP      R0,R10
   \       0x5A   0xD332             BCC.N    ??PCD_WriteEmptyTxFifo_4
   \       0x5C   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \       0x60   0xF8D8 0x1014      LDR      R1,[R8, #+20]
   \       0x64   0x4288             CMP      R0,R1
   \       0x66   0xD22C             BCS.N    ??PCD_WriteEmptyTxFifo_4
   \       0x68   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD028             BEQ.N    ??PCD_WriteEmptyTxFifo_4
   2076            {
   2077              /* Write the FIFO */
   2078              len = ep->xfer_len - ep->xfer_count;
   \       0x70   0xF8D8 0x1014      LDR      R1,[R8, #+20]
   \       0x74   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \       0x78   0x1A09             SUBS     R1,R1,R0
   \       0x7A   0x4689             MOV      R9,R1
   2079          
   2080              if (len > ep->maxpacket)
   \       0x7C   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \       0x80   0x4548             CMP      R0,R9
   \       0x82   0xD202             BCS.N    ??PCD_WriteEmptyTxFifo_5
   2081              {
   2082                len = ep->maxpacket;
   \       0x84   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \       0x88   0x4681             MOV      R9,R0
   2083              }
   2084              len32b = (len + 3U) / 4U;
   \                     ??PCD_WriteEmptyTxFifo_5: (+1)
   \       0x8A   0xF119 0x0003      ADDS     R0,R9,#+3
   \       0x8E   0x0880             LSRS     R0,R0,#+2
   \       0x90   0x4682             MOV      R10,R0
   2085          
   2086              (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
   2087                                    (uint8_t)hpcd->Init.dma_enable);
   \       0x92   0x6928             LDR      R0,[R5, #+16]
   \       0x94   0xB2C0             UXTB     R0,R0
   \       0x96   0x9000             STR      R0,[SP, #+0]
   \       0x98   0x464B             MOV      R3,R9
   \       0x9A   0xB29B             UXTH     R3,R3
   \       0x9C   0x0032             MOVS     R2,R6
   \       0x9E   0xB2D2             UXTB     R2,R2
   \       0xA0   0xF8D8 0x100C      LDR      R1,[R8, #+12]
   \       0xA4   0x4658             MOV      R0,R11
   \       0xA6   0x.... 0x....      BL       USB_WritePacket
   2088          
   2089              ep->xfer_buff  += len;
   \       0xAA   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \       0xAE   0x4448             ADD      R0,R0,R9
   \       0xB0   0xF8C8 0x000C      STR      R0,[R8, #+12]
   2090              ep->xfer_count += len;
   \       0xB4   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \       0xB8   0xEB19 0x0000      ADDS     R0,R9,R0
   \       0xBC   0xF8C8 0x0018      STR      R0,[R8, #+24]
   \       0xC0   0xE7C4             B.N      ??PCD_WriteEmptyTxFifo_3
   2091            }
   2092          
   2093            if (ep->xfer_len <= ep->xfer_count)
   \                     ??PCD_WriteEmptyTxFifo_4: (+1)
   \       0xC2   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \       0xC6   0xF8D8 0x1014      LDR      R1,[R8, #+20]
   \       0xCA   0x4288             CMP      R0,R1
   \       0xCC   0xD30B             BCC.N    ??PCD_WriteEmptyTxFifo_6
   2094            {
   2095              fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
   \       0xCE   0x2101             MOVS     R1,#+1
   \       0xD0   0xF016 0x000F      ANDS     R0,R6,#0xF
   \       0xD4   0x4081             LSLS     R1,R1,R0
   \       0xD6   0x000C             MOVS     R4,R1
   2096              USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
   \       0xD8   0xF517 0x6000      ADDS     R0,R7,#+2048
   \       0xDC   0x6B40             LDR      R0,[R0, #+52]
   \       0xDE   0x43A0             BICS     R0,R0,R4
   \       0xE0   0xF517 0x6100      ADDS     R1,R7,#+2048
   \       0xE4   0x6348             STR      R0,[R1, #+52]
   2097            }
   2098          
   2099            return HAL_OK;
   \                     ??PCD_WriteEmptyTxFifo_6: (+1)
   \       0xE6   0x2000             MOVS     R0,#+0
   \                     ??PCD_WriteEmptyTxFifo_1: (+1)
   \       0xE8   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}
   2100          }
   2101          
   2102          
   2103          /**
   2104            * @brief  process EP OUT transfer complete interrupt.
   2105            * @param  hpcd PCD handle
   2106            * @param  epnum endpoint number
   2107            * @retval HAL status
   2108            */

   \                                 In section .text, align 2, keep-with-next
   2109          static HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
   2110          {
   \                     PCD_EP_OutXfrComplete_int: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000C             MOVS     R4,R1
   2111            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   \        0x8   0x682E             LDR      R6,[R5, #+0]
   2112            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0xA   0x0037             MOVS     R7,R6
   2113            uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
   \        0xC   0xF8D6 0x8040      LDR      R8,[R6, #+64]
   2114            uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
   \       0x10   0xEB17 0x1044      ADDS     R0,R7,R4, LSL #+5
   \       0x14   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x18   0xF8D0 0x9008      LDR      R9,[R0, #+8]
   2115          
   2116            if (hpcd->Init.dma_enable == 1U)
   \       0x1C   0x6928             LDR      R0,[R5, #+16]
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xD165             BNE.N    ??PCD_EP_OutXfrComplete_int_0
   2117            {
   2118              if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
   \       0x22   0xEA5F 0x7009      LSLS     R0,R9,#+28
   \       0x26   0xD50F             BPL.N    ??PCD_EP_OutXfrComplete_int_1
   2119              {
   2120                /* StupPktRcvd = 1 this is a setup packet */
   2121                if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
   2122                    ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
   \       0x28   0x....             LDR.N    R0,??DataTable3_1
   \       0x2A   0x4580             CMP      R8,R0
   \       0x2C   0xF0C0 0x8091      BCC.W    ??PCD_EP_OutXfrComplete_int_2
   \       0x30   0xEA5F 0x4009      LSLS     R0,R9,#+16
   \       0x34   0xF140 0x808D      BPL.W    ??PCD_EP_OutXfrComplete_int_2
   2123                {
   2124                  CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
   \       0x38   0xEB17 0x1044      ADDS     R0,R7,R4, LSL #+5
   \       0x3C   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x40   0xF44F 0x4100      MOV      R1,#+32768
   \       0x44   0x6081             STR      R1,[R0, #+8]
   \       0x46   0xE084             B.N      ??PCD_EP_OutXfrComplete_int_2
   2125                }
   2126              }
   2127              else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
   \                     ??PCD_EP_OutXfrComplete_int_1: (+1)
   \       0x48   0xEA5F 0x6089      LSLS     R0,R9,#+26
   \       0x4C   0xD506             BPL.N    ??PCD_EP_OutXfrComplete_int_3
   2128              {
   2129                CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
   \       0x4E   0xEB17 0x1044      ADDS     R0,R7,R4, LSL #+5
   \       0x52   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x56   0x2120             MOVS     R1,#+32
   \       0x58   0x6081             STR      R1,[R0, #+8]
   \       0x5A   0xE07A             B.N      ??PCD_EP_OutXfrComplete_int_2
   2130              }
   2131              else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
   \                     ??PCD_EP_OutXfrComplete_int_3: (+1)
   \       0x5C   0xF019 0x0F28      TST      R9,#0x28
   \       0x60   0xD177             BNE.N    ??PCD_EP_OutXfrComplete_int_2
   2132              {
   2133                /* StupPktRcvd = 1 this is a setup packet */
   2134                if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
   2135                    ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
   \       0x62   0x....             LDR.N    R0,??DataTable3_1
   \       0x64   0x4580             CMP      R8,R0
   \       0x66   0xD30A             BCC.N    ??PCD_EP_OutXfrComplete_int_4
   \       0x68   0xEA5F 0x4009      LSLS     R0,R9,#+16
   \       0x6C   0xD507             BPL.N    ??PCD_EP_OutXfrComplete_int_4
   2136                {
   2137                  CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
   \       0x6E   0xEB17 0x1044      ADDS     R0,R7,R4, LSL #+5
   \       0x72   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x76   0xF44F 0x4100      MOV      R1,#+32768
   \       0x7A   0x6081             STR      R1,[R0, #+8]
   \       0x7C   0xE069             B.N      ??PCD_EP_OutXfrComplete_int_2
   2138                }
   2139                else
   2140                {
   2141                  /* out data packet received over EP0 */
   2142                  hpcd->OUT_ep[epnum].xfer_count =
   2143                    hpcd->OUT_ep[epnum].maxpacket -
   2144                    (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
   \                     ??PCD_EP_OutXfrComplete_int_4: (+1)
   \       0x7E   0x201C             MOVS     R0,#+28
   \       0x80   0xFB00 0xF104      MUL      R1,R0,R4
   \       0x84   0x4429             ADD      R1,R5,R1
   \       0x86   0xF8D1 0x1204      LDR      R1,[R1, #+516]
   \       0x8A   0xEB17 0x1244      ADDS     R2,R7,R4, LSL #+5
   \       0x8E   0xF512 0x6230      ADDS     R2,R2,#+2816
   \       0x92   0x6912             LDR      R2,[R2, #+16]
   \       0x94   0x0352             LSLS     R2,R2,#+13
   \       0x96   0x0B52             LSRS     R2,R2,#+13
   \       0x98   0x1A89             SUBS     R1,R1,R2
   \       0x9A   0xFB00 0xF204      MUL      R2,R0,R4
   \       0x9E   0x442A             ADD      R2,R5,R2
   \       0xA0   0xF8C2 0x1214      STR      R1,[R2, #+532]
   2145          
   2146                  hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;
   \       0xA4   0xFB00 0xF104      MUL      R1,R0,R4
   \       0xA8   0x4429             ADD      R1,R5,R1
   \       0xAA   0xF8D1 0x1208      LDR      R1,[R1, #+520]
   \       0xAE   0xFB00 0xF204      MUL      R2,R0,R4
   \       0xB2   0x442A             ADD      R2,R5,R2
   \       0xB4   0xF8D2 0x2204      LDR      R2,[R2, #+516]
   \       0xB8   0x4411             ADD      R1,R1,R2
   \       0xBA   0xFB00 0xF204      MUL      R2,R0,R4
   \       0xBE   0x442A             ADD      R2,R5,R2
   \       0xC0   0xF8C2 0x1208      STR      R1,[R2, #+520]
   2147          
   2148                  if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
   \       0xC4   0x2C00             CMP      R4,#+0
   \       0xC6   0xD10C             BNE.N    ??PCD_EP_OutXfrComplete_int_5
   \       0xC8   0xFB00 0xF004      MUL      R0,R0,R4
   \       0xCC   0x4428             ADD      R0,R5,R0
   \       0xCE   0xF8D0 0x0210      LDR      R0,[R0, #+528]
   \       0xD2   0x2800             CMP      R0,#+0
   \       0xD4   0xD105             BNE.N    ??PCD_EP_OutXfrComplete_int_5
   2149                  {
   2150                    /* this is ZLP, so prepare EP0 for next setup */
   2151                    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
   \       0xD6   0xF515 0x7271      ADDS     R2,R5,#+964
   \       0xDA   0x2101             MOVS     R1,#+1
   \       0xDC   0x6828             LDR      R0,[R5, #+0]
   \       0xDE   0x.... 0x....      BL       USB_EP0_OutStart
   2152                  }
   2153          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
   2154                  hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
   2155          #else
   2156                  HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
   \                     ??PCD_EP_OutXfrComplete_int_5: (+1)
   \       0xE2   0x0021             MOVS     R1,R4
   \       0xE4   0xB2C9             UXTB     R1,R1
   \       0xE6   0x0028             MOVS     R0,R5
   \       0xE8   0x.... 0x....      BL       HAL_PCD_DataOutStageCallback
   \       0xEC   0xE031             B.N      ??PCD_EP_OutXfrComplete_int_2
   2157          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
   2158                }
   2159              }
   2160              else
   2161              {
   2162                /* ... */
   2163              }
   2164            }
   2165            else
   2166            {
   2167              if (gSNPSiD == USB_OTG_CORE_ID_310A)
   \                     ??PCD_EP_OutXfrComplete_int_0: (+1)
   \       0xEE   0x....             LDR.N    R0,??DataTable3_2
   \       0xF0   0x4580             CMP      R8,R0
   \       0xF2   0xD119             BNE.N    ??PCD_EP_OutXfrComplete_int_6
   2168              {
   2169                /* StupPktRcvd = 1 this is a setup packet */
   2170                if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
   \       0xF4   0xEA5F 0x4009      LSLS     R0,R9,#+16
   \       0xF8   0xD507             BPL.N    ??PCD_EP_OutXfrComplete_int_7
   2171                {
   2172                  CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
   \       0xFA   0xEB17 0x1044      ADDS     R0,R7,R4, LSL #+5
   \       0xFE   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x102   0xF44F 0x4100      MOV      R1,#+32768
   \      0x106   0x6081             STR      R1,[R0, #+8]
   \      0x108   0xE023             B.N      ??PCD_EP_OutXfrComplete_int_2
   2173                }
   2174                else
   2175                {
   2176                  if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
   \                     ??PCD_EP_OutXfrComplete_int_7: (+1)
   \      0x10A   0xEA5F 0x6089      LSLS     R0,R9,#+26
   \      0x10E   0xD505             BPL.N    ??PCD_EP_OutXfrComplete_int_8
   2177                  {
   2178                    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
   \      0x110   0xEB17 0x1044      ADDS     R0,R7,R4, LSL #+5
   \      0x114   0xF510 0x6030      ADDS     R0,R0,#+2816
   \      0x118   0x2120             MOVS     R1,#+32
   \      0x11A   0x6081             STR      R1,[R0, #+8]
   2179                  }
   2180          
   2181          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
   2182                  hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
   2183          #else
   2184                  HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
   \                     ??PCD_EP_OutXfrComplete_int_8: (+1)
   \      0x11C   0x0021             MOVS     R1,R4
   \      0x11E   0xB2C9             UXTB     R1,R1
   \      0x120   0x0028             MOVS     R0,R5
   \      0x122   0x.... 0x....      BL       HAL_PCD_DataOutStageCallback
   \      0x126   0xE014             B.N      ??PCD_EP_OutXfrComplete_int_2
   2185          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
   2186                }
   2187              }
   2188              else
   2189              {
   2190                if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
   \                     ??PCD_EP_OutXfrComplete_int_6: (+1)
   \      0x128   0x2C00             CMP      R4,#+0
   \      0x12A   0xD10D             BNE.N    ??PCD_EP_OutXfrComplete_int_9
   \      0x12C   0x201C             MOVS     R0,#+28
   \      0x12E   0xFB00 0xF004      MUL      R0,R0,R4
   \      0x132   0x4428             ADD      R0,R5,R0
   \      0x134   0xF8D0 0x0210      LDR      R0,[R0, #+528]
   \      0x138   0x2800             CMP      R0,#+0
   \      0x13A   0xD105             BNE.N    ??PCD_EP_OutXfrComplete_int_9
   2191                {
   2192                  /* this is ZLP, so prepare EP0 for next setup */
   2193                  (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
   \      0x13C   0xF515 0x7271      ADDS     R2,R5,#+964
   \      0x140   0x2100             MOVS     R1,#+0
   \      0x142   0x6828             LDR      R0,[R5, #+0]
   \      0x144   0x.... 0x....      BL       USB_EP0_OutStart
   2194                }
   2195          
   2196          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
   2197                hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
   2198          #else
   2199                HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
   \                     ??PCD_EP_OutXfrComplete_int_9: (+1)
   \      0x148   0x0021             MOVS     R1,R4
   \      0x14A   0xB2C9             UXTB     R1,R1
   \      0x14C   0x0028             MOVS     R0,R5
   \      0x14E   0x.... 0x....      BL       HAL_PCD_DataOutStageCallback
   2200          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
   2201              }
   2202            }
   2203          
   2204            return HAL_OK;
   \                     ??PCD_EP_OutXfrComplete_int_2: (+1)
   \      0x152   0x2000             MOVS     R0,#+0
   \      0x154   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   2205          }
   2206          
   2207          
   2208          /**
   2209            * @brief  process EP OUT setup packet received interrupt.
   2210            * @param  hpcd PCD handle
   2211            * @param  epnum endpoint number
   2212            * @retval HAL status
   2213            */

   \                                 In section .text, align 2, keep-with-next
   2214          static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
   2215          {
   \                     PCD_EP_OutSetupPacket_int: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   2216            USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
   \        0x8   0x6826             LDR      R6,[R4, #+0]
   2217            uint32_t USBx_BASE = (uint32_t)USBx;
   \        0xA   0x0037             MOVS     R7,R6
   2218            uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
   \        0xC   0xF8D6 0x8040      LDR      R8,[R6, #+64]
   2219            uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
   \       0x10   0xEB17 0x1045      ADDS     R0,R7,R5, LSL #+5
   \       0x14   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x18   0xF8D0 0x9008      LDR      R9,[R0, #+8]
   2220          
   2221            if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
   2222                ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
   \       0x1C   0x.... 0x....      LDR.W    R10,??DataTable3_1
   \       0x20   0x45D0             CMP      R8,R10
   \       0x22   0xD309             BCC.N    ??PCD_EP_OutSetupPacket_int_0
   \       0x24   0xEA5F 0x4009      LSLS     R0,R9,#+16
   \       0x28   0xD506             BPL.N    ??PCD_EP_OutSetupPacket_int_0
   2223            {
   2224              CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
   \       0x2A   0xEB17 0x1045      ADDS     R0,R7,R5, LSL #+5
   \       0x2E   0xF510 0x6030      ADDS     R0,R0,#+2816
   \       0x32   0xF44F 0x4100      MOV      R1,#+32768
   \       0x36   0x6081             STR      R1,[R0, #+8]
   2225            }
   2226          
   2227            /* Inform the upper layer that a setup packet is available */
   2228          #if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
   2229            hpcd->SetupStageCallback(hpcd);
   2230          #else
   2231            HAL_PCD_SetupStageCallback(hpcd);
   \                     ??PCD_EP_OutSetupPacket_int_0: (+1)
   \       0x38   0x0020             MOVS     R0,R4
   \       0x3A   0x.... 0x....      BL       HAL_PCD_SetupStageCallback
   2232          #endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
   2233          
   2234            if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
   \       0x3E   0x45D0             CMP      R8,R10
   \       0x40   0xD308             BCC.N    ??PCD_EP_OutSetupPacket_int_1
   \       0x42   0x6920             LDR      R0,[R4, #+16]
   \       0x44   0x2801             CMP      R0,#+1
   \       0x46   0xD105             BNE.N    ??PCD_EP_OutSetupPacket_int_1
   2235            {
   2236              (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
   \       0x48   0xF514 0x7271      ADDS     R2,R4,#+964
   \       0x4C   0x2101             MOVS     R1,#+1
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x.... 0x....      BL       USB_EP0_OutStart
   2237            }
   2238          
   2239            return HAL_OK;
   \                     ??PCD_EP_OutSetupPacket_int_1: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xE8BD 0x87F0      POP      {R4-R10,PC}
   2240          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x4001'3C14        DC32     0x40013c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x4F54'300B        DC32     0x4f54300b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x4F54'310A        DC32     0x4f54310a
   2241          #endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */
   2242          
   2243          
   2244          /**
   2245            * @}
   2246            */
   2247          #endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */
   2248          #endif /* HAL_PCD_MODULE_ENABLED */
   2249          
   2250          /**
   2251            * @}
   2252            */
   2253          
   2254          /**
   2255            * @}
   2256            */
   2257          
   2258          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_PCD_ActivateRemoteWakeup
         8   -> USB_ActivateRemoteWakeup
       0   HAL_PCD_ConnectCallback
       0   HAL_PCD_DataInStageCallback
       0   HAL_PCD_DataOutStageCallback
       8   HAL_PCD_DeActivateRemoteWakeup
         8   -> USB_DeActivateRemoteWakeup
       8   HAL_PCD_DeInit
         8   -> HAL_PCD_MspDeInit
         8   -> USB_StopDevice
      16   HAL_PCD_DevConnect
        16   -> USB_DevConnect
      16   HAL_PCD_DevDisconnect
        16   -> USB_DevDisconnect
       0   HAL_PCD_DisconnectCallback
      16   HAL_PCD_EP_Close
        16   -> USB_DeactivateEndpoint
      16   HAL_PCD_EP_ClrStall
        16   -> USB_EPClearStall
      16   HAL_PCD_EP_Flush
        16   -> USB_FlushRxFifo
        16   -> USB_FlushTxFifo
       0   HAL_PCD_EP_GetRxCount
      32   HAL_PCD_EP_Open
        32   -> USB_ActivateEndpoint
      24   HAL_PCD_EP_Receive
        24   -> USB_EP0StartXfer
        24   -> USB_EPStartXfer
      16   HAL_PCD_EP_SetStall
        16   -> USB_EP0_OutStart
        16   -> USB_EPSetStall
      24   HAL_PCD_EP_Transmit
        24   -> USB_EP0StartXfer
        24   -> USB_EPStartXfer
       0   HAL_PCD_GetState
      48   HAL_PCD_IRQHandler
        48   -> HAL_PCDEx_LPM_Callback
        48   -> HAL_PCD_ConnectCallback
        48   -> HAL_PCD_DataInStageCallback
        48   -> HAL_PCD_DisconnectCallback
        48   -> HAL_PCD_ISOINIncompleteCallback
        48   -> HAL_PCD_ISOOUTIncompleteCallback
        48   -> HAL_PCD_ResetCallback
        48   -> HAL_PCD_ResumeCallback
        48   -> HAL_PCD_SOFCallback
        48   -> HAL_PCD_SuspendCallback
        48   -> HAL_RCC_GetHCLKFreq
        48   -> PCD_EP_OutSetupPacket_int
        48   -> PCD_EP_OutXfrComplete_int
        48   -> PCD_WriteEmptyTxFifo
        48   -> USB_ActivateSetup
        48   -> USB_EP0_OutStart
        48   -> USB_FlushTxFifo
        48   -> USB_GetDevSpeed
        48   -> USB_GetMode
        48   -> USB_ReadDevAllInEpInterrupt
        48   -> USB_ReadDevAllOutEpInterrupt
        48   -> USB_ReadDevInEPInterrupt
        48   -> USB_ReadDevOutEPInterrupt
        48   -> USB_ReadInterrupts
        48   -> USB_ReadPacket
        48   -> USB_SetTurnaroundTime
       0   HAL_PCD_ISOINIncompleteCallback
       0   HAL_PCD_ISOOUTIncompleteCallback
      68   HAL_PCD_Init
        56   -> HAL_PCD_MspInit
        56   -> USB_CoreInit
        56   -> USB_DevDisconnect
        56   -> USB_DevInit
        56   -> USB_DisableGlobalInt
        56   -> USB_SetCurrentMode
        68   -> __aeabi_memcpy4
       0   HAL_PCD_MspDeInit
       0   HAL_PCD_MspInit
       0   HAL_PCD_ResetCallback
       0   HAL_PCD_ResumeCallback
       0   HAL_PCD_SOFCallback
      16   HAL_PCD_SetAddress
        16   -> USB_SetDevAddress
       0   HAL_PCD_SetupStageCallback
      16   HAL_PCD_Start
        16   -> USB_DevConnect
        16   -> USB_EnableGlobalInt
      16   HAL_PCD_Stop
        16   -> USB_DevDisconnect
        16   -> USB_DisableGlobalInt
        16   -> USB_FlushTxFifo
       0   HAL_PCD_SuspendCallback
       0   HAL_PCD_WKUP_IRQHandler
      32   PCD_EP_OutSetupPacket_int
        32   -> HAL_PCD_SetupStageCallback
        32   -> USB_EP0_OutStart
      32   PCD_EP_OutXfrComplete_int
        32   -> HAL_PCD_DataOutStageCallback
        32   -> USB_EP0_OutStart
      40   PCD_WriteEmptyTxFifo
        40   -> USB_WritePacket


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
      12  HAL_PCD_ActivateRemoteWakeup
       2  HAL_PCD_ConnectCallback
       2  HAL_PCD_DataInStageCallback
       2  HAL_PCD_DataOutStageCallback
      12  HAL_PCD_DeActivateRemoteWakeup
      48  HAL_PCD_DeInit
      60  HAL_PCD_DevConnect
      60  HAL_PCD_DevDisconnect
       2  HAL_PCD_DisconnectCallback
     102  HAL_PCD_EP_Close
     124  HAL_PCD_EP_ClrStall
      60  HAL_PCD_EP_Flush
      18  HAL_PCD_EP_GetRxCount
     164  HAL_PCD_EP_Open
     108  HAL_PCD_EP_Receive
     140  HAL_PCD_EP_SetStall
     108  HAL_PCD_EP_Transmit
       6  HAL_PCD_GetState
   1'356  HAL_PCD_IRQHandler
       2  HAL_PCD_ISOINIncompleteCallback
       2  HAL_PCD_ISOOUTIncompleteCallback
     372  HAL_PCD_Init
       2  HAL_PCD_MspDeInit
       2  HAL_PCD_MspInit
       2  HAL_PCD_ResetCallback
       2  HAL_PCD_ResumeCallback
       2  HAL_PCD_SOFCallback
      48  HAL_PCD_SetAddress
       2  HAL_PCD_SetupStageCallback
      66  HAL_PCD_Start
      74  HAL_PCD_Stop
       2  HAL_PCD_SuspendCallback
      32  HAL_PCD_WKUP_IRQHandler
      90  PCD_EP_OutSetupPacket_int
     344  PCD_EP_OutXfrComplete_int
     236  PCD_WriteEmptyTxFifo

 
 3'678 bytes in section .text
 
 3'652 bytes of CODE memory (+ 26 bytes shared)

Errors: none
Warnings: none
