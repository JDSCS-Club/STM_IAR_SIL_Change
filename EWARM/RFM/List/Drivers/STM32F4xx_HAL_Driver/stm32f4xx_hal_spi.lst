###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         21/Sep/2022  13:06:24
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_spi.c
#    Command line      =
#        -f
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_spi.o.rsp
#        (C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_spi.c
#        -D USE_HAL_DRIVER -D STM32F407xx -lC
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver
#        -o
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/App\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Core/Inc\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Include\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/display\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Library\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_spi.o.d
#    Locale            =  C
#    List file         =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_spi.lst
#    Object file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_spi.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_spi.c
      4            * @author  MCD Application Team
      5            * @brief   SPI HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Serial Peripheral Interface (SPI) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *           + Peripheral Control functions
     11            *           + Peripheral State functions
     12            *
     13            @verbatim
     14            ==============================================================================
     15                                  ##### How to use this driver #####
     16            ==============================================================================
     17              [..]
     18                The SPI HAL driver can be used as follows:
     19          
     20                (#) Declare a SPI_HandleTypeDef handle structure, for example:
     21                    SPI_HandleTypeDef  hspi;
     22          
     23                (#)Initialize the SPI low level resources by implementing the HAL_SPI_MspInit() API:
     24                    (##) Enable the SPIx interface clock
     25                    (##) SPI pins configuration
     26                        (+++) Enable the clock for the SPI GPIOs
     27                        (+++) Configure these SPI pins as alternate function push-pull
     28                    (##) NVIC configuration if you need to use interrupt process
     29                        (+++) Configure the SPIx interrupt priority
     30                        (+++) Enable the NVIC SPI IRQ handle
     31                    (##) DMA Configuration if you need to use DMA process
     32                        (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive Stream/Channel
     33                        (+++) Enable the DMAx clock
     34                        (+++) Configure the DMA handle parameters
     35                        (+++) Configure the DMA Tx or Rx Stream/Channel
     36                        (+++) Associate the initialized hdma_tx(or _rx)  handle to the hspi DMA Tx or Rx handle
     37                        (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on the DMA Tx or Rx Stream/Channel
     38          
     39                (#) Program the Mode, BidirectionalMode , Data size, Baudrate Prescaler, NSS
     40                    management, Clock polarity and phase, FirstBit and CRC configuration in the hspi Init structure.
     41          
     42                (#) Initialize the SPI registers by calling the HAL_SPI_Init() API:
     43                    (++) This API configures also the low level Hardware GPIO, CLOCK, CORTEX...etc)
     44                        by calling the customized HAL_SPI_MspInit() API.
     45               [..]
     46                 Circular mode restriction:
     47                (#) The DMA circular mode cannot be used when the SPI is configured in these modes:
     48                    (##) Master 2Lines RxOnly
     49                    (##) Master 1Line Rx
     50                (#) The CRC feature is not managed when the DMA circular mode is enabled
     51                (#) When the SPI DMA Pause/Stop features are used, we must use the following APIs
     52                    the HAL_SPI_DMAPause()/ HAL_SPI_DMAStop() only under the SPI callbacks
     53               [..]
     54                 Master Receive mode restriction:
     55                (#) In Master unidirectional receive-only mode (MSTR =1, BIDIMODE=0, RXONLY=1) or
     56                    bidirectional receive mode (MSTR=1, BIDIMODE=1, BIDIOE=0), to ensure that the SPI
     57                    does not initiate a new transfer the following procedure has to be respected:
     58                    (##) HAL_SPI_DeInit()
     59                    (##) HAL_SPI_Init()
     60               [..]
     61                 Callback registration:
     62          
     63                (#) The compilation flag USE_HAL_SPI_REGISTER_CALLBACKS when set to 1U
     64                    allows the user to configure dynamically the driver callbacks.
     65                    Use Functions HAL_SPI_RegisterCallback() to register an interrupt callback.
     66          
     67                    Function HAL_SPI_RegisterCallback() allows to register following callbacks:
     68                      (++) TxCpltCallback        : SPI Tx Completed callback
     69                      (++) RxCpltCallback        : SPI Rx Completed callback
     70                      (++) TxRxCpltCallback      : SPI TxRx Completed callback
     71                      (++) TxHalfCpltCallback    : SPI Tx Half Completed callback
     72                      (++) RxHalfCpltCallback    : SPI Rx Half Completed callback
     73                      (++) TxRxHalfCpltCallback  : SPI TxRx Half Completed callback
     74                      (++) ErrorCallback         : SPI Error callback
     75                      (++) AbortCpltCallback     : SPI Abort callback
     76                      (++) MspInitCallback       : SPI Msp Init callback
     77                      (++) MspDeInitCallback     : SPI Msp DeInit callback
     78                    This function takes as parameters the HAL peripheral handle, the Callback ID
     79                    and a pointer to the user callback function.
     80          
     81          
     82                (#) Use function HAL_SPI_UnRegisterCallback to reset a callback to the default
     83                    weak function.
     84                    HAL_SPI_UnRegisterCallback takes as parameters the HAL peripheral handle,
     85                    and the Callback ID.
     86                    This function allows to reset following callbacks:
     87                      (++) TxCpltCallback        : SPI Tx Completed callback
     88                      (++) RxCpltCallback        : SPI Rx Completed callback
     89                      (++) TxRxCpltCallback      : SPI TxRx Completed callback
     90                      (++) TxHalfCpltCallback    : SPI Tx Half Completed callback
     91                      (++) RxHalfCpltCallback    : SPI Rx Half Completed callback
     92                      (++) TxRxHalfCpltCallback  : SPI TxRx Half Completed callback
     93                      (++) ErrorCallback         : SPI Error callback
     94                      (++) AbortCpltCallback     : SPI Abort callback
     95                      (++) MspInitCallback       : SPI Msp Init callback
     96                      (++) MspDeInitCallback     : SPI Msp DeInit callback
     97          
     98                 [..]
     99                 By default, after the HAL_SPI_Init() and when the state is HAL_SPI_STATE_RESET
    100                 all callbacks are set to the corresponding weak functions:
    101                 examples HAL_SPI_MasterTxCpltCallback(), HAL_SPI_MasterRxCpltCallback().
    102                 Exception done for MspInit and MspDeInit functions that are
    103                 reset to the legacy weak functions in the HAL_SPI_Init()/ HAL_SPI_DeInit() only when
    104                 these callbacks are null (not registered beforehand).
    105                 If MspInit or MspDeInit are not null, the HAL_SPI_Init()/ HAL_SPI_DeInit()
    106                 keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
    107          
    108                 [..]
    109                 Callbacks can be registered/unregistered in HAL_SPI_STATE_READY state only.
    110                 Exception done MspInit/MspDeInit functions that can be registered/unregistered
    111                 in HAL_SPI_STATE_READY or HAL_SPI_STATE_RESET state,
    112                 thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    113                 Then, the user first registers the MspInit/MspDeInit user callbacks
    114                 using HAL_SPI_RegisterCallback() before calling HAL_SPI_DeInit()
    115                 or HAL_SPI_Init() function.
    116          
    117                 [..]
    118                 When the compilation define USE_HAL_PPP_REGISTER_CALLBACKS is set to 0 or
    119                 not defined, the callback registering feature is not available
    120                 and weak (surcharged) callbacks are used.
    121          
    122               [..]
    123                 Using the HAL it is not possible to reach all supported SPI frequency with the different SPI Modes,
    124                 the following table resume the max SPI frequency reached with data size 8bits/16bits,
    125                   according to frequency of the APBx Peripheral Clock (fPCLK) used by the SPI instance.
    126          
    127            @endverbatim
    128          
    129            Additional table :
    130          
    131                 DataSize = SPI_DATASIZE_8BIT:
    132                 +----------------------------------------------------------------------------------------------+
    133                 |         |                | 2Lines Fullduplex   |     2Lines RxOnly    |         1Line        |
    134                 | Process | Tranfert mode  |---------------------|----------------------|----------------------|
    135                 |         |                |  Master  |  Slave   |  Master   |  Slave   |  Master   |  Slave   |
    136                 |==============================================================================================|
    137                 |    T    |     Polling    | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
    138                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    139                 |    /    |     Interrupt  | Fpclk/4  | Fpclk/8  |    NA     |    NA    |    NA     |   NA     |
    140                 |    R    |----------------|----------|----------|-----------|----------|-----------|----------|
    141                 |    X    |       DMA      | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
    142                 |=========|================|==========|==========|===========|==========|===========|==========|
    143                 |         |     Polling    | Fpclk/2  | Fpclk/2  | Fpclk/64  | Fpclk/2  | Fpclk/64  | Fpclk/2  |
    144                 |         |----------------|----------|----------|-----------|----------|-----------|----------|
    145                 |    R    |     Interrupt  | Fpclk/8  | Fpclk/8  | Fpclk/64  | Fpclk/2  | Fpclk/64  | Fpclk/2  |
    146                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    147                 |         |       DMA      | Fpclk/2  | Fpclk/2  | Fpclk/64  | Fpclk/2  | Fpclk/128 | Fpclk/2  |
    148                 |=========|================|==========|==========|===========|==========|===========|==========|
    149                 |         |     Polling    | Fpclk/2  | Fpclk/4  |     NA    |    NA    | Fpclk/2   | Fpclk/64 |
    150                 |         |----------------|----------|----------|-----------|----------|-----------|----------|
    151                 |    T    |     Interrupt  | Fpclk/2  | Fpclk/4  |     NA    |    NA    | Fpclk/2   | Fpclk/64 |
    152                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    153                 |         |       DMA      | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/2   | Fpclk/128|
    154                 +----------------------------------------------------------------------------------------------+
    155          
    156                 DataSize = SPI_DATASIZE_16BIT:
    157                 +----------------------------------------------------------------------------------------------+
    158                 |         |                | 2Lines Fullduplex   |     2Lines RxOnly    |         1Line        |
    159                 | Process | Tranfert mode  |---------------------|----------------------|----------------------|
    160                 |         |                |  Master  |  Slave   |  Master   |  Slave   |  Master   |  Slave   |
    161                 |==============================================================================================|
    162                 |    T    |     Polling    | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
    163                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    164                 |    /    |     Interrupt  | Fpclk/4  | Fpclk/4  |    NA     |    NA    |    NA     |   NA     |
    165                 |    R    |----------------|----------|----------|-----------|----------|-----------|----------|
    166                 |    X    |       DMA      | Fpclk/2  | Fpclk/2  |    NA     |    NA    |    NA     |   NA     |
    167                 |=========|================|==========|==========|===========|==========|===========|==========|
    168                 |         |     Polling    | Fpclk/2  | Fpclk/2  | Fpclk/64  | Fpclk/2  | Fpclk/32  | Fpclk/2  |
    169                 |         |----------------|----------|----------|-----------|----------|-----------|----------|
    170                 |    R    |     Interrupt  | Fpclk/4  | Fpclk/4  | Fpclk/64  | Fpclk/2  | Fpclk/64  | Fpclk/2  |
    171                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    172                 |         |       DMA      | Fpclk/2  | Fpclk/2  | Fpclk/64  | Fpclk/2  | Fpclk/128 | Fpclk/2  |
    173                 |=========|================|==========|==========|===========|==========|===========|==========|
    174                 |         |     Polling    | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/2   | Fpclk/32 |
    175                 |         |----------------|----------|----------|-----------|----------|-----------|----------|
    176                 |    T    |     Interrupt  | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/2   | Fpclk/64 |
    177                 |    X    |----------------|----------|----------|-----------|----------|-----------|----------|
    178                 |         |       DMA      | Fpclk/2  | Fpclk/2  |     NA    |    NA    | Fpclk/2   | Fpclk/128|
    179                 +----------------------------------------------------------------------------------------------+
    180                 @note The max SPI frequency depend on SPI data size (8bits, 16bits),
    181                       SPI mode(2 Lines fullduplex, 2 lines RxOnly, 1 line TX/RX) and Process mode (Polling, IT, DMA).
    182                 @note
    183                      (#) TX/RX processes are HAL_SPI_TransmitReceive(), HAL_SPI_TransmitReceive_IT() and HAL_SPI_TransmitReceive_DMA()
    184                      (#) RX processes are HAL_SPI_Receive(), HAL_SPI_Receive_IT() and HAL_SPI_Receive_DMA()
    185                      (#) TX processes are HAL_SPI_Transmit(), HAL_SPI_Transmit_IT() and HAL_SPI_Transmit_DMA()
    186          
    187            ******************************************************************************
    188            * @attention
    189            *
    190            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
    191            * All rights reserved.</center></h2>
    192            *
    193            * This software component is licensed by ST under BSD 3-Clause license,
    194            * the "License"; You may not use this file except in compliance with the
    195            * License. You may obtain a copy of the License at:
    196            *                        opensource.org/licenses/BSD-3-Clause
    197            *
    198            ******************************************************************************
    199            */
    200          
    201          /* Includes ------------------------------------------------------------------*/
    202          #include "stm32f4xx_hal.h"
    203          
    204          /** @addtogroup STM32F4xx_HAL_Driver
    205            * @{
    206            */
    207          
    208          /** @defgroup SPI SPI
    209            * @brief SPI HAL module driver
    210            * @{
    211            */
    212          #ifdef HAL_SPI_MODULE_ENABLED
    213          
    214          /* Private typedef -----------------------------------------------------------*/
    215          /* Private defines -----------------------------------------------------------*/
    216          /** @defgroup SPI_Private_Constants SPI Private Constants
    217            * @{
    218            */
    219          #define SPI_DEFAULT_TIMEOUT 100U
    220          #define SPI_BSY_FLAG_WORKAROUND_TIMEOUT 1000U /*!< Timeout 1000 Âµs             */
    221          /**
    222            * @}
    223            */
    224          
    225          /* Private macros ------------------------------------------------------------*/
    226          /* Private variables ---------------------------------------------------------*/
    227          /* Private function prototypes -----------------------------------------------*/
    228          /** @defgroup SPI_Private_Functions SPI Private Functions
    229            * @{
    230            */
    231          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    232          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    233          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    234          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma);
    235          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma);
    236          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma);
    237          static void SPI_DMAError(DMA_HandleTypeDef *hdma);
    238          static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma);
    239          static void SPI_DMATxAbortCallback(DMA_HandleTypeDef *hdma);
    240          static void SPI_DMARxAbortCallback(DMA_HandleTypeDef *hdma);
    241          static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
    242                                                                 uint32_t Timeout, uint32_t Tickstart);
    243          static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    244          static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    245          static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    246          static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    247          static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    248          static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi);
    249          static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    250          static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi);
    251          #if (USE_SPI_CRC != 0U)
    252          static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi);
    253          static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi);
    254          static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi);
    255          static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi);
    256          #endif /* USE_SPI_CRC */
    257          static void SPI_AbortRx_ISR(SPI_HandleTypeDef *hspi);
    258          static void SPI_AbortTx_ISR(SPI_HandleTypeDef *hspi);
    259          static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi);
    260          static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi);
    261          static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi);
    262          static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart);
    263          static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart);
    264          /**
    265            * @}
    266            */
    267          
    268          /* Exported functions --------------------------------------------------------*/
    269          /** @defgroup SPI_Exported_Functions SPI Exported Functions
    270            * @{
    271            */
    272          
    273          /** @defgroup SPI_Exported_Functions_Group1 Initialization and de-initialization functions
    274            *  @brief    Initialization and Configuration functions
    275            *
    276          @verbatim
    277           ===============================================================================
    278                        ##### Initialization and de-initialization functions #####
    279           ===============================================================================
    280              [..]  This subsection provides a set of functions allowing to initialize and
    281                    de-initialize the SPIx peripheral:
    282          
    283                (+) User must implement HAL_SPI_MspInit() function in which he configures
    284                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC ).
    285          
    286                (+) Call the function HAL_SPI_Init() to configure the selected device with
    287                    the selected configuration:
    288                  (++) Mode
    289                  (++) Direction
    290                  (++) Data Size
    291                  (++) Clock Polarity and Phase
    292                  (++) NSS Management
    293                  (++) BaudRate Prescaler
    294                  (++) FirstBit
    295                  (++) TIMode
    296                  (++) CRC Calculation
    297                  (++) CRC Polynomial if CRC enabled
    298          
    299                (+) Call the function HAL_SPI_DeInit() to restore the default configuration
    300                    of the selected SPIx peripheral.
    301          
    302          @endverbatim
    303            * @{
    304            */
    305          
    306          /**
    307            * @brief  Initialize the SPI according to the specified parameters
    308            *         in the SPI_InitTypeDef and initialize the associated handle.
    309            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    310            *               the configuration information for SPI module.
    311            * @retval HAL status
    312            */

   \                                 In section .text, align 2, keep-with-next
    313          HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
    314          {
   \                     HAL_SPI_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    315            /* Check the SPI handle allocation */
    316            if (hspi == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_SPI_Init_0
    317            {
    318              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE03F             B.N      ??HAL_SPI_Init_1
    319            }
    320          
    321            /* Check the parameters */
    322            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    323            assert_param(IS_SPI_MODE(hspi->Init.Mode));
    324            assert_param(IS_SPI_DIRECTION(hspi->Init.Direction));
    325            assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
    326            assert_param(IS_SPI_NSS(hspi->Init.NSS));
    327            assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    328            assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
    329            assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
    330            if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
   \                     ??HAL_SPI_Init_0: (+1)
   \        0xC   0x6A60             LDR      R0,[R4, #+36]
   \        0xE   0x2800             CMP      R0,#+0
    331            {
    332              assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    333              assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));
    334            }
    335          #if (USE_SPI_CRC != 0U)
    336            assert_param(IS_SPI_CRC_CALCULATION(hspi->Init.CRCCalculation));
    337            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    338            {
    339              assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    340            }
    341          #else
    342            hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
   \                     ??HAL_SPI_Init_2: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x62A0             STR      R0,[R4, #+40]
    343          #endif /* USE_SPI_CRC */
    344          
    345            if (hspi->State == HAL_SPI_STATE_RESET)
   \       0x14   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD105             BNE.N    ??HAL_SPI_Init_3
    346            {
    347              /* Allocate lock resource and initialize it */
    348              hspi->Lock = HAL_UNLOCKED;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xF884 0x0050      STRB     R0,[R4, #+80]
    349          
    350          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
    351              /* Init the SPI Callback settings */
    352              hspi->TxCpltCallback       = HAL_SPI_TxCpltCallback;       /* Legacy weak TxCpltCallback       */
    353              hspi->RxCpltCallback       = HAL_SPI_RxCpltCallback;       /* Legacy weak RxCpltCallback       */
    354              hspi->TxRxCpltCallback     = HAL_SPI_TxRxCpltCallback;     /* Legacy weak TxRxCpltCallback     */
    355              hspi->TxHalfCpltCallback   = HAL_SPI_TxHalfCpltCallback;   /* Legacy weak TxHalfCpltCallback   */
    356              hspi->RxHalfCpltCallback   = HAL_SPI_RxHalfCpltCallback;   /* Legacy weak RxHalfCpltCallback   */
    357              hspi->TxRxHalfCpltCallback = HAL_SPI_TxRxHalfCpltCallback; /* Legacy weak TxRxHalfCpltCallback */
    358              hspi->ErrorCallback        = HAL_SPI_ErrorCallback;        /* Legacy weak ErrorCallback        */
    359              hspi->AbortCpltCallback    = HAL_SPI_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
    360          
    361              if (hspi->MspInitCallback == NULL)
    362              {
    363                hspi->MspInitCallback = HAL_SPI_MspInit; /* Legacy weak MspInit  */
    364              }
    365          
    366              /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    367              hspi->MspInitCallback(hspi);
    368          #else
    369              /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    370              HAL_SPI_MspInit(hspi);
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0x.... 0x....      BL       HAL_SPI_MspInit
    371          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
    372            }
    373          
    374            hspi->State = HAL_SPI_STATE_BUSY;
   \                     ??HAL_SPI_Init_3: (+1)
   \       0x28   0x2002             MOVS     R0,#+2
   \       0x2A   0xF884 0x0051      STRB     R0,[R4, #+81]
    375          
    376            /* Disable the selected SPI peripheral */
    377            __HAL_SPI_DISABLE(hspi);
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x6800             LDR      R0,[R0, #+0]
   \       0x32   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x36   0x6821             LDR      R1,[R4, #+0]
   \       0x38   0x6008             STR      R0,[R1, #+0]
    378          
    379            /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
    380            /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
    381            Communication speed, First bit and CRC calculation state */
    382            WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
    383                                            hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
    384                                            hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation));
   \       0x3A   0x6861             LDR      R1,[R4, #+4]
   \       0x3C   0x68A0             LDR      R0,[R4, #+8]
   \       0x3E   0x4301             ORRS     R1,R0,R1
   \       0x40   0x68E0             LDR      R0,[R4, #+12]
   \       0x42   0x4301             ORRS     R1,R0,R1
   \       0x44   0x6920             LDR      R0,[R4, #+16]
   \       0x46   0x4301             ORRS     R1,R0,R1
   \       0x48   0x6960             LDR      R0,[R4, #+20]
   \       0x4A   0x4301             ORRS     R1,R0,R1
   \       0x4C   0x69A0             LDR      R0,[R4, #+24]
   \       0x4E   0xF410 0x7000      ANDS     R0,R0,#0x200
   \       0x52   0x4301             ORRS     R1,R0,R1
   \       0x54   0x69E0             LDR      R0,[R4, #+28]
   \       0x56   0x4301             ORRS     R1,R0,R1
   \       0x58   0x6A20             LDR      R0,[R4, #+32]
   \       0x5A   0x4301             ORRS     R1,R0,R1
   \       0x5C   0x6AA0             LDR      R0,[R4, #+40]
   \       0x5E   0x4301             ORRS     R1,R0,R1
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x6001             STR      R1,[R0, #+0]
    385          
    386            /* Configure : NSS management, TI Mode */
    387            WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
   \       0x64   0x69A1             LDR      R1,[R4, #+24]
   \       0x66   0x0C09             LSRS     R1,R1,#+16
   \       0x68   0xF011 0x0104      ANDS     R1,R1,#0x4
   \       0x6C   0x6A60             LDR      R0,[R4, #+36]
   \       0x6E   0x4301             ORRS     R1,R0,R1
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x6041             STR      R1,[R0, #+4]
    388          
    389          #if (USE_SPI_CRC != 0U)
    390            /*---------------------------- SPIx CRCPOLY Configuration ------------------*/
    391            /* Configure : CRC Polynomial */
    392            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    393            {
    394              WRITE_REG(hspi->Instance->CRCPR, hspi->Init.CRCPolynomial);
    395            }
    396          #endif /* USE_SPI_CRC */
    397          
    398          #if defined(SPI_I2SCFGR_I2SMOD)
    399            /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
    400            CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x69C0             LDR      R0,[R0, #+28]
   \       0x78   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x7C   0x6821             LDR      R1,[R4, #+0]
   \       0x7E   0x61C8             STR      R0,[R1, #+28]
    401          #endif /* SPI_I2SCFGR_I2SMOD */
    402          
    403            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0x6560             STR      R0,[R4, #+84]
    404            hspi->State     = HAL_SPI_STATE_READY;
   \       0x84   0x2001             MOVS     R0,#+1
   \       0x86   0xF884 0x0051      STRB     R0,[R4, #+81]
    405          
    406            return HAL_OK;
   \       0x8A   0x2000             MOVS     R0,#+0
   \                     ??HAL_SPI_Init_1: (+1)
   \       0x8C   0xBD10             POP      {R4,PC}
    407          }
    408          
    409          /**
    410            * @brief  De-Initialize the SPI peripheral.
    411            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    412            *               the configuration information for SPI module.
    413            * @retval HAL status
    414            */

   \                                 In section .text, align 2, keep-with-next
    415          HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
    416          {
   \                     HAL_SPI_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    417            /* Check the SPI handle allocation */
    418            if (hspi == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_SPI_DeInit_0
    419            {
    420              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE014             B.N      ??HAL_SPI_DeInit_1
    421            }
    422          
    423            /* Check SPI Instance parameter */
    424            assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));
    425          
    426            hspi->State = HAL_SPI_STATE_BUSY;
   \                     ??HAL_SPI_DeInit_0: (+1)
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xF884 0x0051      STRB     R0,[R4, #+81]
    427          
    428            /* Disable the SPI Peripheral Clock */
    429            __HAL_SPI_DISABLE(hspi);
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x1A   0x6821             LDR      R1,[R4, #+0]
   \       0x1C   0x6008             STR      R0,[R1, #+0]
    430          
    431          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
    432            if (hspi->MspDeInitCallback == NULL)
    433            {
    434              hspi->MspDeInitCallback = HAL_SPI_MspDeInit; /* Legacy weak MspDeInit  */
    435            }
    436          
    437            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    438            hspi->MspDeInitCallback(hspi);
    439          #else
    440            /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
    441            HAL_SPI_MspDeInit(hspi);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       HAL_SPI_MspDeInit
    442          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
    443          
    444            hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x6560             STR      R0,[R4, #+84]
    445            hspi->State = HAL_SPI_STATE_RESET;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xF884 0x0051      STRB     R0,[R4, #+81]
    446          
    447            /* Release Lock */
    448            __HAL_UNLOCK(hspi);
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xF884 0x0050      STRB     R0,[R4, #+80]
    449          
    450            return HAL_OK;
   \       0x34   0x2000             MOVS     R0,#+0
   \                     ??HAL_SPI_DeInit_1: (+1)
   \       0x36   0xBD10             POP      {R4,PC}
    451          }
    452          
    453          /**
    454            * @brief  Initialize the SPI MSP.
    455            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    456            *               the configuration information for SPI module.
    457            * @retval None
    458            */

   \                                 In section .text, align 2
    459          __weak void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
    460          {
    461            /* Prevent unused argument(s) compilation warning */
    462            UNUSED(hspi);
    463          
    464            /* NOTE : This function should not be modified, when the callback is needed,
    465                      the HAL_SPI_MspInit should be implemented in the user file
    466             */
    467          }
   \                     HAL_SPI_MspInit: (+1)
   \        0x0   0x4770             BX       LR
    468          
    469          /**
    470            * @brief  De-Initialize the SPI MSP.
    471            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    472            *               the configuration information for SPI module.
    473            * @retval None
    474            */

   \                                 In section .text, align 2
    475          __weak void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
    476          {
    477            /* Prevent unused argument(s) compilation warning */
    478            UNUSED(hspi);
    479          
    480            /* NOTE : This function should not be modified, when the callback is needed,
    481                      the HAL_SPI_MspDeInit should be implemented in the user file
    482             */
    483          }
   \                     HAL_SPI_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
    484          
    485          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
    486          /**
    487            * @brief  Register a User SPI Callback
    488            *         To be used instead of the weak predefined callback
    489            * @param  hspi Pointer to a SPI_HandleTypeDef structure that contains
    490            *                the configuration information for the specified SPI.
    491            * @param  CallbackID ID of the callback to be registered
    492            * @param  pCallback pointer to the Callback function
    493            * @retval HAL status
    494            */
    495          HAL_StatusTypeDef HAL_SPI_RegisterCallback(SPI_HandleTypeDef *hspi, HAL_SPI_CallbackIDTypeDef CallbackID,
    496                                                     pSPI_CallbackTypeDef pCallback)
    497          {
    498            HAL_StatusTypeDef status = HAL_OK;
    499          
    500            if (pCallback == NULL)
    501            {
    502              /* Update the error code */
    503              hspi->ErrorCode |= HAL_SPI_ERROR_INVALID_CALLBACK;
    504          
    505              return HAL_ERROR;
    506            }
    507            /* Process locked */
    508            __HAL_LOCK(hspi);
    509          
    510            if (HAL_SPI_STATE_READY == hspi->State)
    511            {
    512              switch (CallbackID)
    513              {
    514                case HAL_SPI_TX_COMPLETE_CB_ID :
    515                  hspi->TxCpltCallback = pCallback;
    516                  break;
    517          
    518                case HAL_SPI_RX_COMPLETE_CB_ID :
    519                  hspi->RxCpltCallback = pCallback;
    520                  break;
    521          
    522                case HAL_SPI_TX_RX_COMPLETE_CB_ID :
    523                  hspi->TxRxCpltCallback = pCallback;
    524                  break;
    525          
    526                case HAL_SPI_TX_HALF_COMPLETE_CB_ID :
    527                  hspi->TxHalfCpltCallback = pCallback;
    528                  break;
    529          
    530                case HAL_SPI_RX_HALF_COMPLETE_CB_ID :
    531                  hspi->RxHalfCpltCallback = pCallback;
    532                  break;
    533          
    534                case HAL_SPI_TX_RX_HALF_COMPLETE_CB_ID :
    535                  hspi->TxRxHalfCpltCallback = pCallback;
    536                  break;
    537          
    538                case HAL_SPI_ERROR_CB_ID :
    539                  hspi->ErrorCallback = pCallback;
    540                  break;
    541          
    542                case HAL_SPI_ABORT_CB_ID :
    543                  hspi->AbortCpltCallback = pCallback;
    544                  break;
    545          
    546                case HAL_SPI_MSPINIT_CB_ID :
    547                  hspi->MspInitCallback = pCallback;
    548                  break;
    549          
    550                case HAL_SPI_MSPDEINIT_CB_ID :
    551                  hspi->MspDeInitCallback = pCallback;
    552                  break;
    553          
    554                default :
    555                  /* Update the error code */
    556                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    557          
    558                  /* Return error status */
    559                  status =  HAL_ERROR;
    560                  break;
    561              }
    562            }
    563            else if (HAL_SPI_STATE_RESET == hspi->State)
    564            {
    565              switch (CallbackID)
    566              {
    567                case HAL_SPI_MSPINIT_CB_ID :
    568                  hspi->MspInitCallback = pCallback;
    569                  break;
    570          
    571                case HAL_SPI_MSPDEINIT_CB_ID :
    572                  hspi->MspDeInitCallback = pCallback;
    573                  break;
    574          
    575                default :
    576                  /* Update the error code */
    577                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    578          
    579                  /* Return error status */
    580                  status =  HAL_ERROR;
    581                  break;
    582              }
    583            }
    584            else
    585            {
    586              /* Update the error code */
    587              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    588          
    589              /* Return error status */
    590              status =  HAL_ERROR;
    591            }
    592          
    593            /* Release Lock */
    594            __HAL_UNLOCK(hspi);
    595            return status;
    596          }
    597          
    598          /**
    599            * @brief  Unregister an SPI Callback
    600            *         SPI callback is redirected to the weak predefined callback
    601            * @param  hspi Pointer to a SPI_HandleTypeDef structure that contains
    602            *                the configuration information for the specified SPI.
    603            * @param  CallbackID ID of the callback to be unregistered
    604            * @retval HAL status
    605            */
    606          HAL_StatusTypeDef HAL_SPI_UnRegisterCallback(SPI_HandleTypeDef *hspi, HAL_SPI_CallbackIDTypeDef CallbackID)
    607          {
    608            HAL_StatusTypeDef status = HAL_OK;
    609          
    610            /* Process locked */
    611            __HAL_LOCK(hspi);
    612          
    613            if (HAL_SPI_STATE_READY == hspi->State)
    614            {
    615              switch (CallbackID)
    616              {
    617                case HAL_SPI_TX_COMPLETE_CB_ID :
    618                  hspi->TxCpltCallback = HAL_SPI_TxCpltCallback;             /* Legacy weak TxCpltCallback       */
    619                  break;
    620          
    621                case HAL_SPI_RX_COMPLETE_CB_ID :
    622                  hspi->RxCpltCallback = HAL_SPI_RxCpltCallback;             /* Legacy weak RxCpltCallback       */
    623                  break;
    624          
    625                case HAL_SPI_TX_RX_COMPLETE_CB_ID :
    626                  hspi->TxRxCpltCallback = HAL_SPI_TxRxCpltCallback;         /* Legacy weak TxRxCpltCallback     */
    627                  break;
    628          
    629                case HAL_SPI_TX_HALF_COMPLETE_CB_ID :
    630                  hspi->TxHalfCpltCallback = HAL_SPI_TxHalfCpltCallback;     /* Legacy weak TxHalfCpltCallback   */
    631                  break;
    632          
    633                case HAL_SPI_RX_HALF_COMPLETE_CB_ID :
    634                  hspi->RxHalfCpltCallback = HAL_SPI_RxHalfCpltCallback;     /* Legacy weak RxHalfCpltCallback   */
    635                  break;
    636          
    637                case HAL_SPI_TX_RX_HALF_COMPLETE_CB_ID :
    638                  hspi->TxRxHalfCpltCallback = HAL_SPI_TxRxHalfCpltCallback; /* Legacy weak TxRxHalfCpltCallback */
    639                  break;
    640          
    641                case HAL_SPI_ERROR_CB_ID :
    642                  hspi->ErrorCallback = HAL_SPI_ErrorCallback;               /* Legacy weak ErrorCallback        */
    643                  break;
    644          
    645                case HAL_SPI_ABORT_CB_ID :
    646                  hspi->AbortCpltCallback = HAL_SPI_AbortCpltCallback;       /* Legacy weak AbortCpltCallback    */
    647                  break;
    648          
    649                case HAL_SPI_MSPINIT_CB_ID :
    650                  hspi->MspInitCallback = HAL_SPI_MspInit;                   /* Legacy weak MspInit              */
    651                  break;
    652          
    653                case HAL_SPI_MSPDEINIT_CB_ID :
    654                  hspi->MspDeInitCallback = HAL_SPI_MspDeInit;               /* Legacy weak MspDeInit            */
    655                  break;
    656          
    657                default :
    658                  /* Update the error code */
    659                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    660          
    661                  /* Return error status */
    662                  status =  HAL_ERROR;
    663                  break;
    664              }
    665            }
    666            else if (HAL_SPI_STATE_RESET == hspi->State)
    667            {
    668              switch (CallbackID)
    669              {
    670                case HAL_SPI_MSPINIT_CB_ID :
    671                  hspi->MspInitCallback = HAL_SPI_MspInit;                   /* Legacy weak MspInit              */
    672                  break;
    673          
    674                case HAL_SPI_MSPDEINIT_CB_ID :
    675                  hspi->MspDeInitCallback = HAL_SPI_MspDeInit;               /* Legacy weak MspDeInit            */
    676                  break;
    677          
    678                default :
    679                  /* Update the error code */
    680                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    681          
    682                  /* Return error status */
    683                  status =  HAL_ERROR;
    684                  break;
    685              }
    686            }
    687            else
    688            {
    689              /* Update the error code */
    690              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_INVALID_CALLBACK);
    691          
    692              /* Return error status */
    693              status =  HAL_ERROR;
    694            }
    695          
    696            /* Release Lock */
    697            __HAL_UNLOCK(hspi);
    698            return status;
    699          }
    700          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
    701          /**
    702            * @}
    703            */
    704          
    705          /** @defgroup SPI_Exported_Functions_Group2 IO operation functions
    706            *  @brief   Data transfers functions
    707            *
    708          @verbatim
    709            ==============================================================================
    710                                ##### IO operation functions #####
    711           ===============================================================================
    712           [..]
    713              This subsection provides a set of functions allowing to manage the SPI
    714              data transfers.
    715          
    716              [..] The SPI supports master and slave mode :
    717          
    718              (#) There are two modes of transfer:
    719                 (++) Blocking mode: The communication is performed in polling mode.
    720                      The HAL status of all data processing is returned by the same function
    721                      after finishing transfer.
    722                 (++) No-Blocking mode: The communication is performed using Interrupts
    723                      or DMA, These APIs return the HAL status.
    724                      The end of the data processing will be indicated through the
    725                      dedicated SPI IRQ when using Interrupt mode or the DMA IRQ when
    726                      using DMA mode.
    727                      The HAL_SPI_TxCpltCallback(), HAL_SPI_RxCpltCallback() and HAL_SPI_TxRxCpltCallback() user callbacks
    728                      will be executed respectively at the end of the transmit or Receive process
    729                      The HAL_SPI_ErrorCallback()user callback will be executed when a communication error is detected
    730          
    731              (#) APIs provided for these 2 transfer modes (Blocking mode or Non blocking mode using either Interrupt or DMA)
    732                  exist for 1Line (simplex) and 2Lines (full duplex) modes.
    733          
    734          @endverbatim
    735            * @{
    736            */
    737          
    738          /**
    739            * @brief  Transmit an amount of data in blocking mode.
    740            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    741            *               the configuration information for SPI module.
    742            * @param  pData pointer to data buffer
    743            * @param  Size amount of data to be sent
    744            * @param  Timeout Timeout duration
    745            * @retval HAL status
    746            */

   \                                 In section .text, align 2, keep-with-next
    747          HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    748          {
   \                     HAL_SPI_Transmit: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x001C             MOVS     R4,R3
    749            uint32_t tickstart;
    750            HAL_StatusTypeDef errorcode = HAL_OK;
   \        0xC   0xF05F 0x0800      MOVS     R8,#+0
    751            uint16_t initial_TxXferCount;
    752          
    753            /* Check Direction parameter */
    754            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
    755          
    756            /* Process Locked */
    757            __HAL_LOCK(hspi);
   \       0x10   0xF896 0x0050      LDRB     R0,[R6, #+80]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD101             BNE.N    ??HAL_SPI_Transmit_0
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0xE0C4             B.N      ??HAL_SPI_Transmit_1
   \                     ??HAL_SPI_Transmit_0: (+1)
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xF886 0x0050      STRB     R0,[R6, #+80]
    758          
    759            /* Init tickstart for timeout management*/
    760            tickstart = HAL_GetTick();
   \       0x22   0x.... 0x....      BL       HAL_GetTick
   \       0x26   0x4681             MOV      R9,R0
    761            initial_TxXferCount = Size;
   \       0x28   0x46BA             MOV      R10,R7
    762          
    763            if (hspi->State != HAL_SPI_STATE_READY)
   \       0x2A   0xF896 0x0051      LDRB     R0,[R6, #+81]
   \       0x2E   0x2801             CMP      R0,#+1
   \       0x30   0xD002             BEQ.N    ??HAL_SPI_Transmit_2
    764            {
    765              errorcode = HAL_BUSY;
   \       0x32   0x2002             MOVS     R0,#+2
   \       0x34   0x4680             MOV      R8,R0
    766              goto error;
   \       0x36   0xE0AE             B.N      ??HAL_SPI_Transmit_3
    767            }
    768          
    769            if ((pData == NULL) || (Size == 0U))
   \                     ??HAL_SPI_Transmit_2: (+1)
   \       0x38   0x2D00             CMP      R5,#+0
   \       0x3A   0xD003             BEQ.N    ??HAL_SPI_Transmit_4
   \       0x3C   0x0038             MOVS     R0,R7
   \       0x3E   0xB280             UXTH     R0,R0
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD102             BNE.N    ??HAL_SPI_Transmit_5
    770            {
    771              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_Transmit_4: (+1)
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0x4680             MOV      R8,R0
    772              goto error;
   \       0x48   0xE0A5             B.N      ??HAL_SPI_Transmit_3
    773            }
    774          
    775            /* Set the transaction information */
    776            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \                     ??HAL_SPI_Transmit_5: (+1)
   \       0x4A   0x2003             MOVS     R0,#+3
   \       0x4C   0xF886 0x0051      STRB     R0,[R6, #+81]
    777            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x6570             STR      R0,[R6, #+84]
    778            hspi->pTxBuffPtr  = (uint8_t *)pData;
   \       0x54   0x6335             STR      R5,[R6, #+48]
    779            hspi->TxXferSize  = Size;
   \       0x56   0x86B7             STRH     R7,[R6, #+52]
    780            hspi->TxXferCount = Size;
   \       0x58   0x86F7             STRH     R7,[R6, #+54]
    781          
    782            /*Init field not used in handle to zero */
    783            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x63B0             STR      R0,[R6, #+56]
    784            hspi->RxXferSize  = 0U;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x87B0             STRH     R0,[R6, #+60]
    785            hspi->RxXferCount = 0U;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x87F0             STRH     R0,[R6, #+62]
    786            hspi->TxISR       = NULL;
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x6470             STR      R0,[R6, #+68]
    787            hspi->RxISR       = NULL;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x6430             STR      R0,[R6, #+64]
    788          
    789            /* Configure communication direction : 1Line */
    790            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \       0x6E   0x68B0             LDR      R0,[R6, #+8]
   \       0x70   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x74   0xD105             BNE.N    ??HAL_SPI_Transmit_6
    791            {
    792              SPI_1LINE_TX(hspi);
   \       0x76   0x6830             LDR      R0,[R6, #+0]
   \       0x78   0x6800             LDR      R0,[R0, #+0]
   \       0x7A   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \       0x7E   0x6831             LDR      R1,[R6, #+0]
   \       0x80   0x6008             STR      R0,[R1, #+0]
    793            }
    794          
    795          #if (USE_SPI_CRC != 0U)
    796            /* Reset CRC Calculation */
    797            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    798            {
    799              SPI_RESET_CRC(hspi);
    800            }
    801          #endif /* USE_SPI_CRC */
    802          
    803            /* Check if the SPI is already enabled */
    804            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Transmit_6: (+1)
   \       0x82   0x6830             LDR      R0,[R6, #+0]
   \       0x84   0x6800             LDR      R0,[R0, #+0]
   \       0x86   0x0640             LSLS     R0,R0,#+25
   \       0x88   0xD405             BMI.N    ??HAL_SPI_Transmit_7
    805            {
    806              /* Enable SPI peripheral */
    807              __HAL_SPI_ENABLE(hspi);
   \       0x8A   0x6830             LDR      R0,[R6, #+0]
   \       0x8C   0x6800             LDR      R0,[R0, #+0]
   \       0x8E   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x92   0x6831             LDR      R1,[R6, #+0]
   \       0x94   0x6008             STR      R0,[R1, #+0]
    808            }
    809          
    810            /* Transmit data in 16 Bit mode */
    811            if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
   \                     ??HAL_SPI_Transmit_7: (+1)
   \       0x96   0x68F0             LDR      R0,[R6, #+12]
   \       0x98   0xF5B0 0x6F00      CMP      R0,#+2048
   \       0x9C   0xD130             BNE.N    ??HAL_SPI_Transmit_8
    812            {
    813              if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
   \       0x9E   0x6870             LDR      R0,[R6, #+4]
   \       0xA0   0x2800             CMP      R0,#+0
   \       0xA2   0xD003             BEQ.N    ??HAL_SPI_Transmit_9
   \       0xA4   0x4650             MOV      R0,R10
   \       0xA6   0xB280             UXTH     R0,R0
   \       0xA8   0x2801             CMP      R0,#+1
   \       0xAA   0xD109             BNE.N    ??HAL_SPI_Transmit_10
    814              {
    815                hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \                     ??HAL_SPI_Transmit_9: (+1)
   \       0xAC   0x6B30             LDR      R0,[R6, #+48]
   \       0xAE   0x8800             LDRH     R0,[R0, #+0]
   \       0xB0   0x6831             LDR      R1,[R6, #+0]
   \       0xB2   0x60C8             STR      R0,[R1, #+12]
    816                hspi->pTxBuffPtr += sizeof(uint16_t);
   \       0xB4   0x6B30             LDR      R0,[R6, #+48]
   \       0xB6   0x1C80             ADDS     R0,R0,#+2
   \       0xB8   0x6330             STR      R0,[R6, #+48]
    817                hspi->TxXferCount--;
   \       0xBA   0x8EF0             LDRH     R0,[R6, #+54]
   \       0xBC   0x1E40             SUBS     R0,R0,#+1
   \       0xBE   0x86F0             STRH     R0,[R6, #+54]
    818              }
    819              /* Transmit data in 16 Bit mode */
    820              while (hspi->TxXferCount > 0U)
   \                     ??HAL_SPI_Transmit_10: (+1)
   \       0xC0   0x8EF0             LDRH     R0,[R6, #+54]
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD04D             BEQ.N    ??HAL_SPI_Transmit_11
    821              {
    822                /* Wait until TXE flag is set to send data */
    823                if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
   \       0xC6   0x6830             LDR      R0,[R6, #+0]
   \       0xC8   0x6880             LDR      R0,[R0, #+8]
   \       0xCA   0x0780             LSLS     R0,R0,#+30
   \       0xCC   0xD50A             BPL.N    ??HAL_SPI_Transmit_12
    824                {
    825                  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \       0xCE   0x6B30             LDR      R0,[R6, #+48]
   \       0xD0   0x8800             LDRH     R0,[R0, #+0]
   \       0xD2   0x6831             LDR      R1,[R6, #+0]
   \       0xD4   0x60C8             STR      R0,[R1, #+12]
    826                  hspi->pTxBuffPtr += sizeof(uint16_t);
   \       0xD6   0x6B30             LDR      R0,[R6, #+48]
   \       0xD8   0x1C80             ADDS     R0,R0,#+2
   \       0xDA   0x6330             STR      R0,[R6, #+48]
    827                  hspi->TxXferCount--;
   \       0xDC   0x8EF0             LDRH     R0,[R6, #+54]
   \       0xDE   0x1E40             SUBS     R0,R0,#+1
   \       0xE0   0x86F0             STRH     R0,[R6, #+54]
   \       0xE2   0xE7ED             B.N      ??HAL_SPI_Transmit_10
    828                }
    829                else
    830                {
    831                  /* Timeout management */
    832                  if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
   \                     ??HAL_SPI_Transmit_12: (+1)
   \       0xE4   0x.... 0x....      BL       HAL_GetTick
   \       0xE8   0xEBB0 0x0009      SUBS     R0,R0,R9
   \       0xEC   0x42A0             CMP      R0,R4
   \       0xEE   0xD302             BCC.N    ??HAL_SPI_Transmit_13
   \       0xF0   0xF114 0x0F01      CMN      R4,#+1
   \       0xF4   0xD101             BNE.N    ??HAL_SPI_Transmit_14
   \                     ??HAL_SPI_Transmit_13: (+1)
   \       0xF6   0x2C00             CMP      R4,#+0
   \       0xF8   0xD1E2             BNE.N    ??HAL_SPI_Transmit_10
    833                  {
    834                    errorcode = HAL_TIMEOUT;
   \                     ??HAL_SPI_Transmit_14: (+1)
   \       0xFA   0x2003             MOVS     R0,#+3
   \       0xFC   0x4680             MOV      R8,R0
    835                    goto error;
   \       0xFE   0xE04A             B.N      ??HAL_SPI_Transmit_3
    836                  }
    837                }
    838              }
    839            }
    840            /* Transmit data in 8 Bit mode */
    841            else
    842            {
    843              if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
   \                     ??HAL_SPI_Transmit_8: (+1)
   \      0x100   0x6870             LDR      R0,[R6, #+4]
   \      0x102   0x2800             CMP      R0,#+0
   \      0x104   0xD003             BEQ.N    ??HAL_SPI_Transmit_15
   \      0x106   0x4650             MOV      R0,R10
   \      0x108   0xB280             UXTH     R0,R0
   \      0x10A   0x2801             CMP      R0,#+1
   \      0x10C   0xD109             BNE.N    ??HAL_SPI_Transmit_16
    844              {
    845                *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
   \                     ??HAL_SPI_Transmit_15: (+1)
   \      0x10E   0x6B30             LDR      R0,[R6, #+48]
   \      0x110   0x7800             LDRB     R0,[R0, #+0]
   \      0x112   0x6831             LDR      R1,[R6, #+0]
   \      0x114   0x7308             STRB     R0,[R1, #+12]
    846                hspi->pTxBuffPtr += sizeof(uint8_t);
   \      0x116   0x6B30             LDR      R0,[R6, #+48]
   \      0x118   0x1C40             ADDS     R0,R0,#+1
   \      0x11A   0x6330             STR      R0,[R6, #+48]
    847                hspi->TxXferCount--;
   \      0x11C   0x8EF0             LDRH     R0,[R6, #+54]
   \      0x11E   0x1E40             SUBS     R0,R0,#+1
   \      0x120   0x86F0             STRH     R0,[R6, #+54]
    848              }
    849              while (hspi->TxXferCount > 0U)
   \                     ??HAL_SPI_Transmit_16: (+1)
   \      0x122   0x8EF0             LDRH     R0,[R6, #+54]
   \      0x124   0x2800             CMP      R0,#+0
   \      0x126   0xD01C             BEQ.N    ??HAL_SPI_Transmit_11
    850              {
    851                /* Wait until TXE flag is set to send data */
    852                if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
   \      0x128   0x6830             LDR      R0,[R6, #+0]
   \      0x12A   0x6880             LDR      R0,[R0, #+8]
   \      0x12C   0x0780             LSLS     R0,R0,#+30
   \      0x12E   0xD50A             BPL.N    ??HAL_SPI_Transmit_17
    853                {
    854                  *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
   \      0x130   0x6B30             LDR      R0,[R6, #+48]
   \      0x132   0x7800             LDRB     R0,[R0, #+0]
   \      0x134   0x6831             LDR      R1,[R6, #+0]
   \      0x136   0x7308             STRB     R0,[R1, #+12]
    855                  hspi->pTxBuffPtr += sizeof(uint8_t);
   \      0x138   0x6B30             LDR      R0,[R6, #+48]
   \      0x13A   0x1C40             ADDS     R0,R0,#+1
   \      0x13C   0x6330             STR      R0,[R6, #+48]
    856                  hspi->TxXferCount--;
   \      0x13E   0x8EF0             LDRH     R0,[R6, #+54]
   \      0x140   0x1E40             SUBS     R0,R0,#+1
   \      0x142   0x86F0             STRH     R0,[R6, #+54]
   \      0x144   0xE7ED             B.N      ??HAL_SPI_Transmit_16
    857                }
    858                else
    859                {
    860                  /* Timeout management */
    861                  if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
   \                     ??HAL_SPI_Transmit_17: (+1)
   \      0x146   0x.... 0x....      BL       HAL_GetTick
   \      0x14A   0xEBB0 0x0009      SUBS     R0,R0,R9
   \      0x14E   0x42A0             CMP      R0,R4
   \      0x150   0xD302             BCC.N    ??HAL_SPI_Transmit_18
   \      0x152   0xF114 0x0F01      CMN      R4,#+1
   \      0x156   0xD101             BNE.N    ??HAL_SPI_Transmit_19
   \                     ??HAL_SPI_Transmit_18: (+1)
   \      0x158   0x2C00             CMP      R4,#+0
   \      0x15A   0xD1E2             BNE.N    ??HAL_SPI_Transmit_16
    862                  {
    863                    errorcode = HAL_TIMEOUT;
   \                     ??HAL_SPI_Transmit_19: (+1)
   \      0x15C   0x2003             MOVS     R0,#+3
   \      0x15E   0x4680             MOV      R8,R0
    864                    goto error;
   \      0x160   0xE019             B.N      ??HAL_SPI_Transmit_3
    865                  }
    866                }
    867              }
    868            }
    869          #if (USE_SPI_CRC != 0U)
    870            /* Enable CRC Transmission */
    871            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    872            {
    873              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
    874            }
    875          #endif /* USE_SPI_CRC */
    876          
    877            /* Check the end of the transaction */
    878            if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_SPI_Transmit_11: (+1)
   \      0x162   0x464A             MOV      R2,R9
   \      0x164   0x0021             MOVS     R1,R4
   \      0x166   0x0030             MOVS     R0,R6
   \      0x168   0x.... 0x....      BL       SPI_EndRxTxTransaction
   \      0x16C   0x2800             CMP      R0,#+0
   \      0x16E   0xD001             BEQ.N    ??HAL_SPI_Transmit_20
    879            {
    880              hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
   \      0x170   0x2020             MOVS     R0,#+32
   \      0x172   0x6570             STR      R0,[R6, #+84]
    881            }
    882          
    883            /* Clear overrun flag in 2 Lines communication mode because received is not read */
    884            if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??HAL_SPI_Transmit_20: (+1)
   \      0x174   0x68B0             LDR      R0,[R6, #+8]
   \      0x176   0x2800             CMP      R0,#+0
   \      0x178   0xD108             BNE.N    ??HAL_SPI_Transmit_21
    885            {
    886              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \      0x17A   0x2000             MOVS     R0,#+0
   \      0x17C   0x9000             STR      R0,[SP, #+0]
   \      0x17E   0x6830             LDR      R0,[R6, #+0]
   \      0x180   0x68C0             LDR      R0,[R0, #+12]
   \      0x182   0x9000             STR      R0,[SP, #+0]
   \      0x184   0x6830             LDR      R0,[R6, #+0]
   \      0x186   0x6880             LDR      R0,[R0, #+8]
   \      0x188   0x9000             STR      R0,[SP, #+0]
   \      0x18A   0x9800             LDR      R0,[SP, #+0]
    887            }
    888          
    889            if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \                     ??HAL_SPI_Transmit_21: (+1)
   \      0x18C   0x6D70             LDR      R0,[R6, #+84]
   \      0x18E   0x2800             CMP      R0,#+0
   \      0x190   0xD001             BEQ.N    ??HAL_SPI_Transmit_3
    890            {
    891              errorcode = HAL_ERROR;
   \      0x192   0x2001             MOVS     R0,#+1
   \      0x194   0x4680             MOV      R8,R0
    892            }
    893          
    894          error:
    895            hspi->State = HAL_SPI_STATE_READY;
   \                     ??HAL_SPI_Transmit_3: (+1)
   \      0x196   0x2001             MOVS     R0,#+1
   \      0x198   0xF886 0x0051      STRB     R0,[R6, #+81]
    896            /* Process Unlocked */
    897            __HAL_UNLOCK(hspi);
   \      0x19C   0x2000             MOVS     R0,#+0
   \      0x19E   0xF886 0x0050      STRB     R0,[R6, #+80]
    898            return errorcode;
   \      0x1A2   0x4640             MOV      R0,R8
   \      0x1A4   0xB2C0             UXTB     R0,R0
   \                     ??HAL_SPI_Transmit_1: (+1)
   \      0x1A6   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
    899          }
    900          
    901          /**
    902            * @brief  Receive an amount of data in blocking mode.
    903            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
    904            *               the configuration information for SPI module.
    905            * @param  pData pointer to data buffer
    906            * @param  Size amount of data to be received
    907            * @param  Timeout Timeout duration
    908            * @retval HAL status
    909            */

   \                                 In section .text, align 2, keep-with-next
    910          HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    911          {
   \                     HAL_SPI_Receive: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x001C             MOVS     R4,R3
    912            uint32_t tickstart;
    913            HAL_StatusTypeDef errorcode = HAL_OK;
   \        0xC   0xF05F 0x0800      MOVS     R8,#+0
    914          
    915            if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
   \       0x10   0x6870             LDR      R0,[R6, #+4]
   \       0x12   0xF5B0 0x7F82      CMP      R0,#+260
   \       0x16   0xD10E             BNE.N    ??HAL_SPI_Receive_0
   \       0x18   0x68B0             LDR      R0,[R6, #+8]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD10B             BNE.N    ??HAL_SPI_Receive_0
    916            {
    917              hspi->State = HAL_SPI_STATE_BUSY_RX;
   \       0x1E   0x2004             MOVS     R0,#+4
   \       0x20   0xF886 0x0051      STRB     R0,[R6, #+81]
    918              /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
    919              return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
   \       0x24   0x9400             STR      R4,[SP, #+0]
   \       0x26   0x003B             MOVS     R3,R7
   \       0x28   0xB29B             UXTH     R3,R3
   \       0x2A   0x002A             MOVS     R2,R5
   \       0x2C   0x0029             MOVS     R1,R5
   \       0x2E   0x0030             MOVS     R0,R6
   \       0x30   0x.... 0x....      BL       HAL_SPI_TransmitReceive
   \       0x34   0xE09A             B.N      ??HAL_SPI_Receive_1
    920            }
    921          
    922            /* Process Locked */
    923            __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_0: (+1)
   \       0x36   0xF896 0x0050      LDRB     R0,[R6, #+80]
   \       0x3A   0x2801             CMP      R0,#+1
   \       0x3C   0xD101             BNE.N    ??HAL_SPI_Receive_2
   \       0x3E   0x2002             MOVS     R0,#+2
   \       0x40   0xE094             B.N      ??HAL_SPI_Receive_1
   \                     ??HAL_SPI_Receive_2: (+1)
   \       0x42   0x2001             MOVS     R0,#+1
   \       0x44   0xF886 0x0050      STRB     R0,[R6, #+80]
    924          
    925            /* Init tickstart for timeout management*/
    926            tickstart = HAL_GetTick();
   \       0x48   0x.... 0x....      BL       HAL_GetTick
   \       0x4C   0x4681             MOV      R9,R0
    927          
    928            if (hspi->State != HAL_SPI_STATE_READY)
   \       0x4E   0xF896 0x0051      LDRB     R0,[R6, #+81]
   \       0x52   0x2801             CMP      R0,#+1
   \       0x54   0xD002             BEQ.N    ??HAL_SPI_Receive_3
    929            {
    930              errorcode = HAL_BUSY;
   \       0x56   0x2002             MOVS     R0,#+2
   \       0x58   0x4680             MOV      R8,R0
    931              goto error;
   \       0x5A   0xE07F             B.N      ??HAL_SPI_Receive_4
    932            }
    933          
    934            if ((pData == NULL) || (Size == 0U))
   \                     ??HAL_SPI_Receive_3: (+1)
   \       0x5C   0x2D00             CMP      R5,#+0
   \       0x5E   0xD003             BEQ.N    ??HAL_SPI_Receive_5
   \       0x60   0x0038             MOVS     R0,R7
   \       0x62   0xB280             UXTH     R0,R0
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD102             BNE.N    ??HAL_SPI_Receive_6
    935            {
    936              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_Receive_5: (+1)
   \       0x68   0x2001             MOVS     R0,#+1
   \       0x6A   0x4680             MOV      R8,R0
    937              goto error;
   \       0x6C   0xE076             B.N      ??HAL_SPI_Receive_4
    938            }
    939          
    940            /* Set the transaction information */
    941            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \                     ??HAL_SPI_Receive_6: (+1)
   \       0x6E   0x2004             MOVS     R0,#+4
   \       0x70   0xF886 0x0051      STRB     R0,[R6, #+81]
    942            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0x6570             STR      R0,[R6, #+84]
    943            hspi->pRxBuffPtr  = (uint8_t *)pData;
   \       0x78   0x63B5             STR      R5,[R6, #+56]
    944            hspi->RxXferSize  = Size;
   \       0x7A   0x87B7             STRH     R7,[R6, #+60]
    945            hspi->RxXferCount = Size;
   \       0x7C   0x87F7             STRH     R7,[R6, #+62]
    946          
    947            /*Init field not used in handle to zero */
    948            hspi->pTxBuffPtr  = (uint8_t *)NULL;
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0x6330             STR      R0,[R6, #+48]
    949            hspi->TxXferSize  = 0U;
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0x86B0             STRH     R0,[R6, #+52]
    950            hspi->TxXferCount = 0U;
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0x86F0             STRH     R0,[R6, #+54]
    951            hspi->RxISR       = NULL;
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0x6430             STR      R0,[R6, #+64]
    952            hspi->TxISR       = NULL;
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0x6470             STR      R0,[R6, #+68]
    953          
    954          #if (USE_SPI_CRC != 0U)
    955            /* Reset CRC Calculation */
    956            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
    957            {
    958              SPI_RESET_CRC(hspi);
    959              /* this is done to handle the CRCNEXT before the latest data */
    960              hspi->RxXferCount--;
    961            }
    962          #endif /* USE_SPI_CRC */
    963          
    964            /* Configure communication direction: 1Line */
    965            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \       0x92   0x68B0             LDR      R0,[R6, #+8]
   \       0x94   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x98   0xD105             BNE.N    ??HAL_SPI_Receive_7
    966            {
    967              SPI_1LINE_RX(hspi);
   \       0x9A   0x6830             LDR      R0,[R6, #+0]
   \       0x9C   0x6800             LDR      R0,[R0, #+0]
   \       0x9E   0xF430 0x4080      BICS     R0,R0,#0x4000
   \       0xA2   0x6831             LDR      R1,[R6, #+0]
   \       0xA4   0x6008             STR      R0,[R1, #+0]
    968            }
    969          
    970            /* Check if the SPI is already enabled */
    971            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Receive_7: (+1)
   \       0xA6   0x6830             LDR      R0,[R6, #+0]
   \       0xA8   0x6800             LDR      R0,[R0, #+0]
   \       0xAA   0x0640             LSLS     R0,R0,#+25
   \       0xAC   0xD405             BMI.N    ??HAL_SPI_Receive_8
    972            {
    973              /* Enable SPI peripheral */
    974              __HAL_SPI_ENABLE(hspi);
   \       0xAE   0x6830             LDR      R0,[R6, #+0]
   \       0xB0   0x6800             LDR      R0,[R0, #+0]
   \       0xB2   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0xB6   0x6831             LDR      R1,[R6, #+0]
   \       0xB8   0x6008             STR      R0,[R1, #+0]
    975            }
    976          
    977            /* Receive data in 8 Bit mode */
    978            if (hspi->Init.DataSize == SPI_DATASIZE_8BIT)
   \                     ??HAL_SPI_Receive_8: (+1)
   \       0xBA   0x68F0             LDR      R0,[R6, #+12]
   \       0xBC   0x2800             CMP      R0,#+0
   \       0xBE   0xD11F             BNE.N    ??HAL_SPI_Receive_9
    979            {
    980              /* Transfer loop */
    981              while (hspi->RxXferCount > 0U)
   \                     ??HAL_SPI_Receive_10: (+1)
   \       0xC0   0x8FF0             LDRH     R0,[R6, #+62]
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD03C             BEQ.N    ??HAL_SPI_Receive_11
    982              {
    983                /* Check the RXNE flag */
    984                if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
   \       0xC6   0x6830             LDR      R0,[R6, #+0]
   \       0xC8   0x6880             LDR      R0,[R0, #+8]
   \       0xCA   0x07C0             LSLS     R0,R0,#+31
   \       0xCC   0xD50A             BPL.N    ??HAL_SPI_Receive_12
    985                {
    986                  /* read the received data */
    987                  (* (uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
   \       0xCE   0x6830             LDR      R0,[R6, #+0]
   \       0xD0   0x7B00             LDRB     R0,[R0, #+12]
   \       0xD2   0x6BB1             LDR      R1,[R6, #+56]
   \       0xD4   0x7008             STRB     R0,[R1, #+0]
    988                  hspi->pRxBuffPtr += sizeof(uint8_t);
   \       0xD6   0x6BB0             LDR      R0,[R6, #+56]
   \       0xD8   0x1C40             ADDS     R0,R0,#+1
   \       0xDA   0x63B0             STR      R0,[R6, #+56]
    989                  hspi->RxXferCount--;
   \       0xDC   0x8FF0             LDRH     R0,[R6, #+62]
   \       0xDE   0x1E40             SUBS     R0,R0,#+1
   \       0xE0   0x87F0             STRH     R0,[R6, #+62]
   \       0xE2   0xE7ED             B.N      ??HAL_SPI_Receive_10
    990                }
    991                else
    992                {
    993                  /* Timeout management */
    994                  if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
   \                     ??HAL_SPI_Receive_12: (+1)
   \       0xE4   0x.... 0x....      BL       HAL_GetTick
   \       0xE8   0xEBB0 0x0009      SUBS     R0,R0,R9
   \       0xEC   0x42A0             CMP      R0,R4
   \       0xEE   0xD302             BCC.N    ??HAL_SPI_Receive_13
   \       0xF0   0xF114 0x0F01      CMN      R4,#+1
   \       0xF4   0xD101             BNE.N    ??HAL_SPI_Receive_14
   \                     ??HAL_SPI_Receive_13: (+1)
   \       0xF6   0x2C00             CMP      R4,#+0
   \       0xF8   0xD1E2             BNE.N    ??HAL_SPI_Receive_10
    995                  {
    996                    errorcode = HAL_TIMEOUT;
   \                     ??HAL_SPI_Receive_14: (+1)
   \       0xFA   0x2003             MOVS     R0,#+3
   \       0xFC   0x4680             MOV      R8,R0
    997                    goto error;
   \       0xFE   0xE02D             B.N      ??HAL_SPI_Receive_4
    998                  }
    999                }
   1000              }
   1001            }
   1002            else
   1003            {
   1004              /* Transfer loop */
   1005              while (hspi->RxXferCount > 0U)
   \                     ??HAL_SPI_Receive_9: (+1)
   \      0x100   0x8FF0             LDRH     R0,[R6, #+62]
   \      0x102   0x2800             CMP      R0,#+0
   \      0x104   0xD01C             BEQ.N    ??HAL_SPI_Receive_11
   1006              {
   1007                /* Check the RXNE flag */
   1008                if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
   \      0x106   0x6830             LDR      R0,[R6, #+0]
   \      0x108   0x6880             LDR      R0,[R0, #+8]
   \      0x10A   0x07C0             LSLS     R0,R0,#+31
   \      0x10C   0xD50A             BPL.N    ??HAL_SPI_Receive_15
   1009                {
   1010                  *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
   \      0x10E   0x6830             LDR      R0,[R6, #+0]
   \      0x110   0x68C0             LDR      R0,[R0, #+12]
   \      0x112   0x6BB1             LDR      R1,[R6, #+56]
   \      0x114   0x8008             STRH     R0,[R1, #+0]
   1011                  hspi->pRxBuffPtr += sizeof(uint16_t);
   \      0x116   0x6BB0             LDR      R0,[R6, #+56]
   \      0x118   0x1C80             ADDS     R0,R0,#+2
   \      0x11A   0x63B0             STR      R0,[R6, #+56]
   1012                  hspi->RxXferCount--;
   \      0x11C   0x8FF0             LDRH     R0,[R6, #+62]
   \      0x11E   0x1E40             SUBS     R0,R0,#+1
   \      0x120   0x87F0             STRH     R0,[R6, #+62]
   \      0x122   0xE7ED             B.N      ??HAL_SPI_Receive_9
   1013                }
   1014                else
   1015                {
   1016                  /* Timeout management */
   1017                  if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
   \                     ??HAL_SPI_Receive_15: (+1)
   \      0x124   0x.... 0x....      BL       HAL_GetTick
   \      0x128   0xEBB0 0x0009      SUBS     R0,R0,R9
   \      0x12C   0x42A0             CMP      R0,R4
   \      0x12E   0xD302             BCC.N    ??HAL_SPI_Receive_16
   \      0x130   0xF114 0x0F01      CMN      R4,#+1
   \      0x134   0xD101             BNE.N    ??HAL_SPI_Receive_17
   \                     ??HAL_SPI_Receive_16: (+1)
   \      0x136   0x2C00             CMP      R4,#+0
   \      0x138   0xD1E2             BNE.N    ??HAL_SPI_Receive_9
   1018                  {
   1019                    errorcode = HAL_TIMEOUT;
   \                     ??HAL_SPI_Receive_17: (+1)
   \      0x13A   0x2003             MOVS     R0,#+3
   \      0x13C   0x4680             MOV      R8,R0
   1020                    goto error;
   \      0x13E   0xE00D             B.N      ??HAL_SPI_Receive_4
   1021                  }
   1022                }
   1023              }
   1024            }
   1025          
   1026          #if (USE_SPI_CRC != 0U)
   1027            /* Handle the CRC Transmission */
   1028            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1029            {
   1030              /* freeze the CRC before the latest data */
   1031              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   1032          
   1033              /* Read the latest data */
   1034              if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
   1035              {
   1036                /* the latest data has not been received */
   1037                errorcode = HAL_TIMEOUT;
   1038                goto error;
   1039              }
   1040          
   1041              /* Receive last data in 16 Bit mode */
   1042              if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
   1043              {
   1044                *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
   1045              }
   1046              /* Receive last data in 8 Bit mode */
   1047              else
   1048              {
   1049                (*(uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
   1050              }
   1051          
   1052              /* Wait the CRC data */
   1053              if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
   1054              {
   1055                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   1056                errorcode = HAL_TIMEOUT;
   1057                goto error;
   1058              }
   1059          
   1060              /* Read CRC to Flush DR and RXNE flag */
   1061              READ_REG(hspi->Instance->DR);
   1062            }
   1063          #endif /* USE_SPI_CRC */
   1064          
   1065            /* Check the end of the transaction */
   1066            if (SPI_EndRxTransaction(hspi, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_SPI_Receive_11: (+1)
   \      0x140   0x464A             MOV      R2,R9
   \      0x142   0x0021             MOVS     R1,R4
   \      0x144   0x0030             MOVS     R0,R6
   \      0x146   0x.... 0x....      BL       SPI_EndRxTransaction
   \      0x14A   0x2800             CMP      R0,#+0
   \      0x14C   0xD001             BEQ.N    ??HAL_SPI_Receive_18
   1067            {
   1068              hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
   \      0x14E   0x2020             MOVS     R0,#+32
   \      0x150   0x6570             STR      R0,[R6, #+84]
   1069            }
   1070          
   1071          #if (USE_SPI_CRC != 0U)
   1072            /* Check if CRC error occurred */
   1073            if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
   1074            {
   1075              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   1076              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   1077            }
   1078          #endif /* USE_SPI_CRC */
   1079          
   1080            if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \                     ??HAL_SPI_Receive_18: (+1)
   \      0x152   0x6D70             LDR      R0,[R6, #+84]
   \      0x154   0x2800             CMP      R0,#+0
   \      0x156   0xD001             BEQ.N    ??HAL_SPI_Receive_4
   1081            {
   1082              errorcode = HAL_ERROR;
   \      0x158   0x2001             MOVS     R0,#+1
   \      0x15A   0x4680             MOV      R8,R0
   1083            }
   1084          
   1085          error :
   1086            hspi->State = HAL_SPI_STATE_READY;
   \                     ??HAL_SPI_Receive_4: (+1)
   \      0x15C   0x2001             MOVS     R0,#+1
   \      0x15E   0xF886 0x0051      STRB     R0,[R6, #+81]
   1087            __HAL_UNLOCK(hspi);
   \      0x162   0x2000             MOVS     R0,#+0
   \      0x164   0xF886 0x0050      STRB     R0,[R6, #+80]
   1088            return errorcode;
   \      0x168   0x4640             MOV      R0,R8
   \      0x16A   0xB2C0             UXTB     R0,R0
   \                     ??HAL_SPI_Receive_1: (+1)
   \      0x16C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1089          }
   1090          
   1091          /**
   1092            * @brief  Transmit and Receive an amount of data in blocking mode.
   1093            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1094            *               the configuration information for SPI module.
   1095            * @param  pTxData pointer to transmission data buffer
   1096            * @param  pRxData pointer to reception data buffer
   1097            * @param  Size amount of data to be sent and received
   1098            * @param  Timeout Timeout duration
   1099            * @retval HAL status
   1100            */

   \                                 In section .text, align 2, keep-with-next
   1101          HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
   1102                                                    uint32_t Timeout)
   1103          {
   \                     HAL_SPI_TransmitReceive: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0007             MOVS     R7,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x4698             MOV      R8,R3
   \        0xC   0x9C0C             LDR      R4,[SP, #+48]
   1104            uint16_t             initial_TxXferCount;
   1105            uint32_t             tmp_mode;
   1106            HAL_SPI_StateTypeDef tmp_state;
   1107            uint32_t             tickstart;
   1108          
   1109            /* Variable used to alternate Rx and Tx during transfer */
   1110            uint32_t             txallowed = 1U;
   \        0xE   0xF05F 0x0901      MOVS     R9,#+1
   1111            HAL_StatusTypeDef    errorcode = HAL_OK;
   \       0x12   0xF05F 0x0A00      MOVS     R10,#+0
   1112          
   1113            /* Check Direction parameter */
   1114            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1115          
   1116            /* Process Locked */
   1117            __HAL_LOCK(hspi);
   \       0x16   0xF897 0x0050      LDRB     R0,[R7, #+80]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_0
   \       0x1E   0x2002             MOVS     R0,#+2
   \       0x20   0xE10A             B.N      ??HAL_SPI_TransmitReceive_1
   \                     ??HAL_SPI_TransmitReceive_0: (+1)
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xF887 0x0050      STRB     R0,[R7, #+80]
   1118          
   1119            /* Init tickstart for timeout management*/
   1120            tickstart = HAL_GetTick();
   \       0x28   0x.... 0x....      BL       HAL_GetTick
   \       0x2C   0x4683             MOV      R11,R0
   1121          
   1122            /* Init temporary variables */
   1123            tmp_state           = hspi->State;
   \       0x2E   0xF897 0x0051      LDRB     R0,[R7, #+81]
   \       0x32   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1124            tmp_mode            = hspi->Init.Mode;
   \       0x36   0x6878             LDR      R0,[R7, #+4]
   \       0x38   0x9002             STR      R0,[SP, #+8]
   1125            initial_TxXferCount = Size;
   \       0x3A   0xF8AD 0x8002      STRH     R8,[SP, #+2]
   1126          
   1127            if (!((tmp_state == HAL_SPI_STATE_READY) || \
   1128                  ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
   \       0x3E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD00D             BEQ.N    ??HAL_SPI_TransmitReceive_2
   \       0x46   0x9802             LDR      R0,[SP, #+8]
   \       0x48   0xF5B0 0x7F82      CMP      R0,#+260
   \       0x4C   0xD106             BNE.N    ??HAL_SPI_TransmitReceive_3
   \       0x4E   0x68B8             LDR      R0,[R7, #+8]
   \       0x50   0x2800             CMP      R0,#+0
   \       0x52   0xD103             BNE.N    ??HAL_SPI_TransmitReceive_3
   \       0x54   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x58   0x2804             CMP      R0,#+4
   \       0x5A   0xD002             BEQ.N    ??HAL_SPI_TransmitReceive_2
   1129            {
   1130              errorcode = HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_3: (+1)
   \       0x5C   0x2002             MOVS     R0,#+2
   \       0x5E   0x4682             MOV      R10,R0
   1131              goto error;
   \       0x60   0xE0E2             B.N      ??HAL_SPI_TransmitReceive_4
   1132            }
   1133          
   1134            if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
   \                     ??HAL_SPI_TransmitReceive_2: (+1)
   \       0x62   0x2D00             CMP      R5,#+0
   \       0x64   0xD005             BEQ.N    ??HAL_SPI_TransmitReceive_5
   \       0x66   0x2E00             CMP      R6,#+0
   \       0x68   0xD003             BEQ.N    ??HAL_SPI_TransmitReceive_5
   \       0x6A   0x4640             MOV      R0,R8
   \       0x6C   0xB280             UXTH     R0,R0
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xD102             BNE.N    ??HAL_SPI_TransmitReceive_6
   1135            {
   1136              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_TransmitReceive_5: (+1)
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0x4682             MOV      R10,R0
   1137              goto error;
   \       0x76   0xE0D7             B.N      ??HAL_SPI_TransmitReceive_4
   1138            }
   1139          
   1140            /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
   1141            if (hspi->State != HAL_SPI_STATE_BUSY_RX)
   \                     ??HAL_SPI_TransmitReceive_6: (+1)
   \       0x78   0xF897 0x0051      LDRB     R0,[R7, #+81]
   \       0x7C   0x2804             CMP      R0,#+4
   \       0x7E   0xD002             BEQ.N    ??HAL_SPI_TransmitReceive_7
   1142            {
   1143              hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   \       0x80   0x2005             MOVS     R0,#+5
   \       0x82   0xF887 0x0051      STRB     R0,[R7, #+81]
   1144            }
   1145          
   1146            /* Set the transaction information */
   1147            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_TransmitReceive_7: (+1)
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0x6578             STR      R0,[R7, #+84]
   1148            hspi->pRxBuffPtr  = (uint8_t *)pRxData;
   \       0x8A   0x63BE             STR      R6,[R7, #+56]
   1149            hspi->RxXferCount = Size;
   \       0x8C   0xF8A7 0x803E      STRH     R8,[R7, #+62]
   1150            hspi->RxXferSize  = Size;
   \       0x90   0xF8A7 0x803C      STRH     R8,[R7, #+60]
   1151            hspi->pTxBuffPtr  = (uint8_t *)pTxData;
   \       0x94   0x633D             STR      R5,[R7, #+48]
   1152            hspi->TxXferCount = Size;
   \       0x96   0xF8A7 0x8036      STRH     R8,[R7, #+54]
   1153            hspi->TxXferSize  = Size;
   \       0x9A   0xF8A7 0x8034      STRH     R8,[R7, #+52]
   1154          
   1155            /*Init field not used in handle to zero */
   1156            hspi->RxISR       = NULL;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x6438             STR      R0,[R7, #+64]
   1157            hspi->TxISR       = NULL;
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0x6478             STR      R0,[R7, #+68]
   1158          
   1159          #if (USE_SPI_CRC != 0U)
   1160            /* Reset CRC Calculation */
   1161            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1162            {
   1163              SPI_RESET_CRC(hspi);
   1164            }
   1165          #endif /* USE_SPI_CRC */
   1166          
   1167            /* Check if the SPI is already enabled */
   1168            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \       0xA6   0x6838             LDR      R0,[R7, #+0]
   \       0xA8   0x6800             LDR      R0,[R0, #+0]
   \       0xAA   0x0640             LSLS     R0,R0,#+25
   \       0xAC   0xD405             BMI.N    ??HAL_SPI_TransmitReceive_8
   1169            {
   1170              /* Enable SPI peripheral */
   1171              __HAL_SPI_ENABLE(hspi);
   \       0xAE   0x6838             LDR      R0,[R7, #+0]
   \       0xB0   0x6800             LDR      R0,[R0, #+0]
   \       0xB2   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0xB6   0x6839             LDR      R1,[R7, #+0]
   \       0xB8   0x6008             STR      R0,[R1, #+0]
   1172            }
   1173          
   1174            /* Transmit and Receive data in 16 Bit mode */
   1175            if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
   \                     ??HAL_SPI_TransmitReceive_8: (+1)
   \       0xBA   0x68F8             LDR      R0,[R7, #+12]
   \       0xBC   0xF5B0 0x6F00      CMP      R0,#+2048
   \       0xC0   0xD14C             BNE.N    ??HAL_SPI_TransmitReceive_9
   1176            {
   1177              if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
   \       0xC2   0x6878             LDR      R0,[R7, #+4]
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xD003             BEQ.N    ??HAL_SPI_TransmitReceive_10
   \       0xC8   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \       0xCC   0x2801             CMP      R0,#+1
   \       0xCE   0xD109             BNE.N    ??HAL_SPI_TransmitReceive_11
   1178              {
   1179                hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \                     ??HAL_SPI_TransmitReceive_10: (+1)
   \       0xD0   0x6B38             LDR      R0,[R7, #+48]
   \       0xD2   0x8800             LDRH     R0,[R0, #+0]
   \       0xD4   0x6839             LDR      R1,[R7, #+0]
   \       0xD6   0x60C8             STR      R0,[R1, #+12]
   1180                hspi->pTxBuffPtr += sizeof(uint16_t);
   \       0xD8   0x6B38             LDR      R0,[R7, #+48]
   \       0xDA   0x1C80             ADDS     R0,R0,#+2
   \       0xDC   0x6338             STR      R0,[R7, #+48]
   1181                hspi->TxXferCount--;
   \       0xDE   0x8EF8             LDRH     R0,[R7, #+54]
   \       0xE0   0x1E40             SUBS     R0,R0,#+1
   \       0xE2   0x86F8             STRH     R0,[R7, #+54]
   1182              }
   1183              while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
   \                     ??HAL_SPI_TransmitReceive_11: (+1)
   \       0xE4   0x8EF8             LDRH     R0,[R7, #+54]
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0xD103             BNE.N    ??HAL_SPI_TransmitReceive_12
   \       0xEA   0x8FF8             LDRH     R0,[R7, #+62]
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xF000 0x8083      BEQ.W    ??HAL_SPI_TransmitReceive_13
   1184              {
   1185                /* Check TXE flag */
   1186                if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
   \                     ??HAL_SPI_TransmitReceive_12: (+1)
   \       0xF2   0x6838             LDR      R0,[R7, #+0]
   \       0xF4   0x6880             LDR      R0,[R0, #+8]
   \       0xF6   0x0780             LSLS     R0,R0,#+30
   \       0xF8   0xD511             BPL.N    ??HAL_SPI_TransmitReceive_14
   \       0xFA   0x8EF8             LDRH     R0,[R7, #+54]
   \       0xFC   0x2800             CMP      R0,#+0
   \       0xFE   0xD00E             BEQ.N    ??HAL_SPI_TransmitReceive_14
   \      0x100   0xF1B9 0x0F01      CMP      R9,#+1
   \      0x104   0xD10B             BNE.N    ??HAL_SPI_TransmitReceive_14
   1187                {
   1188                  hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \      0x106   0x6B38             LDR      R0,[R7, #+48]
   \      0x108   0x8800             LDRH     R0,[R0, #+0]
   \      0x10A   0x6839             LDR      R1,[R7, #+0]
   \      0x10C   0x60C8             STR      R0,[R1, #+12]
   1189                  hspi->pTxBuffPtr += sizeof(uint16_t);
   \      0x10E   0x6B38             LDR      R0,[R7, #+48]
   \      0x110   0x1C80             ADDS     R0,R0,#+2
   \      0x112   0x6338             STR      R0,[R7, #+48]
   1190                  hspi->TxXferCount--;
   \      0x114   0x8EF8             LDRH     R0,[R7, #+54]
   \      0x116   0x1E40             SUBS     R0,R0,#+1
   \      0x118   0x86F8             STRH     R0,[R7, #+54]
   1191                  /* Next Data is a reception (Rx). Tx not allowed */
   1192                  txallowed = 0U;
   \      0x11A   0x2000             MOVS     R0,#+0
   \      0x11C   0x4681             MOV      R9,R0
   1193          
   1194          #if (USE_SPI_CRC != 0U)
   1195                  /* Enable CRC Transmission */
   1196                  if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   1197                  {
   1198                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   1199                  }
   1200          #endif /* USE_SPI_CRC */
   1201                }
   1202          
   1203                /* Check RXNE flag */
   1204                if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
   \                     ??HAL_SPI_TransmitReceive_14: (+1)
   \      0x11E   0x6838             LDR      R0,[R7, #+0]
   \      0x120   0x6880             LDR      R0,[R0, #+8]
   \      0x122   0x07C0             LSLS     R0,R0,#+31
   \      0x124   0xD50E             BPL.N    ??HAL_SPI_TransmitReceive_15
   \      0x126   0x8FF8             LDRH     R0,[R7, #+62]
   \      0x128   0x2800             CMP      R0,#+0
   \      0x12A   0xD00B             BEQ.N    ??HAL_SPI_TransmitReceive_15
   1205                {
   1206                  *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
   \      0x12C   0x6838             LDR      R0,[R7, #+0]
   \      0x12E   0x68C0             LDR      R0,[R0, #+12]
   \      0x130   0x6BB9             LDR      R1,[R7, #+56]
   \      0x132   0x8008             STRH     R0,[R1, #+0]
   1207                  hspi->pRxBuffPtr += sizeof(uint16_t);
   \      0x134   0x6BB8             LDR      R0,[R7, #+56]
   \      0x136   0x1C80             ADDS     R0,R0,#+2
   \      0x138   0x63B8             STR      R0,[R7, #+56]
   1208                  hspi->RxXferCount--;
   \      0x13A   0x8FF8             LDRH     R0,[R7, #+62]
   \      0x13C   0x1E40             SUBS     R0,R0,#+1
   \      0x13E   0x87F8             STRH     R0,[R7, #+62]
   1209                  /* Next Data is a Transmission (Tx). Tx is allowed */
   1210                  txallowed = 1U;
   \      0x140   0x2001             MOVS     R0,#+1
   \      0x142   0x4681             MOV      R9,R0
   1211                }
   1212                if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
   \                     ??HAL_SPI_TransmitReceive_15: (+1)
   \      0x144   0x.... 0x....      BL       HAL_GetTick
   \      0x148   0xEBB0 0x000B      SUBS     R0,R0,R11
   \      0x14C   0x42A0             CMP      R0,R4
   \      0x14E   0xD3C9             BCC.N    ??HAL_SPI_TransmitReceive_11
   \      0x150   0xF114 0x0F01      CMN      R4,#+1
   \      0x154   0xD0C6             BEQ.N    ??HAL_SPI_TransmitReceive_11
   1213                {
   1214                  errorcode = HAL_TIMEOUT;
   \      0x156   0x2003             MOVS     R0,#+3
   \      0x158   0x4682             MOV      R10,R0
   1215                  goto error;
   \      0x15A   0xE065             B.N      ??HAL_SPI_TransmitReceive_4
   1216                }
   1217              }
   1218            }
   1219            /* Transmit and Receive data in 8 Bit mode */
   1220            else
   1221            {
   1222              if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
   \                     ??HAL_SPI_TransmitReceive_9: (+1)
   \      0x15C   0x6878             LDR      R0,[R7, #+4]
   \      0x15E   0x2800             CMP      R0,#+0
   \      0x160   0xD003             BEQ.N    ??HAL_SPI_TransmitReceive_16
   \      0x162   0xF8BD 0x0002      LDRH     R0,[SP, #+2]
   \      0x166   0x2801             CMP      R0,#+1
   \      0x168   0xD109             BNE.N    ??HAL_SPI_TransmitReceive_17
   1223              {
   1224                *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
   \                     ??HAL_SPI_TransmitReceive_16: (+1)
   \      0x16A   0x6B38             LDR      R0,[R7, #+48]
   \      0x16C   0x7800             LDRB     R0,[R0, #+0]
   \      0x16E   0x6839             LDR      R1,[R7, #+0]
   \      0x170   0x7308             STRB     R0,[R1, #+12]
   1225                hspi->pTxBuffPtr += sizeof(uint8_t);
   \      0x172   0x6B38             LDR      R0,[R7, #+48]
   \      0x174   0x1C40             ADDS     R0,R0,#+1
   \      0x176   0x6338             STR      R0,[R7, #+48]
   1226                hspi->TxXferCount--;
   \      0x178   0x8EF8             LDRH     R0,[R7, #+54]
   \      0x17A   0x1E40             SUBS     R0,R0,#+1
   \      0x17C   0x86F8             STRH     R0,[R7, #+54]
   1227              }
   1228              while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
   \                     ??HAL_SPI_TransmitReceive_17: (+1)
   \      0x17E   0x8EF8             LDRH     R0,[R7, #+54]
   \      0x180   0x2800             CMP      R0,#+0
   \      0x182   0xD102             BNE.N    ??HAL_SPI_TransmitReceive_18
   \      0x184   0x8FF8             LDRH     R0,[R7, #+62]
   \      0x186   0x2800             CMP      R0,#+0
   \      0x188   0xD036             BEQ.N    ??HAL_SPI_TransmitReceive_13
   1229              {
   1230                /* Check TXE flag */
   1231                if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
   \                     ??HAL_SPI_TransmitReceive_18: (+1)
   \      0x18A   0x6838             LDR      R0,[R7, #+0]
   \      0x18C   0x6880             LDR      R0,[R0, #+8]
   \      0x18E   0x0780             LSLS     R0,R0,#+30
   \      0x190   0xD511             BPL.N    ??HAL_SPI_TransmitReceive_19
   \      0x192   0x8EF8             LDRH     R0,[R7, #+54]
   \      0x194   0x2800             CMP      R0,#+0
   \      0x196   0xD00E             BEQ.N    ??HAL_SPI_TransmitReceive_19
   \      0x198   0xF1B9 0x0F01      CMP      R9,#+1
   \      0x19C   0xD10B             BNE.N    ??HAL_SPI_TransmitReceive_19
   1232                {
   1233                  *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
   \      0x19E   0x6B38             LDR      R0,[R7, #+48]
   \      0x1A0   0x7800             LDRB     R0,[R0, #+0]
   \      0x1A2   0x6839             LDR      R1,[R7, #+0]
   \      0x1A4   0x7308             STRB     R0,[R1, #+12]
   1234                  hspi->pTxBuffPtr++;
   \      0x1A6   0x6B38             LDR      R0,[R7, #+48]
   \      0x1A8   0x1C40             ADDS     R0,R0,#+1
   \      0x1AA   0x6338             STR      R0,[R7, #+48]
   1235                  hspi->TxXferCount--;
   \      0x1AC   0x8EF8             LDRH     R0,[R7, #+54]
   \      0x1AE   0x1E40             SUBS     R0,R0,#+1
   \      0x1B0   0x86F8             STRH     R0,[R7, #+54]
   1236                  /* Next Data is a reception (Rx). Tx not allowed */
   1237                  txallowed = 0U;
   \      0x1B2   0x2000             MOVS     R0,#+0
   \      0x1B4   0x4681             MOV      R9,R0
   1238          
   1239          #if (USE_SPI_CRC != 0U)
   1240                  /* Enable CRC Transmission */
   1241                  if ((hspi->TxXferCount == 0U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   1242                  {
   1243                    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   1244                  }
   1245          #endif /* USE_SPI_CRC */
   1246                }
   1247          
   1248                /* Wait until RXNE flag is reset */
   1249                if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
   \                     ??HAL_SPI_TransmitReceive_19: (+1)
   \      0x1B6   0x6838             LDR      R0,[R7, #+0]
   \      0x1B8   0x6880             LDR      R0,[R0, #+8]
   \      0x1BA   0x07C0             LSLS     R0,R0,#+31
   \      0x1BC   0xD50E             BPL.N    ??HAL_SPI_TransmitReceive_20
   \      0x1BE   0x8FF8             LDRH     R0,[R7, #+62]
   \      0x1C0   0x2800             CMP      R0,#+0
   \      0x1C2   0xD00B             BEQ.N    ??HAL_SPI_TransmitReceive_20
   1250                {
   1251                  (*(uint8_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
   \      0x1C4   0x6838             LDR      R0,[R7, #+0]
   \      0x1C6   0x68C0             LDR      R0,[R0, #+12]
   \      0x1C8   0x6BB9             LDR      R1,[R7, #+56]
   \      0x1CA   0x7008             STRB     R0,[R1, #+0]
   1252                  hspi->pRxBuffPtr++;
   \      0x1CC   0x6BB8             LDR      R0,[R7, #+56]
   \      0x1CE   0x1C40             ADDS     R0,R0,#+1
   \      0x1D0   0x63B8             STR      R0,[R7, #+56]
   1253                  hspi->RxXferCount--;
   \      0x1D2   0x8FF8             LDRH     R0,[R7, #+62]
   \      0x1D4   0x1E40             SUBS     R0,R0,#+1
   \      0x1D6   0x87F8             STRH     R0,[R7, #+62]
   1254                  /* Next Data is a Transmission (Tx). Tx is allowed */
   1255                  txallowed = 1U;
   \      0x1D8   0x2001             MOVS     R0,#+1
   \      0x1DA   0x4681             MOV      R9,R0
   1256                }
   1257                if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
   \                     ??HAL_SPI_TransmitReceive_20: (+1)
   \      0x1DC   0x.... 0x....      BL       HAL_GetTick
   \      0x1E0   0xEBB0 0x000B      SUBS     R0,R0,R11
   \      0x1E4   0x42A0             CMP      R0,R4
   \      0x1E6   0xD302             BCC.N    ??HAL_SPI_TransmitReceive_21
   \      0x1E8   0xF114 0x0F01      CMN      R4,#+1
   \      0x1EC   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_22
   \                     ??HAL_SPI_TransmitReceive_21: (+1)
   \      0x1EE   0x2C00             CMP      R4,#+0
   \      0x1F0   0xD1C5             BNE.N    ??HAL_SPI_TransmitReceive_17
   1258                {
   1259                  errorcode = HAL_TIMEOUT;
   \                     ??HAL_SPI_TransmitReceive_22: (+1)
   \      0x1F2   0x2003             MOVS     R0,#+3
   \      0x1F4   0x4682             MOV      R10,R0
   1260                  goto error;
   \      0x1F6   0xE017             B.N      ??HAL_SPI_TransmitReceive_4
   1261                }
   1262              }
   1263            }
   1264          
   1265          #if (USE_SPI_CRC != 0U)
   1266            /* Read CRC from DR to close CRC calculation process */
   1267            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1268            {
   1269              /* Wait until TXE flag */
   1270              if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, Timeout, tickstart) != HAL_OK)
   1271              {
   1272                /* Error on the CRC reception */
   1273                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   1274                errorcode = HAL_TIMEOUT;
   1275                goto error;
   1276              }
   1277              /* Read CRC */
   1278              READ_REG(hspi->Instance->DR);
   1279            }
   1280          
   1281            /* Check if CRC error occurred */
   1282            if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
   1283            {
   1284              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   1285              /* Clear CRC Flag */
   1286              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   1287          
   1288              errorcode = HAL_ERROR;
   1289            }
   1290          #endif /* USE_SPI_CRC */
   1291          
   1292            /* Check the end of the transaction */
   1293            if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_SPI_TransmitReceive_13: (+1)
   \      0x1F8   0x465A             MOV      R2,R11
   \      0x1FA   0x0021             MOVS     R1,R4
   \      0x1FC   0x0038             MOVS     R0,R7
   \      0x1FE   0x.... 0x....      BL       SPI_EndRxTxTransaction
   \      0x202   0x2800             CMP      R0,#+0
   \      0x204   0xD004             BEQ.N    ??HAL_SPI_TransmitReceive_23
   1294            {
   1295              errorcode = HAL_ERROR;
   \      0x206   0x2001             MOVS     R0,#+1
   \      0x208   0x4682             MOV      R10,R0
   1296              hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
   \      0x20A   0x2020             MOVS     R0,#+32
   \      0x20C   0x6578             STR      R0,[R7, #+84]
   1297              goto error;
   \      0x20E   0xE00B             B.N      ??HAL_SPI_TransmitReceive_4
   1298            }
   1299          
   1300            /* Clear overrun flag in 2 Lines communication mode because received is not read */
   1301            if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??HAL_SPI_TransmitReceive_23: (+1)
   \      0x210   0x68B8             LDR      R0,[R7, #+8]
   \      0x212   0x2800             CMP      R0,#+0
   \      0x214   0xD108             BNE.N    ??HAL_SPI_TransmitReceive_4
   1302            {
   1303              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \      0x216   0x2000             MOVS     R0,#+0
   \      0x218   0x9001             STR      R0,[SP, #+4]
   \      0x21A   0x6838             LDR      R0,[R7, #+0]
   \      0x21C   0x68C0             LDR      R0,[R0, #+12]
   \      0x21E   0x9001             STR      R0,[SP, #+4]
   \      0x220   0x6838             LDR      R0,[R7, #+0]
   \      0x222   0x6880             LDR      R0,[R0, #+8]
   \      0x224   0x9001             STR      R0,[SP, #+4]
   \      0x226   0x9801             LDR      R0,[SP, #+4]
   1304            }
   1305          
   1306          error :
   1307            hspi->State = HAL_SPI_STATE_READY;
   \                     ??HAL_SPI_TransmitReceive_4: (+1)
   \      0x228   0x2001             MOVS     R0,#+1
   \      0x22A   0xF887 0x0051      STRB     R0,[R7, #+81]
   1308            __HAL_UNLOCK(hspi);
   \      0x22E   0x2000             MOVS     R0,#+0
   \      0x230   0xF887 0x0050      STRB     R0,[R7, #+80]
   1309            return errorcode;
   \      0x234   0x4650             MOV      R0,R10
   \      0x236   0xB2C0             UXTB     R0,R0
   \                     ??HAL_SPI_TransmitReceive_1: (+1)
   \      0x238   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   1310          }
   1311          
   1312          /**
   1313            * @brief  Transmit an amount of data in non-blocking mode with Interrupt.
   1314            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1315            *               the configuration information for SPI module.
   1316            * @param  pData pointer to data buffer
   1317            * @param  Size amount of data to be sent
   1318            * @retval HAL status
   1319            */

   \                                 In section .text, align 2, keep-with-next
   1320          HAL_StatusTypeDef HAL_SPI_Transmit_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1321          {
   \                     HAL_SPI_Transmit_IT: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x0003             MOVS     R3,R0
   1322            HAL_StatusTypeDef errorcode = HAL_OK;
   \        0x4   0x2400             MOVS     R4,#+0
   1323          
   1324            /* Check Direction parameter */
   1325            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
   1326          
   1327            /* Process Locked */
   1328            __HAL_LOCK(hspi);
   \        0x6   0xF893 0x0050      LDRB     R0,[R3, #+80]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE.N    ??HAL_SPI_Transmit_IT_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE04B             B.N      ??HAL_SPI_Transmit_IT_1
   \                     ??HAL_SPI_Transmit_IT_0: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xF883 0x0050      STRB     R0,[R3, #+80]
   1329          
   1330            if ((pData == NULL) || (Size == 0U))
   \       0x18   0x2900             CMP      R1,#+0
   \       0x1A   0xD003             BEQ.N    ??HAL_SPI_Transmit_IT_2
   \       0x1C   0x0010             MOVS     R0,R2
   \       0x1E   0xB280             UXTH     R0,R0
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD102             BNE.N    ??HAL_SPI_Transmit_IT_3
   1331            {
   1332              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_Transmit_IT_2: (+1)
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x0004             MOVS     R4,R0
   1333              goto error;
   \       0x28   0xE03A             B.N      ??HAL_SPI_Transmit_IT_4
   1334            }
   1335          
   1336            if (hspi->State != HAL_SPI_STATE_READY)
   \                     ??HAL_SPI_Transmit_IT_3: (+1)
   \       0x2A   0xF893 0x0051      LDRB     R0,[R3, #+81]
   \       0x2E   0x2801             CMP      R0,#+1
   \       0x30   0xD002             BEQ.N    ??HAL_SPI_Transmit_IT_5
   1337            {
   1338              errorcode = HAL_BUSY;
   \       0x32   0x2002             MOVS     R0,#+2
   \       0x34   0x0004             MOVS     R4,R0
   1339              goto error;
   \       0x36   0xE033             B.N      ??HAL_SPI_Transmit_IT_4
   1340            }
   1341          
   1342            /* Set the transaction information */
   1343            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \                     ??HAL_SPI_Transmit_IT_5: (+1)
   \       0x38   0x2003             MOVS     R0,#+3
   \       0x3A   0xF883 0x0051      STRB     R0,[R3, #+81]
   1344            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x6558             STR      R0,[R3, #+84]
   1345            hspi->pTxBuffPtr  = (uint8_t *)pData;
   \       0x42   0x6319             STR      R1,[R3, #+48]
   1346            hspi->TxXferSize  = Size;
   \       0x44   0x869A             STRH     R2,[R3, #+52]
   1347            hspi->TxXferCount = Size;
   \       0x46   0x86DA             STRH     R2,[R3, #+54]
   1348          
   1349            /* Init field not used in handle to zero */
   1350            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x6398             STR      R0,[R3, #+56]
   1351            hspi->RxXferSize  = 0U;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x8798             STRH     R0,[R3, #+60]
   1352            hspi->RxXferCount = 0U;
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x87D8             STRH     R0,[R3, #+62]
   1353            hspi->RxISR       = NULL;
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x6418             STR      R0,[R3, #+64]
   1354          
   1355            /* Set the function for IT treatment */
   1356            if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \       0x58   0x68D8             LDR      R0,[R3, #+12]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD003             BEQ.N    ??HAL_SPI_Transmit_IT_6
   1357            {
   1358              hspi->TxISR = SPI_TxISR_16BIT;
   \       0x5E   0x.... 0x....      LDR.W    R0,??DataTable5
   \       0x62   0x6458             STR      R0,[R3, #+68]
   \       0x64   0xE002             B.N      ??HAL_SPI_Transmit_IT_7
   1359            }
   1360            else
   1361            {
   1362              hspi->TxISR = SPI_TxISR_8BIT;
   \                     ??HAL_SPI_Transmit_IT_6: (+1)
   \       0x66   0x.... 0x....      LDR.W    R0,??DataTable5_1
   \       0x6A   0x6458             STR      R0,[R3, #+68]
   1363            }
   1364          
   1365            /* Configure communication direction : 1Line */
   1366            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \                     ??HAL_SPI_Transmit_IT_7: (+1)
   \       0x6C   0x6898             LDR      R0,[R3, #+8]
   \       0x6E   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x72   0xD105             BNE.N    ??HAL_SPI_Transmit_IT_8
   1367            {
   1368              SPI_1LINE_TX(hspi);
   \       0x74   0x6818             LDR      R0,[R3, #+0]
   \       0x76   0x6800             LDR      R0,[R0, #+0]
   \       0x78   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \       0x7C   0x681D             LDR      R5,[R3, #+0]
   \       0x7E   0x6028             STR      R0,[R5, #+0]
   1369            }
   1370          
   1371          #if (USE_SPI_CRC != 0U)
   1372            /* Reset CRC Calculation */
   1373            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1374            {
   1375              SPI_RESET_CRC(hspi);
   1376            }
   1377          #endif /* USE_SPI_CRC */
   1378          
   1379            /* Enable TXE and ERR interrupt */
   1380            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
   \                     ??HAL_SPI_Transmit_IT_8: (+1)
   \       0x80   0x6818             LDR      R0,[R3, #+0]
   \       0x82   0x6840             LDR      R0,[R0, #+4]
   \       0x84   0xF050 0x00A0      ORRS     R0,R0,#0xA0
   \       0x88   0x681D             LDR      R5,[R3, #+0]
   \       0x8A   0x6068             STR      R0,[R5, #+4]
   1381          
   1382          
   1383            /* Check if the SPI is already enabled */
   1384            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \       0x8C   0x6818             LDR      R0,[R3, #+0]
   \       0x8E   0x6800             LDR      R0,[R0, #+0]
   \       0x90   0x0640             LSLS     R0,R0,#+25
   \       0x92   0xD405             BMI.N    ??HAL_SPI_Transmit_IT_4
   1385            {
   1386              /* Enable SPI peripheral */
   1387              __HAL_SPI_ENABLE(hspi);
   \       0x94   0x6818             LDR      R0,[R3, #+0]
   \       0x96   0x6800             LDR      R0,[R0, #+0]
   \       0x98   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x9C   0x681D             LDR      R5,[R3, #+0]
   \       0x9E   0x6028             STR      R0,[R5, #+0]
   1388            }
   1389          
   1390          error :
   1391            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Transmit_IT_4: (+1)
   \       0xA0   0x2000             MOVS     R0,#+0
   \       0xA2   0xF883 0x0050      STRB     R0,[R3, #+80]
   1392            return errorcode;
   \       0xA6   0x0020             MOVS     R0,R4
   \       0xA8   0xB2C0             UXTB     R0,R0
   \                     ??HAL_SPI_Transmit_IT_1: (+1)
   \       0xAA   0xBC30             POP      {R4,R5}
   \       0xAC   0x4770             BX       LR
   1393          }
   1394          
   1395          /**
   1396            * @brief  Receive an amount of data in non-blocking mode with Interrupt.
   1397            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1398            *               the configuration information for SPI module.
   1399            * @param  pData pointer to data buffer
   1400            * @param  Size amount of data to be sent
   1401            * @retval HAL status
   1402            */

   \                                 In section .text, align 2, keep-with-next
   1403          HAL_StatusTypeDef HAL_SPI_Receive_IT(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1404          {
   \                     HAL_SPI_Receive_IT: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0016             MOVS     R6,R2
   1405            HAL_StatusTypeDef errorcode = HAL_OK;
   \        0x8   0x2700             MOVS     R7,#+0
   1406          
   1407            if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
   \        0xA   0x68A8             LDR      R0,[R5, #+8]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD10E             BNE.N    ??HAL_SPI_Receive_IT_0
   \       0x10   0x6868             LDR      R0,[R5, #+4]
   \       0x12   0xF5B0 0x7F82      CMP      R0,#+260
   \       0x16   0xD10A             BNE.N    ??HAL_SPI_Receive_IT_0
   1408            {
   1409              hspi->State = HAL_SPI_STATE_BUSY_RX;
   \       0x18   0x2004             MOVS     R0,#+4
   \       0x1A   0xF885 0x0051      STRB     R0,[R5, #+81]
   1410              /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
   1411              return HAL_SPI_TransmitReceive_IT(hspi, pData, pData, Size);
   \       0x1E   0x0033             MOVS     R3,R6
   \       0x20   0xB29B             UXTH     R3,R3
   \       0x22   0x0022             MOVS     R2,R4
   \       0x24   0x0021             MOVS     R1,R4
   \       0x26   0x0028             MOVS     R0,R5
   \       0x28   0x.... 0x....      BL       HAL_SPI_TransmitReceive_IT
   \       0x2C   0xE051             B.N      ??HAL_SPI_Receive_IT_1
   1412            }
   1413          
   1414            /* Process Locked */
   1415            __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_IT_0: (+1)
   \       0x2E   0xF895 0x0050      LDRB     R0,[R5, #+80]
   \       0x32   0x2801             CMP      R0,#+1
   \       0x34   0xD101             BNE.N    ??HAL_SPI_Receive_IT_2
   \       0x36   0x2002             MOVS     R0,#+2
   \       0x38   0xE04B             B.N      ??HAL_SPI_Receive_IT_1
   \                     ??HAL_SPI_Receive_IT_2: (+1)
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0xF885 0x0050      STRB     R0,[R5, #+80]
   1416          
   1417            if (hspi->State != HAL_SPI_STATE_READY)
   \       0x40   0xF895 0x0051      LDRB     R0,[R5, #+81]
   \       0x44   0x2801             CMP      R0,#+1
   \       0x46   0xD002             BEQ.N    ??HAL_SPI_Receive_IT_3
   1418            {
   1419              errorcode = HAL_BUSY;
   \       0x48   0x2002             MOVS     R0,#+2
   \       0x4A   0x0007             MOVS     R7,R0
   1420              goto error;
   \       0x4C   0xE03C             B.N      ??HAL_SPI_Receive_IT_4
   1421            }
   1422          
   1423            if ((pData == NULL) || (Size == 0U))
   \                     ??HAL_SPI_Receive_IT_3: (+1)
   \       0x4E   0x2C00             CMP      R4,#+0
   \       0x50   0xD003             BEQ.N    ??HAL_SPI_Receive_IT_5
   \       0x52   0x0030             MOVS     R0,R6
   \       0x54   0xB280             UXTH     R0,R0
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD102             BNE.N    ??HAL_SPI_Receive_IT_6
   1424            {
   1425              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_Receive_IT_5: (+1)
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0x0007             MOVS     R7,R0
   1426              goto error;
   \       0x5E   0xE033             B.N      ??HAL_SPI_Receive_IT_4
   1427            }
   1428          
   1429            /* Set the transaction information */
   1430            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \                     ??HAL_SPI_Receive_IT_6: (+1)
   \       0x60   0x2004             MOVS     R0,#+4
   \       0x62   0xF885 0x0051      STRB     R0,[R5, #+81]
   1431            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x6568             STR      R0,[R5, #+84]
   1432            hspi->pRxBuffPtr  = (uint8_t *)pData;
   \       0x6A   0x63AC             STR      R4,[R5, #+56]
   1433            hspi->RxXferSize  = Size;
   \       0x6C   0x87AE             STRH     R6,[R5, #+60]
   1434            hspi->RxXferCount = Size;
   \       0x6E   0x87EE             STRH     R6,[R5, #+62]
   1435          
   1436            /* Init field not used in handle to zero */
   1437            hspi->pTxBuffPtr  = (uint8_t *)NULL;
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x6328             STR      R0,[R5, #+48]
   1438            hspi->TxXferSize  = 0U;
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0x86A8             STRH     R0,[R5, #+52]
   1439            hspi->TxXferCount = 0U;
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0x86E8             STRH     R0,[R5, #+54]
   1440            hspi->TxISR       = NULL;
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0x6468             STR      R0,[R5, #+68]
   1441          
   1442            /* Set the function for IT treatment */
   1443            if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \       0x80   0x68E8             LDR      R0,[R5, #+12]
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD003             BEQ.N    ??HAL_SPI_Receive_IT_7
   1444            {
   1445              hspi->RxISR = SPI_RxISR_16BIT;
   \       0x86   0x.... 0x....      LDR.W    R0,??DataTable5_2
   \       0x8A   0x6428             STR      R0,[R5, #+64]
   \       0x8C   0xE002             B.N      ??HAL_SPI_Receive_IT_8
   1446            }
   1447            else
   1448            {
   1449              hspi->RxISR = SPI_RxISR_8BIT;
   \                     ??HAL_SPI_Receive_IT_7: (+1)
   \       0x8E   0x.... 0x....      LDR.W    R0,??DataTable5_3
   \       0x92   0x6428             STR      R0,[R5, #+64]
   1450            }
   1451          
   1452            /* Configure communication direction : 1Line */
   1453            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \                     ??HAL_SPI_Receive_IT_8: (+1)
   \       0x94   0x68A8             LDR      R0,[R5, #+8]
   \       0x96   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x9A   0xD105             BNE.N    ??HAL_SPI_Receive_IT_9
   1454            {
   1455              SPI_1LINE_RX(hspi);
   \       0x9C   0x6828             LDR      R0,[R5, #+0]
   \       0x9E   0x6800             LDR      R0,[R0, #+0]
   \       0xA0   0xF430 0x4080      BICS     R0,R0,#0x4000
   \       0xA4   0x6829             LDR      R1,[R5, #+0]
   \       0xA6   0x6008             STR      R0,[R1, #+0]
   1456            }
   1457          
   1458          #if (USE_SPI_CRC != 0U)
   1459            /* Reset CRC Calculation */
   1460            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1461            {
   1462              SPI_RESET_CRC(hspi);
   1463            }
   1464          #endif /* USE_SPI_CRC */
   1465          
   1466            /* Enable TXE and ERR interrupt */
   1467            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??HAL_SPI_Receive_IT_9: (+1)
   \       0xA8   0x6828             LDR      R0,[R5, #+0]
   \       0xAA   0x6840             LDR      R0,[R0, #+4]
   \       0xAC   0xF050 0x0060      ORRS     R0,R0,#0x60
   \       0xB0   0x6829             LDR      R1,[R5, #+0]
   \       0xB2   0x6048             STR      R0,[R1, #+4]
   1468          
   1469            /* Note : The SPI must be enabled after unlocking current process
   1470                      to avoid the risk of SPI interrupt handle execution before current
   1471                      process unlock */
   1472          
   1473            /* Check if the SPI is already enabled */
   1474            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \       0xB4   0x6828             LDR      R0,[R5, #+0]
   \       0xB6   0x6800             LDR      R0,[R0, #+0]
   \       0xB8   0x0640             LSLS     R0,R0,#+25
   \       0xBA   0xD405             BMI.N    ??HAL_SPI_Receive_IT_4
   1475            {
   1476              /* Enable SPI peripheral */
   1477              __HAL_SPI_ENABLE(hspi);
   \       0xBC   0x6828             LDR      R0,[R5, #+0]
   \       0xBE   0x6800             LDR      R0,[R0, #+0]
   \       0xC0   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0xC4   0x6829             LDR      R1,[R5, #+0]
   \       0xC6   0x6008             STR      R0,[R1, #+0]
   1478            }
   1479          
   1480          error :
   1481            /* Process Unlocked */
   1482            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Receive_IT_4: (+1)
   \       0xC8   0x2000             MOVS     R0,#+0
   \       0xCA   0xF885 0x0050      STRB     R0,[R5, #+80]
   1483            return errorcode;
   \       0xCE   0x0038             MOVS     R0,R7
   \       0xD0   0xB2C0             UXTB     R0,R0
   \                     ??HAL_SPI_Receive_IT_1: (+1)
   \       0xD2   0xBDF2             POP      {R1,R4-R7,PC}
   1484          }
   1485          
   1486          /**
   1487            * @brief  Transmit and Receive an amount of data in non-blocking mode with Interrupt.
   1488            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1489            *               the configuration information for SPI module.
   1490            * @param  pTxData pointer to transmission data buffer
   1491            * @param  pRxData pointer to reception data buffer
   1492            * @param  Size amount of data to be sent and received
   1493            * @retval HAL status
   1494            */

   \                                 In section .text, align 2, keep-with-next
   1495          HAL_StatusTypeDef HAL_SPI_TransmitReceive_IT(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
   1496          {
   \                     HAL_SPI_TransmitReceive_IT: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   \        0x2   0x0004             MOVS     R4,R0
   1497            uint32_t             tmp_mode;
   1498            HAL_SPI_StateTypeDef tmp_state;
   1499            HAL_StatusTypeDef    errorcode = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
   1500          
   1501            /* Check Direction parameter */
   1502            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1503          
   1504            /* Process locked */
   1505            __HAL_LOCK(hspi);
   \        0x6   0xF894 0x0050      LDRB     R0,[R4, #+80]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_IT_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE059             B.N      ??HAL_SPI_TransmitReceive_IT_1
   \                     ??HAL_SPI_TransmitReceive_IT_0: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0xF884 0x0050      STRB     R0,[R4, #+80]
   1506          
   1507            /* Init temporary variables */
   1508            tmp_state           = hspi->State;
   \       0x18   0xF894 0x6051      LDRB     R6,[R4, #+81]
   1509            tmp_mode            = hspi->Init.Mode;
   \       0x1C   0x6867             LDR      R7,[R4, #+4]
   1510          
   1511            if (!((tmp_state == HAL_SPI_STATE_READY) || \
   1512                  ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
   \       0x1E   0x0030             MOVS     R0,R6
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2801             CMP      R0,#+1
   \       0x24   0xD00C             BEQ.N    ??HAL_SPI_TransmitReceive_IT_2
   \       0x26   0xF5B7 0x7F82      CMP      R7,#+260
   \       0x2A   0xD106             BNE.N    ??HAL_SPI_TransmitReceive_IT_3
   \       0x2C   0x68A0             LDR      R0,[R4, #+8]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD103             BNE.N    ??HAL_SPI_TransmitReceive_IT_3
   \       0x32   0x0030             MOVS     R0,R6
   \       0x34   0xB2C0             UXTB     R0,R0
   \       0x36   0x2804             CMP      R0,#+4
   \       0x38   0xD002             BEQ.N    ??HAL_SPI_TransmitReceive_IT_2
   1513            {
   1514              errorcode = HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_IT_3: (+1)
   \       0x3A   0x2002             MOVS     R0,#+2
   \       0x3C   0x0005             MOVS     R5,R0
   1515              goto error;
   \       0x3E   0xE03D             B.N      ??HAL_SPI_TransmitReceive_IT_4
   1516            }
   1517          
   1518            if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
   \                     ??HAL_SPI_TransmitReceive_IT_2: (+1)
   \       0x40   0x2900             CMP      R1,#+0
   \       0x42   0xD005             BEQ.N    ??HAL_SPI_TransmitReceive_IT_5
   \       0x44   0x2A00             CMP      R2,#+0
   \       0x46   0xD003             BEQ.N    ??HAL_SPI_TransmitReceive_IT_5
   \       0x48   0x0018             MOVS     R0,R3
   \       0x4A   0xB280             UXTH     R0,R0
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD102             BNE.N    ??HAL_SPI_TransmitReceive_IT_6
   1519            {
   1520              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_TransmitReceive_IT_5: (+1)
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0x0005             MOVS     R5,R0
   1521              goto error;
   \       0x54   0xE032             B.N      ??HAL_SPI_TransmitReceive_IT_4
   1522            }
   1523          
   1524            /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
   1525            if (hspi->State != HAL_SPI_STATE_BUSY_RX)
   \                     ??HAL_SPI_TransmitReceive_IT_6: (+1)
   \       0x56   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \       0x5A   0x2804             CMP      R0,#+4
   \       0x5C   0xD002             BEQ.N    ??HAL_SPI_TransmitReceive_IT_7
   1526            {
   1527              hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   \       0x5E   0x2005             MOVS     R0,#+5
   \       0x60   0xF884 0x0051      STRB     R0,[R4, #+81]
   1528            }
   1529          
   1530            /* Set the transaction information */
   1531            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_TransmitReceive_IT_7: (+1)
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x6560             STR      R0,[R4, #+84]
   1532            hspi->pTxBuffPtr  = (uint8_t *)pTxData;
   \       0x68   0x6321             STR      R1,[R4, #+48]
   1533            hspi->TxXferSize  = Size;
   \       0x6A   0x86A3             STRH     R3,[R4, #+52]
   1534            hspi->TxXferCount = Size;
   \       0x6C   0x86E3             STRH     R3,[R4, #+54]
   1535            hspi->pRxBuffPtr  = (uint8_t *)pRxData;
   \       0x6E   0x63A2             STR      R2,[R4, #+56]
   1536            hspi->RxXferSize  = Size;
   \       0x70   0x87A3             STRH     R3,[R4, #+60]
   1537            hspi->RxXferCount = Size;
   \       0x72   0x87E3             STRH     R3,[R4, #+62]
   1538          
   1539            /* Set the function for IT treatment */
   1540            if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
   \       0x74   0x68E0             LDR      R0,[R4, #+12]
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD006             BEQ.N    ??HAL_SPI_TransmitReceive_IT_8
   1541            {
   1542              hspi->RxISR     = SPI_2linesRxISR_16BIT;
   \       0x7A   0x.... 0x....      ADR.W    R0,SPI_2linesRxISR_16BIT
   \       0x7E   0x6420             STR      R0,[R4, #+64]
   1543              hspi->TxISR     = SPI_2linesTxISR_16BIT;
   \       0x80   0x.... 0x....      ADR.W    R0,SPI_2linesTxISR_16BIT
   \       0x84   0x6460             STR      R0,[R4, #+68]
   \       0x86   0xE005             B.N      ??HAL_SPI_TransmitReceive_IT_9
   1544            }
   1545            else
   1546            {
   1547              hspi->RxISR     = SPI_2linesRxISR_8BIT;
   \                     ??HAL_SPI_TransmitReceive_IT_8: (+1)
   \       0x88   0x.... 0x....      ADR.W    R0,SPI_2linesRxISR_8BIT
   \       0x8C   0x6420             STR      R0,[R4, #+64]
   1548              hspi->TxISR     = SPI_2linesTxISR_8BIT;
   \       0x8E   0x.... 0x....      ADR.W    R0,SPI_2linesTxISR_8BIT
   \       0x92   0x6460             STR      R0,[R4, #+68]
   1549            }
   1550          
   1551          #if (USE_SPI_CRC != 0U)
   1552            /* Reset CRC Calculation */
   1553            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1554            {
   1555              SPI_RESET_CRC(hspi);
   1556            }
   1557          #endif /* USE_SPI_CRC */
   1558          
   1559            /* Enable TXE, RXNE and ERR interrupt */
   1560            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??HAL_SPI_TransmitReceive_IT_9: (+1)
   \       0x94   0x6820             LDR      R0,[R4, #+0]
   \       0x96   0x6840             LDR      R0,[R0, #+4]
   \       0x98   0xF050 0x00E0      ORRS     R0,R0,#0xE0
   \       0x9C   0xF8D4 0xC000      LDR      R12,[R4, #+0]
   \       0xA0   0xF8CC 0x0004      STR      R0,[R12, #+4]
   1561          
   1562            /* Check if the SPI is already enabled */
   1563            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \       0xA4   0x6820             LDR      R0,[R4, #+0]
   \       0xA6   0x6800             LDR      R0,[R0, #+0]
   \       0xA8   0x0640             LSLS     R0,R0,#+25
   \       0xAA   0xD407             BMI.N    ??HAL_SPI_TransmitReceive_IT_4
   1564            {
   1565              /* Enable SPI peripheral */
   1566              __HAL_SPI_ENABLE(hspi);
   \       0xAC   0x6820             LDR      R0,[R4, #+0]
   \       0xAE   0x6800             LDR      R0,[R0, #+0]
   \       0xB0   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0xB4   0xF8D4 0xC000      LDR      R12,[R4, #+0]
   \       0xB8   0xF8CC 0x0000      STR      R0,[R12, #+0]
   1567            }
   1568          
   1569          error :
   1570            /* Process Unlocked */
   1571            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_IT_4: (+1)
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0xF884 0x0050      STRB     R0,[R4, #+80]
   1572            return errorcode;
   \       0xC2   0x0028             MOVS     R0,R5
   \       0xC4   0xB2C0             UXTB     R0,R0
   \                     ??HAL_SPI_TransmitReceive_IT_1: (+1)
   \       0xC6   0xBCF0             POP      {R4-R7}
   \       0xC8   0x4770             BX       LR
   1573          }
   1574          
   1575          /**
   1576            * @brief  Transmit an amount of data in non-blocking mode with DMA.
   1577            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1578            *               the configuration information for SPI module.
   1579            * @param  pData pointer to data buffer
   1580            * @param  Size amount of data to be sent
   1581            * @retval HAL status
   1582            */

   \                                 In section .text, align 2, keep-with-next
   1583          HAL_StatusTypeDef HAL_SPI_Transmit_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1584          {
   \                     HAL_SPI_Transmit_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0017             MOVS     R7,R2
   1585            HAL_StatusTypeDef errorcode = HAL_OK;
   \        0x8   0x2600             MOVS     R6,#+0
   1586          
   1587            /* Check tx dma handle */
   1588            assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
   1589          
   1590            /* Check Direction parameter */
   1591            assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));
   1592          
   1593            /* Process Locked */
   1594            __HAL_LOCK(hspi);
   \        0xA   0xF895 0x0050      LDRB     R0,[R5, #+80]
   \        0xE   0x2801             CMP      R0,#+1
   \       0x10   0xD101             BNE.N    ??HAL_SPI_Transmit_DMA_0
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xE06C             B.N      ??HAL_SPI_Transmit_DMA_1
   \                     ??HAL_SPI_Transmit_DMA_0: (+1)
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xF885 0x0050      STRB     R0,[R5, #+80]
   1595          
   1596            if (hspi->State != HAL_SPI_STATE_READY)
   \       0x1C   0xF895 0x0051      LDRB     R0,[R5, #+81]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD002             BEQ.N    ??HAL_SPI_Transmit_DMA_2
   1597            {
   1598              errorcode = HAL_BUSY;
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0x0006             MOVS     R6,R0
   1599              goto error;
   \       0x28   0xE05D             B.N      ??HAL_SPI_Transmit_DMA_3
   1600            }
   1601          
   1602            if ((pData == NULL) || (Size == 0U))
   \                     ??HAL_SPI_Transmit_DMA_2: (+1)
   \       0x2A   0x2C00             CMP      R4,#+0
   \       0x2C   0xD003             BEQ.N    ??HAL_SPI_Transmit_DMA_4
   \       0x2E   0x0038             MOVS     R0,R7
   \       0x30   0xB280             UXTH     R0,R0
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD102             BNE.N    ??HAL_SPI_Transmit_DMA_5
   1603            {
   1604              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_Transmit_DMA_4: (+1)
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0x0006             MOVS     R6,R0
   1605              goto error;
   \       0x3A   0xE054             B.N      ??HAL_SPI_Transmit_DMA_3
   1606            }
   1607          
   1608            /* Set the transaction information */
   1609            hspi->State       = HAL_SPI_STATE_BUSY_TX;
   \                     ??HAL_SPI_Transmit_DMA_5: (+1)
   \       0x3C   0x2003             MOVS     R0,#+3
   \       0x3E   0xF885 0x0051      STRB     R0,[R5, #+81]
   1610            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x6568             STR      R0,[R5, #+84]
   1611            hspi->pTxBuffPtr  = (uint8_t *)pData;
   \       0x46   0x632C             STR      R4,[R5, #+48]
   1612            hspi->TxXferSize  = Size;
   \       0x48   0x86AF             STRH     R7,[R5, #+52]
   1613            hspi->TxXferCount = Size;
   \       0x4A   0x86EF             STRH     R7,[R5, #+54]
   1614          
   1615            /* Init field not used in handle to zero */
   1616            hspi->pRxBuffPtr  = (uint8_t *)NULL;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x63A8             STR      R0,[R5, #+56]
   1617            hspi->TxISR       = NULL;
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x6468             STR      R0,[R5, #+68]
   1618            hspi->RxISR       = NULL;
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x6428             STR      R0,[R5, #+64]
   1619            hspi->RxXferSize  = 0U;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x87A8             STRH     R0,[R5, #+60]
   1620            hspi->RxXferCount = 0U;
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0x87E8             STRH     R0,[R5, #+62]
   1621          
   1622            /* Configure communication direction : 1Line */
   1623            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \       0x60   0x68A8             LDR      R0,[R5, #+8]
   \       0x62   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x66   0xD105             BNE.N    ??HAL_SPI_Transmit_DMA_6
   1624            {
   1625              SPI_1LINE_TX(hspi);
   \       0x68   0x6828             LDR      R0,[R5, #+0]
   \       0x6A   0x6800             LDR      R0,[R0, #+0]
   \       0x6C   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \       0x70   0x6829             LDR      R1,[R5, #+0]
   \       0x72   0x6008             STR      R0,[R1, #+0]
   1626            }
   1627          
   1628          #if (USE_SPI_CRC != 0U)
   1629            /* Reset CRC Calculation */
   1630            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1631            {
   1632              SPI_RESET_CRC(hspi);
   1633            }
   1634          #endif /* USE_SPI_CRC */
   1635          
   1636            /* Set the SPI TxDMA Half transfer complete callback */
   1637            hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
   \                     ??HAL_SPI_Transmit_DMA_6: (+1)
   \       0x74   0x.... 0x....      ADR.W    R0,SPI_DMAHalfTransmitCplt
   \       0x78   0x6CA9             LDR      R1,[R5, #+72]
   \       0x7A   0x6408             STR      R0,[R1, #+64]
   1638          
   1639            /* Set the SPI TxDMA transfer complete callback */
   1640            hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
   \       0x7C   0x.... 0x....      ADR.W    R0,SPI_DMATransmitCplt
   \       0x80   0x6CA9             LDR      R1,[R5, #+72]
   \       0x82   0x63C8             STR      R0,[R1, #+60]
   1641          
   1642            /* Set the DMA error callback */
   1643            hspi->hdmatx->XferErrorCallback = SPI_DMAError;
   \       0x84   0x.... 0x....      ADR.W    R0,SPI_DMAError
   \       0x88   0x6CA9             LDR      R1,[R5, #+72]
   \       0x8A   0x64C8             STR      R0,[R1, #+76]
   1644          
   1645            /* Set the DMA AbortCpltCallback */
   1646            hspi->hdmatx->XferAbortCallback = NULL;
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0x6CA9             LDR      R1,[R5, #+72]
   \       0x90   0x6508             STR      R0,[R1, #+80]
   1647          
   1648            /* Enable the Tx DMA Stream/Channel */
   1649            if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
   1650                                           hspi->TxXferCount))
   \       0x92   0x8EEB             LDRH     R3,[R5, #+54]
   \       0x94   0x6828             LDR      R0,[R5, #+0]
   \       0x96   0xF110 0x020C      ADDS     R2,R0,#+12
   \       0x9A   0x6B29             LDR      R1,[R5, #+48]
   \       0x9C   0x6CA8             LDR      R0,[R5, #+72]
   \       0x9E   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD009             BEQ.N    ??HAL_SPI_Transmit_DMA_7
   1651            {
   1652              /* Update SPI error code */
   1653              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   \       0xA6   0x6D68             LDR      R0,[R5, #+84]
   \       0xA8   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xAC   0x6568             STR      R0,[R5, #+84]
   1654              errorcode = HAL_ERROR;
   \       0xAE   0x2001             MOVS     R0,#+1
   \       0xB0   0x0006             MOVS     R6,R0
   1655          
   1656              hspi->State = HAL_SPI_STATE_READY;
   \       0xB2   0x2001             MOVS     R0,#+1
   \       0xB4   0xF885 0x0051      STRB     R0,[R5, #+81]
   1657              goto error;
   \       0xB8   0xE015             B.N      ??HAL_SPI_Transmit_DMA_3
   1658            }
   1659          
   1660            /* Check if the SPI is already enabled */
   1661            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Transmit_DMA_7: (+1)
   \       0xBA   0x6828             LDR      R0,[R5, #+0]
   \       0xBC   0x6800             LDR      R0,[R0, #+0]
   \       0xBE   0x0640             LSLS     R0,R0,#+25
   \       0xC0   0xD405             BMI.N    ??HAL_SPI_Transmit_DMA_8
   1662            {
   1663              /* Enable SPI peripheral */
   1664              __HAL_SPI_ENABLE(hspi);
   \       0xC2   0x6828             LDR      R0,[R5, #+0]
   \       0xC4   0x6800             LDR      R0,[R0, #+0]
   \       0xC6   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0xCA   0x6829             LDR      R1,[R5, #+0]
   \       0xCC   0x6008             STR      R0,[R1, #+0]
   1665            }
   1666          
   1667            /* Enable the SPI Error Interrupt Bit */
   1668            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
   \                     ??HAL_SPI_Transmit_DMA_8: (+1)
   \       0xCE   0x6828             LDR      R0,[R5, #+0]
   \       0xD0   0x6840             LDR      R0,[R0, #+4]
   \       0xD2   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0xD6   0x6829             LDR      R1,[R5, #+0]
   \       0xD8   0x6048             STR      R0,[R1, #+4]
   1669          
   1670            /* Enable Tx DMA Request */
   1671            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \       0xDA   0x6828             LDR      R0,[R5, #+0]
   \       0xDC   0x6840             LDR      R0,[R0, #+4]
   \       0xDE   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0xE2   0x6829             LDR      R1,[R5, #+0]
   \       0xE4   0x6048             STR      R0,[R1, #+4]
   1672          
   1673          error :
   1674            /* Process Unlocked */
   1675            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Transmit_DMA_3: (+1)
   \       0xE6   0x2000             MOVS     R0,#+0
   \       0xE8   0xF885 0x0050      STRB     R0,[R5, #+80]
   1676            return errorcode;
   \       0xEC   0x0030             MOVS     R0,R6
   \       0xEE   0xB2C0             UXTB     R0,R0
   \                     ??HAL_SPI_Transmit_DMA_1: (+1)
   \       0xF0   0xBDF2             POP      {R1,R4-R7,PC}
   1677          }
   1678          
   1679          /**
   1680            * @brief  Receive an amount of data in non-blocking mode with DMA.
   1681            * @note   In case of MASTER mode and SPI_DIRECTION_2LINES direction, hdmatx shall be defined.
   1682            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1683            *               the configuration information for SPI module.
   1684            * @param  pData pointer to data buffer
   1685            * @note   When the CRC feature is enabled the pData Length must be Size + 1.
   1686            * @param  Size amount of data to be sent
   1687            * @retval HAL status
   1688            */

   \                                 In section .text, align 2, keep-with-next
   1689          HAL_StatusTypeDef HAL_SPI_Receive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size)
   1690          {
   \                     HAL_SPI_Receive_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0016             MOVS     R6,R2
   1691            HAL_StatusTypeDef errorcode = HAL_OK;
   \        0x8   0x2700             MOVS     R7,#+0
   1692          
   1693            /* Check rx dma handle */
   1694            assert_param(IS_SPI_DMA_HANDLE(hspi->hdmarx));
   1695          
   1696            if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
   \        0xA   0x68A8             LDR      R0,[R5, #+8]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD10E             BNE.N    ??HAL_SPI_Receive_DMA_0
   \       0x10   0x6868             LDR      R0,[R5, #+4]
   \       0x12   0xF5B0 0x7F82      CMP      R0,#+260
   \       0x16   0xD10A             BNE.N    ??HAL_SPI_Receive_DMA_0
   1697            {
   1698              hspi->State = HAL_SPI_STATE_BUSY_RX;
   \       0x18   0x2004             MOVS     R0,#+4
   \       0x1A   0xF885 0x0051      STRB     R0,[R5, #+81]
   1699          
   1700              /* Check tx dma handle */
   1701              assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
   1702          
   1703              /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
   1704              return HAL_SPI_TransmitReceive_DMA(hspi, pData, pData, Size);
   \       0x1E   0x0033             MOVS     R3,R6
   \       0x20   0xB29B             UXTH     R3,R3
   \       0x22   0x0022             MOVS     R2,R4
   \       0x24   0x0021             MOVS     R1,R4
   \       0x26   0x0028             MOVS     R0,R5
   \       0x28   0x.... 0x....      BL       HAL_SPI_TransmitReceive_DMA
   \       0x2C   0xE070             B.N      ??HAL_SPI_Receive_DMA_1
   1705            }
   1706          
   1707            /* Process Locked */
   1708            __HAL_LOCK(hspi);
   \                     ??HAL_SPI_Receive_DMA_0: (+1)
   \       0x2E   0xF895 0x0050      LDRB     R0,[R5, #+80]
   \       0x32   0x2801             CMP      R0,#+1
   \       0x34   0xD101             BNE.N    ??HAL_SPI_Receive_DMA_2
   \       0x36   0x2002             MOVS     R0,#+2
   \       0x38   0xE06A             B.N      ??HAL_SPI_Receive_DMA_1
   \                     ??HAL_SPI_Receive_DMA_2: (+1)
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0xF885 0x0050      STRB     R0,[R5, #+80]
   1709          
   1710            if (hspi->State != HAL_SPI_STATE_READY)
   \       0x40   0xF895 0x0051      LDRB     R0,[R5, #+81]
   \       0x44   0x2801             CMP      R0,#+1
   \       0x46   0xD002             BEQ.N    ??HAL_SPI_Receive_DMA_3
   1711            {
   1712              errorcode = HAL_BUSY;
   \       0x48   0x2002             MOVS     R0,#+2
   \       0x4A   0x0007             MOVS     R7,R0
   1713              goto error;
   \       0x4C   0xE05B             B.N      ??HAL_SPI_Receive_DMA_4
   1714            }
   1715          
   1716            if ((pData == NULL) || (Size == 0U))
   \                     ??HAL_SPI_Receive_DMA_3: (+1)
   \       0x4E   0x2C00             CMP      R4,#+0
   \       0x50   0xD003             BEQ.N    ??HAL_SPI_Receive_DMA_5
   \       0x52   0x0030             MOVS     R0,R6
   \       0x54   0xB280             UXTH     R0,R0
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD102             BNE.N    ??HAL_SPI_Receive_DMA_6
   1717            {
   1718              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_Receive_DMA_5: (+1)
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0x0007             MOVS     R7,R0
   1719              goto error;
   \       0x5E   0xE052             B.N      ??HAL_SPI_Receive_DMA_4
   1720            }
   1721          
   1722            /* Set the transaction information */
   1723            hspi->State       = HAL_SPI_STATE_BUSY_RX;
   \                     ??HAL_SPI_Receive_DMA_6: (+1)
   \       0x60   0x2004             MOVS     R0,#+4
   \       0x62   0xF885 0x0051      STRB     R0,[R5, #+81]
   1724            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x6568             STR      R0,[R5, #+84]
   1725            hspi->pRxBuffPtr  = (uint8_t *)pData;
   \       0x6A   0x63AC             STR      R4,[R5, #+56]
   1726            hspi->RxXferSize  = Size;
   \       0x6C   0x87AE             STRH     R6,[R5, #+60]
   1727            hspi->RxXferCount = Size;
   \       0x6E   0x87EE             STRH     R6,[R5, #+62]
   1728          
   1729            /*Init field not used in handle to zero */
   1730            hspi->RxISR       = NULL;
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x6428             STR      R0,[R5, #+64]
   1731            hspi->TxISR       = NULL;
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0x6468             STR      R0,[R5, #+68]
   1732            hspi->TxXferSize  = 0U;
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0x86A8             STRH     R0,[R5, #+52]
   1733            hspi->TxXferCount = 0U;
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0x86E8             STRH     R0,[R5, #+54]
   1734          
   1735            /* Configure communication direction : 1Line */
   1736            if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
   \       0x80   0x68A8             LDR      R0,[R5, #+8]
   \       0x82   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x86   0xD105             BNE.N    ??HAL_SPI_Receive_DMA_7
   1737            {
   1738              SPI_1LINE_RX(hspi);
   \       0x88   0x6828             LDR      R0,[R5, #+0]
   \       0x8A   0x6800             LDR      R0,[R0, #+0]
   \       0x8C   0xF430 0x4080      BICS     R0,R0,#0x4000
   \       0x90   0x6829             LDR      R1,[R5, #+0]
   \       0x92   0x6008             STR      R0,[R1, #+0]
   1739            }
   1740          
   1741          #if (USE_SPI_CRC != 0U)
   1742            /* Reset CRC Calculation */
   1743            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1744            {
   1745              SPI_RESET_CRC(hspi);
   1746            }
   1747          #endif /* USE_SPI_CRC */
   1748          
   1749            /* Set the SPI RxDMA Half transfer complete callback */
   1750            hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \                     ??HAL_SPI_Receive_DMA_7: (+1)
   \       0x94   0x.... 0x....      ADR.W    R0,SPI_DMAHalfReceiveCplt
   \       0x98   0x6CE9             LDR      R1,[R5, #+76]
   \       0x9A   0x6408             STR      R0,[R1, #+64]
   1751          
   1752            /* Set the SPI Rx DMA transfer complete callback */
   1753            hspi->hdmarx->XferCpltCallback = SPI_DMAReceiveCplt;
   \       0x9C   0x.... 0x....      ADR.W    R0,SPI_DMAReceiveCplt
   \       0xA0   0x6CE9             LDR      R1,[R5, #+76]
   \       0xA2   0x63C8             STR      R0,[R1, #+60]
   1754          
   1755            /* Set the DMA error callback */
   1756            hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   \       0xA4   0x.... 0x....      ADR.W    R0,SPI_DMAError
   \       0xA8   0x6CE9             LDR      R1,[R5, #+76]
   \       0xAA   0x64C8             STR      R0,[R1, #+76]
   1757          
   1758            /* Set the DMA AbortCpltCallback */
   1759            hspi->hdmarx->XferAbortCallback = NULL;
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0x6CE9             LDR      R1,[R5, #+76]
   \       0xB0   0x6508             STR      R0,[R1, #+80]
   1760          
   1761            /* Enable the Rx DMA Stream/Channel  */
   1762            if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
   1763                                           hspi->RxXferCount))
   \       0xB2   0x8FEB             LDRH     R3,[R5, #+62]
   \       0xB4   0x6BAA             LDR      R2,[R5, #+56]
   \       0xB6   0x6828             LDR      R0,[R5, #+0]
   \       0xB8   0xF110 0x010C      ADDS     R1,R0,#+12
   \       0xBC   0x6CE8             LDR      R0,[R5, #+76]
   \       0xBE   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD009             BEQ.N    ??HAL_SPI_Receive_DMA_8
   1764            {
   1765              /* Update SPI error code */
   1766              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   \       0xC6   0x6D68             LDR      R0,[R5, #+84]
   \       0xC8   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xCC   0x6568             STR      R0,[R5, #+84]
   1767              errorcode = HAL_ERROR;
   \       0xCE   0x2001             MOVS     R0,#+1
   \       0xD0   0x0007             MOVS     R7,R0
   1768          
   1769              hspi->State = HAL_SPI_STATE_READY;
   \       0xD2   0x2001             MOVS     R0,#+1
   \       0xD4   0xF885 0x0051      STRB     R0,[R5, #+81]
   1770              goto error;
   \       0xD8   0xE015             B.N      ??HAL_SPI_Receive_DMA_4
   1771            }
   1772          
   1773            /* Check if the SPI is already enabled */
   1774            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_Receive_DMA_8: (+1)
   \       0xDA   0x6828             LDR      R0,[R5, #+0]
   \       0xDC   0x6800             LDR      R0,[R0, #+0]
   \       0xDE   0x0640             LSLS     R0,R0,#+25
   \       0xE0   0xD405             BMI.N    ??HAL_SPI_Receive_DMA_9
   1775            {
   1776              /* Enable SPI peripheral */
   1777              __HAL_SPI_ENABLE(hspi);
   \       0xE2   0x6828             LDR      R0,[R5, #+0]
   \       0xE4   0x6800             LDR      R0,[R0, #+0]
   \       0xE6   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0xEA   0x6829             LDR      R1,[R5, #+0]
   \       0xEC   0x6008             STR      R0,[R1, #+0]
   1778            }
   1779          
   1780            /* Enable the SPI Error Interrupt Bit */
   1781            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
   \                     ??HAL_SPI_Receive_DMA_9: (+1)
   \       0xEE   0x6828             LDR      R0,[R5, #+0]
   \       0xF0   0x6840             LDR      R0,[R0, #+4]
   \       0xF2   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0xF6   0x6829             LDR      R1,[R5, #+0]
   \       0xF8   0x6048             STR      R0,[R1, #+4]
   1782          
   1783            /* Enable Rx DMA Request */
   1784            SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \       0xFA   0x6828             LDR      R0,[R5, #+0]
   \       0xFC   0x6840             LDR      R0,[R0, #+4]
   \       0xFE   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x102   0x6829             LDR      R1,[R5, #+0]
   \      0x104   0x6048             STR      R0,[R1, #+4]
   1785          
   1786          error:
   1787            /* Process Unlocked */
   1788            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_Receive_DMA_4: (+1)
   \      0x106   0x2000             MOVS     R0,#+0
   \      0x108   0xF885 0x0050      STRB     R0,[R5, #+80]
   1789            return errorcode;
   \      0x10C   0x0038             MOVS     R0,R7
   \      0x10E   0xB2C0             UXTB     R0,R0
   \                     ??HAL_SPI_Receive_DMA_1: (+1)
   \      0x110   0xBDF2             POP      {R1,R4-R7,PC}
   1790          }
   1791          
   1792          /**
   1793            * @brief  Transmit and Receive an amount of data in non-blocking mode with DMA.
   1794            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   1795            *               the configuration information for SPI module.
   1796            * @param  pTxData pointer to transmission data buffer
   1797            * @param  pRxData pointer to reception data buffer
   1798            * @note   When the CRC feature is enabled the pRxData Length must be Size + 1
   1799            * @param  Size amount of data to be sent
   1800            * @retval HAL status
   1801            */

   \                                 In section .text, align 2, keep-with-next
   1802          HAL_StatusTypeDef HAL_SPI_TransmitReceive_DMA(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData,
   1803                                                        uint16_t Size)
   1804          {
   \                     HAL_SPI_TransmitReceive_DMA: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0015             MOVS     R5,R2
   \        0xA   0x001F             MOVS     R7,R3
   1805            uint32_t             tmp_mode;
   1806            HAL_SPI_StateTypeDef tmp_state;
   1807            HAL_StatusTypeDef errorcode = HAL_OK;
   \        0xC   0xF05F 0x0800      MOVS     R8,#+0
   1808          
   1809            /* Check rx & tx dma handles */
   1810            assert_param(IS_SPI_DMA_HANDLE(hspi->hdmarx));
   1811            assert_param(IS_SPI_DMA_HANDLE(hspi->hdmatx));
   1812          
   1813            /* Check Direction parameter */
   1814            assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));
   1815          
   1816            /* Process locked */
   1817            __HAL_LOCK(hspi);
   \       0x10   0xF896 0x0050      LDRB     R0,[R6, #+80]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD101             BNE.N    ??HAL_SPI_TransmitReceive_DMA_0
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0xE0A6             B.N      ??HAL_SPI_TransmitReceive_DMA_1
   \                     ??HAL_SPI_TransmitReceive_DMA_0: (+1)
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xF886 0x0050      STRB     R0,[R6, #+80]
   1818          
   1819            /* Init temporary variables */
   1820            tmp_state           = hspi->State;
   \       0x22   0xF896 0xA051      LDRB     R10,[R6, #+81]
   1821            tmp_mode            = hspi->Init.Mode;
   \       0x26   0xF8D6 0x9004      LDR      R9,[R6, #+4]
   1822          
   1823            if (!((tmp_state == HAL_SPI_STATE_READY) ||
   1824                  ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
   \       0x2A   0x4650             MOV      R0,R10
   \       0x2C   0xB2C0             UXTB     R0,R0
   \       0x2E   0x2801             CMP      R0,#+1
   \       0x30   0xD00C             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_2
   \       0x32   0xF5B9 0x7F82      CMP      R9,#+260
   \       0x36   0xD106             BNE.N    ??HAL_SPI_TransmitReceive_DMA_3
   \       0x38   0x68B0             LDR      R0,[R6, #+8]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD103             BNE.N    ??HAL_SPI_TransmitReceive_DMA_3
   \       0x3E   0x4650             MOV      R0,R10
   \       0x40   0xB2C0             UXTB     R0,R0
   \       0x42   0x2804             CMP      R0,#+4
   \       0x44   0xD002             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_2
   1825            {
   1826              errorcode = HAL_BUSY;
   \                     ??HAL_SPI_TransmitReceive_DMA_3: (+1)
   \       0x46   0x2002             MOVS     R0,#+2
   \       0x48   0x4680             MOV      R8,R0
   1827              goto error;
   \       0x4A   0xE089             B.N      ??HAL_SPI_TransmitReceive_DMA_4
   1828            }
   1829          
   1830            if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
   \                     ??HAL_SPI_TransmitReceive_DMA_2: (+1)
   \       0x4C   0x2C00             CMP      R4,#+0
   \       0x4E   0xD005             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_5
   \       0x50   0x2D00             CMP      R5,#+0
   \       0x52   0xD003             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_5
   \       0x54   0x0038             MOVS     R0,R7
   \       0x56   0xB280             UXTH     R0,R0
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD102             BNE.N    ??HAL_SPI_TransmitReceive_DMA_6
   1831            {
   1832              errorcode = HAL_ERROR;
   \                     ??HAL_SPI_TransmitReceive_DMA_5: (+1)
   \       0x5C   0x2001             MOVS     R0,#+1
   \       0x5E   0x4680             MOV      R8,R0
   1833              goto error;
   \       0x60   0xE07E             B.N      ??HAL_SPI_TransmitReceive_DMA_4
   1834            }
   1835          
   1836            /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
   1837            if (hspi->State != HAL_SPI_STATE_BUSY_RX)
   \                     ??HAL_SPI_TransmitReceive_DMA_6: (+1)
   \       0x62   0xF896 0x0051      LDRB     R0,[R6, #+81]
   \       0x66   0x2804             CMP      R0,#+4
   \       0x68   0xD002             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_7
   1838            {
   1839              hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
   \       0x6A   0x2005             MOVS     R0,#+5
   \       0x6C   0xF886 0x0051      STRB     R0,[R6, #+81]
   1840            }
   1841          
   1842            /* Set the transaction information */
   1843            hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_TransmitReceive_DMA_7: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x6570             STR      R0,[R6, #+84]
   1844            hspi->pTxBuffPtr  = (uint8_t *)pTxData;
   \       0x74   0x6334             STR      R4,[R6, #+48]
   1845            hspi->TxXferSize  = Size;
   \       0x76   0x86B7             STRH     R7,[R6, #+52]
   1846            hspi->TxXferCount = Size;
   \       0x78   0x86F7             STRH     R7,[R6, #+54]
   1847            hspi->pRxBuffPtr  = (uint8_t *)pRxData;
   \       0x7A   0x63B5             STR      R5,[R6, #+56]
   1848            hspi->RxXferSize  = Size;
   \       0x7C   0x87B7             STRH     R7,[R6, #+60]
   1849            hspi->RxXferCount = Size;
   \       0x7E   0x87F7             STRH     R7,[R6, #+62]
   1850          
   1851            /* Init field not used in handle to zero */
   1852            hspi->RxISR       = NULL;
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0x6430             STR      R0,[R6, #+64]
   1853            hspi->TxISR       = NULL;
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0x6470             STR      R0,[R6, #+68]
   1854          
   1855          #if (USE_SPI_CRC != 0U)
   1856            /* Reset CRC Calculation */
   1857            if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   1858            {
   1859              SPI_RESET_CRC(hspi);
   1860            }
   1861          #endif /* USE_SPI_CRC */
   1862          
   1863            /* Check if we are in Rx only or in Rx/Tx Mode and configure the DMA transfer complete callback */
   1864            if (hspi->State == HAL_SPI_STATE_BUSY_RX)
   \       0x88   0xF896 0x0051      LDRB     R0,[R6, #+81]
   \       0x8C   0x2804             CMP      R0,#+4
   \       0x8E   0xD108             BNE.N    ??HAL_SPI_TransmitReceive_DMA_8
   1865            {
   1866              /* Set the SPI Rx DMA Half transfer complete callback */
   1867              hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfReceiveCplt;
   \       0x90   0x.... 0x....      ADR.W    R0,SPI_DMAHalfReceiveCplt
   \       0x94   0x6CF1             LDR      R1,[R6, #+76]
   \       0x96   0x6408             STR      R0,[R1, #+64]
   1868              hspi->hdmarx->XferCpltCallback     = SPI_DMAReceiveCplt;
   \       0x98   0x.... 0x....      ADR.W    R0,SPI_DMAReceiveCplt
   \       0x9C   0x6CF1             LDR      R1,[R6, #+76]
   \       0x9E   0x63C8             STR      R0,[R1, #+60]
   \       0xA0   0xE007             B.N      ??HAL_SPI_TransmitReceive_DMA_9
   1869            }
   1870            else
   1871            {
   1872              /* Set the SPI Tx/Rx DMA Half transfer complete callback */
   1873              hspi->hdmarx->XferHalfCpltCallback = SPI_DMAHalfTransmitReceiveCplt;
   \                     ??HAL_SPI_TransmitReceive_DMA_8: (+1)
   \       0xA2   0x.... 0x....      ADR.W    R0,SPI_DMAHalfTransmitReceiveCplt
   \       0xA6   0x6CF1             LDR      R1,[R6, #+76]
   \       0xA8   0x6408             STR      R0,[R1, #+64]
   1874              hspi->hdmarx->XferCpltCallback     = SPI_DMATransmitReceiveCplt;
   \       0xAA   0x.... 0x....      ADR.W    R0,SPI_DMATransmitReceiveCplt
   \       0xAE   0x6CF1             LDR      R1,[R6, #+76]
   \       0xB0   0x63C8             STR      R0,[R1, #+60]
   1875            }
   1876          
   1877            /* Set the DMA error callback */
   1878            hspi->hdmarx->XferErrorCallback = SPI_DMAError;
   \                     ??HAL_SPI_TransmitReceive_DMA_9: (+1)
   \       0xB2   0x.... 0x....      ADR.W    R0,SPI_DMAError
   \       0xB6   0x6CF1             LDR      R1,[R6, #+76]
   \       0xB8   0x64C8             STR      R0,[R1, #+76]
   1879          
   1880            /* Set the DMA AbortCpltCallback */
   1881            hspi->hdmarx->XferAbortCallback = NULL;
   \       0xBA   0x2000             MOVS     R0,#+0
   \       0xBC   0x6CF1             LDR      R1,[R6, #+76]
   \       0xBE   0x6508             STR      R0,[R1, #+80]
   1882          
   1883            /* Enable the Rx DMA Stream/Channel  */
   1884            if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmarx, (uint32_t)&hspi->Instance->DR, (uint32_t)hspi->pRxBuffPtr,
   1885                                           hspi->RxXferCount))
   \       0xC0   0x8FF3             LDRH     R3,[R6, #+62]
   \       0xC2   0x6BB2             LDR      R2,[R6, #+56]
   \       0xC4   0x6830             LDR      R0,[R6, #+0]
   \       0xC6   0xF110 0x010C      ADDS     R1,R0,#+12
   \       0xCA   0x6CF0             LDR      R0,[R6, #+76]
   \       0xCC   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xD0   0x2800             CMP      R0,#+0
   \       0xD2   0xD009             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_10
   1886            {
   1887              /* Update SPI error code */
   1888              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   \       0xD4   0x6D70             LDR      R0,[R6, #+84]
   \       0xD6   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xDA   0x6570             STR      R0,[R6, #+84]
   1889              errorcode = HAL_ERROR;
   \       0xDC   0x2001             MOVS     R0,#+1
   \       0xDE   0x4680             MOV      R8,R0
   1890          
   1891              hspi->State = HAL_SPI_STATE_READY;
   \       0xE0   0x2001             MOVS     R0,#+1
   \       0xE2   0xF886 0x0051      STRB     R0,[R6, #+81]
   1892              goto error;
   \       0xE6   0xE03B             B.N      ??HAL_SPI_TransmitReceive_DMA_4
   1893            }
   1894          
   1895            /* Enable Rx DMA Request */
   1896            SET_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \                     ??HAL_SPI_TransmitReceive_DMA_10: (+1)
   \       0xE8   0x6830             LDR      R0,[R6, #+0]
   \       0xEA   0x6840             LDR      R0,[R0, #+4]
   \       0xEC   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xF0   0x6831             LDR      R1,[R6, #+0]
   \       0xF2   0x6048             STR      R0,[R1, #+4]
   1897          
   1898            /* Set the SPI Tx DMA transfer complete callback as NULL because the communication closing
   1899            is performed in DMA reception complete callback  */
   1900            hspi->hdmatx->XferHalfCpltCallback = NULL;
   \       0xF4   0x2000             MOVS     R0,#+0
   \       0xF6   0x6CB1             LDR      R1,[R6, #+72]
   \       0xF8   0x6408             STR      R0,[R1, #+64]
   1901            hspi->hdmatx->XferCpltCallback     = NULL;
   \       0xFA   0x2000             MOVS     R0,#+0
   \       0xFC   0x6CB1             LDR      R1,[R6, #+72]
   \       0xFE   0x63C8             STR      R0,[R1, #+60]
   1902            hspi->hdmatx->XferErrorCallback    = NULL;
   \      0x100   0x2000             MOVS     R0,#+0
   \      0x102   0x6CB1             LDR      R1,[R6, #+72]
   \      0x104   0x64C8             STR      R0,[R1, #+76]
   1903            hspi->hdmatx->XferAbortCallback    = NULL;
   \      0x106   0x2000             MOVS     R0,#+0
   \      0x108   0x6CB1             LDR      R1,[R6, #+72]
   \      0x10A   0x6508             STR      R0,[R1, #+80]
   1904          
   1905            /* Enable the Tx DMA Stream/Channel  */
   1906            if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
   1907                                           hspi->TxXferCount))
   \      0x10C   0x8EF3             LDRH     R3,[R6, #+54]
   \      0x10E   0x6830             LDR      R0,[R6, #+0]
   \      0x110   0xF110 0x020C      ADDS     R2,R0,#+12
   \      0x114   0x6B31             LDR      R1,[R6, #+48]
   \      0x116   0x6CB0             LDR      R0,[R6, #+72]
   \      0x118   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x11C   0x2800             CMP      R0,#+0
   \      0x11E   0xD009             BEQ.N    ??HAL_SPI_TransmitReceive_DMA_11
   1908            {
   1909              /* Update SPI error code */
   1910              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   \      0x120   0x6D70             LDR      R0,[R6, #+84]
   \      0x122   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x126   0x6570             STR      R0,[R6, #+84]
   1911              errorcode = HAL_ERROR;
   \      0x128   0x2001             MOVS     R0,#+1
   \      0x12A   0x4680             MOV      R8,R0
   1912          
   1913              hspi->State = HAL_SPI_STATE_READY;
   \      0x12C   0x2001             MOVS     R0,#+1
   \      0x12E   0xF886 0x0051      STRB     R0,[R6, #+81]
   1914              goto error;
   \      0x132   0xE015             B.N      ??HAL_SPI_TransmitReceive_DMA_4
   1915            }
   1916          
   1917            /* Check if the SPI is already enabled */
   1918            if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
   \                     ??HAL_SPI_TransmitReceive_DMA_11: (+1)
   \      0x134   0x6830             LDR      R0,[R6, #+0]
   \      0x136   0x6800             LDR      R0,[R0, #+0]
   \      0x138   0x0640             LSLS     R0,R0,#+25
   \      0x13A   0xD405             BMI.N    ??HAL_SPI_TransmitReceive_DMA_12
   1919            {
   1920              /* Enable SPI peripheral */
   1921              __HAL_SPI_ENABLE(hspi);
   \      0x13C   0x6830             LDR      R0,[R6, #+0]
   \      0x13E   0x6800             LDR      R0,[R0, #+0]
   \      0x140   0xF050 0x0040      ORRS     R0,R0,#0x40
   \      0x144   0x6831             LDR      R1,[R6, #+0]
   \      0x146   0x6008             STR      R0,[R1, #+0]
   1922            }
   1923            /* Enable the SPI Error Interrupt Bit */
   1924            __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
   \                     ??HAL_SPI_TransmitReceive_DMA_12: (+1)
   \      0x148   0x6830             LDR      R0,[R6, #+0]
   \      0x14A   0x6840             LDR      R0,[R0, #+4]
   \      0x14C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \      0x150   0x6831             LDR      R1,[R6, #+0]
   \      0x152   0x6048             STR      R0,[R1, #+4]
   1925          
   1926            /* Enable Tx DMA Request */
   1927            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \      0x154   0x6830             LDR      R0,[R6, #+0]
   \      0x156   0x6840             LDR      R0,[R0, #+4]
   \      0x158   0xF050 0x0002      ORRS     R0,R0,#0x2
   \      0x15C   0x6831             LDR      R1,[R6, #+0]
   \      0x15E   0x6048             STR      R0,[R1, #+4]
   1928          
   1929          error :
   1930            /* Process Unlocked */
   1931            __HAL_UNLOCK(hspi);
   \                     ??HAL_SPI_TransmitReceive_DMA_4: (+1)
   \      0x160   0x2000             MOVS     R0,#+0
   \      0x162   0xF886 0x0050      STRB     R0,[R6, #+80]
   1932            return errorcode;
   \      0x166   0x4640             MOV      R0,R8
   \      0x168   0xB2C0             UXTB     R0,R0
   \                     ??HAL_SPI_TransmitReceive_DMA_1: (+1)
   \      0x16A   0xE8BD 0x87F0      POP      {R4-R10,PC}
   1933          }
   1934          
   1935          /**
   1936            * @brief  Abort ongoing transfer (blocking mode).
   1937            * @param  hspi SPI handle.
   1938            * @note   This procedure could be used for aborting any ongoing transfer (Tx and Rx),
   1939            *         started in Interrupt or DMA mode.
   1940            *         This procedure performs following operations :
   1941            *           - Disable SPI Interrupts (depending of transfer direction)
   1942            *           - Disable the DMA transfer in the peripheral register (if enabled)
   1943            *           - Abort DMA transfer by calling HAL_DMA_Abort (in case of transfer in DMA mode)
   1944            *           - Set handle State to READY
   1945            * @note   This procedure is executed in blocking mode : when exiting function, Abort is considered as completed.
   1946            * @retval HAL status
   1947            */

   \                                 In section .text, align 2, keep-with-next
   1948          HAL_StatusTypeDef HAL_SPI_Abort(SPI_HandleTypeDef *hspi)
   1949          {
   \                     HAL_SPI_Abort: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1950            HAL_StatusTypeDef errorcode;
   1951            __IO uint32_t count;
   1952            __IO uint32_t resetcount;
   1953          
   1954            /* Initialized local variable  */
   1955            errorcode = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
   1956            resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   \        0x6   0x.... 0x....      LDR.W    R0,??DataTable9
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0x2118             MOVS     R1,#+24
   \        0xE   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x12   0xF44F 0x717A      MOV      R1,#+1000
   \       0x16   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x1A   0x2064             MOVS     R0,#+100
   \       0x1C   0x4341             MULS     R1,R0,R1
   \       0x1E   0x9102             STR      R1,[SP, #+8]
   1957            count = resetcount;
   \       0x20   0x9802             LDR      R0,[SP, #+8]
   \       0x22   0x9000             STR      R0,[SP, #+0]
   1958          
   1959            /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
   1960            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x6840             LDR      R0,[R0, #+4]
   \       0x28   0xF030 0x0020      BICS     R0,R0,#0x20
   \       0x2C   0x6821             LDR      R1,[R4, #+0]
   \       0x2E   0x6048             STR      R0,[R1, #+4]
   1961          
   1962            /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
   1963            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6840             LDR      R0,[R0, #+4]
   \       0x34   0x0600             LSLS     R0,R0,#+24
   \       0x36   0xD513             BPL.N    ??HAL_SPI_Abort_0
   1964            {
   1965              hspi->TxISR = SPI_AbortTx_ISR;
   \       0x38   0x.... 0x....      ADR.W    R0,SPI_AbortTx_ISR
   \       0x3C   0x6460             STR      R0,[R4, #+68]
   1966              /* Wait HAL_SPI_STATE_ABORT state */
   1967              do
   1968              {
   1969                if (count == 0U)
   \                     ??HAL_SPI_Abort_1: (+1)
   \       0x3E   0x9800             LDR      R0,[SP, #+0]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD104             BNE.N    ??HAL_SPI_Abort_2
   1970                {
   1971                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   \       0x44   0x6D60             LDR      R0,[R4, #+84]
   \       0x46   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x4A   0x6560             STR      R0,[R4, #+84]
   1972                  break;
   \       0x4C   0xE006             B.N      ??HAL_SPI_Abort_3
   1973                }
   1974                count--;
   \                     ??HAL_SPI_Abort_2: (+1)
   \       0x4E   0x9800             LDR      R0,[SP, #+0]
   \       0x50   0x1E40             SUBS     R0,R0,#+1
   \       0x52   0x9000             STR      R0,[SP, #+0]
   1975              } while (hspi->State != HAL_SPI_STATE_ABORT);
   \       0x54   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \       0x58   0x2807             CMP      R0,#+7
   \       0x5A   0xD1F0             BNE.N    ??HAL_SPI_Abort_1
   1976              /* Reset Timeout Counter */
   1977              count = resetcount;
   \                     ??HAL_SPI_Abort_3: (+1)
   \       0x5C   0x9802             LDR      R0,[SP, #+8]
   \       0x5E   0x9000             STR      R0,[SP, #+0]
   1978            }
   1979          
   1980            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
   \                     ??HAL_SPI_Abort_0: (+1)
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x6840             LDR      R0,[R0, #+4]
   \       0x64   0x0640             LSLS     R0,R0,#+25
   \       0x66   0xD513             BPL.N    ??HAL_SPI_Abort_4
   1981            {
   1982              hspi->RxISR = SPI_AbortRx_ISR;
   \       0x68   0x.... 0x....      ADR.W    R0,SPI_AbortRx_ISR
   \       0x6C   0x6420             STR      R0,[R4, #+64]
   1983              /* Wait HAL_SPI_STATE_ABORT state */
   1984              do
   1985              {
   1986                if (count == 0U)
   \                     ??HAL_SPI_Abort_5: (+1)
   \       0x6E   0x9800             LDR      R0,[SP, #+0]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD104             BNE.N    ??HAL_SPI_Abort_6
   1987                {
   1988                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   \       0x74   0x6D60             LDR      R0,[R4, #+84]
   \       0x76   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x7A   0x6560             STR      R0,[R4, #+84]
   1989                  break;
   \       0x7C   0xE006             B.N      ??HAL_SPI_Abort_7
   1990                }
   1991                count--;
   \                     ??HAL_SPI_Abort_6: (+1)
   \       0x7E   0x9800             LDR      R0,[SP, #+0]
   \       0x80   0x1E40             SUBS     R0,R0,#+1
   \       0x82   0x9000             STR      R0,[SP, #+0]
   1992              } while (hspi->State != HAL_SPI_STATE_ABORT);
   \       0x84   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \       0x88   0x2807             CMP      R0,#+7
   \       0x8A   0xD1F0             BNE.N    ??HAL_SPI_Abort_5
   1993              /* Reset Timeout Counter */
   1994              count = resetcount;
   \                     ??HAL_SPI_Abort_7: (+1)
   \       0x8C   0x9802             LDR      R0,[SP, #+8]
   \       0x8E   0x9000             STR      R0,[SP, #+0]
   1995            }
   1996          
   1997            /* Disable the SPI DMA Tx request if enabled */
   1998            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
   \                     ??HAL_SPI_Abort_4: (+1)
   \       0x90   0x6820             LDR      R0,[R4, #+0]
   \       0x92   0x6840             LDR      R0,[R0, #+4]
   \       0x94   0x0780             LSLS     R0,R0,#+30
   \       0x96   0xD521             BPL.N    ??HAL_SPI_Abort_8
   1999            {
   2000              /* Abort the SPI DMA Tx Stream/Channel : use blocking DMA Abort API (no callback) */
   2001              if (hspi->hdmatx != NULL)
   \       0x98   0x6CA0             LDR      R0,[R4, #+72]
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD01E             BEQ.N    ??HAL_SPI_Abort_8
   2002              {
   2003                /* Set the SPI DMA Abort callback :
   2004                will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
   2005                hspi->hdmatx->XferAbortCallback = NULL;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x6CA1             LDR      R1,[R4, #+72]
   \       0xA2   0x6508             STR      R0,[R1, #+80]
   2006          
   2007                /* Abort DMA Tx Handle linked to SPI Peripheral */
   2008                if (HAL_DMA_Abort(hspi->hdmatx) != HAL_OK)
   \       0xA4   0x6CA0             LDR      R0,[R4, #+72]
   \       0xA6   0x.... 0x....      BL       HAL_DMA_Abort
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD001             BEQ.N    ??HAL_SPI_Abort_9
   2009                {
   2010                  hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   \       0xAE   0x2040             MOVS     R0,#+64
   \       0xB0   0x6560             STR      R0,[R4, #+84]
   2011                }
   2012          
   2013                /* Disable Tx DMA Request */
   2014                CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN));
   \                     ??HAL_SPI_Abort_9: (+1)
   \       0xB2   0x6820             LDR      R0,[R4, #+0]
   \       0xB4   0x6840             LDR      R0,[R0, #+4]
   \       0xB6   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0xBA   0x6821             LDR      R1,[R4, #+0]
   \       0xBC   0x6048             STR      R0,[R1, #+4]
   2015          
   2016                /* Wait until TXE flag is set */
   2017                do
   2018                {
   2019                  if (count == 0U)
   \                     ??HAL_SPI_Abort_10: (+1)
   \       0xBE   0x9800             LDR      R0,[SP, #+0]
   \       0xC0   0x2800             CMP      R0,#+0
   \       0xC2   0xD104             BNE.N    ??HAL_SPI_Abort_11
   2020                  {
   2021                    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   \       0xC4   0x6D60             LDR      R0,[R4, #+84]
   \       0xC6   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0xCA   0x6560             STR      R0,[R4, #+84]
   2022                    break;
   \       0xCC   0xE006             B.N      ??HAL_SPI_Abort_8
   2023                  }
   2024                  count--;
   \                     ??HAL_SPI_Abort_11: (+1)
   \       0xCE   0x9800             LDR      R0,[SP, #+0]
   \       0xD0   0x1E40             SUBS     R0,R0,#+1
   \       0xD2   0x9000             STR      R0,[SP, #+0]
   2025                } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
   \       0xD4   0x6820             LDR      R0,[R4, #+0]
   \       0xD6   0x6880             LDR      R0,[R0, #+8]
   \       0xD8   0x0780             LSLS     R0,R0,#+30
   \       0xDA   0xD5F0             BPL.N    ??HAL_SPI_Abort_10
   2026              }
   2027            }
   2028          
   2029            /* Disable the SPI DMA Rx request if enabled */
   2030            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
   \                     ??HAL_SPI_Abort_8: (+1)
   \       0xDC   0x6820             LDR      R0,[R4, #+0]
   \       0xDE   0x6840             LDR      R0,[R0, #+4]
   \       0xE0   0x07C0             LSLS     R0,R0,#+31
   \       0xE2   0xD518             BPL.N    ??HAL_SPI_Abort_12
   2031            {
   2032              /* Abort the SPI DMA Rx Stream/Channel : use blocking DMA Abort API (no callback) */
   2033              if (hspi->hdmarx != NULL)
   \       0xE4   0x6CE0             LDR      R0,[R4, #+76]
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0xD015             BEQ.N    ??HAL_SPI_Abort_12
   2034              {
   2035                /* Set the SPI DMA Abort callback :
   2036                will lead to call HAL_SPI_AbortCpltCallback() at end of DMA abort procedure */
   2037                hspi->hdmarx->XferAbortCallback = NULL;
   \       0xEA   0x2000             MOVS     R0,#+0
   \       0xEC   0x6CE1             LDR      R1,[R4, #+76]
   \       0xEE   0x6508             STR      R0,[R1, #+80]
   2038          
   2039                /* Abort DMA Rx Handle linked to SPI Peripheral */
   2040                if (HAL_DMA_Abort(hspi->hdmarx) != HAL_OK)
   \       0xF0   0x6CE0             LDR      R0,[R4, #+76]
   \       0xF2   0x.... 0x....      BL       HAL_DMA_Abort
   \       0xF6   0x2800             CMP      R0,#+0
   \       0xF8   0xD001             BEQ.N    ??HAL_SPI_Abort_13
   2041                {
   2042                  hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   \       0xFA   0x2040             MOVS     R0,#+64
   \       0xFC   0x6560             STR      R0,[R4, #+84]
   2043                }
   2044          
   2045                /* Disable peripheral */
   2046                __HAL_SPI_DISABLE(hspi);
   \                     ??HAL_SPI_Abort_13: (+1)
   \       0xFE   0x6820             LDR      R0,[R4, #+0]
   \      0x100   0x6800             LDR      R0,[R0, #+0]
   \      0x102   0xF030 0x0040      BICS     R0,R0,#0x40
   \      0x106   0x6821             LDR      R1,[R4, #+0]
   \      0x108   0x6008             STR      R0,[R1, #+0]
   2047          
   2048                /* Disable Rx DMA Request */
   2049                CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_RXDMAEN));
   \      0x10A   0x6820             LDR      R0,[R4, #+0]
   \      0x10C   0x6840             LDR      R0,[R0, #+4]
   \      0x10E   0x0840             LSRS     R0,R0,#+1
   \      0x110   0x0040             LSLS     R0,R0,#+1
   \      0x112   0x6821             LDR      R1,[R4, #+0]
   \      0x114   0x6048             STR      R0,[R1, #+4]
   2050              }
   2051            }
   2052            /* Reset Tx and Rx transfer counters */
   2053            hspi->RxXferCount = 0U;
   \                     ??HAL_SPI_Abort_12: (+1)
   \      0x116   0x2000             MOVS     R0,#+0
   \      0x118   0x87E0             STRH     R0,[R4, #+62]
   2054            hspi->TxXferCount = 0U;
   \      0x11A   0x2000             MOVS     R0,#+0
   \      0x11C   0x86E0             STRH     R0,[R4, #+54]
   2055          
   2056            /* Check error during Abort procedure */
   2057            if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)
   \      0x11E   0x6D60             LDR      R0,[R4, #+84]
   \      0x120   0x2840             CMP      R0,#+64
   \      0x122   0xD102             BNE.N    ??HAL_SPI_Abort_14
   2058            {
   2059              /* return HAL_Error in case of error during Abort procedure */
   2060              errorcode = HAL_ERROR;
   \      0x124   0x2001             MOVS     R0,#+1
   \      0x126   0x0005             MOVS     R5,R0
   \      0x128   0xE001             B.N      ??HAL_SPI_Abort_15
   2061            }
   2062            else
   2063            {
   2064              /* Reset errorCode */
   2065              hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_Abort_14: (+1)
   \      0x12A   0x2000             MOVS     R0,#+0
   \      0x12C   0x6560             STR      R0,[R4, #+84]
   2066            }
   2067          
   2068            /* Clear the Error flags in the SR register */
   2069            __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \                     ??HAL_SPI_Abort_15: (+1)
   \      0x12E   0x2000             MOVS     R0,#+0
   \      0x130   0x9001             STR      R0,[SP, #+4]
   \      0x132   0x6820             LDR      R0,[R4, #+0]
   \      0x134   0x68C0             LDR      R0,[R0, #+12]
   \      0x136   0x9001             STR      R0,[SP, #+4]
   \      0x138   0x6820             LDR      R0,[R4, #+0]
   \      0x13A   0x6880             LDR      R0,[R0, #+8]
   \      0x13C   0x9001             STR      R0,[SP, #+4]
   \      0x13E   0x9801             LDR      R0,[SP, #+4]
   2070            __HAL_SPI_CLEAR_FREFLAG(hspi);
   \      0x140   0x2000             MOVS     R0,#+0
   \      0x142   0x9001             STR      R0,[SP, #+4]
   \      0x144   0x6820             LDR      R0,[R4, #+0]
   \      0x146   0x6880             LDR      R0,[R0, #+8]
   \      0x148   0x9001             STR      R0,[SP, #+4]
   \      0x14A   0x9801             LDR      R0,[SP, #+4]
   2071          
   2072            /* Restore hspi->state to ready */
   2073            hspi->State = HAL_SPI_STATE_READY;
   \      0x14C   0x2001             MOVS     R0,#+1
   \      0x14E   0xF884 0x0051      STRB     R0,[R4, #+81]
   2074          
   2075            return errorcode;
   \      0x152   0x0028             MOVS     R0,R5
   \      0x154   0xB2C0             UXTB     R0,R0
   \      0x156   0xBD3E             POP      {R1-R5,PC}
   2076          }
   2077          
   2078          /**
   2079            * @brief  Abort ongoing transfer (Interrupt mode).
   2080            * @param  hspi SPI handle.
   2081            * @note   This procedure could be used for aborting any ongoing transfer (Tx and Rx),
   2082            *         started in Interrupt or DMA mode.
   2083            *         This procedure performs following operations :
   2084            *           - Disable SPI Interrupts (depending of transfer direction)
   2085            *           - Disable the DMA transfer in the peripheral register (if enabled)
   2086            *           - Abort DMA transfer by calling HAL_DMA_Abort_IT (in case of transfer in DMA mode)
   2087            *           - Set handle State to READY
   2088            *           - At abort completion, call user abort complete callback
   2089            * @note   This procedure is executed in Interrupt mode, meaning that abort procedure could be
   2090            *         considered as completed only when user abort complete callback is executed (not when exiting function).
   2091            * @retval HAL status
   2092            */

   \                                 In section .text, align 2, keep-with-next
   2093          HAL_StatusTypeDef HAL_SPI_Abort_IT(SPI_HandleTypeDef *hspi)
   2094          {
   \                     HAL_SPI_Abort_IT: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2095            HAL_StatusTypeDef errorcode;
   2096            uint32_t abortcplt ;
   2097            __IO uint32_t count;
   2098            __IO uint32_t resetcount;
   2099          
   2100            /* Initialized local variable  */
   2101            errorcode = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
   2102            abortcplt = 1U;
   \        0x6   0x2601             MOVS     R6,#+1
   2103            resetcount = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   \        0x8   0x.... 0x....      LDR.W    R0,??DataTable9
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x2118             MOVS     R1,#+24
   \       0x10   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x14   0xF44F 0x717A      MOV      R1,#+1000
   \       0x18   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x1C   0x2064             MOVS     R0,#+100
   \       0x1E   0x4341             MULS     R1,R0,R1
   \       0x20   0x9102             STR      R1,[SP, #+8]
   2104            count = resetcount;
   \       0x22   0x9802             LDR      R0,[SP, #+8]
   \       0x24   0x9000             STR      R0,[SP, #+0]
   2105          
   2106            /* Clear ERRIE interrupt to avoid error interrupts generation during Abort procedure */
   2107            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_ERRIE);
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6840             LDR      R0,[R0, #+4]
   \       0x2A   0xF030 0x0020      BICS     R0,R0,#0x20
   \       0x2E   0x6821             LDR      R1,[R4, #+0]
   \       0x30   0x6048             STR      R0,[R1, #+4]
   2108          
   2109            /* Change Rx and Tx Irq Handler to Disable TXEIE, RXNEIE and ERRIE interrupts */
   2110            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXEIE))
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x6840             LDR      R0,[R0, #+4]
   \       0x36   0x0600             LSLS     R0,R0,#+24
   \       0x38   0xD513             BPL.N    ??HAL_SPI_Abort_IT_0
   2111            {
   2112              hspi->TxISR = SPI_AbortTx_ISR;
   \       0x3A   0x.... 0x....      ADR.W    R0,SPI_AbortTx_ISR
   \       0x3E   0x6460             STR      R0,[R4, #+68]
   2113              /* Wait HAL_SPI_STATE_ABORT state */
   2114              do
   2115              {
   2116                if (count == 0U)
   \                     ??HAL_SPI_Abort_IT_1: (+1)
   \       0x40   0x9800             LDR      R0,[SP, #+0]
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD104             BNE.N    ??HAL_SPI_Abort_IT_2
   2117                {
   2118                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   \       0x46   0x6D60             LDR      R0,[R4, #+84]
   \       0x48   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x4C   0x6560             STR      R0,[R4, #+84]
   2119                  break;
   \       0x4E   0xE006             B.N      ??HAL_SPI_Abort_IT_3
   2120                }
   2121                count--;
   \                     ??HAL_SPI_Abort_IT_2: (+1)
   \       0x50   0x9800             LDR      R0,[SP, #+0]
   \       0x52   0x1E40             SUBS     R0,R0,#+1
   \       0x54   0x9000             STR      R0,[SP, #+0]
   2122              } while (hspi->State != HAL_SPI_STATE_ABORT);
   \       0x56   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \       0x5A   0x2807             CMP      R0,#+7
   \       0x5C   0xD1F0             BNE.N    ??HAL_SPI_Abort_IT_1
   2123              /* Reset Timeout Counter */
   2124              count = resetcount;
   \                     ??HAL_SPI_Abort_IT_3: (+1)
   \       0x5E   0x9802             LDR      R0,[SP, #+8]
   \       0x60   0x9000             STR      R0,[SP, #+0]
   2125            }
   2126          
   2127            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXNEIE))
   \                     ??HAL_SPI_Abort_IT_0: (+1)
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x6840             LDR      R0,[R0, #+4]
   \       0x66   0x0640             LSLS     R0,R0,#+25
   \       0x68   0xD513             BPL.N    ??HAL_SPI_Abort_IT_4
   2128            {
   2129              hspi->RxISR = SPI_AbortRx_ISR;
   \       0x6A   0x.... 0x....      ADR.W    R0,SPI_AbortRx_ISR
   \       0x6E   0x6420             STR      R0,[R4, #+64]
   2130              /* Wait HAL_SPI_STATE_ABORT state */
   2131              do
   2132              {
   2133                if (count == 0U)
   \                     ??HAL_SPI_Abort_IT_5: (+1)
   \       0x70   0x9800             LDR      R0,[SP, #+0]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD104             BNE.N    ??HAL_SPI_Abort_IT_6
   2134                {
   2135                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   \       0x76   0x6D60             LDR      R0,[R4, #+84]
   \       0x78   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x7C   0x6560             STR      R0,[R4, #+84]
   2136                  break;
   \       0x7E   0xE006             B.N      ??HAL_SPI_Abort_IT_7
   2137                }
   2138                count--;
   \                     ??HAL_SPI_Abort_IT_6: (+1)
   \       0x80   0x9800             LDR      R0,[SP, #+0]
   \       0x82   0x1E40             SUBS     R0,R0,#+1
   \       0x84   0x9000             STR      R0,[SP, #+0]
   2139              } while (hspi->State != HAL_SPI_STATE_ABORT);
   \       0x86   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \       0x8A   0x2807             CMP      R0,#+7
   \       0x8C   0xD1F0             BNE.N    ??HAL_SPI_Abort_IT_5
   2140              /* Reset Timeout Counter */
   2141              count = resetcount;
   \                     ??HAL_SPI_Abort_IT_7: (+1)
   \       0x8E   0x9802             LDR      R0,[SP, #+8]
   \       0x90   0x9000             STR      R0,[SP, #+0]
   2142            }
   2143          
   2144            /* If DMA Tx and/or DMA Rx Handles are associated to SPI Handle, DMA Abort complete callbacks should be initialised
   2145               before any call to DMA Abort functions */
   2146            /* DMA Tx Handle is valid */
   2147            if (hspi->hdmatx != NULL)
   \                     ??HAL_SPI_Abort_IT_4: (+1)
   \       0x92   0x6CA0             LDR      R0,[R4, #+72]
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD00B             BEQ.N    ??HAL_SPI_Abort_IT_8
   2148            {
   2149              /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
   2150                 Otherwise, set it to NULL */
   2151              if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
   \       0x98   0x6820             LDR      R0,[R4, #+0]
   \       0x9A   0x6840             LDR      R0,[R0, #+4]
   \       0x9C   0x0780             LSLS     R0,R0,#+30
   \       0x9E   0xD504             BPL.N    ??HAL_SPI_Abort_IT_9
   2152              {
   2153                hspi->hdmatx->XferAbortCallback = SPI_DMATxAbortCallback;
   \       0xA0   0x.... 0x....      ADR.W    R0,SPI_DMATxAbortCallback
   \       0xA4   0x6CA1             LDR      R1,[R4, #+72]
   \       0xA6   0x6508             STR      R0,[R1, #+80]
   \       0xA8   0xE002             B.N      ??HAL_SPI_Abort_IT_8
   2154              }
   2155              else
   2156              {
   2157                hspi->hdmatx->XferAbortCallback = NULL;
   \                     ??HAL_SPI_Abort_IT_9: (+1)
   \       0xAA   0x2000             MOVS     R0,#+0
   \       0xAC   0x6CA1             LDR      R1,[R4, #+72]
   \       0xAE   0x6508             STR      R0,[R1, #+80]
   2158              }
   2159            }
   2160            /* DMA Rx Handle is valid */
   2161            if (hspi->hdmarx != NULL)
   \                     ??HAL_SPI_Abort_IT_8: (+1)
   \       0xB0   0x6CE0             LDR      R0,[R4, #+76]
   \       0xB2   0x2800             CMP      R0,#+0
   \       0xB4   0xD00B             BEQ.N    ??HAL_SPI_Abort_IT_10
   2162            {
   2163              /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
   2164                 Otherwise, set it to NULL */
   2165              if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
   \       0xB6   0x6820             LDR      R0,[R4, #+0]
   \       0xB8   0x6840             LDR      R0,[R0, #+4]
   \       0xBA   0x07C0             LSLS     R0,R0,#+31
   \       0xBC   0xD504             BPL.N    ??HAL_SPI_Abort_IT_11
   2166              {
   2167                hspi->hdmarx->XferAbortCallback = SPI_DMARxAbortCallback;
   \       0xBE   0x.... 0x....      ADR.W    R0,SPI_DMARxAbortCallback
   \       0xC2   0x6CE1             LDR      R1,[R4, #+76]
   \       0xC4   0x6508             STR      R0,[R1, #+80]
   \       0xC6   0xE002             B.N      ??HAL_SPI_Abort_IT_10
   2168              }
   2169              else
   2170              {
   2171                hspi->hdmarx->XferAbortCallback = NULL;
   \                     ??HAL_SPI_Abort_IT_11: (+1)
   \       0xC8   0x2000             MOVS     R0,#+0
   \       0xCA   0x6CE1             LDR      R1,[R4, #+76]
   \       0xCC   0x6508             STR      R0,[R1, #+80]
   2172              }
   2173            }
   2174          
   2175            /* Disable the SPI DMA Tx request if enabled */
   2176            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_TXDMAEN))
   \                     ??HAL_SPI_Abort_IT_10: (+1)
   \       0xCE   0x6820             LDR      R0,[R4, #+0]
   \       0xD0   0x6840             LDR      R0,[R0, #+4]
   \       0xD2   0x0780             LSLS     R0,R0,#+30
   \       0xD4   0xD50F             BPL.N    ??HAL_SPI_Abort_IT_12
   2177            {
   2178              /* Abort the SPI DMA Tx Stream/Channel */
   2179              if (hspi->hdmatx != NULL)
   \       0xD6   0x6CA0             LDR      R0,[R4, #+72]
   \       0xD8   0x2800             CMP      R0,#+0
   \       0xDA   0xD00C             BEQ.N    ??HAL_SPI_Abort_IT_12
   2180              {
   2181                /* Abort DMA Tx Handle linked to SPI Peripheral */
   2182                if (HAL_DMA_Abort_IT(hspi->hdmatx) != HAL_OK)
   \       0xDC   0x6CA0             LDR      R0,[R4, #+72]
   \       0xDE   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0xE2   0x2800             CMP      R0,#+0
   \       0xE4   0xD005             BEQ.N    ??HAL_SPI_Abort_IT_13
   2183                {
   2184                  hspi->hdmatx->XferAbortCallback = NULL;
   \       0xE6   0x2000             MOVS     R0,#+0
   \       0xE8   0x6CA1             LDR      R1,[R4, #+72]
   \       0xEA   0x6508             STR      R0,[R1, #+80]
   2185                  hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   \       0xEC   0x2040             MOVS     R0,#+64
   \       0xEE   0x6560             STR      R0,[R4, #+84]
   \       0xF0   0xE001             B.N      ??HAL_SPI_Abort_IT_12
   2186                }
   2187                else
   2188                {
   2189                  abortcplt = 0U;
   \                     ??HAL_SPI_Abort_IT_13: (+1)
   \       0xF2   0x2000             MOVS     R0,#+0
   \       0xF4   0x0006             MOVS     R6,R0
   2190                }
   2191              }
   2192            }
   2193            /* Disable the SPI DMA Rx request if enabled */
   2194            if (HAL_IS_BIT_SET(hspi->Instance->CR2, SPI_CR2_RXDMAEN))
   \                     ??HAL_SPI_Abort_IT_12: (+1)
   \       0xF6   0x6820             LDR      R0,[R4, #+0]
   \       0xF8   0x6840             LDR      R0,[R0, #+4]
   \       0xFA   0x07C0             LSLS     R0,R0,#+31
   \       0xFC   0xD50F             BPL.N    ??HAL_SPI_Abort_IT_14
   2195            {
   2196              /* Abort the SPI DMA Rx Stream/Channel */
   2197              if (hspi->hdmarx != NULL)
   \       0xFE   0x6CE0             LDR      R0,[R4, #+76]
   \      0x100   0x2800             CMP      R0,#+0
   \      0x102   0xD00C             BEQ.N    ??HAL_SPI_Abort_IT_14
   2198              {
   2199                /* Abort DMA Rx Handle linked to SPI Peripheral */
   2200                if (HAL_DMA_Abort_IT(hspi->hdmarx) !=  HAL_OK)
   \      0x104   0x6CE0             LDR      R0,[R4, #+76]
   \      0x106   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \      0x10A   0x2800             CMP      R0,#+0
   \      0x10C   0xD005             BEQ.N    ??HAL_SPI_Abort_IT_15
   2201                {
   2202                  hspi->hdmarx->XferAbortCallback = NULL;
   \      0x10E   0x2000             MOVS     R0,#+0
   \      0x110   0x6CE1             LDR      R1,[R4, #+76]
   \      0x112   0x6508             STR      R0,[R1, #+80]
   2203                  hspi->ErrorCode = HAL_SPI_ERROR_ABORT;
   \      0x114   0x2040             MOVS     R0,#+64
   \      0x116   0x6560             STR      R0,[R4, #+84]
   \      0x118   0xE001             B.N      ??HAL_SPI_Abort_IT_14
   2204                }
   2205                else
   2206                {
   2207                  abortcplt = 0U;
   \                     ??HAL_SPI_Abort_IT_15: (+1)
   \      0x11A   0x2000             MOVS     R0,#+0
   \      0x11C   0x0006             MOVS     R6,R0
   2208                }
   2209              }
   2210            }
   2211          
   2212            if (abortcplt == 1U)
   \                     ??HAL_SPI_Abort_IT_14: (+1)
   \      0x11E   0x2E01             CMP      R6,#+1
   \      0x120   0xD120             BNE.N    ??HAL_SPI_Abort_IT_16
   2213            {
   2214              /* Reset Tx and Rx transfer counters */
   2215              hspi->RxXferCount = 0U;
   \      0x122   0x2000             MOVS     R0,#+0
   \      0x124   0x87E0             STRH     R0,[R4, #+62]
   2216              hspi->TxXferCount = 0U;
   \      0x126   0x2000             MOVS     R0,#+0
   \      0x128   0x86E0             STRH     R0,[R4, #+54]
   2217          
   2218              /* Check error during Abort procedure */
   2219              if (hspi->ErrorCode == HAL_SPI_ERROR_ABORT)
   \      0x12A   0x6D60             LDR      R0,[R4, #+84]
   \      0x12C   0x2840             CMP      R0,#+64
   \      0x12E   0xD102             BNE.N    ??HAL_SPI_Abort_IT_17
   2220              {
   2221                /* return HAL_Error in case of error during Abort procedure */
   2222                errorcode = HAL_ERROR;
   \      0x130   0x2001             MOVS     R0,#+1
   \      0x132   0x0005             MOVS     R5,R0
   \      0x134   0xE001             B.N      ??HAL_SPI_Abort_IT_18
   2223              }
   2224              else
   2225              {
   2226                /* Reset errorCode */
   2227                hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \                     ??HAL_SPI_Abort_IT_17: (+1)
   \      0x136   0x2000             MOVS     R0,#+0
   \      0x138   0x6560             STR      R0,[R4, #+84]
   2228              }
   2229          
   2230              /* Clear the Error flags in the SR register */
   2231              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \                     ??HAL_SPI_Abort_IT_18: (+1)
   \      0x13A   0x2000             MOVS     R0,#+0
   \      0x13C   0x9001             STR      R0,[SP, #+4]
   \      0x13E   0x6820             LDR      R0,[R4, #+0]
   \      0x140   0x68C0             LDR      R0,[R0, #+12]
   \      0x142   0x9001             STR      R0,[SP, #+4]
   \      0x144   0x6820             LDR      R0,[R4, #+0]
   \      0x146   0x6880             LDR      R0,[R0, #+8]
   \      0x148   0x9001             STR      R0,[SP, #+4]
   \      0x14A   0x9801             LDR      R0,[SP, #+4]
   2232              __HAL_SPI_CLEAR_FREFLAG(hspi);
   \      0x14C   0x2000             MOVS     R0,#+0
   \      0x14E   0x9001             STR      R0,[SP, #+4]
   \      0x150   0x6820             LDR      R0,[R4, #+0]
   \      0x152   0x6880             LDR      R0,[R0, #+8]
   \      0x154   0x9001             STR      R0,[SP, #+4]
   \      0x156   0x9801             LDR      R0,[SP, #+4]
   2233          
   2234              /* Restore hspi->State to Ready */
   2235              hspi->State = HAL_SPI_STATE_READY;
   \      0x158   0x2001             MOVS     R0,#+1
   \      0x15A   0xF884 0x0051      STRB     R0,[R4, #+81]
   2236          
   2237              /* As no DMA to be aborted, call directly user Abort complete callback */
   2238          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2239              hspi->AbortCpltCallback(hspi);
   2240          #else
   2241              HAL_SPI_AbortCpltCallback(hspi);
   \      0x15E   0x0020             MOVS     R0,R4
   \      0x160   0x.... 0x....      BL       HAL_SPI_AbortCpltCallback
   2242          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2243            }
   2244          
   2245            return errorcode;
   \                     ??HAL_SPI_Abort_IT_16: (+1)
   \      0x164   0x0028             MOVS     R0,R5
   \      0x166   0xB2C0             UXTB     R0,R0
   \      0x168   0xB004             ADD      SP,SP,#+16
   \      0x16A   0xBD70             POP      {R4-R6,PC}
   2246          }
   2247          
   2248          /**
   2249            * @brief  Pause the DMA Transfer.
   2250            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2251            *               the configuration information for the specified SPI module.
   2252            * @retval HAL status
   2253            */

   \                                 In section .text, align 2, keep-with-next
   2254          HAL_StatusTypeDef HAL_SPI_DMAPause(SPI_HandleTypeDef *hspi)
   2255          {
   \                     HAL_SPI_DMAPause: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   2256            /* Process Locked */
   2257            __HAL_LOCK(hspi);
   \        0x2   0xF891 0x0050      LDRB     R0,[R1, #+80]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD101             BNE.N    ??HAL_SPI_DMAPause_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xE00C             B.N      ??HAL_SPI_DMAPause_1
   \                     ??HAL_SPI_DMAPause_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF881 0x0050      STRB     R0,[R1, #+80]
   2258          
   2259            /* Disable the SPI DMA Tx & Rx requests */
   2260            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \       0x14   0x6808             LDR      R0,[R1, #+0]
   \       0x16   0x6840             LDR      R0,[R0, #+4]
   \       0x18   0x0880             LSRS     R0,R0,#+2
   \       0x1A   0x0080             LSLS     R0,R0,#+2
   \       0x1C   0x680A             LDR      R2,[R1, #+0]
   \       0x1E   0x6050             STR      R0,[R2, #+4]
   2261          
   2262            /* Process Unlocked */
   2263            __HAL_UNLOCK(hspi);
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xF881 0x0050      STRB     R0,[R1, #+80]
   2264          
   2265            return HAL_OK;
   \       0x26   0x2000             MOVS     R0,#+0
   \                     ??HAL_SPI_DMAPause_1: (+1)
   \       0x28   0x4770             BX       LR
   2266          }
   2267          
   2268          /**
   2269            * @brief  Resume the DMA Transfer.
   2270            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2271            *               the configuration information for the specified SPI module.
   2272            * @retval HAL status
   2273            */

   \                                 In section .text, align 2, keep-with-next
   2274          HAL_StatusTypeDef HAL_SPI_DMAResume(SPI_HandleTypeDef *hspi)
   2275          {
   \                     HAL_SPI_DMAResume: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   2276            /* Process Locked */
   2277            __HAL_LOCK(hspi);
   \        0x2   0xF891 0x0050      LDRB     R0,[R1, #+80]
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD101             BNE.N    ??HAL_SPI_DMAResume_0
   \        0xA   0x2002             MOVS     R0,#+2
   \        0xC   0xE00C             B.N      ??HAL_SPI_DMAResume_1
   \                     ??HAL_SPI_DMAResume_0: (+1)
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xF881 0x0050      STRB     R0,[R1, #+80]
   2278          
   2279            /* Enable the SPI DMA Tx & Rx requests */
   2280            SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \       0x14   0x6808             LDR      R0,[R1, #+0]
   \       0x16   0x6840             LDR      R0,[R0, #+4]
   \       0x18   0xF050 0x0003      ORRS     R0,R0,#0x3
   \       0x1C   0x680A             LDR      R2,[R1, #+0]
   \       0x1E   0x6050             STR      R0,[R2, #+4]
   2281          
   2282            /* Process Unlocked */
   2283            __HAL_UNLOCK(hspi);
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xF881 0x0050      STRB     R0,[R1, #+80]
   2284          
   2285            return HAL_OK;
   \       0x26   0x2000             MOVS     R0,#+0
   \                     ??HAL_SPI_DMAResume_1: (+1)
   \       0x28   0x4770             BX       LR
   2286          }
   2287          
   2288          /**
   2289            * @brief  Stop the DMA Transfer.
   2290            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2291            *               the configuration information for the specified SPI module.
   2292            * @retval HAL status
   2293            */

   \                                 In section .text, align 2, keep-with-next
   2294          HAL_StatusTypeDef HAL_SPI_DMAStop(SPI_HandleTypeDef *hspi)
   2295          {
   \                     HAL_SPI_DMAStop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2296            HAL_StatusTypeDef errorcode = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
   2297            /* The Lock is not implemented on this API to allow the user application
   2298               to call the HAL SPI API under callbacks HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback():
   2299               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   2300               and the correspond call back is executed HAL_SPI_TxCpltCallback() or HAL_SPI_RxCpltCallback() or HAL_SPI_TxRxCpltCallback()
   2301               */
   2302          
   2303            /* Abort the SPI DMA tx Stream/Channel  */
   2304            if (hspi->hdmatx != NULL)
   \        0x6   0x6CA0             LDR      R0,[R4, #+72]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD00A             BEQ.N    ??HAL_SPI_DMAStop_0
   2305            {
   2306              if (HAL_OK != HAL_DMA_Abort(hspi->hdmatx))
   \        0xC   0x6CA0             LDR      R0,[R4, #+72]
   \        0xE   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD005             BEQ.N    ??HAL_SPI_DMAStop_0
   2307              {
   2308                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   \       0x16   0x6D60             LDR      R0,[R4, #+84]
   \       0x18   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x1C   0x6560             STR      R0,[R4, #+84]
   2309                errorcode = HAL_ERROR;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0x0005             MOVS     R5,R0
   2310              }
   2311            }
   2312            /* Abort the SPI DMA rx Stream/Channel  */
   2313            if (hspi->hdmarx != NULL)
   \                     ??HAL_SPI_DMAStop_0: (+1)
   \       0x22   0x6CE0             LDR      R0,[R4, #+76]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD00A             BEQ.N    ??HAL_SPI_DMAStop_1
   2314            {
   2315              if (HAL_OK != HAL_DMA_Abort(hspi->hdmarx))
   \       0x28   0x6CE0             LDR      R0,[R4, #+76]
   \       0x2A   0x.... 0x....      BL       HAL_DMA_Abort
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD005             BEQ.N    ??HAL_SPI_DMAStop_1
   2316              {
   2317                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   \       0x32   0x6D60             LDR      R0,[R4, #+84]
   \       0x34   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x38   0x6560             STR      R0,[R4, #+84]
   2318                errorcode = HAL_ERROR;
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0x0005             MOVS     R5,R0
   2319              }
   2320            }
   2321          
   2322            /* Disable the SPI DMA Tx & Rx requests */
   2323            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \                     ??HAL_SPI_DMAStop_1: (+1)
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6840             LDR      R0,[R0, #+4]
   \       0x42   0x0880             LSRS     R0,R0,#+2
   \       0x44   0x0080             LSLS     R0,R0,#+2
   \       0x46   0x6821             LDR      R1,[R4, #+0]
   \       0x48   0x6048             STR      R0,[R1, #+4]
   2324            hspi->State = HAL_SPI_STATE_READY;
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0xF884 0x0051      STRB     R0,[R4, #+81]
   2325            return errorcode;
   \       0x50   0x0028             MOVS     R0,R5
   \       0x52   0xB2C0             UXTB     R0,R0
   \       0x54   0xBD32             POP      {R1,R4,R5,PC}
   2326          }
   2327          
   2328          /**
   2329            * @brief  Handle SPI interrupt request.
   2330            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2331            *               the configuration information for the specified SPI module.
   2332            * @retval None
   2333            */

   \                                 In section .text, align 2, keep-with-next
   2334          void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
   2335          {
   \                     HAL_SPI_IRQHandler: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2336            uint32_t itsource = hspi->Instance->CR2;
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6845             LDR      R5,[R0, #+4]
   2337            uint32_t itflag   = hspi->Instance->SR;
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x6886             LDR      R6,[R0, #+8]
   2338          
   2339            /* SPI in mode Receiver ----------------------------------------------------*/
   2340            if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
   2341                (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
   \        0xC   0xF016 0x0041      ANDS     R0,R6,#0x41
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD105             BNE.N    ??HAL_SPI_IRQHandler_0
   \       0x14   0x0668             LSLS     R0,R5,#+25
   \       0x16   0xD503             BPL.N    ??HAL_SPI_IRQHandler_0
   2342            {
   2343              hspi->RxISR(hspi);
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0x6C21             LDR      R1,[R4, #+64]
   \       0x1C   0x4788             BLX      R1
   2344              return;
   \       0x1E   0xE082             B.N      ??HAL_SPI_IRQHandler_1
   2345            }
   2346          
   2347            /* SPI in mode Transmitter -------------------------------------------------*/
   2348            if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
   \                     ??HAL_SPI_IRQHandler_0: (+1)
   \       0x20   0x07B0             LSLS     R0,R6,#+30
   \       0x22   0xD505             BPL.N    ??HAL_SPI_IRQHandler_2
   \       0x24   0x0628             LSLS     R0,R5,#+24
   \       0x26   0xD503             BPL.N    ??HAL_SPI_IRQHandler_2
   2349            {
   2350              hspi->TxISR(hspi);
   \       0x28   0x0020             MOVS     R0,R4
   \       0x2A   0x6C61             LDR      R1,[R4, #+68]
   \       0x2C   0x4788             BLX      R1
   2351              return;
   \       0x2E   0xE07A             B.N      ??HAL_SPI_IRQHandler_1
   2352            }
   2353          
   2354            /* SPI in Error Treatment --------------------------------------------------*/
   2355            if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
   2356                 || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
   \                     ??HAL_SPI_IRQHandler_2: (+1)
   \       0x30   0xF416 0x7FB0      TST      R6,#0x160
   \       0x34   0xD077             BEQ.N    ??HAL_SPI_IRQHandler_3
   \       0x36   0x06A8             LSLS     R0,R5,#+26
   \       0x38   0xD575             BPL.N    ??HAL_SPI_IRQHandler_3
   2357            {
   2358              /* SPI Overrun error interrupt occurred ----------------------------------*/
   2359              if (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
   \       0x3A   0x0670             LSLS     R0,R6,#+25
   \       0x3C   0xD51B             BPL.N    ??HAL_SPI_IRQHandler_4
   2360              {
   2361                if (hspi->State != HAL_SPI_STATE_BUSY_TX)
   \       0x3E   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \       0x42   0x2803             CMP      R0,#+3
   \       0x44   0xD00D             BEQ.N    ??HAL_SPI_IRQHandler_5
   2362                {
   2363                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
   \       0x46   0x6D60             LDR      R0,[R4, #+84]
   \       0x48   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x4C   0x6560             STR      R0,[R4, #+84]
   2364                  __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x9000             STR      R0,[SP, #+0]
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x68C0             LDR      R0,[R0, #+12]
   \       0x56   0x9000             STR      R0,[SP, #+0]
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x6880             LDR      R0,[R0, #+8]
   \       0x5C   0x9000             STR      R0,[SP, #+0]
   \       0x5E   0x9800             LDR      R0,[SP, #+0]
   \       0x60   0xE009             B.N      ??HAL_SPI_IRQHandler_4
   2365                }
   2366                else
   2367                {
   2368                  __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \                     ??HAL_SPI_IRQHandler_5: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x9000             STR      R0,[SP, #+0]
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x68C0             LDR      R0,[R0, #+12]
   \       0x6A   0x9000             STR      R0,[SP, #+0]
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x6880             LDR      R0,[R0, #+8]
   \       0x70   0x9000             STR      R0,[SP, #+0]
   \       0x72   0x9800             LDR      R0,[SP, #+0]
   2369                  return;
   \       0x74   0xE057             B.N      ??HAL_SPI_IRQHandler_1
   2370                }
   2371              }
   2372          
   2373              /* SPI Mode Fault error interrupt occurred -------------------------------*/
   2374              if (SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET)
   \                     ??HAL_SPI_IRQHandler_4: (+1)
   \       0x76   0x06B0             LSLS     R0,R6,#+26
   \       0x78   0xD50F             BPL.N    ??HAL_SPI_IRQHandler_6
   2375              {
   2376                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
   \       0x7A   0x6D60             LDR      R0,[R4, #+84]
   \       0x7C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x80   0x6560             STR      R0,[R4, #+84]
   2377                __HAL_SPI_CLEAR_MODFFLAG(hspi);
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0x9000             STR      R0,[SP, #+0]
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x6880             LDR      R0,[R0, #+8]
   \       0x8A   0x9000             STR      R0,[SP, #+0]
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x6800             LDR      R0,[R0, #+0]
   \       0x90   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x94   0x6821             LDR      R1,[R4, #+0]
   \       0x96   0x6008             STR      R0,[R1, #+0]
   \       0x98   0x9800             LDR      R0,[SP, #+0]
   2378              }
   2379          
   2380              /* SPI Frame error interrupt occurred ------------------------------------*/
   2381              if (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)
   \                     ??HAL_SPI_IRQHandler_6: (+1)
   \       0x9A   0x05F0             LSLS     R0,R6,#+23
   \       0x9C   0xD509             BPL.N    ??HAL_SPI_IRQHandler_7
   2382              {
   2383                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
   \       0x9E   0x6D60             LDR      R0,[R4, #+84]
   \       0xA0   0xF050 0x0008      ORRS     R0,R0,#0x8
   \       0xA4   0x6560             STR      R0,[R4, #+84]
   2384                __HAL_SPI_CLEAR_FREFLAG(hspi);
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0x9000             STR      R0,[SP, #+0]
   \       0xAA   0x6820             LDR      R0,[R4, #+0]
   \       0xAC   0x6880             LDR      R0,[R0, #+8]
   \       0xAE   0x9000             STR      R0,[SP, #+0]
   \       0xB0   0x9800             LDR      R0,[SP, #+0]
   2385              }
   2386          
   2387              if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \                     ??HAL_SPI_IRQHandler_7: (+1)
   \       0xB2   0x6D60             LDR      R0,[R4, #+84]
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD035             BEQ.N    ??HAL_SPI_IRQHandler_8
   2388              {
   2389                /* Disable all interrupts */
   2390                __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
   \       0xB8   0x6820             LDR      R0,[R4, #+0]
   \       0xBA   0x6840             LDR      R0,[R0, #+4]
   \       0xBC   0xF030 0x00E0      BICS     R0,R0,#0xE0
   \       0xC0   0x6821             LDR      R1,[R4, #+0]
   \       0xC2   0x6048             STR      R0,[R1, #+4]
   2391          
   2392                hspi->State = HAL_SPI_STATE_READY;
   \       0xC4   0x2001             MOVS     R0,#+1
   \       0xC6   0xF884 0x0051      STRB     R0,[R4, #+81]
   2393                /* Disable the SPI DMA requests if enabled */
   2394                if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
   \       0xCA   0xF015 0x0F03      TST      R5,#0x3
   \       0xCE   0xD026             BEQ.N    ??HAL_SPI_IRQHandler_9
   2395                {
   2396                  CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
   \       0xD0   0x6820             LDR      R0,[R4, #+0]
   \       0xD2   0x6840             LDR      R0,[R0, #+4]
   \       0xD4   0x0880             LSRS     R0,R0,#+2
   \       0xD6   0x0080             LSLS     R0,R0,#+2
   \       0xD8   0x6821             LDR      R1,[R4, #+0]
   \       0xDA   0x6048             STR      R0,[R1, #+4]
   2397          
   2398                  /* Abort the SPI DMA Rx channel */
   2399                  if (hspi->hdmarx != NULL)
   \       0xDC   0x6CE0             LDR      R0,[R4, #+76]
   \       0xDE   0x2800             CMP      R0,#+0
   \       0xE0   0xD00C             BEQ.N    ??HAL_SPI_IRQHandler_10
   2400                  {
   2401                    /* Set the SPI DMA Abort callback :
   2402                    will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
   2403                    hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
   \       0xE2   0x.... 0x....      ADR.W    R0,SPI_DMAAbortOnError
   \       0xE6   0x6CE1             LDR      R1,[R4, #+76]
   \       0xE8   0x6508             STR      R0,[R1, #+80]
   2404                    if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
   \       0xEA   0x6CE0             LDR      R0,[R4, #+76]
   \       0xEC   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0xF0   0x2800             CMP      R0,#+0
   \       0xF2   0xD003             BEQ.N    ??HAL_SPI_IRQHandler_10
   2405                    {
   2406                      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   \       0xF4   0x6D60             LDR      R0,[R4, #+84]
   \       0xF6   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0xFA   0x6560             STR      R0,[R4, #+84]
   2407                    }
   2408                  }
   2409                  /* Abort the SPI DMA Tx channel */
   2410                  if (hspi->hdmatx != NULL)
   \                     ??HAL_SPI_IRQHandler_10: (+1)
   \       0xFC   0x6CA0             LDR      R0,[R4, #+72]
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xD010             BEQ.N    ??HAL_SPI_IRQHandler_8
   2411                  {
   2412                    /* Set the SPI DMA Abort callback :
   2413                    will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
   2414                    hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
   \      0x102   0x.... 0x....      ADR.W    R0,SPI_DMAAbortOnError
   \      0x106   0x6CA1             LDR      R1,[R4, #+72]
   \      0x108   0x6508             STR      R0,[R1, #+80]
   2415                    if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
   \      0x10A   0x6CA0             LDR      R0,[R4, #+72]
   \      0x10C   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \      0x110   0x2800             CMP      R0,#+0
   \      0x112   0xD007             BEQ.N    ??HAL_SPI_IRQHandler_8
   2416                    {
   2417                      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   \      0x114   0x6D60             LDR      R0,[R4, #+84]
   \      0x116   0xF050 0x0040      ORRS     R0,R0,#0x40
   \      0x11A   0x6560             STR      R0,[R4, #+84]
   \      0x11C   0xE002             B.N      ??HAL_SPI_IRQHandler_8
   2418                    }
   2419                  }
   2420                }
   2421                else
   2422                {
   2423                  /* Call user error callback */
   2424          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2425                  hspi->ErrorCallback(hspi);
   2426          #else
   2427                  HAL_SPI_ErrorCallback(hspi);
   \                     ??HAL_SPI_IRQHandler_9: (+1)
   \      0x11E   0x0020             MOVS     R0,R4
   \      0x120   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   2428          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2429                }
   2430              }
   2431              return;
   \                     ??HAL_SPI_IRQHandler_8: (+1)
   \      0x124   0xE7FF             B.N      ??HAL_SPI_IRQHandler_1
   2432            }
   2433          }
   \                     ??HAL_SPI_IRQHandler_3: (+1)
   \                     ??HAL_SPI_IRQHandler_1: (+1)
   \      0x126   0xBD73             POP      {R0,R1,R4-R6,PC}
   2434          
   2435          /**
   2436            * @brief  Tx Transfer completed callback.
   2437            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2438            *               the configuration information for SPI module.
   2439            * @retval None
   2440            */

   \                                 In section .text, align 2
   2441          __weak void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)
   2442          {
   2443            /* Prevent unused argument(s) compilation warning */
   2444            UNUSED(hspi);
   2445          
   2446            /* NOTE : This function should not be modified, when the callback is needed,
   2447                      the HAL_SPI_TxCpltCallback should be implemented in the user file
   2448             */
   2449          }
   \                     HAL_SPI_TxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2450          
   2451          /**
   2452            * @brief  Rx Transfer completed callback.
   2453            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2454            *               the configuration information for SPI module.
   2455            * @retval None
   2456            */

   \                                 In section .text, align 2
   2457          __weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
   2458          {
   2459            /* Prevent unused argument(s) compilation warning */
   2460            UNUSED(hspi);
   2461          
   2462            /* NOTE : This function should not be modified, when the callback is needed,
   2463                      the HAL_SPI_RxCpltCallback should be implemented in the user file
   2464             */
   2465          }
   \                     HAL_SPI_RxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2466          
   2467          /**
   2468            * @brief  Tx and Rx Transfer completed callback.
   2469            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2470            *               the configuration information for SPI module.
   2471            * @retval None
   2472            */

   \                                 In section .text, align 2
   2473          __weak void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
   2474          {
   2475            /* Prevent unused argument(s) compilation warning */
   2476            UNUSED(hspi);
   2477          
   2478            /* NOTE : This function should not be modified, when the callback is needed,
   2479                      the HAL_SPI_TxRxCpltCallback should be implemented in the user file
   2480             */
   2481          }
   \                     HAL_SPI_TxRxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2482          
   2483          /**
   2484            * @brief  Tx Half Transfer completed callback.
   2485            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2486            *               the configuration information for SPI module.
   2487            * @retval None
   2488            */

   \                                 In section .text, align 2
   2489          __weak void HAL_SPI_TxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   2490          {
   2491            /* Prevent unused argument(s) compilation warning */
   2492            UNUSED(hspi);
   2493          
   2494            /* NOTE : This function should not be modified, when the callback is needed,
   2495                      the HAL_SPI_TxHalfCpltCallback should be implemented in the user file
   2496             */
   2497          }
   \                     HAL_SPI_TxHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2498          
   2499          /**
   2500            * @brief  Rx Half Transfer completed callback.
   2501            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2502            *               the configuration information for SPI module.
   2503            * @retval None
   2504            */

   \                                 In section .text, align 2
   2505          __weak void HAL_SPI_RxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   2506          {
   2507            /* Prevent unused argument(s) compilation warning */
   2508            UNUSED(hspi);
   2509          
   2510            /* NOTE : This function should not be modified, when the callback is needed,
   2511                      the HAL_SPI_RxHalfCpltCallback() should be implemented in the user file
   2512             */
   2513          }
   \                     HAL_SPI_RxHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2514          
   2515          /**
   2516            * @brief  Tx and Rx Half Transfer callback.
   2517            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2518            *               the configuration information for SPI module.
   2519            * @retval None
   2520            */

   \                                 In section .text, align 2
   2521          __weak void HAL_SPI_TxRxHalfCpltCallback(SPI_HandleTypeDef *hspi)
   2522          {
   2523            /* Prevent unused argument(s) compilation warning */
   2524            UNUSED(hspi);
   2525          
   2526            /* NOTE : This function should not be modified, when the callback is needed,
   2527                      the HAL_SPI_TxRxHalfCpltCallback() should be implemented in the user file
   2528             */
   2529          }
   \                     HAL_SPI_TxRxHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2530          
   2531          /**
   2532            * @brief  SPI error callback.
   2533            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2534            *               the configuration information for SPI module.
   2535            * @retval None
   2536            */

   \                                 In section .text, align 2
   2537          __weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
   2538          {
   2539            /* Prevent unused argument(s) compilation warning */
   2540            UNUSED(hspi);
   2541          
   2542            /* NOTE : This function should not be modified, when the callback is needed,
   2543                      the HAL_SPI_ErrorCallback should be implemented in the user file
   2544             */
   2545            /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
   2546                      and user can use HAL_SPI_GetError() API to check the latest error occurred
   2547             */
   2548          }
   \                     HAL_SPI_ErrorCallback: (+1)
   \        0x0   0x4770             BX       LR
   2549          
   2550          /**
   2551            * @brief  SPI Abort Complete callback.
   2552            * @param  hspi SPI handle.
   2553            * @retval None
   2554            */

   \                                 In section .text, align 2
   2555          __weak void HAL_SPI_AbortCpltCallback(SPI_HandleTypeDef *hspi)
   2556          {
   2557            /* Prevent unused argument(s) compilation warning */
   2558            UNUSED(hspi);
   2559          
   2560            /* NOTE : This function should not be modified, when the callback is needed,
   2561                      the HAL_SPI_AbortCpltCallback can be implemented in the user file.
   2562             */
   2563          }
   \                     HAL_SPI_AbortCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   2564          
   2565          /**
   2566            * @}
   2567            */
   2568          
   2569          /** @defgroup SPI_Exported_Functions_Group3 Peripheral State and Errors functions
   2570            * @brief   SPI control functions
   2571            *
   2572          @verbatim
   2573           ===============================================================================
   2574                                ##### Peripheral State and Errors functions #####
   2575           ===============================================================================
   2576              [..]
   2577              This subsection provides a set of functions allowing to control the SPI.
   2578               (+) HAL_SPI_GetState() API can be helpful to check in run-time the state of the SPI peripheral
   2579               (+) HAL_SPI_GetError() check in run-time Errors occurring during communication
   2580          @endverbatim
   2581            * @{
   2582            */
   2583          
   2584          /**
   2585            * @brief  Return the SPI handle state.
   2586            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2587            *               the configuration information for SPI module.
   2588            * @retval SPI state
   2589            */

   \                                 In section .text, align 2, keep-with-next
   2590          HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
   2591          {
   2592            /* Return SPI handle state */
   2593            return hspi->State;
   \                     HAL_SPI_GetState: (+1)
   \        0x0   0xF890 0x0051      LDRB     R0,[R0, #+81]
   \        0x4   0x4770             BX       LR
   2594          }
   2595          
   2596          /**
   2597            * @brief  Return the SPI error code.
   2598            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   2599            *               the configuration information for SPI module.
   2600            * @retval SPI error code in bitmap format
   2601            */

   \                                 In section .text, align 2, keep-with-next
   2602          uint32_t HAL_SPI_GetError(SPI_HandleTypeDef *hspi)
   2603          {
   2604            /* Return SPI ErrorCode */
   2605            return hspi->ErrorCode;
   \                     HAL_SPI_GetError: (+1)
   \        0x0   0x6D40             LDR      R0,[R0, #+84]
   \        0x2   0x4770             BX       LR
   2606          }
   2607          
   2608          /**
   2609            * @}
   2610            */
   2611          
   2612          /**
   2613            * @}
   2614            */
   2615          
   2616          /** @addtogroup SPI_Private_Functions
   2617            * @brief   Private functions
   2618            * @{
   2619            */
   2620          
   2621          /**
   2622            * @brief  DMA SPI transmit process complete callback.
   2623            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2624            *               the configuration information for the specified DMA module.
   2625            * @retval None
   2626            */

   \                                 In section .text, align 4, keep-with-next
   2627          static void SPI_DMATransmitCplt(DMA_HandleTypeDef *hdma)
   2628          {
   \                     SPI_DMATransmitCplt: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2629            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2630            uint32_t tickstart;
   2631          
   2632            /* Init tickstart for timeout management*/
   2633            tickstart = HAL_GetTick();
   \        0x6   0x.... 0x....      BL       HAL_GetTick
   \        0xA   0x0006             MOVS     R6,R0
   2634          
   2635            /* DMA Normal Mode */
   2636            if ((hdma->Instance->CR & DMA_SxCR_CIRC) != DMA_SxCR_CIRC)
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0x05C0             LSLS     R0,R0,#+23
   \       0x12   0xD42E             BMI.N    ??SPI_DMATransmitCplt_0
   2637            {
   2638              /* Disable ERR interrupt */
   2639              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x6840             LDR      R0,[R0, #+4]
   \       0x18   0xF030 0x0020      BICS     R0,R0,#0x20
   \       0x1C   0x6829             LDR      R1,[R5, #+0]
   \       0x1E   0x6048             STR      R0,[R1, #+4]
   2640          
   2641              /* Disable Tx DMA Request */
   2642              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \       0x20   0x6828             LDR      R0,[R5, #+0]
   \       0x22   0x6840             LDR      R0,[R0, #+4]
   \       0x24   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x28   0x6829             LDR      R1,[R5, #+0]
   \       0x2A   0x6048             STR      R0,[R1, #+4]
   2643          
   2644              /* Check the end of the transaction */
   2645              if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   \       0x2C   0x0032             MOVS     R2,R6
   \       0x2E   0x2164             MOVS     R1,#+100
   \       0x30   0x0028             MOVS     R0,R5
   \       0x32   0x.... 0x....      BL       SPI_EndRxTxTransaction
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD003             BEQ.N    ??SPI_DMATransmitCplt_1
   2646              {
   2647                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x3A   0x6D68             LDR      R0,[R5, #+84]
   \       0x3C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x40   0x6568             STR      R0,[R5, #+84]
   2648              }
   2649          
   2650              /* Clear overrun flag in 2 Lines communication mode because received data is not read */
   2651              if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??SPI_DMATransmitCplt_1: (+1)
   \       0x42   0x68A8             LDR      R0,[R5, #+8]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD108             BNE.N    ??SPI_DMATransmitCplt_2
   2652              {
   2653                __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x9000             STR      R0,[SP, #+0]
   \       0x4C   0x6828             LDR      R0,[R5, #+0]
   \       0x4E   0x68C0             LDR      R0,[R0, #+12]
   \       0x50   0x9000             STR      R0,[SP, #+0]
   \       0x52   0x6828             LDR      R0,[R5, #+0]
   \       0x54   0x6880             LDR      R0,[R0, #+8]
   \       0x56   0x9000             STR      R0,[SP, #+0]
   \       0x58   0x9800             LDR      R0,[SP, #+0]
   2654              }
   2655          
   2656              hspi->TxXferCount = 0U;
   \                     ??SPI_DMATransmitCplt_2: (+1)
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x86E8             STRH     R0,[R5, #+54]
   2657              hspi->State = HAL_SPI_STATE_READY;
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0xF885 0x0051      STRB     R0,[R5, #+81]
   2658          
   2659              if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \       0x64   0x6D68             LDR      R0,[R5, #+84]
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD003             BEQ.N    ??SPI_DMATransmitCplt_0
   2660              {
   2661                /* Call user error callback */
   2662          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2663                hspi->ErrorCallback(hspi);
   2664          #else
   2665                HAL_SPI_ErrorCallback(hspi);
   \       0x6A   0x0028             MOVS     R0,R5
   \       0x6C   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   2666          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2667                return;
   \       0x70   0xE002             B.N      ??SPI_DMATransmitCplt_3
   2668              }
   2669            }
   2670            /* Call user Tx complete callback */
   2671          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2672            hspi->TxCpltCallback(hspi);
   2673          #else
   2674            HAL_SPI_TxCpltCallback(hspi);
   \                     ??SPI_DMATransmitCplt_0: (+1)
   \       0x72   0x0028             MOVS     R0,R5
   \       0x74   0x.... 0x....      BL       HAL_SPI_TxCpltCallback
   2675          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2676          }
   \                     ??SPI_DMATransmitCplt_3: (+1)
   \       0x78   0xBD73             POP      {R0,R1,R4-R6,PC}
   2677          
   2678          /**
   2679            * @brief  DMA SPI receive process complete callback.
   2680            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2681            *               the configuration information for the specified DMA module.
   2682            * @retval None
   2683            */

   \                                 In section .text, align 4, keep-with-next
   2684          static void SPI_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
   2685          {
   \                     SPI_DMAReceiveCplt: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2686            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2687            uint32_t tickstart;
   2688          
   2689            /* Init tickstart for timeout management*/
   2690            tickstart = HAL_GetTick();
   \        0x6   0x.... 0x....      BL       HAL_GetTick
   \        0xA   0x0006             MOVS     R6,R0
   2691          
   2692            /* DMA Normal Mode */
   2693            if ((hdma->Instance->CR & DMA_SxCR_CIRC) != DMA_SxCR_CIRC)
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0x05C0             LSLS     R0,R0,#+23
   \       0x12   0xD42E             BMI.N    ??SPI_DMAReceiveCplt_0
   2694            {
   2695              /* Disable ERR interrupt */
   2696              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x6840             LDR      R0,[R0, #+4]
   \       0x18   0xF030 0x0020      BICS     R0,R0,#0x20
   \       0x1C   0x6829             LDR      R1,[R5, #+0]
   \       0x1E   0x6048             STR      R0,[R1, #+4]
   2697          
   2698          #if (USE_SPI_CRC != 0U)
   2699              /* CRC handling */
   2700              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2701              {
   2702                /* Wait until RXNE flag */
   2703                if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   2704                {
   2705                  /* Error on the CRC reception */
   2706                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   2707                }
   2708                /* Read CRC */
   2709                READ_REG(hspi->Instance->DR);
   2710              }
   2711          #endif /* USE_SPI_CRC */
   2712          
   2713              /* Check if we are in Master RX 2 line mode */
   2714              if ((hspi->Init.Direction == SPI_DIRECTION_2LINES) && (hspi->Init.Mode == SPI_MODE_MASTER))
   \       0x20   0x68A8             LDR      R0,[R5, #+8]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD10A             BNE.N    ??SPI_DMAReceiveCplt_1
   \       0x26   0x6868             LDR      R0,[R5, #+4]
   \       0x28   0xF5B0 0x7F82      CMP      R0,#+260
   \       0x2C   0xD106             BNE.N    ??SPI_DMAReceiveCplt_1
   2715              {
   2716                /* Disable Rx/Tx DMA Request (done by default to handle the case master rx direction 2 lines) */
   2717                CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \       0x2E   0x6828             LDR      R0,[R5, #+0]
   \       0x30   0x6840             LDR      R0,[R0, #+4]
   \       0x32   0x0880             LSRS     R0,R0,#+2
   \       0x34   0x0080             LSLS     R0,R0,#+2
   \       0x36   0x6829             LDR      R1,[R5, #+0]
   \       0x38   0x6048             STR      R0,[R1, #+4]
   \       0x3A   0xE005             B.N      ??SPI_DMAReceiveCplt_2
   2718              }
   2719              else
   2720              {
   2721                /* Normal case */
   2722                CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \                     ??SPI_DMAReceiveCplt_1: (+1)
   \       0x3C   0x6828             LDR      R0,[R5, #+0]
   \       0x3E   0x6840             LDR      R0,[R0, #+4]
   \       0x40   0x0840             LSRS     R0,R0,#+1
   \       0x42   0x0040             LSLS     R0,R0,#+1
   \       0x44   0x6829             LDR      R1,[R5, #+0]
   \       0x46   0x6048             STR      R0,[R1, #+4]
   2723              }
   2724          
   2725              /* Check the end of the transaction */
   2726              if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   \                     ??SPI_DMAReceiveCplt_2: (+1)
   \       0x48   0x0032             MOVS     R2,R6
   \       0x4A   0x2164             MOVS     R1,#+100
   \       0x4C   0x0028             MOVS     R0,R5
   \       0x4E   0x.... 0x....      BL       SPI_EndRxTransaction
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD001             BEQ.N    ??SPI_DMAReceiveCplt_3
   2727              {
   2728                hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
   \       0x56   0x2020             MOVS     R0,#+32
   \       0x58   0x6568             STR      R0,[R5, #+84]
   2729              }
   2730          
   2731              hspi->RxXferCount = 0U;
   \                     ??SPI_DMAReceiveCplt_3: (+1)
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x87E8             STRH     R0,[R5, #+62]
   2732              hspi->State = HAL_SPI_STATE_READY;
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0xF885 0x0051      STRB     R0,[R5, #+81]
   2733          
   2734          #if (USE_SPI_CRC != 0U)
   2735              /* Check if CRC error occurred */
   2736              if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
   2737              {
   2738                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   2739                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   2740              }
   2741          #endif /* USE_SPI_CRC */
   2742          
   2743              if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \       0x64   0x6D68             LDR      R0,[R5, #+84]
   \       0x66   0x2800             CMP      R0,#+0
   \       0x68   0xD003             BEQ.N    ??SPI_DMAReceiveCplt_0
   2744              {
   2745                /* Call user error callback */
   2746          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2747                hspi->ErrorCallback(hspi);
   2748          #else
   2749                HAL_SPI_ErrorCallback(hspi);
   \       0x6A   0x0028             MOVS     R0,R5
   \       0x6C   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   2750          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2751                return;
   \       0x70   0xE002             B.N      ??SPI_DMAReceiveCplt_4
   2752              }
   2753            }
   2754            /* Call user Rx complete callback */
   2755          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2756            hspi->RxCpltCallback(hspi);
   2757          #else
   2758            HAL_SPI_RxCpltCallback(hspi);
   \                     ??SPI_DMAReceiveCplt_0: (+1)
   \       0x72   0x0028             MOVS     R0,R5
   \       0x74   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   2759          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2760          }
   \                     ??SPI_DMAReceiveCplt_4: (+1)
   \       0x78   0xBD70             POP      {R4-R6,PC}
   2761          
   2762          /**
   2763            * @brief  DMA SPI transmit receive process complete callback.
   2764            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2765            *               the configuration information for the specified DMA module.
   2766            * @retval None
   2767            */

   \                                 In section .text, align 4, keep-with-next
   2768          static void SPI_DMATransmitReceiveCplt(DMA_HandleTypeDef *hdma)
   2769          {
   \                     SPI_DMATransmitReceiveCplt: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2770            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2771            uint32_t tickstart;
   2772          
   2773            /* Init tickstart for timeout management*/
   2774            tickstart = HAL_GetTick();
   \        0x6   0x.... 0x....      BL       HAL_GetTick
   \        0xA   0x0006             MOVS     R6,R0
   2775          
   2776            /* DMA Normal Mode */
   2777            if ((hdma->Instance->CR & DMA_SxCR_CIRC) != DMA_SxCR_CIRC)
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0x05C0             LSLS     R0,R0,#+23
   \       0x12   0xD424             BMI.N    ??SPI_DMATransmitReceiveCplt_0
   2778            {
   2779              /* Disable ERR interrupt */
   2780              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x6840             LDR      R0,[R0, #+4]
   \       0x18   0xF030 0x0020      BICS     R0,R0,#0x20
   \       0x1C   0x6829             LDR      R1,[R5, #+0]
   \       0x1E   0x6048             STR      R0,[R1, #+4]
   2781          
   2782          #if (USE_SPI_CRC != 0U)
   2783              /* CRC handling */
   2784              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   2785              {
   2786                /* Wait the CRC data */
   2787                if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, SET, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   2788                {
   2789                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   2790                }
   2791                /* Read CRC to Flush DR and RXNE flag */
   2792                READ_REG(hspi->Instance->DR);
   2793              }
   2794          #endif /* USE_SPI_CRC */
   2795          
   2796              /* Check the end of the transaction */
   2797              if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   \       0x20   0x0032             MOVS     R2,R6
   \       0x22   0x2164             MOVS     R1,#+100
   \       0x24   0x0028             MOVS     R0,R5
   \       0x26   0x.... 0x....      BL       SPI_EndRxTxTransaction
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD003             BEQ.N    ??SPI_DMATransmitReceiveCplt_1
   2798              {
   2799                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x2E   0x6D68             LDR      R0,[R5, #+84]
   \       0x30   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x34   0x6568             STR      R0,[R5, #+84]
   2800              }
   2801          
   2802              /* Disable Rx/Tx DMA Request */
   2803              CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \                     ??SPI_DMATransmitReceiveCplt_1: (+1)
   \       0x36   0x6828             LDR      R0,[R5, #+0]
   \       0x38   0x6840             LDR      R0,[R0, #+4]
   \       0x3A   0x0880             LSRS     R0,R0,#+2
   \       0x3C   0x0080             LSLS     R0,R0,#+2
   \       0x3E   0x6829             LDR      R1,[R5, #+0]
   \       0x40   0x6048             STR      R0,[R1, #+4]
   2804          
   2805              hspi->TxXferCount = 0U;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x86E8             STRH     R0,[R5, #+54]
   2806              hspi->RxXferCount = 0U;
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x87E8             STRH     R0,[R5, #+62]
   2807              hspi->State = HAL_SPI_STATE_READY;
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0xF885 0x0051      STRB     R0,[R5, #+81]
   2808          
   2809          #if (USE_SPI_CRC != 0U)
   2810              /* Check if CRC error occurred */
   2811              if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR))
   2812              {
   2813                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   2814                __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   2815              }
   2816          #endif /* USE_SPI_CRC */
   2817          
   2818              if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \       0x50   0x6D68             LDR      R0,[R5, #+84]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD003             BEQ.N    ??SPI_DMATransmitReceiveCplt_0
   2819              {
   2820                /* Call user error callback */
   2821          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2822                hspi->ErrorCallback(hspi);
   2823          #else
   2824                HAL_SPI_ErrorCallback(hspi);
   \       0x56   0x0028             MOVS     R0,R5
   \       0x58   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   2825          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2826                return;
   \       0x5C   0xE002             B.N      ??SPI_DMATransmitReceiveCplt_2
   2827              }
   2828            }
   2829            /* Call user TxRx complete callback */
   2830          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2831            hspi->TxRxCpltCallback(hspi);
   2832          #else
   2833            HAL_SPI_TxRxCpltCallback(hspi);
   \                     ??SPI_DMATransmitReceiveCplt_0: (+1)
   \       0x5E   0x0028             MOVS     R0,R5
   \       0x60   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   2834          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2835          }
   \                     ??SPI_DMATransmitReceiveCplt_2: (+1)
   \       0x64   0xBD70             POP      {R4-R6,PC}
   2836          
   2837          /**
   2838            * @brief  DMA SPI half transmit process complete callback.
   2839            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2840            *               the configuration information for the specified DMA module.
   2841            * @retval None
   2842            */

   \                                 In section .text, align 4, keep-with-next
   2843          static void SPI_DMAHalfTransmitCplt(DMA_HandleTypeDef *hdma)
   2844          {
   \                     SPI_DMAHalfTransmitCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2845            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2846          
   2847            /* Call user Tx half complete callback */
   2848          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2849            hspi->TxHalfCpltCallback(hspi);
   2850          #else
   2851            HAL_SPI_TxHalfCpltCallback(hspi);
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x.... 0x....      BL       HAL_SPI_TxHalfCpltCallback
   2852          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2853          }
   \        0xC   0xBD31             POP      {R0,R4,R5,PC}
   2854          
   2855          /**
   2856            * @brief  DMA SPI half receive process complete callback
   2857            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2858            *               the configuration information for the specified DMA module.
   2859            * @retval None
   2860            */

   \                                 In section .text, align 4, keep-with-next
   2861          static void SPI_DMAHalfReceiveCplt(DMA_HandleTypeDef *hdma)
   2862          {
   \                     SPI_DMAHalfReceiveCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2863            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2864          
   2865            /* Call user Rx half complete callback */
   2866          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2867            hspi->RxHalfCpltCallback(hspi);
   2868          #else
   2869            HAL_SPI_RxHalfCpltCallback(hspi);
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x.... 0x....      BL       HAL_SPI_RxHalfCpltCallback
   2870          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2871          }
   \        0xC   0xBD31             POP      {R0,R4,R5,PC}
   2872          
   2873          /**
   2874            * @brief  DMA SPI half transmit receive process complete callback.
   2875            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2876            *               the configuration information for the specified DMA module.
   2877            * @retval None
   2878            */

   \                                 In section .text, align 4, keep-with-next
   2879          static void SPI_DMAHalfTransmitReceiveCplt(DMA_HandleTypeDef *hdma)
   2880          {
   \                     SPI_DMAHalfTransmitReceiveCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2881            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2882          
   2883            /* Call user TxRx half complete callback */
   2884          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2885            hspi->TxRxHalfCpltCallback(hspi);
   2886          #else
   2887            HAL_SPI_TxRxHalfCpltCallback(hspi);
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x.... 0x....      BL       HAL_SPI_TxRxHalfCpltCallback
   2888          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2889          }
   \        0xC   0xBD31             POP      {R0,R4,R5,PC}
   2890          
   2891          /**
   2892            * @brief  DMA SPI communication error callback.
   2893            * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
   2894            *               the configuration information for the specified DMA module.
   2895            * @retval None
   2896            */

   \                                 In section .text, align 4, keep-with-next
   2897          static void SPI_DMAError(DMA_HandleTypeDef *hdma)
   2898          {
   \                     SPI_DMAError: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2899            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2900          
   2901            /* Stop the disable DMA transfer on SPI side */
   2902            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0x6840             LDR      R0,[R0, #+4]
   \        0xA   0x0880             LSRS     R0,R0,#+2
   \        0xC   0x0080             LSLS     R0,R0,#+2
   \        0xE   0x6829             LDR      R1,[R5, #+0]
   \       0x10   0x6048             STR      R0,[R1, #+4]
   2903          
   2904            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
   \       0x12   0x6D68             LDR      R0,[R5, #+84]
   \       0x14   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x18   0x6568             STR      R0,[R5, #+84]
   2905            hspi->State = HAL_SPI_STATE_READY;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xF885 0x0051      STRB     R0,[R5, #+81]
   2906            /* Call user error callback */
   2907          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2908            hspi->ErrorCallback(hspi);
   2909          #else
   2910            HAL_SPI_ErrorCallback(hspi);
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   2911          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2912          }
   \       0x26   0xBD31             POP      {R0,R4,R5,PC}
   2913          
   2914          /**
   2915            * @brief  DMA SPI communication abort callback, when initiated by HAL services on Error
   2916            *         (To be called at end of DMA Abort procedure following error occurrence).
   2917            * @param  hdma DMA handle.
   2918            * @retval None
   2919            */

   \                                 In section .text, align 4, keep-with-next
   2920          static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
   2921          {
   \                     SPI_DMAAbortOnError: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2922            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2923            hspi->RxXferCount = 0U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x87E8             STRH     R0,[R5, #+62]
   2924            hspi->TxXferCount = 0U;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x86E8             STRH     R0,[R5, #+54]
   2925          
   2926            /* Call user error callback */
   2927          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2928            hspi->ErrorCallback(hspi);
   2929          #else
   2930            HAL_SPI_ErrorCallback(hspi);
   \        0xE   0x0028             MOVS     R0,R5
   \       0x10   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   2931          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2932          }
   \       0x14   0xBD31             POP      {R0,R4,R5,PC}
   2933          
   2934          /**
   2935            * @brief  DMA SPI Tx communication abort callback, when initiated by user
   2936            *         (To be called at end of DMA Tx Abort procedure following user abort request).
   2937            * @note   When this callback is executed, User Abort complete call back is called only if no
   2938            *         Abort still ongoing for Rx DMA Handle.
   2939            * @param  hdma DMA handle.
   2940            * @retval None
   2941            */

   \                                 In section .text, align 4, keep-with-next
   2942          static void SPI_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
   2943          {
   \                     SPI_DMATxAbortCallback: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2944            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   2945            __IO uint32_t count;
   2946          
   2947            hspi->hdmatx->XferAbortCallback = NULL;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x6CA9             LDR      R1,[R5, #+72]
   \        0xA   0x6508             STR      R0,[R1, #+80]
   2948            count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   \        0xC   0x.... 0x....      LDR.W    R0,??DataTable9
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x2118             MOVS     R1,#+24
   \       0x14   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x18   0xF44F 0x717A      MOV      R1,#+1000
   \       0x1C   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x20   0x2064             MOVS     R0,#+100
   \       0x22   0x4341             MULS     R1,R0,R1
   \       0x24   0x9101             STR      R1,[SP, #+4]
   2949          
   2950            /* Disable Tx DMA Request */
   2951            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
   \       0x26   0x6828             LDR      R0,[R5, #+0]
   \       0x28   0x6840             LDR      R0,[R0, #+4]
   \       0x2A   0xF030 0x0002      BICS     R0,R0,#0x2
   \       0x2E   0x6829             LDR      R1,[R5, #+0]
   \       0x30   0x6048             STR      R0,[R1, #+4]
   2952          
   2953            /* Wait until TXE flag is set */
   2954            do
   2955            {
   2956              if (count == 0U)
   \                     ??SPI_DMATxAbortCallback_0: (+1)
   \       0x32   0x9801             LDR      R0,[SP, #+4]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD104             BNE.N    ??SPI_DMATxAbortCallback_1
   2957              {
   2958                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   \       0x38   0x6D68             LDR      R0,[R5, #+84]
   \       0x3A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x3E   0x6568             STR      R0,[R5, #+84]
   2959                break;
   \       0x40   0xE006             B.N      ??SPI_DMATxAbortCallback_2
   2960              }
   2961              count--;
   \                     ??SPI_DMATxAbortCallback_1: (+1)
   \       0x42   0x9801             LDR      R0,[SP, #+4]
   \       0x44   0x1E40             SUBS     R0,R0,#+1
   \       0x46   0x9001             STR      R0,[SP, #+4]
   2962            } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
   \       0x48   0x6828             LDR      R0,[R5, #+0]
   \       0x4A   0x6880             LDR      R0,[R0, #+8]
   \       0x4C   0x0780             LSLS     R0,R0,#+30
   \       0x4E   0xD5F0             BPL.N    ??SPI_DMATxAbortCallback_0
   2963          
   2964            /* Check if an Abort process is still ongoing */
   2965            if (hspi->hdmarx != NULL)
   \                     ??SPI_DMATxAbortCallback_2: (+1)
   \       0x50   0x6CE8             LDR      R0,[R5, #+76]
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD003             BEQ.N    ??SPI_DMATxAbortCallback_3
   2966            {
   2967              if (hspi->hdmarx->XferAbortCallback != NULL)
   \       0x56   0x6CE8             LDR      R0,[R5, #+76]
   \       0x58   0x6D00             LDR      R0,[R0, #+80]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD11D             BNE.N    ??SPI_DMATxAbortCallback_4
   2968              {
   2969                return;
   2970              }
   2971            }
   2972          
   2973            /* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */
   2974            hspi->RxXferCount = 0U;
   \                     ??SPI_DMATxAbortCallback_3: (+1)
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x87E8             STRH     R0,[R5, #+62]
   2975            hspi->TxXferCount = 0U;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x86E8             STRH     R0,[R5, #+54]
   2976          
   2977            /* Check no error during Abort procedure */
   2978            if (hspi->ErrorCode != HAL_SPI_ERROR_ABORT)
   \       0x66   0x6D68             LDR      R0,[R5, #+84]
   \       0x68   0x2840             CMP      R0,#+64
   \       0x6A   0xD001             BEQ.N    ??SPI_DMATxAbortCallback_5
   2979            {
   2980              /* Reset errorCode */
   2981              hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x6568             STR      R0,[R5, #+84]
   2982            }
   2983          
   2984            /* Clear the Error flags in the SR register */
   2985            __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \                     ??SPI_DMATxAbortCallback_5: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x9000             STR      R0,[SP, #+0]
   \       0x74   0x6828             LDR      R0,[R5, #+0]
   \       0x76   0x68C0             LDR      R0,[R0, #+12]
   \       0x78   0x9000             STR      R0,[SP, #+0]
   \       0x7A   0x6828             LDR      R0,[R5, #+0]
   \       0x7C   0x6880             LDR      R0,[R0, #+8]
   \       0x7E   0x9000             STR      R0,[SP, #+0]
   \       0x80   0x9800             LDR      R0,[SP, #+0]
   2986            __HAL_SPI_CLEAR_FREFLAG(hspi);
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0x9000             STR      R0,[SP, #+0]
   \       0x86   0x6828             LDR      R0,[R5, #+0]
   \       0x88   0x6880             LDR      R0,[R0, #+8]
   \       0x8A   0x9000             STR      R0,[SP, #+0]
   \       0x8C   0x9800             LDR      R0,[SP, #+0]
   2987          
   2988            /* Restore hspi->State to Ready */
   2989            hspi->State  = HAL_SPI_STATE_READY;
   \       0x8E   0x2001             MOVS     R0,#+1
   \       0x90   0xF885 0x0051      STRB     R0,[R5, #+81]
   2990          
   2991            /* Call user Abort complete callback */
   2992          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   2993            hspi->AbortCpltCallback(hspi);
   2994          #else
   2995            HAL_SPI_AbortCpltCallback(hspi);
   \       0x94   0x0028             MOVS     R0,R5
   \       0x96   0x.... 0x....      BL       HAL_SPI_AbortCpltCallback
   2996          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   2997          }
   \                     ??SPI_DMATxAbortCallback_4: (+1)
   \       0x9A   0xBD37             POP      {R0-R2,R4,R5,PC}
   2998          
   2999          /**
   3000            * @brief  DMA SPI Rx communication abort callback, when initiated by user
   3001            *         (To be called at end of DMA Rx Abort procedure following user abort request).
   3002            * @note   When this callback is executed, User Abort complete call back is called only if no
   3003            *         Abort still ongoing for Tx DMA Handle.
   3004            * @param  hdma DMA handle.
   3005            * @retval None
   3006            */

   \                                 In section .text, align 4, keep-with-next
   3007          static void SPI_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
   3008          {
   \                     SPI_DMARxAbortCallback: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3009            SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   3010          
   3011            /* Disable SPI Peripheral */
   3012            __HAL_SPI_DISABLE(hspi);
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0xF030 0x0040      BICS     R0,R0,#0x40
   \        0xE   0x6829             LDR      R1,[R5, #+0]
   \       0x10   0x6008             STR      R0,[R1, #+0]
   3013          
   3014            hspi->hdmarx->XferAbortCallback = NULL;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x6CE9             LDR      R1,[R5, #+76]
   \       0x16   0x6508             STR      R0,[R1, #+80]
   3015          
   3016            /* Disable Rx DMA Request */
   3017            CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_RXDMAEN);
   \       0x18   0x6828             LDR      R0,[R5, #+0]
   \       0x1A   0x6840             LDR      R0,[R0, #+4]
   \       0x1C   0x0840             LSRS     R0,R0,#+1
   \       0x1E   0x0040             LSLS     R0,R0,#+1
   \       0x20   0x6829             LDR      R1,[R5, #+0]
   \       0x22   0x6048             STR      R0,[R1, #+4]
   3018          
   3019            /* Check Busy flag */
   3020            if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   \       0x24   0x.... 0x....      BL       HAL_GetTick
   \       0x28   0x0002             MOVS     R2,R0
   \       0x2A   0x2164             MOVS     R1,#+100
   \       0x2C   0x0028             MOVS     R0,R5
   \       0x2E   0x.... 0x....      BL       SPI_EndRxTxTransaction
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD003             BEQ.N    ??SPI_DMARxAbortCallback_0
   3021            {
   3022              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   \       0x36   0x6D68             LDR      R0,[R5, #+84]
   \       0x38   0xF050 0x0040      ORRS     R0,R0,#0x40
   \       0x3C   0x6568             STR      R0,[R5, #+84]
   3023            }
   3024          
   3025            /* Check if an Abort process is still ongoing */
   3026            if (hspi->hdmatx != NULL)
   \                     ??SPI_DMARxAbortCallback_0: (+1)
   \       0x3E   0x6CA8             LDR      R0,[R5, #+72]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD003             BEQ.N    ??SPI_DMARxAbortCallback_1
   3027            {
   3028              if (hspi->hdmatx->XferAbortCallback != NULL)
   \       0x44   0x6CA8             LDR      R0,[R5, #+72]
   \       0x46   0x6D00             LDR      R0,[R0, #+80]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD11D             BNE.N    ??SPI_DMARxAbortCallback_2
   3029              {
   3030                return;
   3031              }
   3032            }
   3033          
   3034            /* No Abort process still ongoing : All DMA Stream/Channel are aborted, call user Abort Complete callback */
   3035            hspi->RxXferCount = 0U;
   \                     ??SPI_DMARxAbortCallback_1: (+1)
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x87E8             STRH     R0,[R5, #+62]
   3036            hspi->TxXferCount = 0U;
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x86E8             STRH     R0,[R5, #+54]
   3037          
   3038            /* Check no error during Abort procedure */
   3039            if (hspi->ErrorCode != HAL_SPI_ERROR_ABORT)
   \       0x54   0x6D68             LDR      R0,[R5, #+84]
   \       0x56   0x2840             CMP      R0,#+64
   \       0x58   0xD001             BEQ.N    ??SPI_DMARxAbortCallback_3
   3040            {
   3041              /* Reset errorCode */
   3042              hspi->ErrorCode = HAL_SPI_ERROR_NONE;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x6568             STR      R0,[R5, #+84]
   3043            }
   3044          
   3045            /* Clear the Error flags in the SR register */
   3046            __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \                     ??SPI_DMARxAbortCallback_3: (+1)
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x9000             STR      R0,[SP, #+0]
   \       0x62   0x6828             LDR      R0,[R5, #+0]
   \       0x64   0x68C0             LDR      R0,[R0, #+12]
   \       0x66   0x9000             STR      R0,[SP, #+0]
   \       0x68   0x6828             LDR      R0,[R5, #+0]
   \       0x6A   0x6880             LDR      R0,[R0, #+8]
   \       0x6C   0x9000             STR      R0,[SP, #+0]
   \       0x6E   0x9800             LDR      R0,[SP, #+0]
   3047            __HAL_SPI_CLEAR_FREFLAG(hspi);
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x9000             STR      R0,[SP, #+0]
   \       0x74   0x6828             LDR      R0,[R5, #+0]
   \       0x76   0x6880             LDR      R0,[R0, #+8]
   \       0x78   0x9000             STR      R0,[SP, #+0]
   \       0x7A   0x9800             LDR      R0,[SP, #+0]
   3048          
   3049            /* Restore hspi->State to Ready */
   3050            hspi->State  = HAL_SPI_STATE_READY;
   \       0x7C   0x2001             MOVS     R0,#+1
   \       0x7E   0xF885 0x0051      STRB     R0,[R5, #+81]
   3051          
   3052            /* Call user Abort complete callback */
   3053          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3054            hspi->AbortCpltCallback(hspi);
   3055          #else
   3056            HAL_SPI_AbortCpltCallback(hspi);
   \       0x82   0x0028             MOVS     R0,R5
   \       0x84   0x.... 0x....      BL       HAL_SPI_AbortCpltCallback
   3057          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3058          }
   \                     ??SPI_DMARxAbortCallback_2: (+1)
   \       0x88   0xBD31             POP      {R0,R4,R5,PC}
   3059          
   3060          /**
   3061            * @brief  Rx 8-bit handler for Transmit and Receive in Interrupt mode.
   3062            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3063            *               the configuration information for SPI module.
   3064            * @retval None
   3065            */

   \                                 In section .text, align 4, keep-with-next
   3066          static void SPI_2linesRxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   3067          {
   \                     SPI_2linesRxISR_8BIT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3068            /* Receive data in 8bit mode */
   3069            *hspi->pRxBuffPtr = *((__IO uint8_t *)&hspi->Instance->DR);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x7B00             LDRB     R0,[R0, #+12]
   \        0x8   0x6BA1             LDR      R1,[R4, #+56]
   \        0xA   0x7008             STRB     R0,[R1, #+0]
   3070            hspi->pRxBuffPtr++;
   \        0xC   0x6BA0             LDR      R0,[R4, #+56]
   \        0xE   0x1C40             ADDS     R0,R0,#+1
   \       0x10   0x63A0             STR      R0,[R4, #+56]
   3071            hspi->RxXferCount--;
   \       0x12   0x8FE0             LDRH     R0,[R4, #+62]
   \       0x14   0x1E40             SUBS     R0,R0,#+1
   \       0x16   0x87E0             STRH     R0,[R4, #+62]
   3072          
   3073            /* Check end of the reception */
   3074            if (hspi->RxXferCount == 0U)
   \       0x18   0x8FE0             LDRH     R0,[R4, #+62]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD10B             BNE.N    ??SPI_2linesRxISR_8BIT_0
   3075            {
   3076          #if (USE_SPI_CRC != 0U)
   3077              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3078              {
   3079                hspi->RxISR =  SPI_2linesRxISR_8BITCRC;
   3080                return;
   3081              }
   3082          #endif /* USE_SPI_CRC */
   3083          
   3084              /* Disable RXNE  and ERR interrupt */
   3085              __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6840             LDR      R0,[R0, #+4]
   \       0x22   0xF030 0x0060      BICS     R0,R0,#0x60
   \       0x26   0x6821             LDR      R1,[R4, #+0]
   \       0x28   0x6048             STR      R0,[R1, #+4]
   3086          
   3087              if (hspi->TxXferCount == 0U)
   \       0x2A   0x8EE0             LDRH     R0,[R4, #+54]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD102             BNE.N    ??SPI_2linesRxISR_8BIT_0
   3088              {
   3089                SPI_CloseRxTx_ISR(hspi);
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       SPI_CloseRxTx_ISR
   3090              }
   3091            }
   3092          }
   \                     ??SPI_2linesRxISR_8BIT_0: (+1)
   \       0x36   0xBD10             POP      {R4,PC}
   3093          
   3094          #if (USE_SPI_CRC != 0U)
   3095          /**
   3096            * @brief  Rx 8-bit handler for Transmit and Receive in Interrupt mode.
   3097            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3098            *               the configuration information for SPI module.
   3099            * @retval None
   3100            */
   3101          static void SPI_2linesRxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
   3102          {
   3103            /* Read 8bit CRC to flush Data Regsiter */
   3104            READ_REG(*(__IO uint8_t *)&hspi->Instance->DR);
   3105          
   3106            /* Disable RXNE and ERR interrupt */
   3107            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   3108          
   3109            if (hspi->TxXferCount == 0U)
   3110            {
   3111              SPI_CloseRxTx_ISR(hspi);
   3112            }
   3113          }
   3114          #endif /* USE_SPI_CRC */
   3115          
   3116          /**
   3117            * @brief  Tx 8-bit handler for Transmit and Receive in Interrupt mode.
   3118            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3119            *               the configuration information for SPI module.
   3120            * @retval None
   3121            */

   \                                 In section .text, align 4, keep-with-next
   3122          static void SPI_2linesTxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   3123          {
   \                     SPI_2linesTxISR_8BIT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3124            *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
   \        0x4   0x6B20             LDR      R0,[R4, #+48]
   \        0x6   0x7800             LDRB     R0,[R0, #+0]
   \        0x8   0x6821             LDR      R1,[R4, #+0]
   \        0xA   0x7308             STRB     R0,[R1, #+12]
   3125            hspi->pTxBuffPtr++;
   \        0xC   0x6B20             LDR      R0,[R4, #+48]
   \        0xE   0x1C40             ADDS     R0,R0,#+1
   \       0x10   0x6320             STR      R0,[R4, #+48]
   3126            hspi->TxXferCount--;
   \       0x12   0x8EE0             LDRH     R0,[R4, #+54]
   \       0x14   0x1E40             SUBS     R0,R0,#+1
   \       0x16   0x86E0             STRH     R0,[R4, #+54]
   3127          
   3128            /* Check the end of the transmission */
   3129            if (hspi->TxXferCount == 0U)
   \       0x18   0x8EE0             LDRH     R0,[R4, #+54]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD10B             BNE.N    ??SPI_2linesTxISR_8BIT_0
   3130            {
   3131          #if (USE_SPI_CRC != 0U)
   3132              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3133              {
   3134                /* Set CRC Next Bit to send CRC */
   3135                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3136                /* Disable TXE interrupt */
   3137                __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   3138                return;
   3139              }
   3140          #endif /* USE_SPI_CRC */
   3141          
   3142              /* Disable TXE interrupt */
   3143              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6840             LDR      R0,[R0, #+4]
   \       0x22   0xF030 0x0080      BICS     R0,R0,#0x80
   \       0x26   0x6821             LDR      R1,[R4, #+0]
   \       0x28   0x6048             STR      R0,[R1, #+4]
   3144          
   3145              if (hspi->RxXferCount == 0U)
   \       0x2A   0x8FE0             LDRH     R0,[R4, #+62]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD102             BNE.N    ??SPI_2linesTxISR_8BIT_0
   3146              {
   3147                SPI_CloseRxTx_ISR(hspi);
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       SPI_CloseRxTx_ISR
   3148              }
   3149            }
   3150          }
   \                     ??SPI_2linesTxISR_8BIT_0: (+1)
   \       0x36   0xBD10             POP      {R4,PC}
   3151          
   3152          /**
   3153            * @brief  Rx 16-bit handler for Transmit and Receive in Interrupt mode.
   3154            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3155            *               the configuration information for SPI module.
   3156            * @retval None
   3157            */

   \                                 In section .text, align 4, keep-with-next
   3158          static void SPI_2linesRxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   3159          {
   \                     SPI_2linesRxISR_16BIT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3160            /* Receive data in 16 Bit mode */
   3161            *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C0             LDR      R0,[R0, #+12]
   \        0x8   0x6BA1             LDR      R1,[R4, #+56]
   \        0xA   0x8008             STRH     R0,[R1, #+0]
   3162            hspi->pRxBuffPtr += sizeof(uint16_t);
   \        0xC   0x6BA0             LDR      R0,[R4, #+56]
   \        0xE   0x1C80             ADDS     R0,R0,#+2
   \       0x10   0x63A0             STR      R0,[R4, #+56]
   3163            hspi->RxXferCount--;
   \       0x12   0x8FE0             LDRH     R0,[R4, #+62]
   \       0x14   0x1E40             SUBS     R0,R0,#+1
   \       0x16   0x87E0             STRH     R0,[R4, #+62]
   3164          
   3165            if (hspi->RxXferCount == 0U)
   \       0x18   0x8FE0             LDRH     R0,[R4, #+62]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD10B             BNE.N    ??SPI_2linesRxISR_16BIT_0
   3166            {
   3167          #if (USE_SPI_CRC != 0U)
   3168              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3169              {
   3170                hspi->RxISR =  SPI_2linesRxISR_16BITCRC;
   3171                return;
   3172              }
   3173          #endif /* USE_SPI_CRC */
   3174          
   3175              /* Disable RXNE interrupt */
   3176              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6840             LDR      R0,[R0, #+4]
   \       0x22   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x26   0x6821             LDR      R1,[R4, #+0]
   \       0x28   0x6048             STR      R0,[R1, #+4]
   3177          
   3178              if (hspi->TxXferCount == 0U)
   \       0x2A   0x8EE0             LDRH     R0,[R4, #+54]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD102             BNE.N    ??SPI_2linesRxISR_16BIT_0
   3179              {
   3180                SPI_CloseRxTx_ISR(hspi);
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       SPI_CloseRxTx_ISR
   3181              }
   3182            }
   3183          }
   \                     ??SPI_2linesRxISR_16BIT_0: (+1)
   \       0x36   0xBD10             POP      {R4,PC}
   3184          
   3185          #if (USE_SPI_CRC != 0U)
   3186          /**
   3187            * @brief  Manage the CRC 16-bit receive for Transmit and Receive in Interrupt mode.
   3188            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3189            *               the configuration information for SPI module.
   3190            * @retval None
   3191            */
   3192          static void SPI_2linesRxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
   3193          {
   3194            /* Read 16bit CRC to flush Data Regsiter */
   3195            READ_REG(hspi->Instance->DR);
   3196          
   3197            /* Disable RXNE interrupt */
   3198            __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE);
   3199          
   3200            SPI_CloseRxTx_ISR(hspi);
   3201          }
   3202          #endif /* USE_SPI_CRC */
   3203          
   3204          /**
   3205            * @brief  Tx 16-bit handler for Transmit and Receive in Interrupt mode.
   3206            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3207            *               the configuration information for SPI module.
   3208            * @retval None
   3209            */

   \                                 In section .text, align 4, keep-with-next
   3210          static void SPI_2linesTxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   3211          {
   \                     SPI_2linesTxISR_16BIT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3212            /* Transmit data in 16 Bit mode */
   3213            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \        0x4   0x6B20             LDR      R0,[R4, #+48]
   \        0x6   0x8800             LDRH     R0,[R0, #+0]
   \        0x8   0x6821             LDR      R1,[R4, #+0]
   \        0xA   0x60C8             STR      R0,[R1, #+12]
   3214            hspi->pTxBuffPtr += sizeof(uint16_t);
   \        0xC   0x6B20             LDR      R0,[R4, #+48]
   \        0xE   0x1C80             ADDS     R0,R0,#+2
   \       0x10   0x6320             STR      R0,[R4, #+48]
   3215            hspi->TxXferCount--;
   \       0x12   0x8EE0             LDRH     R0,[R4, #+54]
   \       0x14   0x1E40             SUBS     R0,R0,#+1
   \       0x16   0x86E0             STRH     R0,[R4, #+54]
   3216          
   3217            /* Enable CRC Transmission */
   3218            if (hspi->TxXferCount == 0U)
   \       0x18   0x8EE0             LDRH     R0,[R4, #+54]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD10B             BNE.N    ??SPI_2linesTxISR_16BIT_0
   3219            {
   3220          #if (USE_SPI_CRC != 0U)
   3221              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3222              {
   3223                /* Set CRC Next Bit to send CRC */
   3224                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3225                /* Disable TXE interrupt */
   3226                __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   3227                return;
   3228              }
   3229          #endif /* USE_SPI_CRC */
   3230          
   3231              /* Disable TXE interrupt */
   3232              __HAL_SPI_DISABLE_IT(hspi, SPI_IT_TXE);
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6840             LDR      R0,[R0, #+4]
   \       0x22   0xF030 0x0080      BICS     R0,R0,#0x80
   \       0x26   0x6821             LDR      R1,[R4, #+0]
   \       0x28   0x6048             STR      R0,[R1, #+4]
   3233          
   3234              if (hspi->RxXferCount == 0U)
   \       0x2A   0x8FE0             LDRH     R0,[R4, #+62]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD102             BNE.N    ??SPI_2linesTxISR_16BIT_0
   3235              {
   3236                SPI_CloseRxTx_ISR(hspi);
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       SPI_CloseRxTx_ISR
   3237              }
   3238            }
   3239          }
   \                     ??SPI_2linesTxISR_16BIT_0: (+1)
   \       0x36   0xBD10             POP      {R4,PC}
   3240          
   3241          #if (USE_SPI_CRC != 0U)
   3242          /**
   3243            * @brief  Manage the CRC 8-bit receive in Interrupt context.
   3244            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3245            *               the configuration information for SPI module.
   3246            * @retval None
   3247            */
   3248          static void SPI_RxISR_8BITCRC(struct __SPI_HandleTypeDef *hspi)
   3249          {
   3250            /* Read 8bit CRC to flush Data Register */
   3251            READ_REG(*(__IO uint8_t *)&hspi->Instance->DR);
   3252          
   3253            SPI_CloseRx_ISR(hspi);
   3254          }
   3255          #endif /* USE_SPI_CRC */
   3256          
   3257          /**
   3258            * @brief  Manage the receive 8-bit in Interrupt context.
   3259            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3260            *               the configuration information for SPI module.
   3261            * @retval None
   3262            */

   \                                 In section .text, align 2, keep-with-next
   3263          static void SPI_RxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   3264          {
   \                     SPI_RxISR_8BIT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3265            *hspi->pRxBuffPtr = (*(__IO uint8_t *)&hspi->Instance->DR);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x7B00             LDRB     R0,[R0, #+12]
   \        0x8   0x6BA1             LDR      R1,[R4, #+56]
   \        0xA   0x7008             STRB     R0,[R1, #+0]
   3266            hspi->pRxBuffPtr++;
   \        0xC   0x6BA0             LDR      R0,[R4, #+56]
   \        0xE   0x1C40             ADDS     R0,R0,#+1
   \       0x10   0x63A0             STR      R0,[R4, #+56]
   3267            hspi->RxXferCount--;
   \       0x12   0x8FE0             LDRH     R0,[R4, #+62]
   \       0x14   0x1E40             SUBS     R0,R0,#+1
   \       0x16   0x87E0             STRH     R0,[R4, #+62]
   3268          
   3269          #if (USE_SPI_CRC != 0U)
   3270            /* Enable CRC Transmission */
   3271            if ((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   3272            {
   3273              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3274            }
   3275          #endif /* USE_SPI_CRC */
   3276          
   3277            if (hspi->RxXferCount == 0U)
   \       0x18   0x8FE0             LDRH     R0,[R4, #+62]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD102             BNE.N    ??SPI_RxISR_8BIT_0
   3278            {
   3279          #if (USE_SPI_CRC != 0U)
   3280              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3281              {
   3282                hspi->RxISR =  SPI_RxISR_8BITCRC;
   3283                return;
   3284              }
   3285          #endif /* USE_SPI_CRC */
   3286              SPI_CloseRx_ISR(hspi);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       SPI_CloseRx_ISR
   3287            }
   3288          }
   \                     ??SPI_RxISR_8BIT_0: (+1)
   \       0x24   0xBD10             POP      {R4,PC}
   3289          
   3290          #if (USE_SPI_CRC != 0U)
   3291          /**
   3292            * @brief  Manage the CRC 16-bit receive in Interrupt context.
   3293            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3294            *               the configuration information for SPI module.
   3295            * @retval None
   3296            */
   3297          static void SPI_RxISR_16BITCRC(struct __SPI_HandleTypeDef *hspi)
   3298          {
   3299            /* Read 16bit CRC to flush Data Register */
   3300            READ_REG(hspi->Instance->DR);
   3301          
   3302            /* Disable RXNE and ERR interrupt */
   3303            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   3304          
   3305            SPI_CloseRx_ISR(hspi);
   3306          }
   3307          #endif /* USE_SPI_CRC */
   3308          
   3309          /**
   3310            * @brief  Manage the 16-bit receive in Interrupt context.
   3311            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3312            *               the configuration information for SPI module.
   3313            * @retval None
   3314            */

   \                                 In section .text, align 2, keep-with-next
   3315          static void SPI_RxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   3316          {
   \                     SPI_RxISR_16BIT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3317            *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)(hspi->Instance->DR);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C0             LDR      R0,[R0, #+12]
   \        0x8   0x6BA1             LDR      R1,[R4, #+56]
   \        0xA   0x8008             STRH     R0,[R1, #+0]
   3318            hspi->pRxBuffPtr += sizeof(uint16_t);
   \        0xC   0x6BA0             LDR      R0,[R4, #+56]
   \        0xE   0x1C80             ADDS     R0,R0,#+2
   \       0x10   0x63A0             STR      R0,[R4, #+56]
   3319            hspi->RxXferCount--;
   \       0x12   0x8FE0             LDRH     R0,[R4, #+62]
   \       0x14   0x1E40             SUBS     R0,R0,#+1
   \       0x16   0x87E0             STRH     R0,[R4, #+62]
   3320          
   3321          #if (USE_SPI_CRC != 0U)
   3322            /* Enable CRC Transmission */
   3323            if ((hspi->RxXferCount == 1U) && (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE))
   3324            {
   3325              SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3326            }
   3327          #endif /* USE_SPI_CRC */
   3328          
   3329            if (hspi->RxXferCount == 0U)
   \       0x18   0x8FE0             LDRH     R0,[R4, #+62]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD102             BNE.N    ??SPI_RxISR_16BIT_0
   3330            {
   3331          #if (USE_SPI_CRC != 0U)
   3332              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3333              {
   3334                hspi->RxISR = SPI_RxISR_16BITCRC;
   3335                return;
   3336              }
   3337          #endif /* USE_SPI_CRC */
   3338              SPI_CloseRx_ISR(hspi);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       SPI_CloseRx_ISR
   3339            }
   3340          }
   \                     ??SPI_RxISR_16BIT_0: (+1)
   \       0x24   0xBD10             POP      {R4,PC}
   3341          
   3342          /**
   3343            * @brief  Handle the data 8-bit transmit in Interrupt mode.
   3344            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3345            *               the configuration information for SPI module.
   3346            * @retval None
   3347            */

   \                                 In section .text, align 2, keep-with-next
   3348          static void SPI_TxISR_8BIT(struct __SPI_HandleTypeDef *hspi)
   3349          {
   \                     SPI_TxISR_8BIT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3350            *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
   \        0x4   0x6B20             LDR      R0,[R4, #+48]
   \        0x6   0x7800             LDRB     R0,[R0, #+0]
   \        0x8   0x6821             LDR      R1,[R4, #+0]
   \        0xA   0x7308             STRB     R0,[R1, #+12]
   3351            hspi->pTxBuffPtr++;
   \        0xC   0x6B20             LDR      R0,[R4, #+48]
   \        0xE   0x1C40             ADDS     R0,R0,#+1
   \       0x10   0x6320             STR      R0,[R4, #+48]
   3352            hspi->TxXferCount--;
   \       0x12   0x8EE0             LDRH     R0,[R4, #+54]
   \       0x14   0x1E40             SUBS     R0,R0,#+1
   \       0x16   0x86E0             STRH     R0,[R4, #+54]
   3353          
   3354            if (hspi->TxXferCount == 0U)
   \       0x18   0x8EE0             LDRH     R0,[R4, #+54]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD102             BNE.N    ??SPI_TxISR_8BIT_0
   3355            {
   3356          #if (USE_SPI_CRC != 0U)
   3357              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3358              {
   3359                /* Enable CRC Transmission */
   3360                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3361              }
   3362          #endif /* USE_SPI_CRC */
   3363              SPI_CloseTx_ISR(hspi);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       SPI_CloseTx_ISR
   3364            }
   3365          }
   \                     ??SPI_TxISR_8BIT_0: (+1)
   \       0x24   0xBD10             POP      {R4,PC}
   3366          
   3367          /**
   3368            * @brief  Handle the data 16-bit transmit in Interrupt mode.
   3369            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3370            *               the configuration information for SPI module.
   3371            * @retval None
   3372            */

   \                                 In section .text, align 2, keep-with-next
   3373          static void SPI_TxISR_16BIT(struct __SPI_HandleTypeDef *hspi)
   3374          {
   \                     SPI_TxISR_16BIT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3375            /* Transmit data in 16 Bit mode */
   3376            hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
   \        0x4   0x6B20             LDR      R0,[R4, #+48]
   \        0x6   0x8800             LDRH     R0,[R0, #+0]
   \        0x8   0x6821             LDR      R1,[R4, #+0]
   \        0xA   0x60C8             STR      R0,[R1, #+12]
   3377            hspi->pTxBuffPtr += sizeof(uint16_t);
   \        0xC   0x6B20             LDR      R0,[R4, #+48]
   \        0xE   0x1C80             ADDS     R0,R0,#+2
   \       0x10   0x6320             STR      R0,[R4, #+48]
   3378            hspi->TxXferCount--;
   \       0x12   0x8EE0             LDRH     R0,[R4, #+54]
   \       0x14   0x1E40             SUBS     R0,R0,#+1
   \       0x16   0x86E0             STRH     R0,[R4, #+54]
   3379          
   3380            if (hspi->TxXferCount == 0U)
   \       0x18   0x8EE0             LDRH     R0,[R4, #+54]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD102             BNE.N    ??SPI_TxISR_16BIT_0
   3381            {
   3382          #if (USE_SPI_CRC != 0U)
   3383              if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   3384              {
   3385                /* Enable CRC Transmission */
   3386                SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
   3387              }
   3388          #endif /* USE_SPI_CRC */
   3389              SPI_CloseTx_ISR(hspi);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       SPI_CloseTx_ISR
   3390            }
   3391          }
   \                     ??SPI_TxISR_16BIT_0: (+1)
   \       0x24   0xBD10             POP      {R4,PC}
   3392          
   3393          /**
   3394            * @brief  Handle SPI Communication Timeout.
   3395            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3396            *              the configuration information for SPI module.
   3397            * @param  Flag SPI flag to check
   3398            * @param  State flag state to check
   3399            * @param  Timeout Timeout duration
   3400            * @param  Tickstart tick start value
   3401            * @retval HAL status
   3402            */

   \                                 In section .text, align 2, keep-with-next
   3403          static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
   3404                                                                 uint32_t Timeout, uint32_t Tickstart)
   3405          {
   \                     SPI_WaitFlagStateUntilTimeout: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x001C             MOVS     R4,R3
   \        0xC   0x9F06             LDR      R7,[SP, #+24]
   3406            while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
   \                     ??SPI_WaitFlagStateUntilTimeout_0: (+1)
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x6880             LDR      R0,[R0, #+8]
   \       0x12   0x4030             ANDS     R0,R6,R0
   \       0x14   0x42B0             CMP      R0,R6
   \       0x16   0xD101             BNE.N    ??SPI_WaitFlagStateUntilTimeout_1
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE000             B.N      ??SPI_WaitFlagStateUntilTimeout_2
   \                     ??SPI_WaitFlagStateUntilTimeout_1: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \                     ??SPI_WaitFlagStateUntilTimeout_2: (+1)
   \       0x1E   0x4641             MOV      R1,R8
   \       0x20   0xB2C9             UXTB     R1,R1
   \       0x22   0x4288             CMP      R0,R1
   \       0x24   0xD039             BEQ.N    ??SPI_WaitFlagStateUntilTimeout_3
   3407            {
   3408              if (Timeout != HAL_MAX_DELAY)
   \       0x26   0xF114 0x0F01      CMN      R4,#+1
   \       0x2A   0xD0F0             BEQ.N    ??SPI_WaitFlagStateUntilTimeout_0
   3409              {
   3410                if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
   \       0x2C   0x.... 0x....      BL       HAL_GetTick
   \       0x30   0x1BC0             SUBS     R0,R0,R7
   \       0x32   0x42A0             CMP      R0,R4
   \       0x34   0xD201             BCS.N    ??SPI_WaitFlagStateUntilTimeout_4
   \       0x36   0x2C00             CMP      R4,#+0
   \       0x38   0xD1E9             BNE.N    ??SPI_WaitFlagStateUntilTimeout_0
   3411                {
   3412                  /* Disable the SPI and reset the CRC: the CRC value should be cleared
   3413                  on both master and slave sides in order to resynchronize the master
   3414                  and slave for their respective CRC calculation */
   3415          
   3416                  /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
   3417                  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
   \                     ??SPI_WaitFlagStateUntilTimeout_4: (+1)
   \       0x3A   0x6828             LDR      R0,[R5, #+0]
   \       0x3C   0x6840             LDR      R0,[R0, #+4]
   \       0x3E   0xF030 0x00E0      BICS     R0,R0,#0xE0
   \       0x42   0x6829             LDR      R1,[R5, #+0]
   \       0x44   0x6048             STR      R0,[R1, #+4]
   3418          
   3419                  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
   3420                                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \       0x46   0x6868             LDR      R0,[R5, #+4]
   \       0x48   0xF5B0 0x7F82      CMP      R0,#+260
   \       0x4C   0xD10D             BNE.N    ??SPI_WaitFlagStateUntilTimeout_5
   \       0x4E   0x68A8             LDR      R0,[R5, #+8]
   \       0x50   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x54   0xD003             BEQ.N    ??SPI_WaitFlagStateUntilTimeout_6
   \       0x56   0x68A8             LDR      R0,[R5, #+8]
   \       0x58   0xF5B0 0x6F80      CMP      R0,#+1024
   \       0x5C   0xD105             BNE.N    ??SPI_WaitFlagStateUntilTimeout_5
   3421                  {
   3422                    /* Disable SPI peripheral */
   3423                    __HAL_SPI_DISABLE(hspi);
   \                     ??SPI_WaitFlagStateUntilTimeout_6: (+1)
   \       0x5E   0x6828             LDR      R0,[R5, #+0]
   \       0x60   0x6800             LDR      R0,[R0, #+0]
   \       0x62   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x66   0x6829             LDR      R1,[R5, #+0]
   \       0x68   0x6008             STR      R0,[R1, #+0]
   3424                  }
   3425          
   3426                  /* Reset CRC Calculation */
   3427                  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
   \                     ??SPI_WaitFlagStateUntilTimeout_5: (+1)
   \       0x6A   0x6AA8             LDR      R0,[R5, #+40]
   \       0x6C   0xF5B0 0x5F00      CMP      R0,#+8192
   \       0x70   0xD10B             BNE.N    ??SPI_WaitFlagStateUntilTimeout_7
   3428                  {
   3429                    SPI_RESET_CRC(hspi);
   \       0x72   0x6828             LDR      R0,[R5, #+0]
   \       0x74   0x6800             LDR      R0,[R0, #+0]
   \       0x76   0xF430 0x5000      BICS     R0,R0,#0x2000
   \       0x7A   0x6829             LDR      R1,[R5, #+0]
   \       0x7C   0x6008             STR      R0,[R1, #+0]
   \       0x7E   0x6828             LDR      R0,[R5, #+0]
   \       0x80   0x6800             LDR      R0,[R0, #+0]
   \       0x82   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \       0x86   0x6829             LDR      R1,[R5, #+0]
   \       0x88   0x6008             STR      R0,[R1, #+0]
   3430                  }
   3431          
   3432                  hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_WaitFlagStateUntilTimeout_7: (+1)
   \       0x8A   0x2001             MOVS     R0,#+1
   \       0x8C   0xF885 0x0051      STRB     R0,[R5, #+81]
   3433          
   3434                  /* Process Unlocked */
   3435                  __HAL_UNLOCK(hspi);
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0xF885 0x0050      STRB     R0,[R5, #+80]
   3436          
   3437                  return HAL_TIMEOUT;
   \       0x96   0x2003             MOVS     R0,#+3
   \       0x98   0xE000             B.N      ??SPI_WaitFlagStateUntilTimeout_8
   3438                }
   3439              }
   3440            }
   3441          
   3442            return HAL_OK;
   \                     ??SPI_WaitFlagStateUntilTimeout_3: (+1)
   \       0x9A   0x2000             MOVS     R0,#+0
   \                     ??SPI_WaitFlagStateUntilTimeout_8: (+1)
   \       0x9C   0xE8BD 0x81F0      POP      {R4-R8,PC}
   3443          }
   3444          
   3445          /**
   3446            * @brief  Handle the check of the RX transaction complete.
   3447            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3448            *               the configuration information for SPI module.
   3449            * @param  Timeout Timeout duration
   3450            * @param  Tickstart tick start value
   3451            * @retval HAL status
   3452            */

   \                                 In section .text, align 2, keep-with-next
   3453          static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
   3454          {
   \                     SPI_EndRxTransaction: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   3455            if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
   3456                                                         || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
   \        0x8   0x6860             LDR      R0,[R4, #+4]
   \        0xA   0xF5B0 0x7F82      CMP      R0,#+260
   \        0xE   0xD10D             BNE.N    ??SPI_EndRxTransaction_0
   \       0x10   0x68A0             LDR      R0,[R4, #+8]
   \       0x12   0xF5B0 0x4F00      CMP      R0,#+32768
   \       0x16   0xD003             BEQ.N    ??SPI_EndRxTransaction_1
   \       0x18   0x68A0             LDR      R0,[R4, #+8]
   \       0x1A   0xF5B0 0x6F80      CMP      R0,#+1024
   \       0x1E   0xD105             BNE.N    ??SPI_EndRxTransaction_0
   3457            {
   3458              /* Disable SPI peripheral */
   3459              __HAL_SPI_DISABLE(hspi);
   \                     ??SPI_EndRxTransaction_1: (+1)
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x6800             LDR      R0,[R0, #+0]
   \       0x24   0xF030 0x0040      BICS     R0,R0,#0x40
   \       0x28   0x6821             LDR      R1,[R4, #+0]
   \       0x2A   0x6008             STR      R0,[R1, #+0]
   3460            }
   3461          
   3462            /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
   3463            if (hspi->Init.Mode == SPI_MODE_MASTER)
   \                     ??SPI_EndRxTransaction_0: (+1)
   \       0x2C   0x6860             LDR      R0,[R4, #+4]
   \       0x2E   0xF5B0 0x7F82      CMP      R0,#+260
   \       0x32   0xD121             BNE.N    ??SPI_EndRxTransaction_2
   3464            {
   3465              if (hspi->Init.Direction != SPI_DIRECTION_2LINES_RXONLY)
   \       0x34   0x68A0             LDR      R0,[R4, #+8]
   \       0x36   0xF5B0 0x6F80      CMP      R0,#+1024
   \       0x3A   0xD00E             BEQ.N    ??SPI_EndRxTransaction_3
   3466              {
   3467                /* Control the BSY flag */
   3468                if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
   \       0x3C   0x9600             STR      R6,[SP, #+0]
   \       0x3E   0x002B             MOVS     R3,R5
   \       0x40   0x2200             MOVS     R2,#+0
   \       0x42   0x2180             MOVS     R1,#+128
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD023             BEQ.N    ??SPI_EndRxTransaction_4
   3469                {
   3470                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x4E   0x6D60             LDR      R0,[R4, #+84]
   \       0x50   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x54   0x6560             STR      R0,[R4, #+84]
   3471                  return HAL_TIMEOUT;
   \       0x56   0x2003             MOVS     R0,#+3
   \       0x58   0xE01E             B.N      ??SPI_EndRxTransaction_5
   3472                }
   3473              }
   3474              else
   3475              {
   3476                /* Wait the RXNE reset */
   3477                if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
   \                     ??SPI_EndRxTransaction_3: (+1)
   \       0x5A   0x9600             STR      R6,[SP, #+0]
   \       0x5C   0x002B             MOVS     R3,R5
   \       0x5E   0x2200             MOVS     R2,#+0
   \       0x60   0x2101             MOVS     R1,#+1
   \       0x62   0x0020             MOVS     R0,R4
   \       0x64   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD014             BEQ.N    ??SPI_EndRxTransaction_4
   3478                {
   3479                  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x6C   0x6D60             LDR      R0,[R4, #+84]
   \       0x6E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x72   0x6560             STR      R0,[R4, #+84]
   3480                  return HAL_TIMEOUT;
   \       0x74   0x2003             MOVS     R0,#+3
   \       0x76   0xE00F             B.N      ??SPI_EndRxTransaction_5
   3481                }
   3482              }
   3483            }
   3484            else
   3485            {
   3486              /* Wait the RXNE reset */
   3487              if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
   \                     ??SPI_EndRxTransaction_2: (+1)
   \       0x78   0x9600             STR      R6,[SP, #+0]
   \       0x7A   0x002B             MOVS     R3,R5
   \       0x7C   0x2200             MOVS     R2,#+0
   \       0x7E   0x2101             MOVS     R1,#+1
   \       0x80   0x0020             MOVS     R0,R4
   \       0x82   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD005             BEQ.N    ??SPI_EndRxTransaction_4
   3488              {
   3489                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x8A   0x6D60             LDR      R0,[R4, #+84]
   \       0x8C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x90   0x6560             STR      R0,[R4, #+84]
   3490                return HAL_TIMEOUT;
   \       0x92   0x2003             MOVS     R0,#+3
   \       0x94   0xE000             B.N      ??SPI_EndRxTransaction_5
   3491              }
   3492            }
   3493            return HAL_OK;
   \                     ??SPI_EndRxTransaction_4: (+1)
   \       0x96   0x2000             MOVS     R0,#+0
   \                     ??SPI_EndRxTransaction_5: (+1)
   \       0x98   0xBD76             POP      {R1,R2,R4-R6,PC}
   3494          }
   3495          
   3496          /**
   3497            * @brief  Handle the check of the RXTX or TX transaction complete.
   3498            * @param  hspi SPI handle
   3499            * @param  Timeout Timeout duration
   3500            * @param  Tickstart tick start value
   3501            * @retval HAL status
   3502            */

   \                                 In section .text, align 2, keep-with-next
   3503          static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
   3504          {
   \                     SPI_EndRxTxTransaction: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   3505            /* Timeout in Âµs */
   3506            __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
   \        0x8   0x....             LDR.N    R0,??DataTable9
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0x2118             MOVS     R1,#+24
   \        0xE   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x12   0x....             LDR.N    R1,??DataTable9_1
   \       0x14   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x18   0xF44F 0x707A      MOV      R0,#+1000
   \       0x1C   0x4341             MULS     R1,R0,R1
   \       0x1E   0x9101             STR      R1,[SP, #+4]
   3507            /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
   3508            if (hspi->Init.Mode == SPI_MODE_MASTER)
   \       0x20   0x6860             LDR      R0,[R4, #+4]
   \       0x22   0xF5B0 0x7F82      CMP      R0,#+260
   \       0x26   0xD10E             BNE.N    ??SPI_EndRxTxTransaction_0
   3509            {
   3510              /* Control the BSY flag */
   3511              if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
   \       0x28   0x9600             STR      R6,[SP, #+0]
   \       0x2A   0x002B             MOVS     R3,R5
   \       0x2C   0x2200             MOVS     R2,#+0
   \       0x2E   0x2180             MOVS     R1,#+128
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x.... 0x....      BL       SPI_WaitFlagStateUntilTimeout
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD00F             BEQ.N    ??SPI_EndRxTxTransaction_1
   3512              {
   3513                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x3A   0x6D60             LDR      R0,[R4, #+84]
   \       0x3C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x40   0x6560             STR      R0,[R4, #+84]
   3514                return HAL_TIMEOUT;
   \       0x42   0x2003             MOVS     R0,#+3
   \       0x44   0xE00A             B.N      ??SPI_EndRxTxTransaction_2
   3515              }
   3516            }
   3517            else
   3518            {
   3519              /* Wait BSY flag during 1 Byte time transfer in case of Full-Duplex and Tx transfer
   3520              * If Timeout is reached, the transfer is considered as finish.
   3521              * User have to calculate the timeout value to fit with the time of 1 byte transfer.
   3522              * This time is directly link with the SPI clock from Master device.
   3523              */
   3524              do
   3525              {
   3526                if (count == 0U)
   \                     ??SPI_EndRxTxTransaction_0: (+1)
   \       0x46   0x9801             LDR      R0,[SP, #+4]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD006             BEQ.N    ??SPI_EndRxTxTransaction_1
   3527                {
   3528                  break;
   3529                }
   3530                count--;
   \                     ??SPI_EndRxTxTransaction_3: (+1)
   \       0x4C   0x9801             LDR      R0,[SP, #+4]
   \       0x4E   0x1E40             SUBS     R0,R0,#+1
   \       0x50   0x9001             STR      R0,[SP, #+4]
   3531              } while (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_BSY) != RESET);
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x6880             LDR      R0,[R0, #+8]
   \       0x56   0x0600             LSLS     R0,R0,#+24
   \       0x58   0xD4F5             BMI.N    ??SPI_EndRxTxTransaction_0
   3532            }
   3533          
   3534            return HAL_OK;
   \                     ??SPI_EndRxTxTransaction_1: (+1)
   \       0x5A   0x2000             MOVS     R0,#+0
   \                     ??SPI_EndRxTxTransaction_2: (+1)
   \       0x5C   0xBD76             POP      {R1,R2,R4-R6,PC}
   3535          }
   3536          
   3537          /**
   3538            * @brief  Handle the end of the RXTX transaction.
   3539            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3540            *               the configuration information for SPI module.
   3541            * @retval None
   3542            */

   \                                 In section .text, align 2, keep-with-next
   3543          static void SPI_CloseRxTx_ISR(SPI_HandleTypeDef *hspi)
   3544          {
   \                     SPI_CloseRxTx_ISR: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3545            uint32_t tickstart;
   3546            __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   \        0x4   0x....             LDR.N    R0,??DataTable9
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x2118             MOVS     R1,#+24
   \        0xA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \        0xE   0xF44F 0x717A      MOV      R1,#+1000
   \       0x12   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x16   0x2064             MOVS     R0,#+100
   \       0x18   0x4341             MULS     R1,R0,R1
   \       0x1A   0x9101             STR      R1,[SP, #+4]
   3547          
   3548            /* Init tickstart for timeout managment*/
   3549            tickstart = HAL_GetTick();
   \       0x1C   0x.... 0x....      BL       HAL_GetTick
   \       0x20   0x0005             MOVS     R5,R0
   3550          
   3551            /* Disable ERR interrupt */
   3552            __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6840             LDR      R0,[R0, #+4]
   \       0x26   0xF030 0x0020      BICS     R0,R0,#0x20
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6048             STR      R0,[R1, #+4]
   3553          
   3554            /* Wait until TXE flag is set */
   3555            do
   3556            {
   3557              if (count == 0U)
   \                     ??SPI_CloseRxTx_ISR_0: (+1)
   \       0x2E   0x9801             LDR      R0,[SP, #+4]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD104             BNE.N    ??SPI_CloseRxTx_ISR_1
   3558              {
   3559                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x34   0x6D60             LDR      R0,[R4, #+84]
   \       0x36   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x3A   0x6560             STR      R0,[R4, #+84]
   3560                break;
   \       0x3C   0xE006             B.N      ??SPI_CloseRxTx_ISR_2
   3561              }
   3562              count--;
   \                     ??SPI_CloseRxTx_ISR_1: (+1)
   \       0x3E   0x9801             LDR      R0,[SP, #+4]
   \       0x40   0x1E40             SUBS     R0,R0,#+1
   \       0x42   0x9001             STR      R0,[SP, #+4]
   3563            } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x6880             LDR      R0,[R0, #+8]
   \       0x48   0x0780             LSLS     R0,R0,#+30
   \       0x4A   0xD5F0             BPL.N    ??SPI_CloseRxTx_ISR_0
   3564          
   3565            /* Check the end of the transaction */
   3566            if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   \                     ??SPI_CloseRxTx_ISR_2: (+1)
   \       0x4C   0x002A             MOVS     R2,R5
   \       0x4E   0x2164             MOVS     R1,#+100
   \       0x50   0x0020             MOVS     R0,R4
   \       0x52   0x.... 0x....      BL       SPI_EndRxTxTransaction
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD003             BEQ.N    ??SPI_CloseRxTx_ISR_3
   3567            {
   3568              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x5A   0x6D60             LDR      R0,[R4, #+84]
   \       0x5C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x60   0x6560             STR      R0,[R4, #+84]
   3569            }
   3570          
   3571            /* Clear overrun flag in 2 Lines communication mode because received is not read */
   3572            if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??SPI_CloseRxTx_ISR_3: (+1)
   \       0x62   0x68A0             LDR      R0,[R4, #+8]
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD108             BNE.N    ??SPI_CloseRxTx_ISR_4
   3573            {
   3574              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0x9000             STR      R0,[SP, #+0]
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x68C0             LDR      R0,[R0, #+12]
   \       0x70   0x9000             STR      R0,[SP, #+0]
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x6880             LDR      R0,[R0, #+8]
   \       0x76   0x9000             STR      R0,[SP, #+0]
   \       0x78   0x9800             LDR      R0,[SP, #+0]
   3575            }
   3576          
   3577          #if (USE_SPI_CRC != 0U)
   3578            /* Check if CRC error occurred */
   3579            if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   3580            {
   3581              hspi->State = HAL_SPI_STATE_READY;
   3582              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   3583              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   3584              /* Call user error callback */
   3585          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3586              hspi->ErrorCallback(hspi);
   3587          #else
   3588              HAL_SPI_ErrorCallback(hspi);
   3589          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3590            }
   3591            else
   3592            {
   3593          #endif /* USE_SPI_CRC */
   3594              if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \                     ??SPI_CloseRxTx_ISR_4: (+1)
   \       0x7A   0x6D60             LDR      R0,[R4, #+84]
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD111             BNE.N    ??SPI_CloseRxTx_ISR_5
   3595              {
   3596                if (hspi->State == HAL_SPI_STATE_BUSY_RX)
   \       0x80   0xF894 0x0051      LDRB     R0,[R4, #+81]
   \       0x84   0x2804             CMP      R0,#+4
   \       0x86   0xD106             BNE.N    ??SPI_CloseRxTx_ISR_6
   3597                {
   3598                  hspi->State = HAL_SPI_STATE_READY;
   \       0x88   0x2001             MOVS     R0,#+1
   \       0x8A   0xF884 0x0051      STRB     R0,[R4, #+81]
   3599                  /* Call user Rx complete callback */
   3600          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3601                  hspi->RxCpltCallback(hspi);
   3602          #else
   3603                  HAL_SPI_RxCpltCallback(hspi);
   \       0x8E   0x0020             MOVS     R0,R4
   \       0x90   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   \       0x94   0xE00C             B.N      ??SPI_CloseRxTx_ISR_7
   3604          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3605                }
   3606                else
   3607                {
   3608                  hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseRxTx_ISR_6: (+1)
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0xF884 0x0051      STRB     R0,[R4, #+81]
   3609                  /* Call user TxRx complete callback */
   3610          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3611                  hspi->TxRxCpltCallback(hspi);
   3612          #else
   3613                  HAL_SPI_TxRxCpltCallback(hspi);
   \       0x9C   0x0020             MOVS     R0,R4
   \       0x9E   0x.... 0x....      BL       HAL_SPI_TxRxCpltCallback
   \       0xA2   0xE005             B.N      ??SPI_CloseRxTx_ISR_7
   3614          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3615                }
   3616              }
   3617              else
   3618              {
   3619                hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseRxTx_ISR_5: (+1)
   \       0xA4   0x2001             MOVS     R0,#+1
   \       0xA6   0xF884 0x0051      STRB     R0,[R4, #+81]
   3620                /* Call user error callback */
   3621          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3622                hspi->ErrorCallback(hspi);
   3623          #else
   3624                HAL_SPI_ErrorCallback(hspi);
   \       0xAA   0x0020             MOVS     R0,R4
   \       0xAC   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   3625          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3626              }
   3627          #if (USE_SPI_CRC != 0U)
   3628            }
   3629          #endif /* USE_SPI_CRC */
   3630          }
   \                     ??SPI_CloseRxTx_ISR_7: (+1)
   \       0xB0   0xBD37             POP      {R0-R2,R4,R5,PC}
   3631          
   3632          /**
   3633            * @brief  Handle the end of the RX transaction.
   3634            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3635            *               the configuration information for SPI module.
   3636            * @retval None
   3637            */

   \                                 In section .text, align 2, keep-with-next
   3638          static void SPI_CloseRx_ISR(SPI_HandleTypeDef *hspi)
   3639          {
   \                     SPI_CloseRx_ISR: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3640            /* Disable RXNE and ERR interrupt */
   3641            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_RXNE | SPI_IT_ERR));
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x6840             LDR      R0,[R0, #+4]
   \        0x8   0xF030 0x0060      BICS     R0,R0,#0x60
   \        0xC   0x6821             LDR      R1,[R4, #+0]
   \        0xE   0x6048             STR      R0,[R1, #+4]
   3642          
   3643            /* Check the end of the transaction */
   3644            if (SPI_EndRxTransaction(hspi, SPI_DEFAULT_TIMEOUT, HAL_GetTick()) != HAL_OK)
   \       0x10   0x.... 0x....      BL       HAL_GetTick
   \       0x14   0x0002             MOVS     R2,R0
   \       0x16   0x2164             MOVS     R1,#+100
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0x.... 0x....      BL       SPI_EndRxTransaction
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD003             BEQ.N    ??SPI_CloseRx_ISR_0
   3645            {
   3646              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x22   0x6D60             LDR      R0,[R4, #+84]
   \       0x24   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x28   0x6560             STR      R0,[R4, #+84]
   3647            }
   3648          
   3649            /* Clear overrun flag in 2 Lines communication mode because received is not read */
   3650            if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??SPI_CloseRx_ISR_0: (+1)
   \       0x2A   0x68A0             LDR      R0,[R4, #+8]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD108             BNE.N    ??SPI_CloseRx_ISR_1
   3651            {
   3652              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x9000             STR      R0,[SP, #+0]
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x68C0             LDR      R0,[R0, #+12]
   \       0x38   0x9000             STR      R0,[SP, #+0]
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x6880             LDR      R0,[R0, #+8]
   \       0x3E   0x9000             STR      R0,[SP, #+0]
   \       0x40   0x9800             LDR      R0,[SP, #+0]
   3653            }
   3654            hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseRx_ISR_1: (+1)
   \       0x42   0x2001             MOVS     R0,#+1
   \       0x44   0xF884 0x0051      STRB     R0,[R4, #+81]
   3655          
   3656          #if (USE_SPI_CRC != 0U)
   3657            /* Check if CRC error occurred */
   3658            if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_CRCERR) != RESET)
   3659            {
   3660              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
   3661              __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
   3662              /* Call user error callback */
   3663          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3664              hspi->ErrorCallback(hspi);
   3665          #else
   3666              HAL_SPI_ErrorCallback(hspi);
   3667          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3668            }
   3669            else
   3670            {
   3671          #endif /* USE_SPI_CRC */
   3672              if (hspi->ErrorCode == HAL_SPI_ERROR_NONE)
   \       0x48   0x6D60             LDR      R0,[R4, #+84]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD103             BNE.N    ??SPI_CloseRx_ISR_2
   3673              {
   3674                /* Call user Rx complete callback */
   3675          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3676                hspi->RxCpltCallback(hspi);
   3677          #else
   3678                HAL_SPI_RxCpltCallback(hspi);
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x.... 0x....      BL       HAL_SPI_RxCpltCallback
   \       0x54   0xE002             B.N      ??SPI_CloseRx_ISR_3
   3679          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3680              }
   3681              else
   3682              {
   3683                /* Call user error callback */
   3684          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3685                hspi->ErrorCallback(hspi);
   3686          #else
   3687                HAL_SPI_ErrorCallback(hspi);
   \                     ??SPI_CloseRx_ISR_2: (+1)
   \       0x56   0x0020             MOVS     R0,R4
   \       0x58   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   3688          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3689              }
   3690          #if (USE_SPI_CRC != 0U)
   3691            }
   3692          #endif /* USE_SPI_CRC */
   3693          }
   \                     ??SPI_CloseRx_ISR_3: (+1)
   \       0x5C   0xBD13             POP      {R0,R1,R4,PC}
   3694          
   3695          /**
   3696            * @brief  Handle the end of the TX transaction.
   3697            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3698            *               the configuration information for SPI module.
   3699            * @retval None
   3700            */

   \                                 In section .text, align 2, keep-with-next
   3701          static void SPI_CloseTx_ISR(SPI_HandleTypeDef *hspi)
   3702          {
   \                     SPI_CloseTx_ISR: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3703            uint32_t tickstart;
   3704            __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   \        0x4   0x....             LDR.N    R0,??DataTable9
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x2118             MOVS     R1,#+24
   \        0xA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \        0xE   0xF44F 0x717A      MOV      R1,#+1000
   \       0x12   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x16   0x2064             MOVS     R0,#+100
   \       0x18   0x4341             MULS     R1,R0,R1
   \       0x1A   0x9101             STR      R1,[SP, #+4]
   3705          
   3706            /* Init tickstart for timeout management*/
   3707            tickstart = HAL_GetTick();
   \       0x1C   0x.... 0x....      BL       HAL_GetTick
   \       0x20   0x0005             MOVS     R5,R0
   3708          
   3709            /* Wait until TXE flag is set */
   3710            do
   3711            {
   3712              if (count == 0U)
   \                     ??SPI_CloseTx_ISR_0: (+1)
   \       0x22   0x9801             LDR      R0,[SP, #+4]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD104             BNE.N    ??SPI_CloseTx_ISR_1
   3713              {
   3714                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x28   0x6D60             LDR      R0,[R4, #+84]
   \       0x2A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x2E   0x6560             STR      R0,[R4, #+84]
   3715                break;
   \       0x30   0xE006             B.N      ??SPI_CloseTx_ISR_2
   3716              }
   3717              count--;
   \                     ??SPI_CloseTx_ISR_1: (+1)
   \       0x32   0x9801             LDR      R0,[SP, #+4]
   \       0x34   0x1E40             SUBS     R0,R0,#+1
   \       0x36   0x9001             STR      R0,[SP, #+4]
   3718            } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x6880             LDR      R0,[R0, #+8]
   \       0x3C   0x0780             LSLS     R0,R0,#+30
   \       0x3E   0xD5F0             BPL.N    ??SPI_CloseTx_ISR_0
   3719          
   3720            /* Disable TXE and ERR interrupt */
   3721            __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_ERR));
   \                     ??SPI_CloseTx_ISR_2: (+1)
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x6840             LDR      R0,[R0, #+4]
   \       0x44   0xF030 0x00A0      BICS     R0,R0,#0xA0
   \       0x48   0x6821             LDR      R1,[R4, #+0]
   \       0x4A   0x6048             STR      R0,[R1, #+4]
   3722          
   3723            /* Check the end of the transaction */
   3724            if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
   \       0x4C   0x002A             MOVS     R2,R5
   \       0x4E   0x2164             MOVS     R1,#+100
   \       0x50   0x0020             MOVS     R0,R4
   \       0x52   0x.... 0x....      BL       SPI_EndRxTxTransaction
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD003             BEQ.N    ??SPI_CloseTx_ISR_3
   3725            {
   3726              SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
   \       0x5A   0x6D60             LDR      R0,[R4, #+84]
   \       0x5C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x60   0x6560             STR      R0,[R4, #+84]
   3727            }
   3728          
   3729            /* Clear overrun flag in 2 Lines communication mode because received is not read */
   3730            if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
   \                     ??SPI_CloseTx_ISR_3: (+1)
   \       0x62   0x68A0             LDR      R0,[R4, #+8]
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD108             BNE.N    ??SPI_CloseTx_ISR_4
   3731            {
   3732              __HAL_SPI_CLEAR_OVRFLAG(hspi);
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0x9000             STR      R0,[SP, #+0]
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x68C0             LDR      R0,[R0, #+12]
   \       0x70   0x9000             STR      R0,[SP, #+0]
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x6880             LDR      R0,[R0, #+8]
   \       0x76   0x9000             STR      R0,[SP, #+0]
   \       0x78   0x9800             LDR      R0,[SP, #+0]
   3733            }
   3734          
   3735            hspi->State = HAL_SPI_STATE_READY;
   \                     ??SPI_CloseTx_ISR_4: (+1)
   \       0x7A   0x2001             MOVS     R0,#+1
   \       0x7C   0xF884 0x0051      STRB     R0,[R4, #+81]
   3736            if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
   \       0x80   0x6D60             LDR      R0,[R4, #+84]
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD003             BEQ.N    ??SPI_CloseTx_ISR_5
   3737            {
   3738              /* Call user error callback */
   3739          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3740              hspi->ErrorCallback(hspi);
   3741          #else
   3742              HAL_SPI_ErrorCallback(hspi);
   \       0x86   0x0020             MOVS     R0,R4
   \       0x88   0x.... 0x....      BL       HAL_SPI_ErrorCallback
   \       0x8C   0xE002             B.N      ??SPI_CloseTx_ISR_6
   3743          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3744            }
   3745            else
   3746            {
   3747              /* Call user Rx complete callback */
   3748          #if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
   3749              hspi->TxCpltCallback(hspi);
   3750          #else
   3751              HAL_SPI_TxCpltCallback(hspi);
   \                     ??SPI_CloseTx_ISR_5: (+1)
   \       0x8E   0x0020             MOVS     R0,R4
   \       0x90   0x.... 0x....      BL       HAL_SPI_TxCpltCallback
   3752          #endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
   3753            }
   3754          }
   \                     ??SPI_CloseTx_ISR_6: (+1)
   \       0x94   0xBD37             POP      {R0-R2,R4,R5,PC}
   3755          
   3756          /**
   3757            * @brief  Handle abort a Rx transaction.
   3758            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3759            *               the configuration information for SPI module.
   3760            * @retval None
   3761            */

   \                                 In section .text, align 4, keep-with-next
   3762          static void SPI_AbortRx_ISR(SPI_HandleTypeDef *hspi)
   3763          {
   \                     SPI_AbortRx_ISR: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   3764            __IO uint32_t count = SPI_DEFAULT_TIMEOUT * (SystemCoreClock / 24U / 1000U);
   \        0x2   0x....             LDR.N    R1,??DataTable9
   \        0x4   0x6809             LDR      R1,[R1, #+0]
   \        0x6   0x2218             MOVS     R2,#+24
   \        0x8   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \        0xC   0xF44F 0x727A      MOV      R2,#+1000
   \       0x10   0xFBB1 0xF2F2      UDIV     R2,R1,R2
   \       0x14   0x2164             MOVS     R1,#+100
   \       0x16   0x434A             MULS     R2,R1,R2
   \       0x18   0x9200             STR      R2,[SP, #+0]
   3765          
   3766            /* Wait until TXE flag is set */
   3767            do
   3768            {
   3769              if (count == 0U)
   \                     ??SPI_AbortRx_ISR_0: (+1)
   \       0x1A   0x9900             LDR      R1,[SP, #+0]
   \       0x1C   0x2900             CMP      R1,#+0
   \       0x1E   0xD104             BNE.N    ??SPI_AbortRx_ISR_1
   3770              {
   3771                SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
   \       0x20   0x6D41             LDR      R1,[R0, #+84]
   \       0x22   0xF051 0x0140      ORRS     R1,R1,#0x40
   \       0x26   0x6541             STR      R1,[R0, #+84]
   3772                break;
   \       0x28   0xE006             B.N      ??SPI_AbortRx_ISR_2
   3773              }
   3774              count--;
   \                     ??SPI_AbortRx_ISR_1: (+1)
   \       0x2A   0x9900             LDR      R1,[SP, #+0]
   \       0x2C   0x1E49             SUBS     R1,R1,#+1
   \       0x2E   0x9100             STR      R1,[SP, #+0]
   3775            } while ((hspi->Instance->SR & SPI_FLAG_TXE) == RESET);
   \       0x30   0x6801             LDR      R1,[R0, #+0]
   \       0x32   0x6889             LDR      R1,[R1, #+8]
   \       0x34   0x0789             LSLS     R1,R1,#+30
   \       0x36   0xD5F0             BPL.N    ??SPI_AbortRx_ISR_0
   3776          
   3777            /* Disable SPI Peripheral */
   3778            __HAL_SPI_DISABLE(hspi);
   \                     ??SPI_AbortRx_ISR_2: (+1)
   \       0x38   0x6801             LDR      R1,[R0, #+0]
   \       0x3A   0x6809             LDR      R1,[R1, #+0]
   \       0x3C   0xF031 0x0140      BICS     R1,R1,#0x40
   \       0x40   0x6802             LDR      R2,[R0, #+0]
   \       0x42   0x6011             STR      R1,[R2, #+0]
   3779          
   3780            /* Disable TXEIE, RXNEIE and ERRIE(mode fault event, overrun error, TI frame error) interrupts */
   3781            CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE | SPI_CR2_RXNEIE | SPI_CR2_ERRIE));
   \       0x44   0x6801             LDR      R1,[R0, #+0]
   \       0x46   0x6849             LDR      R1,[R1, #+4]
   \       0x48   0xF031 0x01E0      BICS     R1,R1,#0xE0
   \       0x4C   0x6802             LDR      R2,[R0, #+0]
   \       0x4E   0x6051             STR      R1,[R2, #+4]
   3782          
   3783            /* Read CRC to flush Data Register */
   3784            READ_REG(hspi->Instance->DR);
   \       0x50   0x6801             LDR      R1,[R0, #+0]
   \       0x52   0x68C9             LDR      R1,[R1, #+12]
   3785          
   3786            hspi->State = HAL_SPI_STATE_ABORT;
   \       0x54   0x2107             MOVS     R1,#+7
   \       0x56   0xF880 0x1051      STRB     R1,[R0, #+81]
   3787          }
   \       0x5A   0xB001             ADD      SP,SP,#+4
   \       0x5C   0x4770             BX       LR
   3788          
   3789          /**
   3790            * @brief  Handle abort a Tx or Rx/Tx transaction.
   3791            * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
   3792            *               the configuration information for SPI module.
   3793            * @retval None
   3794            */

   \                                 In section .text, align 4, keep-with-next
   3795          static void SPI_AbortTx_ISR(SPI_HandleTypeDef *hspi)
   3796          {
   3797            /* Disable TXEIE interrupt */
   3798            CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXEIE));
   \                     SPI_AbortTx_ISR: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x6849             LDR      R1,[R1, #+4]
   \        0x4   0xF031 0x0180      BICS     R1,R1,#0x80
   \        0x8   0x6802             LDR      R2,[R0, #+0]
   \        0xA   0x6051             STR      R1,[R2, #+4]
   3799          
   3800            /* Disable SPI Peripheral */
   3801            __HAL_SPI_DISABLE(hspi);
   \        0xC   0x6801             LDR      R1,[R0, #+0]
   \        0xE   0x6809             LDR      R1,[R1, #+0]
   \       0x10   0xF031 0x0140      BICS     R1,R1,#0x40
   \       0x14   0x6802             LDR      R2,[R0, #+0]
   \       0x16   0x6011             STR      R1,[R2, #+0]
   3802          
   3803            hspi->State = HAL_SPI_STATE_ABORT;
   \       0x18   0x2107             MOVS     R1,#+7
   \       0x1A   0xF880 0x1051      STRB     R1,[R0, #+81]
   3804          }
   \       0x1E   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x....'....        DC32     SPI_TxISR_16BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x....'....        DC32     SPI_TxISR_8BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x....'....        DC32     SPI_RxISR_16BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0x....'....        DC32     SPI_RxISR_8BIT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x000F'4240        DC32     0xf4240
   3805          
   3806          /**
   3807            * @}
   3808            */
   3809          
   3810          #endif /* HAL_SPI_MODULE_ENABLED */
   3811          
   3812          /**
   3813            * @}
   3814            */
   3815          
   3816          /**
   3817            * @}
   3818            */
   3819          
   3820          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   HAL_SPI_Abort
        24   -> HAL_DMA_Abort
       0   HAL_SPI_AbortCpltCallback
      32   HAL_SPI_Abort_IT
        32   -> HAL_DMA_Abort_IT
        32   -> HAL_SPI_AbortCpltCallback
       0   HAL_SPI_DMAPause
       0   HAL_SPI_DMAResume
      16   HAL_SPI_DMAStop
        16   -> HAL_DMA_Abort
       8   HAL_SPI_DeInit
         8   -> HAL_SPI_MspDeInit
       0   HAL_SPI_ErrorCallback
       0   HAL_SPI_GetError
       0   HAL_SPI_GetState
      24   HAL_SPI_IRQHandler
        24   -- Indirect call
        24   -> HAL_DMA_Abort_IT
        24   -> HAL_SPI_ErrorCallback
       8   HAL_SPI_Init
         8   -> HAL_SPI_MspInit
       0   HAL_SPI_MspDeInit
       0   HAL_SPI_MspInit
      32   HAL_SPI_Receive
        32   -> HAL_GetTick
        32   -> HAL_SPI_TransmitReceive
        32   -> SPI_EndRxTransaction
      24   HAL_SPI_Receive_DMA
        24   -> HAL_DMA_Start_IT
        24   -> HAL_SPI_TransmitReceive_DMA
      24   HAL_SPI_Receive_IT
        24   -> HAL_SPI_TransmitReceive_IT
       0   HAL_SPI_RxCpltCallback
       0   HAL_SPI_RxHalfCpltCallback
      40   HAL_SPI_Transmit
        40   -> HAL_GetTick
        40   -> SPI_EndRxTxTransaction
      48   HAL_SPI_TransmitReceive
        48   -> HAL_GetTick
        48   -> SPI_EndRxTxTransaction
      32   HAL_SPI_TransmitReceive_DMA
        32   -> HAL_DMA_Start_IT
      16   HAL_SPI_TransmitReceive_IT
      24   HAL_SPI_Transmit_DMA
        24   -> HAL_DMA_Start_IT
       8   HAL_SPI_Transmit_IT
       0   HAL_SPI_TxCpltCallback
       0   HAL_SPI_TxHalfCpltCallback
       0   HAL_SPI_TxRxCpltCallback
       0   HAL_SPI_TxRxHalfCpltCallback
       8   SPI_2linesRxISR_16BIT
         8   -> SPI_CloseRxTx_ISR
       8   SPI_2linesRxISR_8BIT
         8   -> SPI_CloseRxTx_ISR
       8   SPI_2linesTxISR_16BIT
         8   -> SPI_CloseRxTx_ISR
       8   SPI_2linesTxISR_8BIT
         8   -> SPI_CloseRxTx_ISR
       4   SPI_AbortRx_ISR
       0   SPI_AbortTx_ISR
      24   SPI_CloseRxTx_ISR
        24   -> HAL_GetTick
        24   -> HAL_SPI_ErrorCallback
        24   -> HAL_SPI_RxCpltCallback
        24   -> HAL_SPI_TxRxCpltCallback
        24   -> SPI_EndRxTxTransaction
      16   SPI_CloseRx_ISR
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_RxCpltCallback
        16   -> SPI_EndRxTransaction
      24   SPI_CloseTx_ISR
        24   -> HAL_GetTick
        24   -> HAL_SPI_ErrorCallback
        24   -> HAL_SPI_TxCpltCallback
        24   -> SPI_EndRxTxTransaction
      16   SPI_DMAAbortOnError
        16   -> HAL_SPI_ErrorCallback
      16   SPI_DMAError
        16   -> HAL_SPI_ErrorCallback
      16   SPI_DMAHalfReceiveCplt
        16   -> HAL_SPI_RxHalfCpltCallback
      16   SPI_DMAHalfTransmitCplt
        16   -> HAL_SPI_TxHalfCpltCallback
      16   SPI_DMAHalfTransmitReceiveCplt
        16   -> HAL_SPI_TxRxHalfCpltCallback
      16   SPI_DMAReceiveCplt
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_RxCpltCallback
        16   -> SPI_EndRxTransaction
      16   SPI_DMARxAbortCallback
        16   -> HAL_GetTick
        16   -> HAL_SPI_AbortCpltCallback
        16   -> SPI_EndRxTxTransaction
      24   SPI_DMATransmitCplt
        24   -> HAL_GetTick
        24   -> HAL_SPI_ErrorCallback
        24   -> HAL_SPI_TxCpltCallback
        24   -> SPI_EndRxTxTransaction
      16   SPI_DMATransmitReceiveCplt
        16   -> HAL_GetTick
        16   -> HAL_SPI_ErrorCallback
        16   -> HAL_SPI_TxRxCpltCallback
        16   -> SPI_EndRxTxTransaction
      24   SPI_DMATxAbortCallback
        24   -> HAL_SPI_AbortCpltCallback
      24   SPI_EndRxTransaction
        24   -> SPI_WaitFlagStateUntilTimeout
      24   SPI_EndRxTxTransaction
        24   -> SPI_WaitFlagStateUntilTimeout
       8   SPI_RxISR_16BIT
         8   -> SPI_CloseRx_ISR
       8   SPI_RxISR_8BIT
         8   -> SPI_CloseRx_ISR
       8   SPI_TxISR_16BIT
         8   -> SPI_CloseTx_ISR
       8   SPI_TxISR_8BIT
         8   -> SPI_CloseTx_ISR
      24   SPI_WaitFlagStateUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable9
       4  ??DataTable9_1
     344  HAL_SPI_Abort
       2  HAL_SPI_AbortCpltCallback
     364  HAL_SPI_Abort_IT
      42  HAL_SPI_DMAPause
      42  HAL_SPI_DMAResume
      86  HAL_SPI_DMAStop
      56  HAL_SPI_DeInit
       2  HAL_SPI_ErrorCallback
       4  HAL_SPI_GetError
       6  HAL_SPI_GetState
     296  HAL_SPI_IRQHandler
     142  HAL_SPI_Init
       2  HAL_SPI_MspDeInit
       2  HAL_SPI_MspInit
     368  HAL_SPI_Receive
     274  HAL_SPI_Receive_DMA
     212  HAL_SPI_Receive_IT
       2  HAL_SPI_RxCpltCallback
       2  HAL_SPI_RxHalfCpltCallback
     426  HAL_SPI_Transmit
     572  HAL_SPI_TransmitReceive
     366  HAL_SPI_TransmitReceive_DMA
     202  HAL_SPI_TransmitReceive_IT
     242  HAL_SPI_Transmit_DMA
     174  HAL_SPI_Transmit_IT
       2  HAL_SPI_TxCpltCallback
       2  HAL_SPI_TxHalfCpltCallback
       2  HAL_SPI_TxRxCpltCallback
       2  HAL_SPI_TxRxHalfCpltCallback
      56  SPI_2linesRxISR_16BIT
      56  SPI_2linesRxISR_8BIT
      56  SPI_2linesTxISR_16BIT
      56  SPI_2linesTxISR_8BIT
      94  SPI_AbortRx_ISR
      32  SPI_AbortTx_ISR
     178  SPI_CloseRxTx_ISR
      94  SPI_CloseRx_ISR
     150  SPI_CloseTx_ISR
      22  SPI_DMAAbortOnError
      40  SPI_DMAError
      14  SPI_DMAHalfReceiveCplt
      14  SPI_DMAHalfTransmitCplt
      14  SPI_DMAHalfTransmitReceiveCplt
     122  SPI_DMAReceiveCplt
     138  SPI_DMARxAbortCallback
     122  SPI_DMATransmitCplt
     102  SPI_DMATransmitReceiveCplt
     156  SPI_DMATxAbortCallback
     154  SPI_EndRxTransaction
      94  SPI_EndRxTxTransaction
      38  SPI_RxISR_16BIT
      38  SPI_RxISR_8BIT
      38  SPI_TxISR_16BIT
      38  SPI_TxISR_8BIT
     160  SPI_WaitFlagStateUntilTimeout

 
 6'338 bytes in section .text
 
 6'318 bytes of CODE memory (+ 20 bytes shared)

Errors: none
Warnings: none
