###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         21/Sep/2022  13:40:11
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal.c
#    Command line      =
#        -f
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal.o.rsp
#        (C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal.c
#        -D USE_HAL_DRIVER -D STM32F407xx -lC
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver
#        -o
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/App\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Core/Inc\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Include\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/display\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Library\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal.o.d
#    Locale            =  C
#    List file         =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal.lst
#    Object file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal.c
      4            * @author  MCD Application Team
      5            * @brief   HAL module driver.
      6            *          This is the common part of the HAL initialization
      7            *
      8            @verbatim
      9            ==============================================================================
     10                               ##### How to use this driver #####
     11            ==============================================================================
     12              [..]
     13              The common HAL driver contains a set of generic and common APIs that can be
     14              used by the PPP peripheral drivers and the user to start using the HAL. 
     15              [..]
     16              The HAL contains two APIs' categories: 
     17                   (+) Common HAL APIs
     18                   (+) Services HAL APIs
     19          
     20            @endverbatim
     21            ******************************************************************************
     22            * @attention
     23            *
     24            * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics.
     25            * All rights reserved.</center></h2>
     26            *
     27            * This software component is licensed by ST under BSD 3-Clause license,
     28            * the "License"; You may not use this file except in compliance with the
     29            * License. You may obtain a copy of the License at:
     30            *                        opensource.org/licenses/BSD-3-Clause
     31            *
     32            ******************************************************************************
     33            */ 
     34          
     35          /* Includes ------------------------------------------------------------------*/
     36          #include "stm32f4xx_hal.h"
     37          
     38          /** @addtogroup STM32F4xx_HAL_Driver
     39            * @{
     40            */
     41          
     42          /** @defgroup HAL HAL
     43            * @brief HAL module driver.
     44            * @{
     45            */
     46          
     47          /* Private typedef -----------------------------------------------------------*/
     48          /* Private define ------------------------------------------------------------*/
     49          /** @addtogroup HAL_Private_Constants
     50            * @{
     51            */
     52          /**
     53            * @brief STM32F4xx HAL Driver version number V1.7.10
     54            */
     55          #define __STM32F4xx_HAL_VERSION_MAIN   (0x01U) /*!< [31:24] main version */
     56          #define __STM32F4xx_HAL_VERSION_SUB1   (0x07U) /*!< [23:16] sub1 version */
     57          #define __STM32F4xx_HAL_VERSION_SUB2   (0x0AU) /*!< [15:8]  sub2 version */
     58          #define __STM32F4xx_HAL_VERSION_RC     (0x00U) /*!< [7:0]  release candidate */ 
     59          #define __STM32F4xx_HAL_VERSION         ((__STM32F4xx_HAL_VERSION_MAIN << 24U)\
     60                                                  |(__STM32F4xx_HAL_VERSION_SUB1 << 16U)\
     61                                                  |(__STM32F4xx_HAL_VERSION_SUB2 << 8U )\
     62                                                  |(__STM32F4xx_HAL_VERSION_RC))
     63                                                  
     64          #define IDCODE_DEVID_MASK    0x00000FFFU
     65          
     66          /* ------------ RCC registers bit address in the alias region ----------- */
     67          #define SYSCFG_OFFSET             (SYSCFG_BASE - PERIPH_BASE)
     68          /* ---  MEMRMP Register ---*/ 
     69          /* Alias word address of UFB_MODE bit */ 
     70          #define MEMRMP_OFFSET             SYSCFG_OFFSET 
     71          #define UFB_MODE_BIT_NUMBER       SYSCFG_MEMRMP_UFB_MODE_Pos
     72          #define UFB_MODE_BB               (uint32_t)(PERIPH_BB_BASE + (MEMRMP_OFFSET * 32U) + (UFB_MODE_BIT_NUMBER * 4U)) 
     73          
     74          /* ---  CMPCR Register ---*/ 
     75          /* Alias word address of CMP_PD bit */ 
     76          #define CMPCR_OFFSET              (SYSCFG_OFFSET + 0x20U) 
     77          #define CMP_PD_BIT_NUMBER         SYSCFG_CMPCR_CMP_PD_Pos
     78          #define CMPCR_CMP_PD_BB           (uint32_t)(PERIPH_BB_BASE + (CMPCR_OFFSET * 32U) + (CMP_PD_BIT_NUMBER * 4U))
     79          
     80          /* ---  MCHDLYCR Register ---*/ 
     81          /* Alias word address of BSCKSEL bit */ 
     82          #define MCHDLYCR_OFFSET            (SYSCFG_OFFSET + 0x30U) 
     83          #define BSCKSEL_BIT_NUMBER         SYSCFG_MCHDLYCR_BSCKSEL_Pos
     84          #define MCHDLYCR_BSCKSEL_BB        (uint32_t)(PERIPH_BB_BASE + (MCHDLYCR_OFFSET * 32U) + (BSCKSEL_BIT_NUMBER * 4U))
     85          /**
     86            * @}
     87            */
     88          
     89          /* Private macro -------------------------------------------------------------*/
     90          /* Private variables ---------------------------------------------------------*/
     91          /** @addtogroup HAL_Private_Variables
     92            * @{
     93            */

   \                                 In section .bss, align 4
     94          __IO uint32_t uwTick;
   \                     uwTick:
   \        0x0                      DS8 4

   \                                 In section .data, align 4
     95          uint32_t uwTickPrio   = (1UL << __NVIC_PRIO_BITS); /* Invalid PRIO */
   \                     uwTickPrio:
   \        0x0   0x0000'0010        DC32 16

   \                                 In section .data, align 1
     96          HAL_TickFreqTypeDef uwTickFreq = HAL_TICK_FREQ_DEFAULT;  /* 1KHz */
   \                     uwTickFreq:
   \        0x0   0x01               DC8 1
     97          /**
     98            * @}
     99            */
    100          /* Private function prototypes -----------------------------------------------*/
    101          /* Private functions ---------------------------------------------------------*/
    102          
    103          /** @defgroup HAL_Exported_Functions HAL Exported Functions
    104            * @{
    105            */
    106          
    107          /** @defgroup HAL_Exported_Functions_Group1 Initialization and de-initialization Functions 
    108           *  @brief    Initialization and de-initialization functions
    109           *
    110          @verbatim    
    111           ===============================================================================
    112                        ##### Initialization and Configuration functions #####
    113           ===============================================================================
    114              [..]  This section provides functions allowing to:
    115                (+) Initializes the Flash interface the NVIC allocation and initial clock 
    116                    configuration. It initializes the systick also when timeout is needed 
    117                    and the backup domain when enabled.
    118                (+) De-Initializes common part of the HAL.
    119                (+) Configure the time base source to have 1ms time base with a dedicated 
    120                    Tick interrupt priority. 
    121                  (++) SysTick timer is used by default as source of time base, but user
    122                       can eventually implement his proper time base source (a general purpose 
    123                       timer for example or other time source), keeping in mind that Time base 
    124                       duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and 
    125                       handled in milliseconds basis.
    126                  (++) Time base configuration function (HAL_InitTick ()) is called automatically 
    127                       at the beginning of the program after reset by HAL_Init() or at any time 
    128                       when clock is configured, by HAL_RCC_ClockConfig(). 
    129                  (++) Source of time base is configured  to generate interrupts at regular 
    130                       time intervals. Care must be taken if HAL_Delay() is called from a 
    131                       peripheral ISR process, the Tick interrupt line must have higher priority 
    132                      (numerically lower) than the peripheral interrupt. Otherwise the caller 
    133                      ISR process will be blocked. 
    134                 (++) functions affecting time base configurations are declared as __weak  
    135                       to make  override possible  in case of other  implementations in user file.
    136          @endverbatim
    137            * @{
    138            */
    139          
    140          /**
    141            * @brief  This function is used to initialize the HAL Library; it must be the first 
    142            *         instruction to be executed in the main program (before to call any other
    143            *         HAL function), it performs the following:
    144            *           Configure the Flash prefetch, instruction and Data caches.
    145            *           Configures the SysTick to generate an interrupt each 1 millisecond,
    146            *           which is clocked by the HSI (at this stage, the clock is not yet
    147            *           configured and thus the system is running from the internal HSI at 16 MHz).
    148            *           Set NVIC Group Priority to 4.
    149            *           Calls the HAL_MspInit() callback function defined in user file 
    150            *           "stm32f4xx_hal_msp.c" to do the global low level hardware initialization 
    151            *            
    152            * @note   SysTick is used as time base for the HAL_Delay() function, the application
    153            *         need to ensure that the SysTick time base is always set to 1 millisecond
    154            *         to have correct HAL operation.
    155            * @retval HAL status
    156            */

   \                                 In section .text, align 2, keep-with-next
    157          HAL_StatusTypeDef HAL_Init(void)
    158          {
   \                     HAL_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    159            /* Configure Flash prefetch, Instruction cache, Data cache */ 
    160          #if (INSTRUCTION_CACHE_ENABLE != 0U)
    161            __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
   \        0x2   0x....             LDR.N    R0,??DataTable18
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0xF451 0x7100      ORRS     R1,R1,#0x200
   \        0xA   0x6001             STR      R1,[R0, #+0]
    162          #endif /* INSTRUCTION_CACHE_ENABLE */
    163          
    164          #if (DATA_CACHE_ENABLE != 0U)
    165            __HAL_FLASH_DATA_CACHE_ENABLE();
   \        0xC   0x6801             LDR      R1,[R0, #+0]
   \        0xE   0xF451 0x6180      ORRS     R1,R1,#0x400
   \       0x12   0x6001             STR      R1,[R0, #+0]
    166          #endif /* DATA_CACHE_ENABLE */
    167          
    168          #if (PREFETCH_ENABLE != 0U)
    169            __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
    170          #endif /* PREFETCH_ENABLE */
    171          
    172            /* Set Interrupt Group Priority */
    173            HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
   \       0x14   0x2003             MOVS     R0,#+3
   \       0x16   0x.... 0x....      BL       HAL_NVIC_SetPriorityGrouping
    174          
    175            /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
    176            HAL_InitTick(TICK_INT_PRIORITY);
   \       0x1A   0x200F             MOVS     R0,#+15
   \       0x1C   0x.... 0x....      BL       HAL_InitTick
    177          
    178            /* Init the low level hardware */
    179            HAL_MspInit();
   \       0x20   0x.... 0x....      BL       HAL_MspInit
    180          
    181            /* Return function status */
    182            return HAL_OK;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xBD02             POP      {R1,PC}
    183          }
    184          
    185          /**
    186            * @brief  This function de-Initializes common part of the HAL and stops the systick.
    187            *         This function is optional.   
    188            * @retval HAL status
    189            */

   \                                 In section .text, align 2, keep-with-next
    190          HAL_StatusTypeDef HAL_DeInit(void)
    191          {
   \                     HAL_DeInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    192            /* Reset of all peripherals */
    193            __HAL_RCC_APB1_FORCE_RESET();
   \        0x2   0x....             LDR.N    R0,??DataTable18_1
   \        0x4   0xF05F 0x31FF      MOVS     R1,#+4294967295
   \        0x8   0x6001             STR      R1,[R0, #+0]
    194            __HAL_RCC_APB1_RELEASE_RESET();
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x6002             STR      R2,[R0, #+0]
    195          
    196            __HAL_RCC_APB2_FORCE_RESET();
   \        0xE   0x....             LDR.N    R0,??DataTable18_2
   \       0x10   0x6001             STR      R1,[R0, #+0]
    197            __HAL_RCC_APB2_RELEASE_RESET();
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0x6002             STR      R2,[R0, #+0]
    198          
    199            __HAL_RCC_AHB1_FORCE_RESET();
   \       0x16   0x....             LDR.N    R0,??DataTable18_3
   \       0x18   0x6001             STR      R1,[R0, #+0]
    200            __HAL_RCC_AHB1_RELEASE_RESET();
   \       0x1A   0x2200             MOVS     R2,#+0
   \       0x1C   0x6002             STR      R2,[R0, #+0]
    201          
    202            __HAL_RCC_AHB2_FORCE_RESET();
   \       0x1E   0x....             LDR.N    R0,??DataTable18_4
   \       0x20   0x6001             STR      R1,[R0, #+0]
    203            __HAL_RCC_AHB2_RELEASE_RESET();
   \       0x22   0x2200             MOVS     R2,#+0
   \       0x24   0x6002             STR      R2,[R0, #+0]
    204          
    205            __HAL_RCC_AHB3_FORCE_RESET();
   \       0x26   0x....             LDR.N    R0,??DataTable18_5
   \       0x28   0x6001             STR      R1,[R0, #+0]
    206            __HAL_RCC_AHB3_RELEASE_RESET();
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0x6001             STR      R1,[R0, #+0]
    207          
    208            /* De-Init the low level hardware */
    209            HAL_MspDeInit();
   \       0x2E   0x.... 0x....      BL       HAL_MspDeInit
    210              
    211            /* Return function status */
    212            return HAL_OK;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xBD02             POP      {R1,PC}
    213          }
    214          
    215          /**
    216            * @brief  Initialize the MSP.
    217            * @retval None
    218            */

   \                                 In section .text, align 2
    219          __weak void HAL_MspInit(void)
    220          {
    221            /* NOTE : This function should not be modified, when the callback is needed,
    222                      the HAL_MspInit could be implemented in the user file
    223             */
    224          }
   \                     HAL_MspInit: (+1)
   \        0x0   0x4770             BX       LR
    225          
    226          /**
    227            * @brief  DeInitializes the MSP.
    228            * @retval None
    229            */

   \                                 In section .text, align 2
    230          __weak void HAL_MspDeInit(void)
    231          {
    232            /* NOTE : This function should not be modified, when the callback is needed,
    233                      the HAL_MspDeInit could be implemented in the user file
    234             */ 
    235          }
   \                     HAL_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
    236          
    237          /**
    238            * @brief This function configures the source of the time base.
    239            *        The time source is configured  to have 1ms time base with a dedicated 
    240            *        Tick interrupt priority.
    241            * @note This function is called  automatically at the beginning of program after
    242            *       reset by HAL_Init() or at any time when clock is reconfigured  by HAL_RCC_ClockConfig().
    243            * @note In the default implementation, SysTick timer is the source of time base. 
    244            *       It is used to generate interrupts at regular time intervals. 
    245            *       Care must be taken if HAL_Delay() is called from a peripheral ISR process, 
    246            *       The SysTick interrupt must have higher priority (numerically lower)
    247            *       than the peripheral interrupt. Otherwise the caller ISR process will be blocked.
    248            *       The function is declared as __weak  to be overwritten  in case of other
    249            *       implementation  in user file.
    250            * @param TickPriority Tick interrupt priority.
    251            * @retval HAL status
    252            */

   \                                 In section .text, align 4
    253          __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
    254          {
   \                     HAL_InitTick: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    255            /* Configure the SysTick to have interrupt in 1ms time basis*/
    256            if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
   \        0x4   0xF44F 0x707A      MOV      R0,#+1000
   \        0x8   0x490D             LDR.N    R1,??HAL_InitTick_0
   \        0xA   0x7809             LDRB     R1,[R1, #+0]
   \        0xC   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x10   0x490C             LDR.N    R1,??HAL_InitTick_0+0x4
   \       0x12   0x6809             LDR      R1,[R1, #+0]
   \       0x14   0xFBB1 0xF0F0      UDIV     R0,R1,R0
   \       0x18   0x.... 0x....      BL       HAL_SYSTICK_Config
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD001             BEQ.N    ??HAL_InitTick_1
    257            {
    258              return HAL_ERROR;
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xE00C             B.N      ??HAL_InitTick_2
    259            }
    260          
    261            /* Configure the SysTick IRQ priority */
    262            if (TickPriority < (1UL << __NVIC_PRIO_BITS))
   \                     ??HAL_InitTick_1: (+1)
   \       0x24   0x2C10             CMP      R4,#+16
   \       0x26   0xD209             BCS.N    ??HAL_InitTick_3
    263            {
    264              HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
   \       0x28   0x2200             MOVS     R2,#+0
   \       0x2A   0x0021             MOVS     R1,R4
   \       0x2C   0xF05F 0x30FF      MOVS     R0,#+4294967295
   \       0x30   0x.... 0x....      BL       HAL_NVIC_SetPriority
    265              uwTickPrio = TickPriority;
   \       0x34   0x4804             LDR.N    R0,??HAL_InitTick_0+0x8
   \       0x36   0x6004             STR      R4,[R0, #+0]
    266            }
    267            else
    268            {
    269              return HAL_ERROR;
    270            }
    271          
    272            /* Return function status */
    273            return HAL_OK;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xE000             B.N      ??HAL_InitTick_2
   \                     ??HAL_InitTick_3: (+1)
   \       0x3C   0x2001             MOVS     R0,#+1
   \                     ??HAL_InitTick_2: (+1)
   \       0x3E   0xBD10             POP      {R4,PC}
   \                     ??HAL_InitTick_0:
   \       0x40   0x....'....        DC32     uwTickFreq
   \       0x44   0x....'....        DC32     SystemCoreClock
   \       0x48   0x....'....        DC32     uwTickPrio
    274          }
    275          
    276          /**
    277            * @}
    278            */
    279          
    280          /** @defgroup HAL_Exported_Functions_Group2 HAL Control functions 
    281           *  @brief    HAL Control functions
    282           *
    283          @verbatim
    284           ===============================================================================
    285                                ##### HAL Control functions #####
    286           ===============================================================================
    287              [..]  This section provides functions allowing to:
    288                (+) Provide a tick value in millisecond
    289                (+) Provide a blocking delay in millisecond
    290                (+) Suspend the time base source interrupt
    291                (+) Resume the time base source interrupt
    292                (+) Get the HAL API driver version
    293                (+) Get the device identifier
    294                (+) Get the device revision identifier
    295                (+) Enable/Disable Debug module during SLEEP mode
    296                (+) Enable/Disable Debug module during STOP mode
    297                (+) Enable/Disable Debug module during STANDBY mode
    298          
    299          @endverbatim
    300            * @{
    301            */
    302          
    303          /**
    304            * @brief This function is called to increment  a global variable "uwTick"
    305            *        used as application time base.
    306            * @note In the default implementation, this variable is incremented each 1ms
    307            *       in SysTick ISR.
    308           * @note This function is declared as __weak to be overwritten in case of other 
    309            *      implementations in user file.
    310            * @retval None
    311            */

   \                                 In section .text, align 4
    312          __weak void HAL_IncTick(void)
    313          {
    314            uwTick += uwTickFreq;
   \                     HAL_IncTick: (+1)
   \        0x0   0x4803             LDR.N    R0,??HAL_IncTick_0
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x4A03             LDR.N    R2,??HAL_IncTick_0+0x4
   \        0x6   0x7812             LDRB     R2,[R2, #+0]
   \        0x8   0x1889             ADDS     R1,R1,R2
   \        0xA   0x6001             STR      R1,[R0, #+0]
    315          }
   \        0xC   0x4770             BX       LR
   \        0xE   0xBF00             Nop
   \                     ??HAL_IncTick_0:
   \       0x10   0x....'....        DC32     uwTick
   \       0x14   0x....'....        DC32     uwTickFreq
    316          
    317          /**
    318            * @brief Provides a tick value in millisecond.
    319            * @note This function is declared as __weak to be overwritten in case of other 
    320            *       implementations in user file.
    321            * @retval tick value
    322            */

   \                                 In section .text, align 4
    323          __weak uint32_t HAL_GetTick(void)
    324          {
    325            return uwTick;
   \                     HAL_GetTick: (+1)
   \        0x0   0x4801             LDR.N    R0,??HAL_GetTick_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
   \        0x6   0xBF00             Nop
   \                     ??HAL_GetTick_0:
   \        0x8   0x....'....        DC32     uwTick
    326          }
    327          
    328          /**
    329            * @brief This function returns a tick priority.
    330            * @retval tick priority
    331            */

   \                                 In section .text, align 2, keep-with-next
    332          uint32_t HAL_GetTickPrio(void)
    333          {
    334            return uwTickPrio;
   \                     HAL_GetTickPrio: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable18_6
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
    335          }
    336          
    337          /**
    338            * @brief Set new tick Freq.
    339            * @retval Status
    340            */

   \                                 In section .text, align 2, keep-with-next
    341          HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
    342          {
   \                     HAL_SetTickFreq: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
    343            HAL_StatusTypeDef status  = HAL_OK;
   \        0x4   0x2700             MOVS     R7,#+0
    344            HAL_TickFreqTypeDef prevTickFreq;
    345          
    346            assert_param(IS_TICKFREQ(Freq));
    347          
    348            if (uwTickFreq != Freq)
   \        0x6   0x....             LDR.N    R6,??DataTable18_7
   \        0x8   0x7830             LDRB     R0,[R6, #+0]
   \        0xA   0x0029             MOVS     R1,R5
   \        0xC   0xB2C9             UXTB     R1,R1
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xD00C             BEQ.N    ??HAL_SetTickFreq_0
    349            {
    350              /* Back up uwTickFreq frequency */
    351              prevTickFreq = uwTickFreq;
   \       0x12   0x7830             LDRB     R0,[R6, #+0]
   \       0x14   0x0004             MOVS     R4,R0
    352          
    353              /* Update uwTickFreq global variable used by HAL_InitTick() */
    354              uwTickFreq = Freq;
   \       0x16   0x7035             STRB     R5,[R6, #+0]
    355          
    356              /* Apply the new tick Freq  */
    357              status = HAL_InitTick(uwTickPrio);
   \       0x18   0x....             LDR.N    R0,??DataTable18_6
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0x.... 0x....      BL       HAL_InitTick
   \       0x20   0x0007             MOVS     R7,R0
    358          
    359              if (status != HAL_OK)
   \       0x22   0x0038             MOVS     R0,R7
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD000             BEQ.N    ??HAL_SetTickFreq_0
    360              {
    361                /* Restore previous tick frequency */
    362                uwTickFreq = prevTickFreq;
   \       0x2A   0x7034             STRB     R4,[R6, #+0]
    363              }
    364            }
    365          
    366            return status;
   \                     ??HAL_SetTickFreq_0: (+1)
   \       0x2C   0x0038             MOVS     R0,R7
   \       0x2E   0xB2C0             UXTB     R0,R0
   \       0x30   0xBDF2             POP      {R1,R4-R7,PC}
    367          }
    368          
    369          /**
    370            * @brief Return tick frequency.
    371            * @retval tick period in Hz
    372            */

   \                                 In section .text, align 2, keep-with-next
    373          HAL_TickFreqTypeDef HAL_GetTickFreq(void)
    374          {
    375            return uwTickFreq;
   \                     HAL_GetTickFreq: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable18_7
   \        0x2   0x7800             LDRB     R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
    376          }
    377          
    378          /**
    379            * @brief This function provides minimum delay (in milliseconds) based 
    380            *        on variable incremented.
    381            * @note In the default implementation , SysTick timer is the source of time base.
    382            *       It is used to generate interrupts at regular time intervals where uwTick
    383            *       is incremented.
    384            * @note This function is declared as __weak to be overwritten in case of other
    385            *       implementations in user file.
    386            * @param Delay specifies the delay time length, in milliseconds.
    387            * @retval None
    388            */

   \                                 In section .text, align 4
    389          __weak void HAL_Delay(uint32_t Delay)
    390          {
   \                     HAL_Delay: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    391            uint32_t tickstart = HAL_GetTick();
   \        0x4   0x.... 0x....      BL       HAL_GetTick
   \        0x8   0x0005             MOVS     R5,R0
    392            uint32_t wait = Delay;
   \        0xA   0x0026             MOVS     R6,R4
    393          
    394            /* Add a freq to guarantee minimum wait */
    395            if (wait < HAL_MAX_DELAY)
   \        0xC   0xF116 0x0F01      CMN      R6,#+1
   \       0x10   0xD002             BEQ.N    ??HAL_Delay_1
    396            {
    397              wait += (uint32_t)(uwTickFreq);
   \       0x12   0x4804             LDR.N    R0,??HAL_Delay_0
   \       0x14   0x7800             LDRB     R0,[R0, #+0]
   \       0x16   0x1836             ADDS     R6,R6,R0
    398            }
    399          
    400            while((HAL_GetTick() - tickstart) < wait)
   \                     ??HAL_Delay_1: (+1)
   \       0x18   0x.... 0x....      BL       HAL_GetTick
   \       0x1C   0x1B40             SUBS     R0,R0,R5
   \       0x1E   0x42B0             CMP      R0,R6
   \       0x20   0xD3FA             BCC.N    ??HAL_Delay_1
    401            {
    402            }
    403          }
   \       0x22   0xBD70             POP      {R4-R6,PC}
   \                     ??HAL_Delay_0:
   \       0x24   0x....'....        DC32     uwTickFreq
    404          
    405          /**
    406            * @brief Suspend Tick increment.
    407            * @note In the default implementation , SysTick timer is the source of time base. It is
    408            *       used to generate interrupts at regular time intervals. Once HAL_SuspendTick()
    409            *       is called, the SysTick interrupt will be disabled and so Tick increment 
    410            *       is suspended.
    411            * @note This function is declared as __weak to be overwritten in case of other
    412            *       implementations in user file.
    413            * @retval None
    414            */

   \                                 In section .text, align 4
    415          __weak void HAL_SuspendTick(void)
    416          {
    417            /* Disable SysTick Interrupt */
    418            SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
   \                     HAL_SuspendTick: (+1)
   \        0x0   0x4802             LDR.N    R0,??HAL_SuspendTick_0
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF031 0x0102      BICS     R1,R1,#0x2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    419          }
   \        0xA   0x4770             BX       LR
   \                     ??HAL_SuspendTick_0:
   \        0xC   0xE000'E010        DC32     0xe000e010
    420          
    421          /**
    422            * @brief Resume Tick increment.
    423            * @note In the default implementation , SysTick timer is the source of time base. It is
    424            *       used to generate interrupts at regular time intervals. Once HAL_ResumeTick()
    425            *       is called, the SysTick interrupt will be enabled and so Tick increment 
    426            *       is resumed.
    427            * @note This function is declared as __weak to be overwritten in case of other
    428            *       implementations in user file.
    429            * @retval None
    430            */

   \                                 In section .text, align 4
    431          __weak void HAL_ResumeTick(void)
    432          {
    433            /* Enable SysTick Interrupt */
    434            SysTick->CTRL  |= SysTick_CTRL_TICKINT_Msk;
   \                     HAL_ResumeTick: (+1)
   \        0x0   0x4802             LDR.N    R0,??HAL_ResumeTick_0
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF051 0x0102      ORRS     R1,R1,#0x2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    435          }
   \        0xA   0x4770             BX       LR
   \                     ??HAL_ResumeTick_0:
   \        0xC   0xE000'E010        DC32     0xe000e010
    436          
    437          /**
    438            * @brief  Returns the HAL revision
    439            * @retval version : 0xXYZR (8bits for each decimal, R for RC)
    440            */

   \                                 In section .text, align 2, keep-with-next
    441          uint32_t HAL_GetHalVersion(void)
    442          {
    443            return __STM32F4xx_HAL_VERSION;
   \                     HAL_GetHalVersion: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable18_8
   \        0x2   0x4770             BX       LR
    444          }
    445          
    446          /**
    447            * @brief  Returns the device revision identifier.
    448            * @retval Device revision identifier
    449            */

   \                                 In section .text, align 2, keep-with-next
    450          uint32_t HAL_GetREVID(void)
    451          {
    452            return((DBGMCU->IDCODE) >> 16U);
   \                     HAL_GetREVID: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable18_9
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0C00             LSRS     R0,R0,#+16
   \        0x6   0x4770             BX       LR
    453          }
    454          
    455          /**
    456            * @brief  Returns the device identifier.
    457            * @retval Device identifier
    458            */

   \                                 In section .text, align 2, keep-with-next
    459          uint32_t HAL_GetDEVID(void)
    460          {
    461            return((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
   \                     HAL_GetDEVID: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable18_9
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0500             LSLS     R0,R0,#+20
   \        0x6   0x0D00             LSRS     R0,R0,#+20
   \        0x8   0x4770             BX       LR
    462          }
    463          
    464          /**
    465            * @brief  Enable the Debug Module during SLEEP mode
    466            * @retval None
    467            */

   \                                 In section .text, align 2, keep-with-next
    468          void HAL_DBGMCU_EnableDBGSleepMode(void)
    469          {
    470            SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
   \                     HAL_DBGMCU_EnableDBGSleepMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable18_10
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF051 0x0101      ORRS     R1,R1,#0x1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    471          }
   \        0xA   0x4770             BX       LR
    472          
    473          /**
    474            * @brief  Disable the Debug Module during SLEEP mode
    475            * @retval None
    476            */

   \                                 In section .text, align 2, keep-with-next
    477          void HAL_DBGMCU_DisableDBGSleepMode(void)
    478          {
    479            CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
   \                     HAL_DBGMCU_DisableDBGSleepMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable18_10
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x0849             LSRS     R1,R1,#+1
   \        0x6   0x0049             LSLS     R1,R1,#+1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    480          }
   \        0xA   0x4770             BX       LR
    481          
    482          /**
    483            * @brief  Enable the Debug Module during STOP mode
    484            * @retval None
    485            */

   \                                 In section .text, align 2, keep-with-next
    486          void HAL_DBGMCU_EnableDBGStopMode(void)
    487          {
    488            SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
   \                     HAL_DBGMCU_EnableDBGStopMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable18_10
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF051 0x0102      ORRS     R1,R1,#0x2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    489          }
   \        0xA   0x4770             BX       LR
    490          
    491          /**
    492            * @brief  Disable the Debug Module during STOP mode
    493            * @retval None
    494            */

   \                                 In section .text, align 2, keep-with-next
    495          void HAL_DBGMCU_DisableDBGStopMode(void)
    496          {
    497            CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
   \                     HAL_DBGMCU_DisableDBGStopMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable18_10
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF031 0x0102      BICS     R1,R1,#0x2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    498          }
   \        0xA   0x4770             BX       LR
    499          
    500          /**
    501            * @brief  Enable the Debug Module during STANDBY mode
    502            * @retval None
    503            */

   \                                 In section .text, align 2, keep-with-next
    504          void HAL_DBGMCU_EnableDBGStandbyMode(void)
    505          {
    506            SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
   \                     HAL_DBGMCU_EnableDBGStandbyMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable18_10
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF051 0x0104      ORRS     R1,R1,#0x4
   \        0x8   0x6001             STR      R1,[R0, #+0]
    507          }
   \        0xA   0x4770             BX       LR
    508          
    509          /**
    510            * @brief  Disable the Debug Module during STANDBY mode
    511            * @retval None
    512            */

   \                                 In section .text, align 2, keep-with-next
    513          void HAL_DBGMCU_DisableDBGStandbyMode(void)
    514          {
    515            CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
   \                     HAL_DBGMCU_DisableDBGStandbyMode: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable18_10
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF031 0x0104      BICS     R1,R1,#0x4
   \        0x8   0x6001             STR      R1,[R0, #+0]
    516          }
   \        0xA   0x4770             BX       LR
    517          
    518          /**
    519            * @brief  Enables the I/O Compensation Cell.
    520            * @note   The I/O compensation cell can be used only when the device supply
    521            *         voltage ranges from 2.4 to 3.6 V.  
    522            * @retval None
    523            */

   \                                 In section .text, align 2, keep-with-next
    524          void HAL_EnableCompensationCell(void)
    525          {
    526            *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)ENABLE;
   \                     HAL_EnableCompensationCell: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x....             LDR.N    R1,??DataTable18_11
   \        0x4   0x6008             STR      R0,[R1, #+0]
    527          }
   \        0x6   0x4770             BX       LR
    528          
    529          /**
    530            * @brief  Power-down the I/O Compensation Cell.
    531            * @note   The I/O compensation cell can be used only when the device supply
    532            *         voltage ranges from 2.4 to 3.6 V.  
    533            * @retval None
    534            */

   \                                 In section .text, align 2, keep-with-next
    535          void HAL_DisableCompensationCell(void)
    536          {
    537            *(__IO uint32_t *)CMPCR_CMP_PD_BB = (uint32_t)DISABLE;
   \                     HAL_DisableCompensationCell: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x....             LDR.N    R1,??DataTable18_11
   \        0x4   0x6008             STR      R0,[R1, #+0]
    538          }
   \        0x6   0x4770             BX       LR
    539          
    540          /**
    541            * @brief  Returns first word of the unique device identifier (UID based on 96 bits)
    542            * @retval Device identifier
    543            */

   \                                 In section .text, align 2, keep-with-next
    544          uint32_t HAL_GetUIDw0(void)
    545          {
    546            return (READ_REG(*((uint32_t *)UID_BASE)));
   \                     HAL_GetUIDw0: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable18_12
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
    547          }
    548          
    549          /**
    550            * @brief  Returns second word of the unique device identifier (UID based on 96 bits)
    551            * @retval Device identifier
    552            */

   \                                 In section .text, align 2, keep-with-next
    553          uint32_t HAL_GetUIDw1(void)
    554          {
    555            return (READ_REG(*((uint32_t *)(UID_BASE + 4U))));
   \                     HAL_GetUIDw1: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable18_13
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
    556          }
    557          
    558          /**
    559            * @brief  Returns third word of the unique device identifier (UID based on 96 bits)
    560            * @retval Device identifier
    561            */

   \                                 In section .text, align 2, keep-with-next
    562          uint32_t HAL_GetUIDw2(void)
    563          {
    564            return (READ_REG(*((uint32_t *)(UID_BASE + 8U))));
   \                     HAL_GetUIDw2: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable18_14
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR
    565          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x4002'3C00        DC32     0x40023c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \        0x0   0x4002'3820        DC32     0x40023820

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \        0x0   0x4002'3824        DC32     0x40023824

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \        0x0   0x4002'3810        DC32     0x40023810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \        0x0   0x4002'3814        DC32     0x40023814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \        0x0   0x4002'3818        DC32     0x40023818

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \        0x0   0x....'....        DC32     uwTickPrio

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_7:
   \        0x0   0x....'....        DC32     uwTickFreq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_8:
   \        0x0   0x0107'0A00        DC32     0x1070a00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_9:
   \        0x0   0xE004'2000        DC32     0xe0042000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_10:
   \        0x0   0xE004'2004        DC32     0xe0042004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_11:
   \        0x0   0x4227'0400        DC32     0x42270400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_12:
   \        0x0   0x1FFF'7A10        DC32     0x1fff7a10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_13:
   \        0x0   0x1FFF'7A14        DC32     0x1fff7a14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_14:
   \        0x0   0x1FFF'7A18        DC32     0x1fff7a18
    566          
    567          #if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) ||\
    568              defined(STM32F469xx) || defined(STM32F479xx)
    569          /**
    570            * @brief  Enables the Internal FLASH Bank Swapping.
    571            *   
    572            * @note   This function can be used only for STM32F42xxx/43xxx/469xx/479xx devices. 
    573            *
    574            * @note   Flash Bank2 mapped at 0x08000000 (and aliased @0x00000000) 
    575            *         and Flash Bank1 mapped at 0x08100000 (and aliased at 0x00100000)   
    576            *
    577            * @retval None
    578            */
    579          void HAL_EnableMemorySwappingBank(void)
    580          {
    581            *(__IO uint32_t *)UFB_MODE_BB = (uint32_t)ENABLE;
    582          }
    583          
    584          /**
    585            * @brief  Disables the Internal FLASH Bank Swapping.
    586            *   
    587            * @note   This function can be used only for STM32F42xxx/43xxx/469xx/479xx devices. 
    588            *
    589            * @note   The default state : Flash Bank1 mapped at 0x08000000 (and aliased @0x00000000) 
    590            *         and Flash Bank2 mapped at 0x08100000 (and aliased at 0x00100000) 
    591            *           
    592            * @retval None
    593            */
    594          void HAL_DisableMemorySwappingBank(void)
    595          {
    596            *(__IO uint32_t *)UFB_MODE_BB = (uint32_t)DISABLE;
    597          }
    598          #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx || STM32F469xx || STM32F479xx */
    599          /**
    600            * @}
    601            */
    602          
    603          /**
    604            * @}
    605            */
    606          
    607          /**
    608            * @}
    609            */
    610          
    611          /**
    612            * @}
    613            */
    614          
    615          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_DBGMCU_DisableDBGSleepMode
       0   HAL_DBGMCU_DisableDBGStandbyMode
       0   HAL_DBGMCU_DisableDBGStopMode
       0   HAL_DBGMCU_EnableDBGSleepMode
       0   HAL_DBGMCU_EnableDBGStandbyMode
       0   HAL_DBGMCU_EnableDBGStopMode
       8   HAL_DeInit
         8   -> HAL_MspDeInit
      16   HAL_Delay
        16   -> HAL_GetTick
       0   HAL_DisableCompensationCell
       0   HAL_EnableCompensationCell
       0   HAL_GetDEVID
       0   HAL_GetHalVersion
       0   HAL_GetREVID
       0   HAL_GetTick
       0   HAL_GetTickFreq
       0   HAL_GetTickPrio
       0   HAL_GetUIDw0
       0   HAL_GetUIDw1
       0   HAL_GetUIDw2
       0   HAL_IncTick
       8   HAL_Init
         8   -> HAL_InitTick
         8   -> HAL_MspInit
         8   -> HAL_NVIC_SetPriorityGrouping
       8   HAL_InitTick
         8   -> HAL_NVIC_SetPriority
         8   -> HAL_SYSTICK_Config
       0   HAL_MspDeInit
       0   HAL_MspInit
       0   HAL_ResumeTick
      24   HAL_SetTickFreq
        24   -> HAL_InitTick
       0   HAL_SuspendTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_10
       4  ??DataTable18_11
       4  ??DataTable18_12
       4  ??DataTable18_13
       4  ??DataTable18_14
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable18_9
      12  HAL_DBGMCU_DisableDBGSleepMode
      12  HAL_DBGMCU_DisableDBGStandbyMode
      12  HAL_DBGMCU_DisableDBGStopMode
      12  HAL_DBGMCU_EnableDBGSleepMode
      12  HAL_DBGMCU_EnableDBGStandbyMode
      12  HAL_DBGMCU_EnableDBGStopMode
      54  HAL_DeInit
      40  HAL_Delay
       8  HAL_DisableCompensationCell
       8  HAL_EnableCompensationCell
      10  HAL_GetDEVID
       4  HAL_GetHalVersion
       8  HAL_GetREVID
      12  HAL_GetTick
       6  HAL_GetTickFreq
       6  HAL_GetTickPrio
       6  HAL_GetUIDw0
       6  HAL_GetUIDw1
       6  HAL_GetUIDw2
      24  HAL_IncTick
      40  HAL_Init
      76  HAL_InitTick
       2  HAL_MspDeInit
       2  HAL_MspInit
      16  HAL_ResumeTick
      50  HAL_SetTickFreq
      16  HAL_SuspendTick
       4  uwTick
       1  uwTickFreq
       4  uwTickPrio

 
   4 bytes in section .bss
   5 bytes in section .data
 532 bytes in section .text
 
 344 bytes of CODE memory (+ 188 bytes shared)
   9 bytes of DATA memory

Errors: none
Warnings: none
