###############################################################################
#
#                                                         30/Sep/2022  17:12:34
# IAR ANSI C/C++ Compiler V9.20.3.326/W64 for ARM Functional Safety
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_i2c.c
#    Command line      =
#        -f
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_i2c.o.rsp
#        (C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_i2c.c
#        -D USE_HAL_DRIVER -D STM32F407xx -lC
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver
#        -o
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0 EWARM FS
#        9.20.3\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/App\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Core/Inc\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Include\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/display\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Library\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.0 EWARM FS 9.20.3\arm\CMSIS\Core\Include\\")
#        --dependencies=n
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_i2c.o.d
#    Locale            =  C
#    List file         =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_i2c.lst
#    Object file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_i2c.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_i2c.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_i2c.c
      4            * @author  MCD Application Team
      5            * @brief   I2C HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Inter Integrated Circuit (I2C) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *           + Peripheral State, Mode and Error functions
     11            *
     12            @verbatim
     13            ==============================================================================
     14                                  ##### How to use this driver #####
     15            ==============================================================================
     16            [..]
     17              The I2C HAL driver can be used as follows:
     18          
     19              (#) Declare a I2C_HandleTypeDef handle structure, for example:
     20                  I2C_HandleTypeDef  hi2c;
     21          
     22              (#)Initialize the I2C low level resources by implementing the @ref HAL_I2C_MspInit() API:
     23                  (##) Enable the I2Cx interface clock
     24                  (##) I2C pins configuration
     25                      (+++) Enable the clock for the I2C GPIOs
     26                      (+++) Configure I2C pins as alternate function open-drain
     27                  (##) NVIC configuration if you need to use interrupt process
     28                      (+++) Configure the I2Cx interrupt priority
     29                      (+++) Enable the NVIC I2C IRQ Channel
     30                  (##) DMA Configuration if you need to use DMA process
     31                      (+++) Declare a DMA_HandleTypeDef handle structure for the transmit or receive stream
     32                      (+++) Enable the DMAx interface clock using
     33                      (+++) Configure the DMA handle parameters
     34                      (+++) Configure the DMA Tx or Rx stream
     35                      (+++) Associate the initialized DMA handle to the hi2c DMA Tx or Rx handle
     36                      (+++) Configure the priority and enable the NVIC for the transfer complete interrupt on
     37                            the DMA Tx or Rx stream
     38          
     39              (#) Configure the Communication Speed, Duty cycle, Addressing mode, Own Address1,
     40                  Dual Addressing mode, Own Address2, General call and Nostretch mode in the hi2c Init structure.
     41          
     42              (#) Initialize the I2C registers by calling the @ref HAL_I2C_Init(), configures also the low level Hardware
     43                  (GPIO, CLOCK, NVIC...etc) by calling the customized @ref HAL_I2C_MspInit() API.
     44          
     45              (#) To check if target device is ready for communication, use the function @ref HAL_I2C_IsDeviceReady()
     46          
     47              (#) For I2C IO and IO MEM operations, three operation modes are available within this driver :
     48          
     49              *** Polling mode IO operation ***
     50              =================================
     51              [..]
     52                (+) Transmit in master mode an amount of data in blocking mode using @ref HAL_I2C_Master_Transmit()
     53                (+) Receive in master mode an amount of data in blocking mode using @ref HAL_I2C_Master_Receive()
     54                (+) Transmit in slave mode an amount of data in blocking mode using @ref HAL_I2C_Slave_Transmit()
     55                (+) Receive in slave mode an amount of data in blocking mode using @ref HAL_I2C_Slave_Receive()
     56          
     57              *** Polling mode IO MEM operation ***
     58              =====================================
     59              [..]
     60                (+) Write an amount of data in blocking mode to a specific memory address using @ref HAL_I2C_Mem_Write()
     61                (+) Read an amount of data in blocking mode from a specific memory address using @ref HAL_I2C_Mem_Read()
     62          
     63          
     64              *** Interrupt mode IO operation ***
     65              ===================================
     66              [..]
     67                (+) Transmit in master mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Transmit_IT()
     68                (+) At transmission end of transfer, @ref HAL_I2C_MasterTxCpltCallback() is executed and user can
     69                     add his own code by customization of function pointer @ref HAL_I2C_MasterTxCpltCallback()
     70                (+) Receive in master mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Receive_IT()
     71                (+) At reception end of transfer, @ref HAL_I2C_MasterRxCpltCallback() is executed and user can
     72                     add his own code by customization of function pointer @ref HAL_I2C_MasterRxCpltCallback()
     73                (+) Transmit in slave mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Transmit_IT()
     74                (+) At transmission end of transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executed and user can
     75                     add his own code by customization of function pointer @ref HAL_I2C_SlaveTxCpltCallback()
     76                (+) Receive in slave mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Receive_IT()
     77                (+) At reception end of transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed and user can
     78                     add his own code by customization of function pointer @ref HAL_I2C_SlaveRxCpltCallback()
     79                (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
     80                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
     81                (+) Abort a master I2C process communication with Interrupt using @ref HAL_I2C_Master_Abort_IT()
     82                (+) End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can
     83                     add his own code by customization of function pointer @ref HAL_I2C_AbortCpltCallback()
     84          
     85              *** Interrupt mode or DMA mode IO sequential operation ***
     86              ==========================================================
     87              [..]
     88                (@) These interfaces allow to manage a sequential transfer with a repeated start condition
     89                    when a direction change during transfer
     90              [..]
     91                (+) A specific option field manage the different steps of a sequential transfer
     92                (+) Option field values are defined through @ref I2C_XferOptions_definition and are listed below:
     93                (++) I2C_FIRST_AND_LAST_FRAME: No sequential usage, functionnal is same as associated interfaces in no sequential mode
     94                (++) I2C_FIRST_FRAME: Sequential usage, this option allow to manage a sequence with start condition, address
     95                                      and data to transfer without a final stop condition
     96                (++) I2C_FIRST_AND_NEXT_FRAME: Sequential usage (Master only), this option allow to manage a sequence with start condition, address
     97                                      and data to transfer without a final stop condition, an then permit a call the same master sequential interface
     98                                      several times (like @ref HAL_I2C_Master_Seq_Transmit_IT() then @ref HAL_I2C_Master_Seq_Transmit_IT()
     99                                      or @ref HAL_I2C_Master_Seq_Transmit_DMA() then @ref HAL_I2C_Master_Seq_Transmit_DMA())
    100                (++) I2C_NEXT_FRAME: Sequential usage, this option allow to manage a sequence with a restart condition, address
    101                                      and with new data to transfer if the direction change or manage only the new data to transfer
    102                                      if no direction change and without a final stop condition in both cases
    103                (++) I2C_LAST_FRAME: Sequential usage, this option allow to manage a sequance with a restart condition, address
    104                                      and with new data to transfer if the direction change or manage only the new data to transfer
    105                                      if no direction change and with a final stop condition in both cases
    106                (++) I2C_LAST_FRAME_NO_STOP: Sequential usage (Master only), this option allow to manage a restart condition after several call of the same master sequential
    107                                      interface several times (link with option I2C_FIRST_AND_NEXT_FRAME).
    108                                      Usage can, transfer several bytes one by one using HAL_I2C_Master_Seq_Transmit_IT(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME)
    109                                        or HAL_I2C_Master_Seq_Receive_IT(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME)
    110                                        or HAL_I2C_Master_Seq_Transmit_DMA(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME)
    111                                        or HAL_I2C_Master_Seq_Receive_DMA(option I2C_FIRST_AND_NEXT_FRAME then I2C_NEXT_FRAME).
    112                                      Then usage of this option I2C_LAST_FRAME_NO_STOP at the last Transmit or Receive sequence permit to call the oposite interface Receive or Transmit
    113                                        without stopping the communication and so generate a restart condition.
    114                (++) I2C_OTHER_FRAME: Sequential usage (Master only), this option allow to manage a restart condition after each call of the same master sequential
    115                                      interface.
    116                                      Usage can, transfer several bytes one by one with a restart with slave address between each bytes using HAL_I2C_Master_Seq_Transmit_IT(option I2C_FIRST_FRAME then I2C_OTHER_FRAME)
    117                                        or HAL_I2C_Master_Seq_Receive_IT(option I2C_FIRST_FRAME then I2C_OTHER_FRAME)
    118                                        or HAL_I2C_Master_Seq_Transmit_DMA(option I2C_FIRST_FRAME then I2C_OTHER_FRAME)
    119                                        or HAL_I2C_Master_Seq_Receive_DMA(option I2C_FIRST_FRAME then I2C_OTHER_FRAME).
    120                                      Then usage of this option I2C_OTHER_AND_LAST_FRAME at the last frame to help automatic generation of STOP condition.
    121          
    122                (+) Differents sequential I2C interfaces are listed below:
    123                (++) Sequential transmit in master I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Seq_Transmit_IT()
    124                      or using @ref HAL_I2C_Master_Seq_Transmit_DMA()
    125                (+++) At transmission end of current frame transfer, @ref HAL_I2C_MasterTxCpltCallback() is executed and user can
    126                     add his own code by customization of function pointer @ref HAL_I2C_MasterTxCpltCallback()
    127                (++) Sequential receive in master I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Master_Seq_Receive_IT()
    128                      or using @ref HAL_I2C_Master_Seq_Receive_DMA()
    129                (+++) At reception end of current frame transfer, @ref HAL_I2C_MasterRxCpltCallback() is executed and user can
    130                     add his own code by customization of function pointer @ref HAL_I2C_MasterRxCpltCallback()
    131                (++) Abort a master IT or DMA I2C process communication with Interrupt using @ref HAL_I2C_Master_Abort_IT()
    132                (+++) End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can
    133                     add his own code by customization of function pointer @ref HAL_I2C_AbortCpltCallback()
    134                (++) Enable/disable the Address listen mode in slave I2C mode using @ref HAL_I2C_EnableListen_IT() @ref HAL_I2C_DisableListen_IT()
    135                (+++) When address slave I2C match, @ref HAL_I2C_AddrCallback() is executed and user can
    136                     add his own code to check the Address Match Code and the transmission direction request by master (Write/Read).
    137                (+++) At Listen mode end @ref HAL_I2C_ListenCpltCallback() is executed and user can
    138                     add his own code by customization of function pointer @ref HAL_I2C_ListenCpltCallback()
    139                (++) Sequential transmit in slave I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Seq_Transmit_IT()
    140                      or using @ref HAL_I2C_Slave_Seq_Transmit_DMA()
    141                (+++) At transmission end of current frame transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executed and user can
    142                     add his own code by customization of function pointer @ref HAL_I2C_SlaveTxCpltCallback()
    143                (++) Sequential receive in slave I2C mode an amount of data in non-blocking mode using @ref HAL_I2C_Slave_Seq_Receive_IT()
    144                      or using @ref HAL_I2C_Slave_Seq_Receive_DMA()
    145                (+++) At reception end of current frame transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed and user can
    146                     add his own code by customization of function pointer @ref HAL_I2C_SlaveRxCpltCallback()
    147                (++) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
    148                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
    149          
    150              *** Interrupt mode IO MEM operation ***
    151              =======================================
    152              [..]
    153                (+) Write an amount of data in non-blocking mode with Interrupt to a specific memory address using
    154                    @ref HAL_I2C_Mem_Write_IT()
    155                (+) At Memory end of write transfer, @ref HAL_I2C_MemTxCpltCallback() is executed and user can
    156                     add his own code by customization of function pointer @ref HAL_I2C_MemTxCpltCallback()
    157                (+) Read an amount of data in non-blocking mode with Interrupt from a specific memory address using
    158                    @ref HAL_I2C_Mem_Read_IT()
    159                (+) At Memory end of read transfer, @ref HAL_I2C_MemRxCpltCallback() is executed and user can
    160                     add his own code by customization of function pointer @ref HAL_I2C_MemRxCpltCallback()
    161                (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
    162                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
    163          
    164              *** DMA mode IO operation ***
    165              ==============================
    166              [..]
    167                (+) Transmit in master mode an amount of data in non-blocking mode (DMA) using
    168                    @ref HAL_I2C_Master_Transmit_DMA()
    169                (+) At transmission end of transfer, @ref HAL_I2C_MasterTxCpltCallback() is executed and user can
    170                     add his own code by customization of function pointer @ref HAL_I2C_MasterTxCpltCallback()
    171                (+) Receive in master mode an amount of data in non-blocking mode (DMA) using
    172                    @ref HAL_I2C_Master_Receive_DMA()
    173                (+) At reception end of transfer, @ref HAL_I2C_MasterRxCpltCallback() is executed and user can
    174                     add his own code by customization of function pointer @ref HAL_I2C_MasterRxCpltCallback()
    175                (+) Transmit in slave mode an amount of data in non-blocking mode (DMA) using
    176                    @ref HAL_I2C_Slave_Transmit_DMA()
    177                (+) At transmission end of transfer, @ref HAL_I2C_SlaveTxCpltCallback() is executed and user can
    178                     add his own code by customization of function pointer @ref HAL_I2C_SlaveTxCpltCallback()
    179                (+) Receive in slave mode an amount of data in non-blocking mode (DMA) using
    180                    @ref HAL_I2C_Slave_Receive_DMA()
    181                (+) At reception end of transfer, @ref HAL_I2C_SlaveRxCpltCallback() is executed and user can
    182                     add his own code by customization of function pointer @ref HAL_I2C_SlaveRxCpltCallback()
    183                (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
    184                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
    185                (+) Abort a master I2C process communication with Interrupt using @ref HAL_I2C_Master_Abort_IT()
    186                (+) End of abort process, @ref HAL_I2C_AbortCpltCallback() is executed and user can
    187                     add his own code by customization of function pointer @ref HAL_I2C_AbortCpltCallback()
    188          
    189              *** DMA mode IO MEM operation ***
    190              =================================
    191              [..]
    192                (+) Write an amount of data in non-blocking mode with DMA to a specific memory address using
    193                    @ref HAL_I2C_Mem_Write_DMA()
    194                (+) At Memory end of write transfer, @ref HAL_I2C_MemTxCpltCallback() is executed and user can
    195                     add his own code by customization of function pointer @ref HAL_I2C_MemTxCpltCallback()
    196                (+) Read an amount of data in non-blocking mode with DMA from a specific memory address using
    197                    @ref HAL_I2C_Mem_Read_DMA()
    198                (+) At Memory end of read transfer, @ref HAL_I2C_MemRxCpltCallback() is executed and user can
    199                     add his own code by customization of function pointer @ref HAL_I2C_MemRxCpltCallback()
    200                (+) In case of transfer Error, @ref HAL_I2C_ErrorCallback() function is executed and user can
    201                     add his own code by customization of function pointer @ref HAL_I2C_ErrorCallback()
    202          
    203          
    204               *** I2C HAL driver macros list ***
    205               ==================================
    206               [..]
    207                 Below the list of most used macros in I2C HAL driver.
    208          
    209                (+) @ref __HAL_I2C_ENABLE:     Enable the I2C peripheral
    210                (+) @ref __HAL_I2C_DISABLE:    Disable the I2C peripheral
    211                (+) @ref __HAL_I2C_GET_FLAG:   Checks whether the specified I2C flag is set or not
    212                (+) @ref __HAL_I2C_CLEAR_FLAG: Clear the specified I2C pending flag
    213                (+) @ref __HAL_I2C_ENABLE_IT:  Enable the specified I2C interrupt
    214                (+) @ref __HAL_I2C_DISABLE_IT: Disable the specified I2C interrupt
    215          
    216               *** Callback registration ***
    217               =============================================
    218              [..]
    219               The compilation flag USE_HAL_I2C_REGISTER_CALLBACKS when set to 1
    220               allows the user to configure dynamically the driver callbacks.
    221               Use Functions @ref HAL_I2C_RegisterCallback() or @ref HAL_I2C_RegisterAddrCallback()
    222               to register an interrupt callback.
    223              [..]
    224               Function @ref HAL_I2C_RegisterCallback() allows to register following callbacks:
    225                 (+) MasterTxCpltCallback : callback for Master transmission end of transfer.
    226                 (+) MasterRxCpltCallback : callback for Master reception end of transfer.
    227                 (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.
    228                 (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.
    229                 (+) ListenCpltCallback   : callback for end of listen mode.
    230                 (+) MemTxCpltCallback    : callback for Memory transmission end of transfer.
    231                 (+) MemRxCpltCallback    : callback for Memory reception end of transfer.
    232                 (+) ErrorCallback        : callback for error detection.
    233                 (+) AbortCpltCallback    : callback for abort completion process.
    234                 (+) MspInitCallback      : callback for Msp Init.
    235                 (+) MspDeInitCallback    : callback for Msp DeInit.
    236               This function takes as parameters the HAL peripheral handle, the Callback ID
    237               and a pointer to the user callback function.
    238              [..]
    239               For specific callback AddrCallback use dedicated register callbacks : @ref HAL_I2C_RegisterAddrCallback().
    240              [..]
    241               Use function @ref HAL_I2C_UnRegisterCallback to reset a callback to the default
    242               weak function.
    243               @ref HAL_I2C_UnRegisterCallback takes as parameters the HAL peripheral handle,
    244               and the Callback ID.
    245               This function allows to reset following callbacks:
    246                 (+) MasterTxCpltCallback : callback for Master transmission end of transfer.
    247                 (+) MasterRxCpltCallback : callback for Master reception end of transfer.
    248                 (+) SlaveTxCpltCallback  : callback for Slave transmission end of transfer.
    249                 (+) SlaveRxCpltCallback  : callback for Slave reception end of transfer.
    250                 (+) ListenCpltCallback   : callback for end of listen mode.
    251                 (+) MemTxCpltCallback    : callback for Memory transmission end of transfer.
    252                 (+) MemRxCpltCallback    : callback for Memory reception end of transfer.
    253                 (+) ErrorCallback        : callback for error detection.
    254                 (+) AbortCpltCallback    : callback for abort completion process.
    255                 (+) MspInitCallback      : callback for Msp Init.
    256                 (+) MspDeInitCallback    : callback for Msp DeInit.
    257              [..]
    258               For callback AddrCallback use dedicated register callbacks : @ref HAL_I2C_UnRegisterAddrCallback().
    259              [..]
    260               By default, after the @ref HAL_I2C_Init() and when the state is @ref HAL_I2C_STATE_RESET
    261               all callbacks are set to the corresponding weak functions:
    262               examples @ref HAL_I2C_MasterTxCpltCallback(), @ref HAL_I2C_MasterRxCpltCallback().
    263               Exception done for MspInit and MspDeInit functions that are
    264               reset to the legacy weak functions in the @ref HAL_I2C_Init()/ @ref HAL_I2C_DeInit() only when
    265               these callbacks are null (not registered beforehand).
    266               If MspInit or MspDeInit are not null, the @ref HAL_I2C_Init()/ @ref HAL_I2C_DeInit()
    267               keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
    268              [..]
    269               Callbacks can be registered/unregistered in @ref HAL_I2C_STATE_READY state only.
    270               Exception done MspInit/MspDeInit functions that can be registered/unregistered
    271               in @ref HAL_I2C_STATE_READY or @ref HAL_I2C_STATE_RESET state,
    272               thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    273               Then, the user first registers the MspInit/MspDeInit user callbacks
    274               using @ref HAL_I2C_RegisterCallback() before calling @ref HAL_I2C_DeInit()
    275               or @ref HAL_I2C_Init() function.
    276              [..]
    277               When the compilation flag USE_HAL_I2C_REGISTER_CALLBACKS is set to 0 or
    278               not defined, the callback registration feature is not available and all callbacks
    279               are set to the corresponding weak functions.
    280          
    281          
    282          
    283               [..]
    284                 (@) You can refer to the I2C HAL driver header file for more useful macros
    285          
    286            @endverbatim
    287            ******************************************************************************
    288            * @attention
    289            *
    290            * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
    291            * All rights reserved.</center></h2>
    292            *
    293            * This software component is licensed by ST under BSD 3-Clause license,
    294            * the "License"; You may not use this file except in compliance with the
    295            * License. You may obtain a copy of the License at:
    296            *                        opensource.org/licenses/BSD-3-Clause
    297            *
    298            ******************************************************************************
    299            */
    300          
    301          /* Includes ------------------------------------------------------------------*/
    302          #include "stm32f4xx_hal.h"
    303          
    304          /** @addtogroup STM32F4xx_HAL_Driver
    305            * @{
    306            */
    307          
    308          /** @defgroup I2C I2C
    309            * @brief I2C HAL module driver
    310            * @{
    311            */
    312          
    313          #ifdef HAL_I2C_MODULE_ENABLED
    314          
    315          /* Private typedef -----------------------------------------------------------*/
    316          /* Private define ------------------------------------------------------------*/
    317          /** @addtogroup I2C_Private_Define
    318            * @{
    319            */
    320          #define I2C_TIMEOUT_FLAG          15U         /*!< Timeout 35 ms             */
    321          #define I2C_TIMEOUT_BUSY_FLAG     10U         /*!< Timeout 25 ms             */
    322          #define I2C_TIMEOUT_STOP_FLAG     5U          /*!< Timeout 5 ms              */
    323          #define I2C_NO_OPTION_FRAME       0xFFFF0000U /*!< XferOptions default value */
    324          
    325          /* Private define for @ref PreviousState usage */
    326          #define I2C_STATE_MSK             ((uint32_t)((uint32_t)((uint32_t)HAL_I2C_STATE_BUSY_TX | (uint32_t)HAL_I2C_STATE_BUSY_RX) & (uint32_t)(~((uint32_t)HAL_I2C_STATE_READY)))) /*!< Mask State define, keep only RX and TX bits            */
    327          #define I2C_STATE_NONE            ((uint32_t)(HAL_I2C_MODE_NONE))                                                        /*!< Default Value                                          */
    328          #define I2C_STATE_MASTER_BUSY_TX  ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MASTER))            /*!< Master Busy TX, combinaison of State LSB and Mode enum */
    329          #define I2C_STATE_MASTER_BUSY_RX  ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_MASTER))            /*!< Master Busy RX, combinaison of State LSB and Mode enum */
    330          #define I2C_STATE_SLAVE_BUSY_TX   ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_TX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_SLAVE))             /*!< Slave Busy TX, combinaison of State LSB and Mode enum  */
    331          #define I2C_STATE_SLAVE_BUSY_RX   ((uint32_t)(((uint32_t)HAL_I2C_STATE_BUSY_RX & I2C_STATE_MSK) | (uint32_t)HAL_I2C_MODE_SLAVE))             /*!< Slave Busy RX, combinaison of State LSB and Mode enum  */
    332          
    333          /**
    334            * @}
    335            */
    336          
    337          /* Private macro -------------------------------------------------------------*/
    338          /* Private variables ---------------------------------------------------------*/
    339          /* Private function prototypes -----------------------------------------------*/
    340          
    341          /** @defgroup I2C_Private_Functions I2C Private Functions
    342            * @{
    343            */
    344          /* Private functions to handle DMA transfer */
    345          static void I2C_DMAXferCplt(DMA_HandleTypeDef *hdma);
    346          static void I2C_DMAError(DMA_HandleTypeDef *hdma);
    347          static void I2C_DMAAbort(DMA_HandleTypeDef *hdma);
    348          
    349          static void I2C_ITError(I2C_HandleTypeDef *hi2c);
    350          
    351          static HAL_StatusTypeDef I2C_MasterRequestWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart);
    352          static HAL_StatusTypeDef I2C_MasterRequestRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart);
    353          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart);
    354          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart);
    355          
    356          /* Private functions to handle flags during polling transfer */
    357          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart);
    358          static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout, uint32_t Tickstart);
    359          static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    360          static HAL_StatusTypeDef I2C_WaitOnBTFFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    361          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    362          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart);
    363          static HAL_StatusTypeDef I2C_WaitOnSTOPRequestThroughIT(I2C_HandleTypeDef *hi2c);
    364          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c);
    365          
    366          /* Private functions for I2C transfer IRQ handler */
    367          static void I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c);
    368          static void I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c);
    369          static void I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c);
    370          static void I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c);
    371          static void I2C_Master_SB(I2C_HandleTypeDef *hi2c);
    372          static void I2C_Master_ADD10(I2C_HandleTypeDef *hi2c);
    373          static void I2C_Master_ADDR(I2C_HandleTypeDef *hi2c);
    374          
    375          static void I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c);
    376          static void I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c);
    377          static void I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c);
    378          static void I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c);
    379          static void I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c, uint32_t IT2Flags);
    380          static void I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c);
    381          static void I2C_Slave_AF(I2C_HandleTypeDef *hi2c);
    382          
    383          static void I2C_MemoryTransmit_TXE_BTF(I2C_HandleTypeDef *hi2c);
    384          
    385          /* Private function to Convert Specific options */
    386          static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c);
    387          /**
    388            * @}
    389            */
    390          
    391          /* Exported functions --------------------------------------------------------*/
    392          
    393          /** @defgroup I2C_Exported_Functions I2C Exported Functions
    394            * @{
    395            */
    396          
    397          /** @defgroup I2C_Exported_Functions_Group1 Initialization and de-initialization functions
    398           *  @brief    Initialization and Configuration functions
    399           *
    400          @verbatim
    401           ===============================================================================
    402                        ##### Initialization and de-initialization functions #####
    403           ===============================================================================
    404              [..]  This subsection provides a set of functions allowing to initialize and
    405                    deinitialize the I2Cx peripheral:
    406          
    407                (+) User must Implement HAL_I2C_MspInit() function in which he configures
    408                    all related peripherals resources (CLOCK, GPIO, DMA, IT and NVIC).
    409          
    410                (+) Call the function HAL_I2C_Init() to configure the selected device with
    411                    the selected configuration:
    412                  (++) Communication Speed
    413                  (++) Duty cycle
    414                  (++) Addressing mode
    415                  (++) Own Address 1
    416                  (++) Dual Addressing mode
    417                  (++) Own Address 2
    418                  (++) General call mode
    419                  (++) Nostretch mode
    420          
    421                (+) Call the function HAL_I2C_DeInit() to restore the default configuration
    422                    of the selected I2Cx peripheral.
    423          
    424          @endverbatim
    425            * @{
    426            */
    427          
    428          /**
    429            * @brief  Initializes the I2C according to the specified parameters
    430            *         in the I2C_InitTypeDef and initialize the associated handle.
    431            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    432            *                the configuration information for the specified I2C.
    433            * @retval HAL status
    434            */

   \                                 In section .text, align 2, keep-with-next
    435          HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
    436          {
   \                     HAL_I2C_Init: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    437            uint32_t freqrange;
    438            uint32_t pclk1;
    439          
    440            /* Check the I2C handle allocation */
    441            if (hi2c == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_I2C_Init_0
    442            {
    443              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE0E1             B.N      ??HAL_I2C_Init_1
    444            }
    445          
    446            /* Check the parameters */
    447            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    448            assert_param(IS_I2C_CLOCK_SPEED(hi2c->Init.ClockSpeed));
    449            assert_param(IS_I2C_DUTY_CYCLE(hi2c->Init.DutyCycle));
    450            assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
    451            assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
    452            assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
    453            assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
    454            assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
    455            assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
    456          
    457            if (hi2c->State == HAL_I2C_STATE_RESET)
   \                     ??HAL_I2C_Init_0: (+1)
   \        0xC   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD105             BNE.N    ??HAL_I2C_Init_2
    458            {
    459              /* Allocate lock resource and initialize it */
    460              hi2c->Lock = HAL_UNLOCKED;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xF884 0x003C      STRB     R0,[R4, #+60]
    461          
    462          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    463              /* Init the I2C Callback settings */
    464              hi2c->MasterTxCpltCallback = HAL_I2C_MasterTxCpltCallback; /* Legacy weak MasterTxCpltCallback */
    465              hi2c->MasterRxCpltCallback = HAL_I2C_MasterRxCpltCallback; /* Legacy weak MasterRxCpltCallback */
    466              hi2c->SlaveTxCpltCallback  = HAL_I2C_SlaveTxCpltCallback;  /* Legacy weak SlaveTxCpltCallback  */
    467              hi2c->SlaveRxCpltCallback  = HAL_I2C_SlaveRxCpltCallback;  /* Legacy weak SlaveRxCpltCallback  */
    468              hi2c->ListenCpltCallback   = HAL_I2C_ListenCpltCallback;   /* Legacy weak ListenCpltCallback   */
    469              hi2c->MemTxCpltCallback    = HAL_I2C_MemTxCpltCallback;    /* Legacy weak MemTxCpltCallback    */
    470              hi2c->MemRxCpltCallback    = HAL_I2C_MemRxCpltCallback;    /* Legacy weak MemRxCpltCallback    */
    471              hi2c->ErrorCallback        = HAL_I2C_ErrorCallback;        /* Legacy weak ErrorCallback        */
    472              hi2c->AbortCpltCallback    = HAL_I2C_AbortCpltCallback;    /* Legacy weak AbortCpltCallback    */
    473              hi2c->AddrCallback         = HAL_I2C_AddrCallback;         /* Legacy weak AddrCallback         */
    474          
    475              if (hi2c->MspInitCallback == NULL)
    476              {
    477                hi2c->MspInitCallback = HAL_I2C_MspInit; /* Legacy weak MspInit  */
    478              }
    479          
    480              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    481              hi2c->MspInitCallback(hi2c);
    482          #else
    483              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    484              HAL_I2C_MspInit(hi2c);
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       HAL_I2C_MspInit
    485          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    486            }
    487          
    488            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_Init_2: (+1)
   \       0x20   0x2024             MOVS     R0,#+36
   \       0x22   0xF884 0x003D      STRB     R0,[R4, #+61]
    489          
    490            /* Disable the selected I2C peripheral */
    491            __HAL_I2C_DISABLE(hi2c);
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0x0840             LSRS     R0,R0,#+1
   \       0x2C   0x0040             LSLS     R0,R0,#+1
   \       0x2E   0x6821             LDR      R1,[R4, #+0]
   \       0x30   0x6008             STR      R0,[R1, #+0]
    492          
    493            /*Reset I2C*/
    494            hi2c->Instance->CR1 |= I2C_CR1_SWRST;
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x6800             LDR      R0,[R0, #+0]
   \       0x36   0xF450 0x4000      ORRS     R0,R0,#0x8000
   \       0x3A   0x6821             LDR      R1,[R4, #+0]
   \       0x3C   0x6008             STR      R0,[R1, #+0]
    495            hi2c->Instance->CR1 &= ~I2C_CR1_SWRST;
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6800             LDR      R0,[R0, #+0]
   \       0x42   0xF430 0x4000      BICS     R0,R0,#0x8000
   \       0x46   0x6821             LDR      R1,[R4, #+0]
   \       0x48   0x6008             STR      R0,[R1, #+0]
    496          
    497            /* Get PCLK1 frequency */
    498            pclk1 = HAL_RCC_GetPCLK1Freq();
   \       0x4A   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \       0x4E   0x0001             MOVS     R1,R0
    499          
    500            /* Check the minimum allowed PCLK1 frequency */
    501            if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
   \       0x50   0x.... 0x....      LDR.W    R0,??DataTable8
   \       0x54   0x6862             LDR      R2,[R4, #+4]
   \       0x56   0x4282             CMP      R2,R0
   \       0x58   0xD208             BCS.N    ??HAL_I2C_Init_3
   \       0x5A   0x.... 0x....      LDR.W    R2,??DataTable8_1
   \       0x5E   0x4291             CMP      R1,R2
   \       0x60   0xD201             BCS.N    ??HAL_I2C_Init_4
   \       0x62   0x2201             MOVS     R2,#+1
   \       0x64   0xE000             B.N      ??HAL_I2C_Init_5
   \                     ??HAL_I2C_Init_4: (+1)
   \       0x66   0x2200             MOVS     R2,#+0
   \                     ??HAL_I2C_Init_5: (+1)
   \       0x68   0xB2D2             UXTB     R2,R2
   \       0x6A   0xE007             B.N      ??HAL_I2C_Init_6
   \                     ??HAL_I2C_Init_3: (+1)
   \       0x6C   0x.... 0x....      LDR.W    R2,??DataTable8_2
   \       0x70   0x4291             CMP      R1,R2
   \       0x72   0xD201             BCS.N    ??HAL_I2C_Init_7
   \       0x74   0x2201             MOVS     R2,#+1
   \       0x76   0xE000             B.N      ??HAL_I2C_Init_8
   \                     ??HAL_I2C_Init_7: (+1)
   \       0x78   0x2200             MOVS     R2,#+0
   \                     ??HAL_I2C_Init_8: (+1)
   \       0x7A   0xB2D2             UXTB     R2,R2
   \                     ??HAL_I2C_Init_6: (+1)
   \       0x7C   0x2A01             CMP      R2,#+1
   \       0x7E   0xD101             BNE.N    ??HAL_I2C_Init_9
    502            {
    503              return HAL_ERROR;
   \       0x80   0x2001             MOVS     R0,#+1
   \       0x82   0xE0A5             B.N      ??HAL_I2C_Init_1
    504            }
    505          
    506            /* Calculate frequency range */
    507            freqrange = I2C_FREQRANGE(pclk1);
   \                     ??HAL_I2C_Init_9: (+1)
   \       0x84   0x.... 0x....      LDR.W    R2,??DataTable8_3
   \       0x88   0xFBB1 0xF2F2      UDIV     R2,R1,R2
    508          
    509            /*---------------------------- I2Cx CR2 Configuration ----------------------*/
    510            /* Configure I2Cx: Frequency range */
    511            MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
   \       0x8C   0x6823             LDR      R3,[R4, #+0]
   \       0x8E   0x685B             LDR      R3,[R3, #+4]
   \       0x90   0x099B             LSRS     R3,R3,#+6
   \       0x92   0x019B             LSLS     R3,R3,#+6
   \       0x94   0x4313             ORRS     R3,R2,R3
   \       0x96   0x6825             LDR      R5,[R4, #+0]
   \       0x98   0x606B             STR      R3,[R5, #+4]
    512          
    513            /*---------------------------- I2Cx TRISE Configuration --------------------*/
    514            /* Configure I2Cx: Rise Time */
    515            MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
   \       0x9A   0x6823             LDR      R3,[R4, #+0]
   \       0x9C   0x6A1B             LDR      R3,[R3, #+32]
   \       0x9E   0x6865             LDR      R5,[R4, #+4]
   \       0xA0   0x4285             CMP      R5,R0
   \       0xA2   0xD201             BCS.N    ??HAL_I2C_Init_10
   \       0xA4   0x1C55             ADDS     R5,R2,#+1
   \       0xA6   0xE008             B.N      ??HAL_I2C_Init_11
   \                     ??HAL_I2C_Init_10: (+1)
   \       0xA8   0xF44F 0x7596      MOV      R5,#+300
   \       0xAC   0xFB05 0xF502      MUL      R5,R5,R2
   \       0xB0   0xF44F 0x767A      MOV      R6,#+1000
   \       0xB4   0xFBB5 0xF5F6      UDIV     R5,R5,R6
   \       0xB8   0x1C6D             ADDS     R5,R5,#+1
   \                     ??HAL_I2C_Init_11: (+1)
   \       0xBA   0x099B             LSRS     R3,R3,#+6
   \       0xBC   0x019B             LSLS     R3,R3,#+6
   \       0xBE   0x432B             ORRS     R3,R5,R3
   \       0xC0   0x6825             LDR      R5,[R4, #+0]
   \       0xC2   0x622B             STR      R3,[R5, #+32]
    516          
    517            /*---------------------------- I2Cx CCR Configuration ----------------------*/
    518            /* Configure I2Cx: Speed */
    519            MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
   \       0xC4   0x6823             LDR      R3,[R4, #+0]
   \       0xC6   0x69DB             LDR      R3,[R3, #+28]
   \       0xC8   0x6865             LDR      R5,[R4, #+4]
   \       0xCA   0x4285             CMP      R5,R0
   \       0xCC   0xD214             BCS.N    ??HAL_I2C_Init_12
   \       0xCE   0x1E48             SUBS     R0,R1,#+1
   \       0xD0   0x6865             LDR      R5,[R4, #+4]
   \       0xD2   0x006D             LSLS     R5,R5,#+1
   \       0xD4   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \       0xD8   0x1C40             ADDS     R0,R0,#+1
   \       0xDA   0x0500             LSLS     R0,R0,#+20
   \       0xDC   0x0D00             LSRS     R0,R0,#+20
   \       0xDE   0x2804             CMP      R0,#+4
   \       0xE0   0xD201             BCS.N    ??HAL_I2C_Init_13
   \       0xE2   0x2504             MOVS     R5,#+4
   \       0xE4   0xE03E             B.N      ??HAL_I2C_Init_14
   \                     ??HAL_I2C_Init_13: (+1)
   \       0xE6   0x1E48             SUBS     R0,R1,#+1
   \       0xE8   0x6865             LDR      R5,[R4, #+4]
   \       0xEA   0x006D             LSLS     R5,R5,#+1
   \       0xEC   0xFBB0 0xF5F5      UDIV     R5,R0,R5
   \       0xF0   0x1C6D             ADDS     R5,R5,#+1
   \       0xF2   0x052D             LSLS     R5,R5,#+20
   \       0xF4   0x0D2D             LSRS     R5,R5,#+20
   \       0xF6   0xE035             B.N      ??HAL_I2C_Init_14
   \                     ??HAL_I2C_Init_12: (+1)
   \       0xF8   0x68A0             LDR      R0,[R4, #+8]
   \       0xFA   0x2800             CMP      R0,#+0
   \       0xFC   0xD109             BNE.N    ??HAL_I2C_Init_15
   \       0xFE   0x1E4D             SUBS     R5,R1,#+1
   \      0x100   0x6866             LDR      R6,[R4, #+4]
   \      0x102   0x2003             MOVS     R0,#+3
   \      0x104   0x4346             MULS     R6,R0,R6
   \      0x106   0xFBB5 0xF0F6      UDIV     R0,R5,R6
   \      0x10A   0x1C40             ADDS     R0,R0,#+1
   \      0x10C   0x0500             LSLS     R0,R0,#+20
   \      0x10E   0x0D00             LSRS     R0,R0,#+20
   \      0x110   0xE00A             B.N      ??HAL_I2C_Init_16
   \                     ??HAL_I2C_Init_15: (+1)
   \      0x112   0x1E4D             SUBS     R5,R1,#+1
   \      0x114   0x6866             LDR      R6,[R4, #+4]
   \      0x116   0x2019             MOVS     R0,#+25
   \      0x118   0x4346             MULS     R6,R0,R6
   \      0x11A   0xFBB5 0xF0F6      UDIV     R0,R5,R6
   \      0x11E   0x1C40             ADDS     R0,R0,#+1
   \      0x120   0x0500             LSLS     R0,R0,#+20
   \      0x122   0x0D00             LSRS     R0,R0,#+20
   \      0x124   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \                     ??HAL_I2C_Init_16: (+1)
   \      0x128   0x0500             LSLS     R0,R0,#+20
   \      0x12A   0xD101             BNE.N    ??HAL_I2C_Init_17
   \      0x12C   0x2501             MOVS     R5,#+1
   \      0x12E   0xE019             B.N      ??HAL_I2C_Init_14
   \                     ??HAL_I2C_Init_17: (+1)
   \      0x130   0x68A0             LDR      R0,[R4, #+8]
   \      0x132   0x2800             CMP      R0,#+0
   \      0x134   0xD109             BNE.N    ??HAL_I2C_Init_18
   \      0x136   0x1E4D             SUBS     R5,R1,#+1
   \      0x138   0x6866             LDR      R6,[R4, #+4]
   \      0x13A   0x2003             MOVS     R0,#+3
   \      0x13C   0x4346             MULS     R6,R0,R6
   \      0x13E   0xFBB5 0xF5F6      UDIV     R5,R5,R6
   \      0x142   0x1C6D             ADDS     R5,R5,#+1
   \      0x144   0x052D             LSLS     R5,R5,#+20
   \      0x146   0x0D2D             LSRS     R5,R5,#+20
   \      0x148   0xE00A             B.N      ??HAL_I2C_Init_19
   \                     ??HAL_I2C_Init_18: (+1)
   \      0x14A   0x1E4D             SUBS     R5,R1,#+1
   \      0x14C   0x6866             LDR      R6,[R4, #+4]
   \      0x14E   0x2019             MOVS     R0,#+25
   \      0x150   0x4346             MULS     R6,R0,R6
   \      0x152   0xFBB5 0xF5F6      UDIV     R5,R5,R6
   \      0x156   0x1C6D             ADDS     R5,R5,#+1
   \      0x158   0x052D             LSLS     R5,R5,#+20
   \      0x15A   0x0D2D             LSRS     R5,R5,#+20
   \      0x15C   0xF455 0x4580      ORRS     R5,R5,#0x4000
   \                     ??HAL_I2C_Init_19: (+1)
   \      0x160   0xF455 0x4500      ORRS     R5,R5,#0x8000
   \                     ??HAL_I2C_Init_14: (+1)
   \      0x164   0x.... 0x....      LDR.W    R0,??DataTable9
   \      0x168   0x4003             ANDS     R3,R0,R3
   \      0x16A   0x432B             ORRS     R3,R5,R3
   \      0x16C   0x6820             LDR      R0,[R4, #+0]
   \      0x16E   0x61C3             STR      R3,[R0, #+28]
    520          
    521            /*---------------------------- I2Cx CR1 Configuration ----------------------*/
    522            /* Configure I2Cx: Generalcall and NoStretch mode */
    523            MODIFY_REG(hi2c->Instance->CR1, (I2C_CR1_ENGC | I2C_CR1_NOSTRETCH), (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode));
   \      0x170   0x6820             LDR      R0,[R4, #+0]
   \      0x172   0x6803             LDR      R3,[R0, #+0]
   \      0x174   0xF033 0x03C0      BICS     R3,R3,#0xC0
   \      0x178   0x69E0             LDR      R0,[R4, #+28]
   \      0x17A   0x4303             ORRS     R3,R0,R3
   \      0x17C   0x6A20             LDR      R0,[R4, #+32]
   \      0x17E   0x4303             ORRS     R3,R0,R3
   \      0x180   0x6820             LDR      R0,[R4, #+0]
   \      0x182   0x6003             STR      R3,[R0, #+0]
    524          
    525            /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
    526            /* Configure I2Cx: Own Address1 and addressing mode */
    527            MODIFY_REG(hi2c->Instance->OAR1, (I2C_OAR1_ADDMODE | I2C_OAR1_ADD8_9 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD0), (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1));
   \      0x184   0x6820             LDR      R0,[R4, #+0]
   \      0x186   0x6883             LDR      R3,[R0, #+8]
   \      0x188   0x.... 0x....      LDR.W    R0,??DataTable9_1
   \      0x18C   0x4003             ANDS     R3,R0,R3
   \      0x18E   0x6920             LDR      R0,[R4, #+16]
   \      0x190   0x4303             ORRS     R3,R0,R3
   \      0x192   0x68E0             LDR      R0,[R4, #+12]
   \      0x194   0x4303             ORRS     R3,R0,R3
   \      0x196   0x6820             LDR      R0,[R4, #+0]
   \      0x198   0x6083             STR      R3,[R0, #+8]
    528          
    529            /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
    530            /* Configure I2Cx: Dual mode and Own Address2 */
    531            MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));
   \      0x19A   0x6820             LDR      R0,[R4, #+0]
   \      0x19C   0x68C3             LDR      R3,[R0, #+12]
   \      0x19E   0x0A1B             LSRS     R3,R3,#+8
   \      0x1A0   0x021B             LSLS     R3,R3,#+8
   \      0x1A2   0x69A5             LDR      R5,[R4, #+24]
   \      0x1A4   0x6960             LDR      R0,[R4, #+20]
   \      0x1A6   0x4305             ORRS     R5,R0,R5
   \      0x1A8   0x432B             ORRS     R3,R5,R3
   \      0x1AA   0x6820             LDR      R0,[R4, #+0]
   \      0x1AC   0x60C3             STR      R3,[R0, #+12]
    532          
    533            /* Enable the selected I2C peripheral */
    534            __HAL_I2C_ENABLE(hi2c);
   \      0x1AE   0x6820             LDR      R0,[R4, #+0]
   \      0x1B0   0x6800             LDR      R0,[R0, #+0]
   \      0x1B2   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x1B6   0x6823             LDR      R3,[R4, #+0]
   \      0x1B8   0x6018             STR      R0,[R3, #+0]
    535          
    536            hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \      0x1BA   0x2000             MOVS     R0,#+0
   \      0x1BC   0x6420             STR      R0,[R4, #+64]
    537            hi2c->State = HAL_I2C_STATE_READY;
   \      0x1BE   0x2020             MOVS     R0,#+32
   \      0x1C0   0xF884 0x003D      STRB     R0,[R4, #+61]
    538            hi2c->PreviousState = I2C_STATE_NONE;
   \      0x1C4   0x2000             MOVS     R0,#+0
   \      0x1C6   0x6320             STR      R0,[R4, #+48]
    539            hi2c->Mode = HAL_I2C_MODE_NONE;
   \      0x1C8   0x2000             MOVS     R0,#+0
   \      0x1CA   0xF884 0x003E      STRB     R0,[R4, #+62]
    540          
    541            return HAL_OK;
   \      0x1CE   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_Init_1: (+1)
   \      0x1D0   0xBD70             POP      {R4-R6,PC}
    542          }
    543          
    544          /**
    545            * @brief  DeInitialize the I2C peripheral.
    546            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    547            *         the configuration information for the specified I2C.
    548            * @retval HAL status
    549            */

   \                                 In section .text, align 2, keep-with-next
    550          HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
    551          {
   \                     HAL_I2C_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    552            /* Check the I2C handle allocation */
    553            if (hi2c == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE.N    ??HAL_I2C_DeInit_0
    554            {
    555              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE019             B.N      ??HAL_I2C_DeInit_1
    556            }
    557          
    558            /* Check the parameters */
    559            assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
    560          
    561            hi2c->State = HAL_I2C_STATE_BUSY;
   \                     ??HAL_I2C_DeInit_0: (+1)
   \        0xC   0x2024             MOVS     R0,#+36
   \        0xE   0xF884 0x003D      STRB     R0,[R4, #+61]
    562          
    563            /* Disable the I2C Peripheral Clock */
    564            __HAL_I2C_DISABLE(hi2c);
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x0840             LSRS     R0,R0,#+1
   \       0x18   0x0040             LSLS     R0,R0,#+1
   \       0x1A   0x6821             LDR      R1,[R4, #+0]
   \       0x1C   0x6008             STR      R0,[R1, #+0]
    565          
    566          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    567            if (hi2c->MspDeInitCallback == NULL)
    568            {
    569              hi2c->MspDeInitCallback = HAL_I2C_MspDeInit; /* Legacy weak MspDeInit  */
    570            }
    571          
    572            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    573            hi2c->MspDeInitCallback(hi2c);
    574          #else
    575            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    576            HAL_I2C_MspDeInit(hi2c);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       HAL_I2C_MspDeInit
    577          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    578          
    579            hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x6420             STR      R0,[R4, #+64]
    580            hi2c->State         = HAL_I2C_STATE_RESET;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xF884 0x003D      STRB     R0,[R4, #+61]
    581            hi2c->PreviousState = I2C_STATE_NONE;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x6320             STR      R0,[R4, #+48]
    582            hi2c->Mode          = HAL_I2C_MODE_NONE;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xF884 0x003E      STRB     R0,[R4, #+62]
    583          
    584            /* Release Lock */
    585            __HAL_UNLOCK(hi2c);
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0xF884 0x003C      STRB     R0,[R4, #+60]
    586          
    587            return HAL_OK;
   \       0x3E   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_DeInit_1: (+1)
   \       0x40   0xBD10             POP      {R4,PC}
    588          }
    589          
    590          /**
    591            * @brief  Initialize the I2C MSP.
    592            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    593            *         the configuration information for the specified I2C.
    594            * @retval None
    595            */

   \                                 In section .text, align 2
    596          __weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
    597          {
    598            /* Prevent unused argument(s) compilation warning */
    599            UNUSED(hi2c);
    600          
    601            /* NOTE : This function should not be modified, when the callback is needed,
    602                      the HAL_I2C_MspInit could be implemented in the user file
    603             */
    604          }
   \                     HAL_I2C_MspInit: (+1)
   \        0x0   0x4770             BX       LR
    605          
    606          /**
    607            * @brief  DeInitialize the I2C MSP.
    608            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    609            *         the configuration information for the specified I2C.
    610            * @retval None
    611            */

   \                                 In section .text, align 2
    612          __weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
    613          {
    614            /* Prevent unused argument(s) compilation warning */
    615            UNUSED(hi2c);
    616          
    617            /* NOTE : This function should not be modified, when the callback is needed,
    618                      the HAL_I2C_MspDeInit could be implemented in the user file
    619             */
    620          }
   \                     HAL_I2C_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR
    621          
    622          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    623          /**
    624            * @brief  Register a User I2C Callback
    625            *         To be used instead of the weak predefined callback
    626            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    627            *                the configuration information for the specified I2C.
    628            * @param  CallbackID ID of the callback to be registered
    629            *         This parameter can be one of the following values:
    630            *          @arg @ref HAL_I2C_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID
    631            *          @arg @ref HAL_I2C_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID
    632            *          @arg @ref HAL_I2C_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID
    633            *          @arg @ref HAL_I2C_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID
    634            *          @arg @ref HAL_I2C_LISTEN_COMPLETE_CB_ID Listen Complete callback ID
    635            *          @arg @ref HAL_I2C_MEM_TX_COMPLETE_CB_ID Memory Tx Transfer callback ID
    636            *          @arg @ref HAL_I2C_MEM_RX_COMPLETE_CB_ID Memory Rx Transfer completed callback ID
    637            *          @arg @ref HAL_I2C_ERROR_CB_ID Error callback ID
    638            *          @arg @ref HAL_I2C_ABORT_CB_ID Abort callback ID
    639            *          @arg @ref HAL_I2C_MSPINIT_CB_ID MspInit callback ID
    640            *          @arg @ref HAL_I2C_MSPDEINIT_CB_ID MspDeInit callback ID
    641            * @param  pCallback pointer to the Callback function
    642            * @retval HAL status
    643            */
    644          HAL_StatusTypeDef HAL_I2C_RegisterCallback(I2C_HandleTypeDef *hi2c, HAL_I2C_CallbackIDTypeDef CallbackID, pI2C_CallbackTypeDef pCallback)
    645          {
    646            HAL_StatusTypeDef status = HAL_OK;
    647          
    648            if (pCallback == NULL)
    649            {
    650              /* Update the error code */
    651              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    652          
    653              return HAL_ERROR;
    654            }
    655            /* Process locked */
    656            __HAL_LOCK(hi2c);
    657          
    658            if (HAL_I2C_STATE_READY == hi2c->State)
    659            {
    660              switch (CallbackID)
    661              {
    662                case HAL_I2C_MASTER_TX_COMPLETE_CB_ID :
    663                  hi2c->MasterTxCpltCallback = pCallback;
    664                  break;
    665          
    666                case HAL_I2C_MASTER_RX_COMPLETE_CB_ID :
    667                  hi2c->MasterRxCpltCallback = pCallback;
    668                  break;
    669          
    670                case HAL_I2C_SLAVE_TX_COMPLETE_CB_ID :
    671                  hi2c->SlaveTxCpltCallback = pCallback;
    672                  break;
    673          
    674                case HAL_I2C_SLAVE_RX_COMPLETE_CB_ID :
    675                  hi2c->SlaveRxCpltCallback = pCallback;
    676                  break;
    677          
    678                case HAL_I2C_LISTEN_COMPLETE_CB_ID :
    679                  hi2c->ListenCpltCallback = pCallback;
    680                  break;
    681          
    682                case HAL_I2C_MEM_TX_COMPLETE_CB_ID :
    683                  hi2c->MemTxCpltCallback = pCallback;
    684                  break;
    685          
    686                case HAL_I2C_MEM_RX_COMPLETE_CB_ID :
    687                  hi2c->MemRxCpltCallback = pCallback;
    688                  break;
    689          
    690                case HAL_I2C_ERROR_CB_ID :
    691                  hi2c->ErrorCallback = pCallback;
    692                  break;
    693          
    694                case HAL_I2C_ABORT_CB_ID :
    695                  hi2c->AbortCpltCallback = pCallback;
    696                  break;
    697          
    698                case HAL_I2C_MSPINIT_CB_ID :
    699                  hi2c->MspInitCallback = pCallback;
    700                  break;
    701          
    702                case HAL_I2C_MSPDEINIT_CB_ID :
    703                  hi2c->MspDeInitCallback = pCallback;
    704                  break;
    705          
    706                default :
    707                  /* Update the error code */
    708                  hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    709          
    710                  /* Return error status */
    711                  status =  HAL_ERROR;
    712                  break;
    713              }
    714            }
    715            else if (HAL_I2C_STATE_RESET == hi2c->State)
    716            {
    717              switch (CallbackID)
    718              {
    719                case HAL_I2C_MSPINIT_CB_ID :
    720                  hi2c->MspInitCallback = pCallback;
    721                  break;
    722          
    723                case HAL_I2C_MSPDEINIT_CB_ID :
    724                  hi2c->MspDeInitCallback = pCallback;
    725                  break;
    726          
    727                default :
    728                  /* Update the error code */
    729                  hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    730          
    731                  /* Return error status */
    732                  status =  HAL_ERROR;
    733                  break;
    734              }
    735            }
    736            else
    737            {
    738              /* Update the error code */
    739              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    740          
    741              /* Return error status */
    742              status =  HAL_ERROR;
    743            }
    744          
    745            /* Release Lock */
    746            __HAL_UNLOCK(hi2c);
    747            return status;
    748          }
    749          
    750          /**
    751            * @brief  Unregister an I2C Callback
    752            *         I2C callback is redirected to the weak predefined callback
    753            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    754            *                the configuration information for the specified I2C.
    755            * @param  CallbackID ID of the callback to be unregistered
    756            *         This parameter can be one of the following values:
    757            *         This parameter can be one of the following values:
    758            *          @arg @ref HAL_I2C_MASTER_TX_COMPLETE_CB_ID Master Tx Transfer completed callback ID
    759            *          @arg @ref HAL_I2C_MASTER_RX_COMPLETE_CB_ID Master Rx Transfer completed callback ID
    760            *          @arg @ref HAL_I2C_SLAVE_TX_COMPLETE_CB_ID Slave Tx Transfer completed callback ID
    761            *          @arg @ref HAL_I2C_SLAVE_RX_COMPLETE_CB_ID Slave Rx Transfer completed callback ID
    762            *          @arg @ref HAL_I2C_LISTEN_COMPLETE_CB_ID Listen Complete callback ID
    763            *          @arg @ref HAL_I2C_MEM_TX_COMPLETE_CB_ID Memory Tx Transfer callback ID
    764            *          @arg @ref HAL_I2C_MEM_RX_COMPLETE_CB_ID Memory Rx Transfer completed callback ID
    765            *          @arg @ref HAL_I2C_ERROR_CB_ID Error callback ID
    766            *          @arg @ref HAL_I2C_ABORT_CB_ID Abort callback ID
    767            *          @arg @ref HAL_I2C_MSPINIT_CB_ID MspInit callback ID
    768            *          @arg @ref HAL_I2C_MSPDEINIT_CB_ID MspDeInit callback ID
    769            * @retval HAL status
    770            */
    771          HAL_StatusTypeDef HAL_I2C_UnRegisterCallback(I2C_HandleTypeDef *hi2c, HAL_I2C_CallbackIDTypeDef CallbackID)
    772          {
    773            HAL_StatusTypeDef status = HAL_OK;
    774          
    775            /* Process locked */
    776            __HAL_LOCK(hi2c);
    777          
    778            if (HAL_I2C_STATE_READY == hi2c->State)
    779            {
    780              switch (CallbackID)
    781              {
    782                case HAL_I2C_MASTER_TX_COMPLETE_CB_ID :
    783                  hi2c->MasterTxCpltCallback = HAL_I2C_MasterTxCpltCallback; /* Legacy weak MasterTxCpltCallback */
    784                  break;
    785          
    786                case HAL_I2C_MASTER_RX_COMPLETE_CB_ID :
    787                  hi2c->MasterRxCpltCallback = HAL_I2C_MasterRxCpltCallback; /* Legacy weak MasterRxCpltCallback */
    788                  break;
    789          
    790                case HAL_I2C_SLAVE_TX_COMPLETE_CB_ID :
    791                  hi2c->SlaveTxCpltCallback = HAL_I2C_SlaveTxCpltCallback;   /* Legacy weak SlaveTxCpltCallback  */
    792                  break;
    793          
    794                case HAL_I2C_SLAVE_RX_COMPLETE_CB_ID :
    795                  hi2c->SlaveRxCpltCallback = HAL_I2C_SlaveRxCpltCallback;   /* Legacy weak SlaveRxCpltCallback  */
    796                  break;
    797          
    798                case HAL_I2C_LISTEN_COMPLETE_CB_ID :
    799                  hi2c->ListenCpltCallback = HAL_I2C_ListenCpltCallback;     /* Legacy weak ListenCpltCallback   */
    800                  break;
    801          
    802                case HAL_I2C_MEM_TX_COMPLETE_CB_ID :
    803                  hi2c->MemTxCpltCallback = HAL_I2C_MemTxCpltCallback;       /* Legacy weak MemTxCpltCallback    */
    804                  break;
    805          
    806                case HAL_I2C_MEM_RX_COMPLETE_CB_ID :
    807                  hi2c->MemRxCpltCallback = HAL_I2C_MemRxCpltCallback;       /* Legacy weak MemRxCpltCallback    */
    808                  break;
    809          
    810                case HAL_I2C_ERROR_CB_ID :
    811                  hi2c->ErrorCallback = HAL_I2C_ErrorCallback;               /* Legacy weak ErrorCallback        */
    812                  break;
    813          
    814                case HAL_I2C_ABORT_CB_ID :
    815                  hi2c->AbortCpltCallback = HAL_I2C_AbortCpltCallback;       /* Legacy weak AbortCpltCallback    */
    816                  break;
    817          
    818                case HAL_I2C_MSPINIT_CB_ID :
    819                  hi2c->MspInitCallback = HAL_I2C_MspInit;                   /* Legacy weak MspInit              */
    820                  break;
    821          
    822                case HAL_I2C_MSPDEINIT_CB_ID :
    823                  hi2c->MspDeInitCallback = HAL_I2C_MspDeInit;               /* Legacy weak MspDeInit            */
    824                  break;
    825          
    826                default :
    827                  /* Update the error code */
    828                  hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    829          
    830                  /* Return error status */
    831                  status =  HAL_ERROR;
    832                  break;
    833              }
    834            }
    835            else if (HAL_I2C_STATE_RESET == hi2c->State)
    836            {
    837              switch (CallbackID)
    838              {
    839                case HAL_I2C_MSPINIT_CB_ID :
    840                  hi2c->MspInitCallback = HAL_I2C_MspInit;                   /* Legacy weak MspInit              */
    841                  break;
    842          
    843                case HAL_I2C_MSPDEINIT_CB_ID :
    844                  hi2c->MspDeInitCallback = HAL_I2C_MspDeInit;               /* Legacy weak MspDeInit            */
    845                  break;
    846          
    847                default :
    848                  /* Update the error code */
    849                  hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    850          
    851                  /* Return error status */
    852                  status =  HAL_ERROR;
    853                  break;
    854              }
    855            }
    856            else
    857            {
    858              /* Update the error code */
    859              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    860          
    861              /* Return error status */
    862              status =  HAL_ERROR;
    863            }
    864          
    865            /* Release Lock */
    866            __HAL_UNLOCK(hi2c);
    867            return status;
    868          }
    869          
    870          /**
    871            * @brief  Register the Slave Address Match I2C Callback
    872            *         To be used instead of the weak HAL_I2C_AddrCallback() predefined callback
    873            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    874            *                the configuration information for the specified I2C.
    875            * @param  pCallback pointer to the Address Match Callback function
    876            * @retval HAL status
    877            */
    878          HAL_StatusTypeDef HAL_I2C_RegisterAddrCallback(I2C_HandleTypeDef *hi2c, pI2C_AddrCallbackTypeDef pCallback)
    879          {
    880            HAL_StatusTypeDef status = HAL_OK;
    881          
    882            if (pCallback == NULL)
    883            {
    884              /* Update the error code */
    885              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    886          
    887              return HAL_ERROR;
    888            }
    889            /* Process locked */
    890            __HAL_LOCK(hi2c);
    891          
    892            if (HAL_I2C_STATE_READY == hi2c->State)
    893            {
    894              hi2c->AddrCallback = pCallback;
    895            }
    896            else
    897            {
    898              /* Update the error code */
    899              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    900          
    901              /* Return error status */
    902              status =  HAL_ERROR;
    903            }
    904          
    905            /* Release Lock */
    906            __HAL_UNLOCK(hi2c);
    907            return status;
    908          }
    909          
    910          /**
    911            * @brief  UnRegister the Slave Address Match I2C Callback
    912            *         Info Ready I2C Callback is redirected to the weak HAL_I2C_AddrCallback() predefined callback
    913            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
    914            *                the configuration information for the specified I2C.
    915            * @retval HAL status
    916            */
    917          HAL_StatusTypeDef HAL_I2C_UnRegisterAddrCallback(I2C_HandleTypeDef *hi2c)
    918          {
    919            HAL_StatusTypeDef status = HAL_OK;
    920          
    921            /* Process locked */
    922            __HAL_LOCK(hi2c);
    923          
    924            if (HAL_I2C_STATE_READY == hi2c->State)
    925            {
    926              hi2c->AddrCallback = HAL_I2C_AddrCallback; /* Legacy weak AddrCallback  */
    927            }
    928            else
    929            {
    930              /* Update the error code */
    931              hi2c->ErrorCode |= HAL_I2C_ERROR_INVALID_CALLBACK;
    932          
    933              /* Return error status */
    934              status =  HAL_ERROR;
    935            }
    936          
    937            /* Release Lock */
    938            __HAL_UNLOCK(hi2c);
    939            return status;
    940          }
    941          
    942          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    943          
    944          /**
    945            * @}
    946            */
    947          
    948          /** @defgroup I2C_Exported_Functions_Group2 Input and Output operation functions
    949           *  @brief   Data transfers functions
    950           *
    951          @verbatim
    952           ===============================================================================
    953                                ##### IO operation functions #####
    954           ===============================================================================
    955              [..]
    956              This subsection provides a set of functions allowing to manage the I2C data
    957              transfers.
    958          
    959              (#) There are two modes of transfer:
    960                 (++) Blocking mode : The communication is performed in the polling mode.
    961                      The status of all data processing is returned by the same function
    962                      after finishing transfer.
    963                 (++) No-Blocking mode : The communication is performed using Interrupts
    964                      or DMA. These functions return the status of the transfer startup.
    965                      The end of the data processing will be indicated through the
    966                      dedicated I2C IRQ when using Interrupt mode or the DMA IRQ when
    967                      using DMA mode.
    968          
    969              (#) Blocking mode functions are :
    970                  (++) HAL_I2C_Master_Transmit()
    971                  (++) HAL_I2C_Master_Receive()
    972                  (++) HAL_I2C_Slave_Transmit()
    973                  (++) HAL_I2C_Slave_Receive()
    974                  (++) HAL_I2C_Mem_Write()
    975                  (++) HAL_I2C_Mem_Read()
    976                  (++) HAL_I2C_IsDeviceReady()
    977          
    978              (#) No-Blocking mode functions with Interrupt are :
    979                  (++) HAL_I2C_Master_Transmit_IT()
    980                  (++) HAL_I2C_Master_Receive_IT()
    981                  (++) HAL_I2C_Slave_Transmit_IT()
    982                  (++) HAL_I2C_Slave_Receive_IT()
    983                  (++) HAL_I2C_Mem_Write_IT()
    984                  (++) HAL_I2C_Mem_Read_IT()
    985                  (++) HAL_I2C_Master_Seq_Transmit_IT()
    986                  (++) HAL_I2C_Master_Seq_Receive_IT()
    987                  (++) HAL_I2C_Slave_Seq_Transmit_IT()
    988                  (++) HAL_I2C_Slave_Seq_Receive_IT()
    989                  (++) HAL_I2C_EnableListen_IT()
    990                  (++) HAL_I2C_DisableListen_IT()
    991                  (++) HAL_I2C_Master_Abort_IT()
    992          
    993              (#) No-Blocking mode functions with DMA are :
    994                  (++) HAL_I2C_Master_Transmit_DMA()
    995                  (++) HAL_I2C_Master_Receive_DMA()
    996                  (++) HAL_I2C_Slave_Transmit_DMA()
    997                  (++) HAL_I2C_Slave_Receive_DMA()
    998                  (++) HAL_I2C_Mem_Write_DMA()
    999                  (++) HAL_I2C_Mem_Read_DMA()
   1000                  (++) HAL_I2C_Master_Seq_Transmit_DMA()
   1001                  (++) HAL_I2C_Master_Seq_Receive_DMA()
   1002                  (++) HAL_I2C_Slave_Seq_Transmit_DMA()
   1003                  (++) HAL_I2C_Slave_Seq_Receive_DMA()
   1004          
   1005              (#) A set of Transfer Complete Callbacks are provided in non Blocking mode:
   1006                  (++) HAL_I2C_MasterTxCpltCallback()
   1007                  (++) HAL_I2C_MasterRxCpltCallback()
   1008                  (++) HAL_I2C_SlaveTxCpltCallback()
   1009                  (++) HAL_I2C_SlaveRxCpltCallback()
   1010                  (++) HAL_I2C_MemTxCpltCallback()
   1011                  (++) HAL_I2C_MemRxCpltCallback()
   1012                  (++) HAL_I2C_AddrCallback()
   1013                  (++) HAL_I2C_ListenCpltCallback()
   1014                  (++) HAL_I2C_ErrorCallback()
   1015                  (++) HAL_I2C_AbortCpltCallback()
   1016          
   1017          @endverbatim
   1018            * @{
   1019            */
   1020          
   1021          /**
   1022            * @brief  Transmits in master mode an amount of data in blocking mode.
   1023            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1024            *                the configuration information for the specified I2C.
   1025            * @param  DevAddress Target device address: The device 7 bits address value
   1026            *         in datasheet must be shifted to the left before calling the interface
   1027            * @param  pData Pointer to data buffer
   1028            * @param  Size Amount of data to be sent
   1029            * @param  Timeout Timeout duration
   1030            * @retval HAL status
   1031            */

   \                                 In section .text, align 2, keep-with-next
   1032          HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1033          {
   \                     HAL_I2C_Master_Transmit: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8020      LDR      R8,[SP, #+32]
   1034            /* Init tickstart for timeout management*/
   1035            uint32_t tickstart = HAL_GetTick();
   \       0x10   0x.... 0x....      BL       HAL_GetTick
   \       0x14   0x4681             MOV      R9,R0
   1036          
   1037            if (hi2c->State == HAL_I2C_STATE_READY)
   \       0x16   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \       0x1A   0x2820             CMP      R0,#+32
   \       0x1C   0xF040 0x80A2      BNE.W    ??HAL_I2C_Master_Transmit_0
   1038            {
   1039              /* Wait until BUSY flag is reset */
   1040              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \       0x20   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0x24   0x230A             MOVS     R3,#+10
   \       0x26   0x2201             MOVS     R2,#+1
   \       0x28   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD001             BEQ.N    ??HAL_I2C_Master_Transmit_1
   1041              {
   1042                return HAL_BUSY;
   \       0x36   0x2002             MOVS     R0,#+2
   \       0x38   0xE095             B.N      ??HAL_I2C_Master_Transmit_2
   1043              }
   1044          
   1045              /* Process Locked */
   1046              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Transmit_1: (+1)
   \       0x3A   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD101             BNE.N    ??HAL_I2C_Master_Transmit_3
   \       0x42   0x2002             MOVS     R0,#+2
   \       0x44   0xE08F             B.N      ??HAL_I2C_Master_Transmit_2
   \                     ??HAL_I2C_Master_Transmit_3: (+1)
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0xF884 0x003C      STRB     R0,[R4, #+60]
   1047          
   1048              /* Check if the I2C is already enabled */
   1049              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x6800             LDR      R0,[R0, #+0]
   \       0x50   0x07C0             LSLS     R0,R0,#+31
   \       0x52   0xD405             BMI.N    ??HAL_I2C_Master_Transmit_4
   1050              {
   1051                /* Enable I2C peripheral */
   1052                __HAL_I2C_ENABLE(hi2c);
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x6800             LDR      R0,[R0, #+0]
   \       0x58   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x5C   0x6821             LDR      R1,[R4, #+0]
   \       0x5E   0x6008             STR      R0,[R1, #+0]
   1053              }
   1054          
   1055              /* Disable Pos */
   1056              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Master_Transmit_4: (+1)
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x6800             LDR      R0,[R0, #+0]
   \       0x64   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x68   0x6821             LDR      R1,[R4, #+0]
   \       0x6A   0x6008             STR      R0,[R1, #+0]
   1057          
   1058              hi2c->State       = HAL_I2C_STATE_BUSY_TX;
   \       0x6C   0x2021             MOVS     R0,#+33
   \       0x6E   0xF884 0x003D      STRB     R0,[R4, #+61]
   1059              hi2c->Mode        = HAL_I2C_MODE_MASTER;
   \       0x72   0x2010             MOVS     R0,#+16
   \       0x74   0xF884 0x003E      STRB     R0,[R4, #+62]
   1060              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0x6420             STR      R0,[R4, #+64]
   1061          
   1062              /* Prepare transfer parameters */
   1063              hi2c->pBuffPtr    = pData;
   \       0x7C   0x6266             STR      R6,[R4, #+36]
   1064              hi2c->XferCount   = Size;
   \       0x7E   0x8567             STRH     R7,[R4, #+42]
   1065              hi2c->XferSize    = hi2c->XferCount;
   \       0x80   0x8D60             LDRH     R0,[R4, #+42]
   \       0x82   0x8520             STRH     R0,[R4, #+40]
   1066              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable10
   \       0x88   0x62E0             STR      R0,[R4, #+44]
   1067          
   1068              /* Send Slave Address */
   1069              if (I2C_MasterRequestWrite(hi2c, DevAddress, Timeout, tickstart) != HAL_OK)
   \       0x8A   0x464B             MOV      R3,R9
   \       0x8C   0x4642             MOV      R2,R8
   \       0x8E   0x0029             MOVS     R1,R5
   \       0x90   0xB289             UXTH     R1,R1
   \       0x92   0x0020             MOVS     R0,R4
   \       0x94   0x.... 0x....      BL       I2C_MasterRequestWrite
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD001             BEQ.N    ??HAL_I2C_Master_Transmit_5
   1070              {
   1071                return HAL_ERROR;
   \       0x9C   0x2001             MOVS     R0,#+1
   \       0x9E   0xE062             B.N      ??HAL_I2C_Master_Transmit_2
   1072              }
   1073          
   1074              /* Clear ADDR flag */
   1075              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Master_Transmit_5: (+1)
   \       0xA0   0x2000             MOVS     R0,#+0
   \       0xA2   0x9000             STR      R0,[SP, #+0]
   \       0xA4   0x6820             LDR      R0,[R4, #+0]
   \       0xA6   0x6940             LDR      R0,[R0, #+20]
   \       0xA8   0x9000             STR      R0,[SP, #+0]
   \       0xAA   0x6820             LDR      R0,[R4, #+0]
   \       0xAC   0x6980             LDR      R0,[R0, #+24]
   \       0xAE   0x9000             STR      R0,[SP, #+0]
   \       0xB0   0x9800             LDR      R0,[SP, #+0]
   1076          
   1077              while (hi2c->XferSize > 0U)
   \                     ??HAL_I2C_Master_Transmit_6: (+1)
   \       0xB2   0x8D20             LDRH     R0,[R4, #+40]
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD044             BEQ.N    ??HAL_I2C_Master_Transmit_7
   1078              {
   1079                /* Wait until TXE flag is set */
   1080                if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \       0xB8   0x464A             MOV      R2,R9
   \       0xBA   0x4641             MOV      R1,R8
   \       0xBC   0x0020             MOVS     R0,R4
   \       0xBE   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD00A             BEQ.N    ??HAL_I2C_Master_Transmit_8
   1081                {
   1082                  if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \       0xC6   0x6C20             LDR      R0,[R4, #+64]
   \       0xC8   0x2804             CMP      R0,#+4
   \       0xCA   0xD105             BNE.N    ??HAL_I2C_Master_Transmit_9
   1083                  {
   1084                    /* Generate Stop */
   1085                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0xCC   0x6820             LDR      R0,[R4, #+0]
   \       0xCE   0x6800             LDR      R0,[R0, #+0]
   \       0xD0   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0xD4   0x6821             LDR      R1,[R4, #+0]
   \       0xD6   0x6008             STR      R0,[R1, #+0]
   1086                  }
   1087                  return HAL_ERROR;
   \                     ??HAL_I2C_Master_Transmit_9: (+1)
   \       0xD8   0x2001             MOVS     R0,#+1
   \       0xDA   0xE044             B.N      ??HAL_I2C_Master_Transmit_2
   1088                }
   1089          
   1090                /* Write data to DR */
   1091                hi2c->Instance->DR = *hi2c->pBuffPtr;
   \                     ??HAL_I2C_Master_Transmit_8: (+1)
   \       0xDC   0x6A60             LDR      R0,[R4, #+36]
   \       0xDE   0x7800             LDRB     R0,[R0, #+0]
   \       0xE0   0x6821             LDR      R1,[R4, #+0]
   \       0xE2   0x6108             STR      R0,[R1, #+16]
   1092          
   1093                /* Increment Buffer pointer */
   1094                hi2c->pBuffPtr++;
   \       0xE4   0x6A60             LDR      R0,[R4, #+36]
   \       0xE6   0x1C40             ADDS     R0,R0,#+1
   \       0xE8   0x6260             STR      R0,[R4, #+36]
   1095          
   1096                /* Update counter */
   1097                hi2c->XferCount--;
   \       0xEA   0x8D60             LDRH     R0,[R4, #+42]
   \       0xEC   0x1E40             SUBS     R0,R0,#+1
   \       0xEE   0x8560             STRH     R0,[R4, #+42]
   1098                hi2c->XferSize--;
   \       0xF0   0x8D20             LDRH     R0,[R4, #+40]
   \       0xF2   0x1E40             SUBS     R0,R0,#+1
   \       0xF4   0x8520             STRH     R0,[R4, #+40]
   1099          
   1100                if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
   \       0xF6   0x6820             LDR      R0,[R4, #+0]
   \       0xF8   0x6940             LDR      R0,[R0, #+20]
   \       0xFA   0x0740             LSLS     R0,R0,#+29
   \       0xFC   0xD50F             BPL.N    ??HAL_I2C_Master_Transmit_10
   \       0xFE   0x8D20             LDRH     R0,[R4, #+40]
   \      0x100   0x2800             CMP      R0,#+0
   \      0x102   0xD00C             BEQ.N    ??HAL_I2C_Master_Transmit_10
   1101                {
   1102                  /* Write data to DR */
   1103                  hi2c->Instance->DR = *hi2c->pBuffPtr;
   \      0x104   0x6A60             LDR      R0,[R4, #+36]
   \      0x106   0x7800             LDRB     R0,[R0, #+0]
   \      0x108   0x6821             LDR      R1,[R4, #+0]
   \      0x10A   0x6108             STR      R0,[R1, #+16]
   1104          
   1105                  /* Increment Buffer pointer */
   1106                  hi2c->pBuffPtr++;
   \      0x10C   0x6A60             LDR      R0,[R4, #+36]
   \      0x10E   0x1C40             ADDS     R0,R0,#+1
   \      0x110   0x6260             STR      R0,[R4, #+36]
   1107          
   1108                  /* Update counter */
   1109                  hi2c->XferCount--;
   \      0x112   0x8D60             LDRH     R0,[R4, #+42]
   \      0x114   0x1E40             SUBS     R0,R0,#+1
   \      0x116   0x8560             STRH     R0,[R4, #+42]
   1110                  hi2c->XferSize--;
   \      0x118   0x8D20             LDRH     R0,[R4, #+40]
   \      0x11A   0x1E40             SUBS     R0,R0,#+1
   \      0x11C   0x8520             STRH     R0,[R4, #+40]
   1111                }
   1112          
   1113                /* Wait until BTF flag is set */
   1114                if (I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Master_Transmit_10: (+1)
   \      0x11E   0x464A             MOV      R2,R9
   \      0x120   0x4641             MOV      R1,R8
   \      0x122   0x0020             MOVS     R0,R4
   \      0x124   0x.... 0x....      BL       I2C_WaitOnBTFFlagUntilTimeout
   \      0x128   0x2800             CMP      R0,#+0
   \      0x12A   0xD0C2             BEQ.N    ??HAL_I2C_Master_Transmit_6
   1115                {
   1116                  if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \      0x12C   0x6C20             LDR      R0,[R4, #+64]
   \      0x12E   0x2804             CMP      R0,#+4
   \      0x130   0xD105             BNE.N    ??HAL_I2C_Master_Transmit_11
   1117                  {
   1118                    /* Generate Stop */
   1119                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \      0x132   0x6820             LDR      R0,[R4, #+0]
   \      0x134   0x6800             LDR      R0,[R0, #+0]
   \      0x136   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x13A   0x6821             LDR      R1,[R4, #+0]
   \      0x13C   0x6008             STR      R0,[R1, #+0]
   1120                  }
   1121                  return HAL_ERROR;
   \                     ??HAL_I2C_Master_Transmit_11: (+1)
   \      0x13E   0x2001             MOVS     R0,#+1
   \      0x140   0xE011             B.N      ??HAL_I2C_Master_Transmit_2
   1122                }
   1123              }
   1124          
   1125              /* Generate Stop */
   1126              SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??HAL_I2C_Master_Transmit_7: (+1)
   \      0x142   0x6820             LDR      R0,[R4, #+0]
   \      0x144   0x6800             LDR      R0,[R0, #+0]
   \      0x146   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x14A   0x6821             LDR      R1,[R4, #+0]
   \      0x14C   0x6008             STR      R0,[R1, #+0]
   1127          
   1128              hi2c->State = HAL_I2C_STATE_READY;
   \      0x14E   0x2020             MOVS     R0,#+32
   \      0x150   0xF884 0x003D      STRB     R0,[R4, #+61]
   1129              hi2c->Mode = HAL_I2C_MODE_NONE;
   \      0x154   0x2000             MOVS     R0,#+0
   \      0x156   0xF884 0x003E      STRB     R0,[R4, #+62]
   1130          
   1131              /* Process Unlocked */
   1132              __HAL_UNLOCK(hi2c);
   \      0x15A   0x2000             MOVS     R0,#+0
   \      0x15C   0xF884 0x003C      STRB     R0,[R4, #+60]
   1133          
   1134              return HAL_OK;
   \      0x160   0x2000             MOVS     R0,#+0
   \      0x162   0xE000             B.N      ??HAL_I2C_Master_Transmit_2
   1135            }
   1136            else
   1137            {
   1138              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_0: (+1)
   \      0x164   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_2: (+1)
   \      0x166   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1139            }
   1140          }
   1141          
   1142          /**
   1143            * @brief  Receives in master mode an amount of data in blocking mode.
   1144            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1145            *                the configuration information for the specified I2C.
   1146            * @param  DevAddress Target device address: The device 7 bits address value
   1147            *         in datasheet must be shifted to the left before calling the interface
   1148            * @param  pData Pointer to data buffer
   1149            * @param  Size Amount of data to be sent
   1150            * @param  Timeout Timeout duration
   1151            * @retval HAL status
   1152            */

   \                                 In section .text, align 2, keep-with-next
   1153          HAL_StatusTypeDef HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1154          {
   \                     HAL_I2C_Master_Receive: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   1155            /* Init tickstart for timeout management*/
   1156            uint32_t tickstart = HAL_GetTick();
   \       0x10   0x.... 0x....      BL       HAL_GetTick
   \       0x14   0x4681             MOV      R9,R0
   1157          
   1158            if (hi2c->State == HAL_I2C_STATE_READY)
   \       0x16   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \       0x1A   0x2820             CMP      R0,#+32
   \       0x1C   0xF040 0x8169      BNE.W    ??HAL_I2C_Master_Receive_0
   1159            {
   1160              /* Wait until BUSY flag is reset */
   1161              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \       0x20   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0x24   0x230A             MOVS     R3,#+10
   \       0x26   0x2201             MOVS     R2,#+1
   \       0x28   0x.... 0x....      LDR.W    R1,??DataTable9_2
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_1
   1162              {
   1163                return HAL_BUSY;
   \       0x36   0x2002             MOVS     R0,#+2
   \       0x38   0xE15C             B.N      ??HAL_I2C_Master_Receive_2
   1164              }
   1165          
   1166              /* Process Locked */
   1167              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Receive_1: (+1)
   \       0x3A   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD101             BNE.N    ??HAL_I2C_Master_Receive_3
   \       0x42   0x2002             MOVS     R0,#+2
   \       0x44   0xE156             B.N      ??HAL_I2C_Master_Receive_2
   \                     ??HAL_I2C_Master_Receive_3: (+1)
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0xF884 0x003C      STRB     R0,[R4, #+60]
   1168          
   1169              /* Check if the I2C is already enabled */
   1170              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x6800             LDR      R0,[R0, #+0]
   \       0x50   0x07C0             LSLS     R0,R0,#+31
   \       0x52   0xD405             BMI.N    ??HAL_I2C_Master_Receive_4
   1171              {
   1172                /* Enable I2C peripheral */
   1173                __HAL_I2C_ENABLE(hi2c);
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x6800             LDR      R0,[R0, #+0]
   \       0x58   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x5C   0x6821             LDR      R1,[R4, #+0]
   \       0x5E   0x6008             STR      R0,[R1, #+0]
   1174              }
   1175          
   1176              /* Disable Pos */
   1177              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Master_Receive_4: (+1)
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x6800             LDR      R0,[R0, #+0]
   \       0x64   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x68   0x6821             LDR      R1,[R4, #+0]
   \       0x6A   0x6008             STR      R0,[R1, #+0]
   1178          
   1179              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   \       0x6C   0x2022             MOVS     R0,#+34
   \       0x6E   0xF884 0x003D      STRB     R0,[R4, #+61]
   1180              hi2c->Mode        = HAL_I2C_MODE_MASTER;
   \       0x72   0x2010             MOVS     R0,#+16
   \       0x74   0xF884 0x003E      STRB     R0,[R4, #+62]
   1181              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0x6420             STR      R0,[R4, #+64]
   1182          
   1183              /* Prepare transfer parameters */
   1184              hi2c->pBuffPtr    = pData;
   \       0x7C   0x6266             STR      R6,[R4, #+36]
   1185              hi2c->XferCount   = Size;
   \       0x7E   0x8567             STRH     R7,[R4, #+42]
   1186              hi2c->XferSize    = hi2c->XferCount;
   \       0x80   0x8D60             LDRH     R0,[R4, #+42]
   \       0x82   0x8520             STRH     R0,[R4, #+40]
   1187              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x84   0x.... 0x....      LDR.W    R0,??DataTable10
   \       0x88   0x62E0             STR      R0,[R4, #+44]
   1188          
   1189              /* Send Slave Address */
   1190              if (I2C_MasterRequestRead(hi2c, DevAddress, Timeout, tickstart) != HAL_OK)
   \       0x8A   0x464B             MOV      R3,R9
   \       0x8C   0x4642             MOV      R2,R8
   \       0x8E   0x0029             MOVS     R1,R5
   \       0x90   0xB289             UXTH     R1,R1
   \       0x92   0x0020             MOVS     R0,R4
   \       0x94   0x.... 0x....      BL       I2C_MasterRequestRead
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_5
   1191              {
   1192                return HAL_ERROR;
   \       0x9C   0x2001             MOVS     R0,#+1
   \       0x9E   0xE129             B.N      ??HAL_I2C_Master_Receive_2
   1193              }
   1194          
   1195              if (hi2c->XferSize == 0U)
   \                     ??HAL_I2C_Master_Receive_5: (+1)
   \       0xA0   0x8D20             LDRH     R0,[R4, #+40]
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD10F             BNE.N    ??HAL_I2C_Master_Receive_6
   1196              {
   1197                /* Clear ADDR flag */
   1198                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0x9000             STR      R0,[SP, #+0]
   \       0xAA   0x6820             LDR      R0,[R4, #+0]
   \       0xAC   0x6940             LDR      R0,[R0, #+20]
   \       0xAE   0x9000             STR      R0,[SP, #+0]
   \       0xB0   0x6820             LDR      R0,[R4, #+0]
   \       0xB2   0x6980             LDR      R0,[R0, #+24]
   \       0xB4   0x9000             STR      R0,[SP, #+0]
   \       0xB6   0x9800             LDR      R0,[SP, #+0]
   1199          
   1200                /* Generate Stop */
   1201                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0xB8   0x6820             LDR      R0,[R4, #+0]
   \       0xBA   0x6800             LDR      R0,[R0, #+0]
   \       0xBC   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0xC0   0x6821             LDR      R1,[R4, #+0]
   \       0xC2   0x6008             STR      R0,[R1, #+0]
   \       0xC4   0xE040             B.N      ??HAL_I2C_Master_Receive_7
   1202              }
   1203              else if (hi2c->XferSize == 1U)
   \                     ??HAL_I2C_Master_Receive_6: (+1)
   \       0xC6   0x8D20             LDRH     R0,[R4, #+40]
   \       0xC8   0x2801             CMP      R0,#+1
   \       0xCA   0xD115             BNE.N    ??HAL_I2C_Master_Receive_8
   1204              {
   1205                /* Disable Acknowledge */
   1206                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0xCC   0x6820             LDR      R0,[R4, #+0]
   \       0xCE   0x6800             LDR      R0,[R0, #+0]
   \       0xD0   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0xD4   0x6821             LDR      R1,[R4, #+0]
   \       0xD6   0x6008             STR      R0,[R1, #+0]
   1207          
   1208                /* Clear ADDR flag */
   1209                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \       0xD8   0x2000             MOVS     R0,#+0
   \       0xDA   0x9000             STR      R0,[SP, #+0]
   \       0xDC   0x6820             LDR      R0,[R4, #+0]
   \       0xDE   0x6940             LDR      R0,[R0, #+20]
   \       0xE0   0x9000             STR      R0,[SP, #+0]
   \       0xE2   0x6820             LDR      R0,[R4, #+0]
   \       0xE4   0x6980             LDR      R0,[R0, #+24]
   \       0xE6   0x9000             STR      R0,[SP, #+0]
   \       0xE8   0x9800             LDR      R0,[SP, #+0]
   1210          
   1211                /* Generate Stop */
   1212                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0xEA   0x6820             LDR      R0,[R4, #+0]
   \       0xEC   0x6800             LDR      R0,[R0, #+0]
   \       0xEE   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0xF2   0x6821             LDR      R1,[R4, #+0]
   \       0xF4   0x6008             STR      R0,[R1, #+0]
   \       0xF6   0xE027             B.N      ??HAL_I2C_Master_Receive_7
   1213              }
   1214              else if (hi2c->XferSize == 2U)
   \                     ??HAL_I2C_Master_Receive_8: (+1)
   \       0xF8   0x8D20             LDRH     R0,[R4, #+40]
   \       0xFA   0x2802             CMP      R0,#+2
   \       0xFC   0xD115             BNE.N    ??HAL_I2C_Master_Receive_9
   1215              {
   1216                /* Disable Acknowledge */
   1217                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0xFE   0x6820             LDR      R0,[R4, #+0]
   \      0x100   0x6800             LDR      R0,[R0, #+0]
   \      0x102   0xF430 0x6080      BICS     R0,R0,#0x400
   \      0x106   0x6821             LDR      R1,[R4, #+0]
   \      0x108   0x6008             STR      R0,[R1, #+0]
   1218          
   1219                /* Enable Pos */
   1220                SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \      0x10A   0x6820             LDR      R0,[R4, #+0]
   \      0x10C   0x6800             LDR      R0,[R0, #+0]
   \      0x10E   0xF450 0x6000      ORRS     R0,R0,#0x800
   \      0x112   0x6821             LDR      R1,[R4, #+0]
   \      0x114   0x6008             STR      R0,[R1, #+0]
   1221          
   1222                /* Clear ADDR flag */
   1223                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \      0x116   0x2000             MOVS     R0,#+0
   \      0x118   0x9000             STR      R0,[SP, #+0]
   \      0x11A   0x6820             LDR      R0,[R4, #+0]
   \      0x11C   0x6940             LDR      R0,[R0, #+20]
   \      0x11E   0x9000             STR      R0,[SP, #+0]
   \      0x120   0x6820             LDR      R0,[R4, #+0]
   \      0x122   0x6980             LDR      R0,[R0, #+24]
   \      0x124   0x9000             STR      R0,[SP, #+0]
   \      0x126   0x9800             LDR      R0,[SP, #+0]
   \      0x128   0xE00E             B.N      ??HAL_I2C_Master_Receive_7
   1224              }
   1225              else
   1226              {
   1227                /* Enable Acknowledge */
   1228                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Receive_9: (+1)
   \      0x12A   0x6820             LDR      R0,[R4, #+0]
   \      0x12C   0x6800             LDR      R0,[R0, #+0]
   \      0x12E   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x132   0x6821             LDR      R1,[R4, #+0]
   \      0x134   0x6008             STR      R0,[R1, #+0]
   1229          
   1230                /* Clear ADDR flag */
   1231                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \      0x136   0x2000             MOVS     R0,#+0
   \      0x138   0x9000             STR      R0,[SP, #+0]
   \      0x13A   0x6820             LDR      R0,[R4, #+0]
   \      0x13C   0x6940             LDR      R0,[R0, #+20]
   \      0x13E   0x9000             STR      R0,[SP, #+0]
   \      0x140   0x6820             LDR      R0,[R4, #+0]
   \      0x142   0x6980             LDR      R0,[R0, #+24]
   \      0x144   0x9000             STR      R0,[SP, #+0]
   \      0x146   0x9800             LDR      R0,[SP, #+0]
   1232              }
   1233          
   1234              while (hi2c->XferSize > 0U)
   \                     ??HAL_I2C_Master_Receive_7: (+1)
   \      0x148   0x8D20             LDRH     R0,[R4, #+40]
   \      0x14A   0x2800             CMP      R0,#+0
   \      0x14C   0xF000 0x80C6      BEQ.W    ??HAL_I2C_Master_Receive_10
   1235              {
   1236                if (hi2c->XferSize <= 3U)
   \      0x150   0x8D20             LDRH     R0,[R4, #+40]
   \      0x152   0x2804             CMP      R0,#+4
   \      0x154   0xF080 0x8099      BCS.W    ??HAL_I2C_Master_Receive_11
   1237                {
   1238                  /* One byte */
   1239                  if (hi2c->XferSize == 1U)
   \      0x158   0x8D20             LDRH     R0,[R4, #+40]
   \      0x15A   0x2801             CMP      R0,#+1
   \      0x15C   0xD116             BNE.N    ??HAL_I2C_Master_Receive_12
   1240                  {
   1241                    /* Wait until RXNE flag is set */
   1242                    if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \      0x15E   0x464A             MOV      R2,R9
   \      0x160   0x4641             MOV      R1,R8
   \      0x162   0x0020             MOVS     R0,R4
   \      0x164   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \      0x168   0x2800             CMP      R0,#+0
   \      0x16A   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_13
   1243                    {
   1244                      return HAL_ERROR;
   \      0x16C   0x2001             MOVS     R0,#+1
   \      0x16E   0xE0C1             B.N      ??HAL_I2C_Master_Receive_2
   1245                    }
   1246          
   1247                    /* Read data from DR */
   1248                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \                     ??HAL_I2C_Master_Receive_13: (+1)
   \      0x170   0x6820             LDR      R0,[R4, #+0]
   \      0x172   0x6900             LDR      R0,[R0, #+16]
   \      0x174   0x6A61             LDR      R1,[R4, #+36]
   \      0x176   0x7008             STRB     R0,[R1, #+0]
   1249          
   1250                    /* Increment Buffer pointer */
   1251                    hi2c->pBuffPtr++;
   \      0x178   0x6A60             LDR      R0,[R4, #+36]
   \      0x17A   0x1C40             ADDS     R0,R0,#+1
   \      0x17C   0x6260             STR      R0,[R4, #+36]
   1252          
   1253                    /* Update counter */
   1254                    hi2c->XferSize--;
   \      0x17E   0x8D20             LDRH     R0,[R4, #+40]
   \      0x180   0x1E40             SUBS     R0,R0,#+1
   \      0x182   0x8520             STRH     R0,[R4, #+40]
   1255                    hi2c->XferCount--;
   \      0x184   0x8D60             LDRH     R0,[R4, #+42]
   \      0x186   0x1E40             SUBS     R0,R0,#+1
   \      0x188   0x8560             STRH     R0,[R4, #+42]
   \      0x18A   0xE7DD             B.N      ??HAL_I2C_Master_Receive_7
   1256                  }
   1257                  /* Two bytes */
   1258                  else if (hi2c->XferSize == 2U)
   \                     ??HAL_I2C_Master_Receive_12: (+1)
   \      0x18C   0x8D20             LDRH     R0,[R4, #+40]
   \      0x18E   0x2802             CMP      R0,#+2
   \      0x190   0xD12D             BNE.N    ??HAL_I2C_Master_Receive_14
   1259                  {
   1260                    /* Wait until BTF flag is set */
   1261                    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \      0x192   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \      0x196   0x4643             MOV      R3,R8
   \      0x198   0x2200             MOVS     R2,#+0
   \      0x19A   0x.... 0x....      LDR.W    R1,??DataTable12
   \      0x19E   0x0020             MOVS     R0,R4
   \      0x1A0   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \      0x1A4   0x2800             CMP      R0,#+0
   \      0x1A6   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_15
   1262                    {
   1263                      return HAL_ERROR;
   \      0x1A8   0x2001             MOVS     R0,#+1
   \      0x1AA   0xE0A3             B.N      ??HAL_I2C_Master_Receive_2
   1264                    }
   1265          
   1266                    /* Generate Stop */
   1267                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??HAL_I2C_Master_Receive_15: (+1)
   \      0x1AC   0x6820             LDR      R0,[R4, #+0]
   \      0x1AE   0x6800             LDR      R0,[R0, #+0]
   \      0x1B0   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x1B4   0x6821             LDR      R1,[R4, #+0]
   \      0x1B6   0x6008             STR      R0,[R1, #+0]
   1268          
   1269                    /* Read data from DR */
   1270                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x1B8   0x6820             LDR      R0,[R4, #+0]
   \      0x1BA   0x6900             LDR      R0,[R0, #+16]
   \      0x1BC   0x6A61             LDR      R1,[R4, #+36]
   \      0x1BE   0x7008             STRB     R0,[R1, #+0]
   1271          
   1272                    /* Increment Buffer pointer */
   1273                    hi2c->pBuffPtr++;
   \      0x1C0   0x6A60             LDR      R0,[R4, #+36]
   \      0x1C2   0x1C40             ADDS     R0,R0,#+1
   \      0x1C4   0x6260             STR      R0,[R4, #+36]
   1274          
   1275                    /* Update counter */
   1276                    hi2c->XferSize--;
   \      0x1C6   0x8D20             LDRH     R0,[R4, #+40]
   \      0x1C8   0x1E40             SUBS     R0,R0,#+1
   \      0x1CA   0x8520             STRH     R0,[R4, #+40]
   1277                    hi2c->XferCount--;
   \      0x1CC   0x8D60             LDRH     R0,[R4, #+42]
   \      0x1CE   0x1E40             SUBS     R0,R0,#+1
   \      0x1D0   0x8560             STRH     R0,[R4, #+42]
   1278          
   1279                    /* Read data from DR */
   1280                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x1D2   0x6820             LDR      R0,[R4, #+0]
   \      0x1D4   0x6900             LDR      R0,[R0, #+16]
   \      0x1D6   0x6A61             LDR      R1,[R4, #+36]
   \      0x1D8   0x7008             STRB     R0,[R1, #+0]
   1281          
   1282                    /* Increment Buffer pointer */
   1283                    hi2c->pBuffPtr++;
   \      0x1DA   0x6A60             LDR      R0,[R4, #+36]
   \      0x1DC   0x1C40             ADDS     R0,R0,#+1
   \      0x1DE   0x6260             STR      R0,[R4, #+36]
   1284          
   1285                    /* Update counter */
   1286                    hi2c->XferSize--;
   \      0x1E0   0x8D20             LDRH     R0,[R4, #+40]
   \      0x1E2   0x1E40             SUBS     R0,R0,#+1
   \      0x1E4   0x8520             STRH     R0,[R4, #+40]
   1287                    hi2c->XferCount--;
   \      0x1E6   0x8D60             LDRH     R0,[R4, #+42]
   \      0x1E8   0x1E40             SUBS     R0,R0,#+1
   \      0x1EA   0x8560             STRH     R0,[R4, #+42]
   \      0x1EC   0xE7AC             B.N      ??HAL_I2C_Master_Receive_7
   1288                  }
   1289                  /* 3 Last bytes */
   1290                  else
   1291                  {
   1292                    /* Wait until BTF flag is set */
   1293                    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Master_Receive_14: (+1)
   \      0x1EE   0x.... 0x....      LDR.W    R10,??DataTable12
   \      0x1F2   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \      0x1F6   0x4643             MOV      R3,R8
   \      0x1F8   0x2200             MOVS     R2,#+0
   \      0x1FA   0x4651             MOV      R1,R10
   \      0x1FC   0x0020             MOVS     R0,R4
   \      0x1FE   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \      0x202   0x2800             CMP      R0,#+0
   \      0x204   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_16
   1294                    {
   1295                      return HAL_ERROR;
   \      0x206   0x2001             MOVS     R0,#+1
   \      0x208   0xE074             B.N      ??HAL_I2C_Master_Receive_2
   1296                    }
   1297          
   1298                    /* Disable Acknowledge */
   1299                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Receive_16: (+1)
   \      0x20A   0x6820             LDR      R0,[R4, #+0]
   \      0x20C   0x6800             LDR      R0,[R0, #+0]
   \      0x20E   0xF430 0x6080      BICS     R0,R0,#0x400
   \      0x212   0x6821             LDR      R1,[R4, #+0]
   \      0x214   0x6008             STR      R0,[R1, #+0]
   1300          
   1301                    /* Read data from DR */
   1302                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x216   0x6820             LDR      R0,[R4, #+0]
   \      0x218   0x6900             LDR      R0,[R0, #+16]
   \      0x21A   0x6A61             LDR      R1,[R4, #+36]
   \      0x21C   0x7008             STRB     R0,[R1, #+0]
   1303          
   1304                    /* Increment Buffer pointer */
   1305                    hi2c->pBuffPtr++;
   \      0x21E   0x6A60             LDR      R0,[R4, #+36]
   \      0x220   0x1C40             ADDS     R0,R0,#+1
   \      0x222   0x6260             STR      R0,[R4, #+36]
   1306          
   1307                    /* Update counter */
   1308                    hi2c->XferSize--;
   \      0x224   0x8D20             LDRH     R0,[R4, #+40]
   \      0x226   0x1E40             SUBS     R0,R0,#+1
   \      0x228   0x8520             STRH     R0,[R4, #+40]
   1309                    hi2c->XferCount--;
   \      0x22A   0x8D60             LDRH     R0,[R4, #+42]
   \      0x22C   0x1E40             SUBS     R0,R0,#+1
   \      0x22E   0x8560             STRH     R0,[R4, #+42]
   1310          
   1311                    /* Wait until BTF flag is set */
   1312                    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \      0x230   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \      0x234   0x4643             MOV      R3,R8
   \      0x236   0x2200             MOVS     R2,#+0
   \      0x238   0x4651             MOV      R1,R10
   \      0x23A   0x0020             MOVS     R0,R4
   \      0x23C   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \      0x240   0x2800             CMP      R0,#+0
   \      0x242   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_17
   1313                    {
   1314                      return HAL_ERROR;
   \      0x244   0x2001             MOVS     R0,#+1
   \      0x246   0xE055             B.N      ??HAL_I2C_Master_Receive_2
   1315                    }
   1316          
   1317                    /* Generate Stop */
   1318                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??HAL_I2C_Master_Receive_17: (+1)
   \      0x248   0x6820             LDR      R0,[R4, #+0]
   \      0x24A   0x6800             LDR      R0,[R0, #+0]
   \      0x24C   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x250   0x6821             LDR      R1,[R4, #+0]
   \      0x252   0x6008             STR      R0,[R1, #+0]
   1319          
   1320                    /* Read data from DR */
   1321                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x254   0x6820             LDR      R0,[R4, #+0]
   \      0x256   0x6900             LDR      R0,[R0, #+16]
   \      0x258   0x6A61             LDR      R1,[R4, #+36]
   \      0x25A   0x7008             STRB     R0,[R1, #+0]
   1322          
   1323                    /* Increment Buffer pointer */
   1324                    hi2c->pBuffPtr++;
   \      0x25C   0x6A60             LDR      R0,[R4, #+36]
   \      0x25E   0x1C40             ADDS     R0,R0,#+1
   \      0x260   0x6260             STR      R0,[R4, #+36]
   1325          
   1326                    /* Update counter */
   1327                    hi2c->XferSize--;
   \      0x262   0x8D20             LDRH     R0,[R4, #+40]
   \      0x264   0x1E40             SUBS     R0,R0,#+1
   \      0x266   0x8520             STRH     R0,[R4, #+40]
   1328                    hi2c->XferCount--;
   \      0x268   0x8D60             LDRH     R0,[R4, #+42]
   \      0x26A   0x1E40             SUBS     R0,R0,#+1
   \      0x26C   0x8560             STRH     R0,[R4, #+42]
   1329          
   1330                    /* Read data from DR */
   1331                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x26E   0x6820             LDR      R0,[R4, #+0]
   \      0x270   0x6900             LDR      R0,[R0, #+16]
   \      0x272   0x6A61             LDR      R1,[R4, #+36]
   \      0x274   0x7008             STRB     R0,[R1, #+0]
   1332          
   1333                    /* Increment Buffer pointer */
   1334                    hi2c->pBuffPtr++;
   \      0x276   0x6A60             LDR      R0,[R4, #+36]
   \      0x278   0x1C40             ADDS     R0,R0,#+1
   \      0x27A   0x6260             STR      R0,[R4, #+36]
   1335          
   1336                    /* Update counter */
   1337                    hi2c->XferSize--;
   \      0x27C   0x8D20             LDRH     R0,[R4, #+40]
   \      0x27E   0x1E40             SUBS     R0,R0,#+1
   \      0x280   0x8520             STRH     R0,[R4, #+40]
   1338                    hi2c->XferCount--;
   \      0x282   0x8D60             LDRH     R0,[R4, #+42]
   \      0x284   0x1E40             SUBS     R0,R0,#+1
   \      0x286   0x8560             STRH     R0,[R4, #+42]
   \      0x288   0xE75E             B.N      ??HAL_I2C_Master_Receive_7
   1339                  }
   1340                }
   1341                else
   1342                {
   1343                  /* Wait until RXNE flag is set */
   1344                  if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Master_Receive_11: (+1)
   \      0x28A   0x464A             MOV      R2,R9
   \      0x28C   0x4641             MOV      R1,R8
   \      0x28E   0x0020             MOVS     R0,R4
   \      0x290   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \      0x294   0x2800             CMP      R0,#+0
   \      0x296   0xD001             BEQ.N    ??HAL_I2C_Master_Receive_18
   1345                  {
   1346                    return HAL_ERROR;
   \      0x298   0x2001             MOVS     R0,#+1
   \      0x29A   0xE02B             B.N      ??HAL_I2C_Master_Receive_2
   1347                  }
   1348          
   1349                  /* Read data from DR */
   1350                  *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \                     ??HAL_I2C_Master_Receive_18: (+1)
   \      0x29C   0x6820             LDR      R0,[R4, #+0]
   \      0x29E   0x6900             LDR      R0,[R0, #+16]
   \      0x2A0   0x6A61             LDR      R1,[R4, #+36]
   \      0x2A2   0x7008             STRB     R0,[R1, #+0]
   1351          
   1352                  /* Increment Buffer pointer */
   1353                  hi2c->pBuffPtr++;
   \      0x2A4   0x6A60             LDR      R0,[R4, #+36]
   \      0x2A6   0x1C40             ADDS     R0,R0,#+1
   \      0x2A8   0x6260             STR      R0,[R4, #+36]
   1354          
   1355                  /* Update counter */
   1356                  hi2c->XferSize--;
   \      0x2AA   0x8D20             LDRH     R0,[R4, #+40]
   \      0x2AC   0x1E40             SUBS     R0,R0,#+1
   \      0x2AE   0x8520             STRH     R0,[R4, #+40]
   1357                  hi2c->XferCount--;
   \      0x2B0   0x8D60             LDRH     R0,[R4, #+42]
   \      0x2B2   0x1E40             SUBS     R0,R0,#+1
   \      0x2B4   0x8560             STRH     R0,[R4, #+42]
   1358          
   1359                  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
   \      0x2B6   0x6820             LDR      R0,[R4, #+0]
   \      0x2B8   0x6940             LDR      R0,[R0, #+20]
   \      0x2BA   0x0740             LSLS     R0,R0,#+29
   \      0x2BC   0xF57F 0xAF44      BPL.W    ??HAL_I2C_Master_Receive_7
   1360                  {
   1361                    /* Read data from DR */
   1362                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x2C0   0x6820             LDR      R0,[R4, #+0]
   \      0x2C2   0x6900             LDR      R0,[R0, #+16]
   \      0x2C4   0x6A61             LDR      R1,[R4, #+36]
   \      0x2C6   0x7008             STRB     R0,[R1, #+0]
   1363          
   1364                    /* Increment Buffer pointer */
   1365                    hi2c->pBuffPtr++;
   \      0x2C8   0x6A60             LDR      R0,[R4, #+36]
   \      0x2CA   0x1C40             ADDS     R0,R0,#+1
   \      0x2CC   0x6260             STR      R0,[R4, #+36]
   1366          
   1367                    /* Update counter */
   1368                    hi2c->XferSize--;
   \      0x2CE   0x8D20             LDRH     R0,[R4, #+40]
   \      0x2D0   0x1E40             SUBS     R0,R0,#+1
   \      0x2D2   0x8520             STRH     R0,[R4, #+40]
   1369                    hi2c->XferCount--;
   \      0x2D4   0x8D60             LDRH     R0,[R4, #+42]
   \      0x2D6   0x1E40             SUBS     R0,R0,#+1
   \      0x2D8   0x8560             STRH     R0,[R4, #+42]
   \      0x2DA   0xE735             B.N      ??HAL_I2C_Master_Receive_7
   1370                  }
   1371                }
   1372              }
   1373          
   1374              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Receive_10: (+1)
   \      0x2DC   0x2020             MOVS     R0,#+32
   \      0x2DE   0xF884 0x003D      STRB     R0,[R4, #+61]
   1375              hi2c->Mode = HAL_I2C_MODE_NONE;
   \      0x2E2   0x2000             MOVS     R0,#+0
   \      0x2E4   0xF884 0x003E      STRB     R0,[R4, #+62]
   1376          
   1377              /* Process Unlocked */
   1378              __HAL_UNLOCK(hi2c);
   \      0x2E8   0x2000             MOVS     R0,#+0
   \      0x2EA   0xF884 0x003C      STRB     R0,[R4, #+60]
   1379          
   1380              return HAL_OK;
   \      0x2EE   0x2000             MOVS     R0,#+0
   \      0x2F0   0xE000             B.N      ??HAL_I2C_Master_Receive_2
   1381            }
   1382            else
   1383            {
   1384              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_0: (+1)
   \      0x2F2   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_2: (+1)
   \      0x2F4   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   1385            }
   1386          }
   1387          
   1388          /**
   1389            * @brief  Transmits in slave mode an amount of data in blocking mode.
   1390            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1391            *                the configuration information for the specified I2C.
   1392            * @param  pData Pointer to data buffer
   1393            * @param  Size Amount of data to be sent
   1394            * @param  Timeout Timeout duration
   1395            * @retval HAL status
   1396            */

   \                                 In section .text, align 2, keep-with-next
   1397          HAL_StatusTypeDef HAL_I2C_Slave_Transmit(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1398          {
   \                     HAL_I2C_Slave_Transmit: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1399            /* Init tickstart for timeout management*/
   1400            uint32_t tickstart = HAL_GetTick();
   \        0xC   0x.... 0x....      BL       HAL_GetTick
   \       0x10   0x4680             MOV      R8,R0
   1401          
   1402            if (hi2c->State == HAL_I2C_STATE_READY)
   \       0x12   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x16   0x2820             CMP      R0,#+32
   \       0x18   0xF040 0x80BC      BNE.W    ??HAL_I2C_Slave_Transmit_0
   1403            {
   1404              if ((pData == NULL) || (Size == 0U))
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD003             BEQ.N    ??HAL_I2C_Slave_Transmit_1
   \       0x20   0x0030             MOVS     R0,R6
   \       0x22   0xB280             UXTH     R0,R0
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_2
   1405              {
   1406                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Transmit_1: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE0B4             B.N      ??HAL_I2C_Slave_Transmit_3
   1407              }
   1408          
   1409              /* Process Locked */
   1410              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_2: (+1)
   \       0x2C   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0x30   0x2801             CMP      R0,#+1
   \       0x32   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_4
   \       0x34   0x2002             MOVS     R0,#+2
   \       0x36   0xE0AE             B.N      ??HAL_I2C_Slave_Transmit_3
   \                     ??HAL_I2C_Slave_Transmit_4: (+1)
   \       0x38   0x2001             MOVS     R0,#+1
   \       0x3A   0xF885 0x003C      STRB     R0,[R5, #+60]
   1411          
   1412              /* Check if the I2C is already enabled */
   1413              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x3E   0x6828             LDR      R0,[R5, #+0]
   \       0x40   0x6800             LDR      R0,[R0, #+0]
   \       0x42   0x07C0             LSLS     R0,R0,#+31
   \       0x44   0xD405             BMI.N    ??HAL_I2C_Slave_Transmit_5
   1414              {
   1415                /* Enable I2C peripheral */
   1416                __HAL_I2C_ENABLE(hi2c);
   \       0x46   0x6828             LDR      R0,[R5, #+0]
   \       0x48   0x6800             LDR      R0,[R0, #+0]
   \       0x4A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x4E   0x6829             LDR      R1,[R5, #+0]
   \       0x50   0x6008             STR      R0,[R1, #+0]
   1417              }
   1418          
   1419              /* Disable Pos */
   1420              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Slave_Transmit_5: (+1)
   \       0x52   0x6828             LDR      R0,[R5, #+0]
   \       0x54   0x6800             LDR      R0,[R0, #+0]
   \       0x56   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x5A   0x6829             LDR      R1,[R5, #+0]
   \       0x5C   0x6008             STR      R0,[R1, #+0]
   1421          
   1422              hi2c->State       = HAL_I2C_STATE_BUSY_TX;
   \       0x5E   0x2021             MOVS     R0,#+33
   \       0x60   0xF885 0x003D      STRB     R0,[R5, #+61]
   1423              hi2c->Mode        = HAL_I2C_MODE_SLAVE;
   \       0x64   0x2020             MOVS     R0,#+32
   \       0x66   0xF885 0x003E      STRB     R0,[R5, #+62]
   1424              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x6428             STR      R0,[R5, #+64]
   1425          
   1426              /* Prepare transfer parameters */
   1427              hi2c->pBuffPtr    = pData;
   \       0x6E   0x626C             STR      R4,[R5, #+36]
   1428              hi2c->XferCount   = Size;
   \       0x70   0x856E             STRH     R6,[R5, #+42]
   1429              hi2c->XferSize    = hi2c->XferCount;
   \       0x72   0x8D68             LDRH     R0,[R5, #+42]
   \       0x74   0x8528             STRH     R0,[R5, #+40]
   1430              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x76   0x.... 0x....      LDR.W    R0,??DataTable10
   \       0x7A   0x62E8             STR      R0,[R5, #+44]
   1431          
   1432              /* Enable Address Acknowledge */
   1433              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x7C   0x6828             LDR      R0,[R5, #+0]
   \       0x7E   0x6800             LDR      R0,[R0, #+0]
   \       0x80   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0x84   0x6829             LDR      R1,[R5, #+0]
   \       0x86   0x6008             STR      R0,[R1, #+0]
   1434          
   1435              /* Wait until ADDR flag is set */
   1436              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
   \       0x88   0x.... 0x....      LDR.W    R9,??DataTable13
   \       0x8C   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x90   0x003B             MOVS     R3,R7
   \       0x92   0x2200             MOVS     R2,#+0
   \       0x94   0x4649             MOV      R1,R9
   \       0x96   0x0028             MOVS     R0,R5
   \       0x98   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_6
   1437              {
   1438                return HAL_ERROR;
   \       0xA0   0x2001             MOVS     R0,#+1
   \       0xA2   0xE078             B.N      ??HAL_I2C_Slave_Transmit_3
   1439              }
   1440          
   1441              /* Clear ADDR flag */
   1442              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_6: (+1)
   \       0xA4   0x2000             MOVS     R0,#+0
   \       0xA6   0x9000             STR      R0,[SP, #+0]
   \       0xA8   0x6828             LDR      R0,[R5, #+0]
   \       0xAA   0x6940             LDR      R0,[R0, #+20]
   \       0xAC   0x9000             STR      R0,[SP, #+0]
   \       0xAE   0x6828             LDR      R0,[R5, #+0]
   \       0xB0   0x6980             LDR      R0,[R0, #+24]
   \       0xB2   0x9000             STR      R0,[SP, #+0]
   \       0xB4   0x9800             LDR      R0,[SP, #+0]
   1443          
   1444              /* If 10bit addressing mode is selected */
   1445              if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
   \       0xB6   0x6928             LDR      R0,[R5, #+16]
   \       0xB8   0xF5B0 0x4F40      CMP      R0,#+49152
   \       0xBC   0xD114             BNE.N    ??HAL_I2C_Slave_Transmit_7
   1446              {
   1447                /* Wait until ADDR flag is set */
   1448                if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
   \       0xBE   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0xC2   0x003B             MOVS     R3,R7
   \       0xC4   0x2200             MOVS     R2,#+0
   \       0xC6   0x4649             MOV      R1,R9
   \       0xC8   0x0028             MOVS     R0,R5
   \       0xCA   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \       0xCE   0x2800             CMP      R0,#+0
   \       0xD0   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_8
   1449                {
   1450                  return HAL_ERROR;
   \       0xD2   0x2001             MOVS     R0,#+1
   \       0xD4   0xE05F             B.N      ??HAL_I2C_Slave_Transmit_3
   1451                }
   1452          
   1453                /* Clear ADDR flag */
   1454                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_8: (+1)
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0x9000             STR      R0,[SP, #+0]
   \       0xDA   0x6828             LDR      R0,[R5, #+0]
   \       0xDC   0x6940             LDR      R0,[R0, #+20]
   \       0xDE   0x9000             STR      R0,[SP, #+0]
   \       0xE0   0x6828             LDR      R0,[R5, #+0]
   \       0xE2   0x6980             LDR      R0,[R0, #+24]
   \       0xE4   0x9000             STR      R0,[SP, #+0]
   \       0xE6   0x9800             LDR      R0,[SP, #+0]
   1455              }
   1456          
   1457              while (hi2c->XferSize > 0U)
   \                     ??HAL_I2C_Slave_Transmit_7: (+1)
   \       0xE8   0x8D28             LDRH     R0,[R5, #+40]
   \       0xEA   0x2800             CMP      R0,#+0
   \       0xEC   0xD030             BEQ.N    ??HAL_I2C_Slave_Transmit_9
   1458              {
   1459                /* Wait until TXE flag is set */
   1460                if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \       0xEE   0x4642             MOV      R2,R8
   \       0xF0   0x0039             MOVS     R1,R7
   \       0xF2   0x0028             MOVS     R0,R5
   \       0xF4   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \       0xF8   0x2800             CMP      R0,#+0
   \       0xFA   0xD007             BEQ.N    ??HAL_I2C_Slave_Transmit_10
   1461                {
   1462                  /* Disable Address Acknowledge */
   1463                  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0xFC   0x6828             LDR      R0,[R5, #+0]
   \       0xFE   0x6800             LDR      R0,[R0, #+0]
   \      0x100   0xF430 0x6080      BICS     R0,R0,#0x400
   \      0x104   0x6829             LDR      R1,[R5, #+0]
   \      0x106   0x6008             STR      R0,[R1, #+0]
   1464          
   1465                  return HAL_ERROR;
   \      0x108   0x2001             MOVS     R0,#+1
   \      0x10A   0xE044             B.N      ??HAL_I2C_Slave_Transmit_3
   1466                }
   1467          
   1468                /* Write data to DR */
   1469                hi2c->Instance->DR = *hi2c->pBuffPtr;
   \                     ??HAL_I2C_Slave_Transmit_10: (+1)
   \      0x10C   0x6A68             LDR      R0,[R5, #+36]
   \      0x10E   0x7800             LDRB     R0,[R0, #+0]
   \      0x110   0x6829             LDR      R1,[R5, #+0]
   \      0x112   0x6108             STR      R0,[R1, #+16]
   1470          
   1471                /* Increment Buffer pointer */
   1472                hi2c->pBuffPtr++;
   \      0x114   0x6A68             LDR      R0,[R5, #+36]
   \      0x116   0x1C40             ADDS     R0,R0,#+1
   \      0x118   0x6268             STR      R0,[R5, #+36]
   1473          
   1474                /* Update counter */
   1475                hi2c->XferCount--;
   \      0x11A   0x8D68             LDRH     R0,[R5, #+42]
   \      0x11C   0x1E40             SUBS     R0,R0,#+1
   \      0x11E   0x8568             STRH     R0,[R5, #+42]
   1476                hi2c->XferSize--;
   \      0x120   0x8D28             LDRH     R0,[R5, #+40]
   \      0x122   0x1E40             SUBS     R0,R0,#+1
   \      0x124   0x8528             STRH     R0,[R5, #+40]
   1477          
   1478                if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
   \      0x126   0x6828             LDR      R0,[R5, #+0]
   \      0x128   0x6940             LDR      R0,[R0, #+20]
   \      0x12A   0x0740             LSLS     R0,R0,#+29
   \      0x12C   0xD5DC             BPL.N    ??HAL_I2C_Slave_Transmit_7
   \      0x12E   0x8D28             LDRH     R0,[R5, #+40]
   \      0x130   0x2800             CMP      R0,#+0
   \      0x132   0xD0D9             BEQ.N    ??HAL_I2C_Slave_Transmit_7
   1479                {
   1480                  /* Write data to DR */
   1481                  hi2c->Instance->DR = *hi2c->pBuffPtr;
   \      0x134   0x6A68             LDR      R0,[R5, #+36]
   \      0x136   0x7800             LDRB     R0,[R0, #+0]
   \      0x138   0x6829             LDR      R1,[R5, #+0]
   \      0x13A   0x6108             STR      R0,[R1, #+16]
   1482          
   1483                  /* Increment Buffer pointer */
   1484                  hi2c->pBuffPtr++;
   \      0x13C   0x6A68             LDR      R0,[R5, #+36]
   \      0x13E   0x1C40             ADDS     R0,R0,#+1
   \      0x140   0x6268             STR      R0,[R5, #+36]
   1485          
   1486                  /* Update counter */
   1487                  hi2c->XferCount--;
   \      0x142   0x8D68             LDRH     R0,[R5, #+42]
   \      0x144   0x1E40             SUBS     R0,R0,#+1
   \      0x146   0x8568             STRH     R0,[R5, #+42]
   1488                  hi2c->XferSize--;
   \      0x148   0x8D28             LDRH     R0,[R5, #+40]
   \      0x14A   0x1E40             SUBS     R0,R0,#+1
   \      0x14C   0x8528             STRH     R0,[R5, #+40]
   \      0x14E   0xE7CB             B.N      ??HAL_I2C_Slave_Transmit_7
   1489                }
   1490              }
   1491          
   1492              /* Wait until AF flag is set */
   1493              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_AF, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Slave_Transmit_9: (+1)
   \      0x150   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \      0x154   0x003B             MOVS     R3,R7
   \      0x156   0x2200             MOVS     R2,#+0
   \      0x158   0xF45F 0x3182      MOVS     R1,#+66560
   \      0x15C   0x0028             MOVS     R0,R5
   \      0x15E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \      0x162   0x2800             CMP      R0,#+0
   \      0x164   0xD001             BEQ.N    ??HAL_I2C_Slave_Transmit_11
   1494              {
   1495                return HAL_ERROR;
   \      0x166   0x2001             MOVS     R0,#+1
   \      0x168   0xE015             B.N      ??HAL_I2C_Slave_Transmit_3
   1496              }
   1497          
   1498              /* Clear AF flag */
   1499              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??HAL_I2C_Slave_Transmit_11: (+1)
   \      0x16A   0xF47F 0x6080      MVNS     R0,#+1024
   \      0x16E   0x6829             LDR      R1,[R5, #+0]
   \      0x170   0x6148             STR      R0,[R1, #+20]
   1500          
   1501              /* Disable Address Acknowledge */
   1502              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \      0x172   0x6828             LDR      R0,[R5, #+0]
   \      0x174   0x6800             LDR      R0,[R0, #+0]
   \      0x176   0xF430 0x6080      BICS     R0,R0,#0x400
   \      0x17A   0x6829             LDR      R1,[R5, #+0]
   \      0x17C   0x6008             STR      R0,[R1, #+0]
   1503          
   1504              hi2c->State = HAL_I2C_STATE_READY;
   \      0x17E   0x2020             MOVS     R0,#+32
   \      0x180   0xF885 0x003D      STRB     R0,[R5, #+61]
   1505              hi2c->Mode = HAL_I2C_MODE_NONE;
   \      0x184   0x2000             MOVS     R0,#+0
   \      0x186   0xF885 0x003E      STRB     R0,[R5, #+62]
   1506          
   1507              /* Process Unlocked */
   1508              __HAL_UNLOCK(hi2c);
   \      0x18A   0x2000             MOVS     R0,#+0
   \      0x18C   0xF885 0x003C      STRB     R0,[R5, #+60]
   1509          
   1510              return HAL_OK;
   \      0x190   0x2000             MOVS     R0,#+0
   \      0x192   0xE000             B.N      ??HAL_I2C_Slave_Transmit_3
   1511            }
   1512            else
   1513            {
   1514              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_0: (+1)
   \      0x194   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_3: (+1)
   \      0x196   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   1515            }
   1516          }
   1517          
   1518          /**
   1519            * @brief  Receive in slave mode an amount of data in blocking mode
   1520            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1521            *         the configuration information for the specified I2C.
   1522            * @param  pData Pointer to data buffer
   1523            * @param  Size Amount of data to be sent
   1524            * @param  Timeout Timeout duration
   1525            * @retval HAL status
   1526            */

   \                                 In section .text, align 2, keep-with-next
   1527          HAL_StatusTypeDef HAL_I2C_Slave_Receive(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   1528          {
   \                     HAL_I2C_Slave_Receive: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   1529            /* Init tickstart for timeout management*/
   1530            uint32_t tickstart = HAL_GetTick();
   \        0xC   0x.... 0x....      BL       HAL_GetTick
   \       0x10   0x4680             MOV      R8,R0
   1531          
   1532            if (hi2c->State == HAL_I2C_STATE_READY)
   \       0x12   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x16   0x2820             CMP      R0,#+32
   \       0x18   0xF040 0x80AC      BNE.W    ??HAL_I2C_Slave_Receive_0
   1533            {
   1534              if ((pData == NULL) || (Size == (uint16_t)0))
   \       0x1C   0x2C00             CMP      R4,#+0
   \       0x1E   0xD003             BEQ.N    ??HAL_I2C_Slave_Receive_1
   \       0x20   0x0030             MOVS     R0,R6
   \       0x22   0xB280             UXTH     R0,R0
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_2
   1535              {
   1536                return HAL_ERROR;
   \                     ??HAL_I2C_Slave_Receive_1: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE0A4             B.N      ??HAL_I2C_Slave_Receive_3
   1537              }
   1538          
   1539              /* Process Locked */
   1540              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Receive_2: (+1)
   \       0x2C   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0x30   0x2801             CMP      R0,#+1
   \       0x32   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_4
   \       0x34   0x2002             MOVS     R0,#+2
   \       0x36   0xE09E             B.N      ??HAL_I2C_Slave_Receive_3
   \                     ??HAL_I2C_Slave_Receive_4: (+1)
   \       0x38   0x2001             MOVS     R0,#+1
   \       0x3A   0xF885 0x003C      STRB     R0,[R5, #+60]
   1541          
   1542              /* Check if the I2C is already enabled */
   1543              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x3E   0x6828             LDR      R0,[R5, #+0]
   \       0x40   0x6800             LDR      R0,[R0, #+0]
   \       0x42   0x07C0             LSLS     R0,R0,#+31
   \       0x44   0xD405             BMI.N    ??HAL_I2C_Slave_Receive_5
   1544              {
   1545                /* Enable I2C peripheral */
   1546                __HAL_I2C_ENABLE(hi2c);
   \       0x46   0x6828             LDR      R0,[R5, #+0]
   \       0x48   0x6800             LDR      R0,[R0, #+0]
   \       0x4A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x4E   0x6829             LDR      R1,[R5, #+0]
   \       0x50   0x6008             STR      R0,[R1, #+0]
   1547              }
   1548          
   1549              /* Disable Pos */
   1550              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Slave_Receive_5: (+1)
   \       0x52   0x6828             LDR      R0,[R5, #+0]
   \       0x54   0x6800             LDR      R0,[R0, #+0]
   \       0x56   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x5A   0x6829             LDR      R1,[R5, #+0]
   \       0x5C   0x6008             STR      R0,[R1, #+0]
   1551          
   1552              hi2c->State       = HAL_I2C_STATE_BUSY_RX;
   \       0x5E   0x2022             MOVS     R0,#+34
   \       0x60   0xF885 0x003D      STRB     R0,[R5, #+61]
   1553              hi2c->Mode        = HAL_I2C_MODE_SLAVE;
   \       0x64   0x2020             MOVS     R0,#+32
   \       0x66   0xF885 0x003E      STRB     R0,[R5, #+62]
   1554              hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x6428             STR      R0,[R5, #+64]
   1555          
   1556              /* Prepare transfer parameters */
   1557              hi2c->pBuffPtr    = pData;
   \       0x6E   0x626C             STR      R4,[R5, #+36]
   1558              hi2c->XferCount   = Size;
   \       0x70   0x856E             STRH     R6,[R5, #+42]
   1559              hi2c->XferSize    = hi2c->XferCount;
   \       0x72   0x8D68             LDRH     R0,[R5, #+42]
   \       0x74   0x8528             STRH     R0,[R5, #+40]
   1560              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x76   0x.... 0x....      LDR.W    R0,??DataTable10
   \       0x7A   0x62E8             STR      R0,[R5, #+44]
   1561          
   1562              /* Enable Address Acknowledge */
   1563              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x7C   0x6828             LDR      R0,[R5, #+0]
   \       0x7E   0x6800             LDR      R0,[R0, #+0]
   \       0x80   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0x84   0x6829             LDR      R1,[R5, #+0]
   \       0x86   0x6008             STR      R0,[R1, #+0]
   1564          
   1565              /* Wait until ADDR flag is set */
   1566              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, RESET, Timeout, tickstart) != HAL_OK)
   \       0x88   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x8C   0x003B             MOVS     R3,R7
   \       0x8E   0x2200             MOVS     R2,#+0
   \       0x90   0x.... 0x....      LDR.W    R1,??DataTable13
   \       0x94   0x0028             MOVS     R0,R5
   \       0x96   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \       0x9A   0x2800             CMP      R0,#+0
   \       0x9C   0xD001             BEQ.N    ??HAL_I2C_Slave_Receive_6
   1567              {
   1568                return HAL_ERROR;
   \       0x9E   0x2001             MOVS     R0,#+1
   \       0xA0   0xE069             B.N      ??HAL_I2C_Slave_Receive_3
   1569              }
   1570          
   1571              /* Clear ADDR flag */
   1572              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Receive_6: (+1)
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0x9000             STR      R0,[SP, #+0]
   \       0xA6   0x6828             LDR      R0,[R5, #+0]
   \       0xA8   0x6940             LDR      R0,[R0, #+20]
   \       0xAA   0x9000             STR      R0,[SP, #+0]
   \       0xAC   0x6828             LDR      R0,[R5, #+0]
   \       0xAE   0x6980             LDR      R0,[R0, #+24]
   \       0xB0   0x9000             STR      R0,[SP, #+0]
   \       0xB2   0x9800             LDR      R0,[SP, #+0]
   1573          
   1574              while (hi2c->XferSize > 0U)
   \                     ??HAL_I2C_Slave_Receive_7: (+1)
   \       0xB4   0x8D28             LDRH     R0,[R5, #+40]
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD030             BEQ.N    ??HAL_I2C_Slave_Receive_8
   1575              {
   1576                /* Wait until RXNE flag is set */
   1577                if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \       0xBA   0x4642             MOV      R2,R8
   \       0xBC   0x0039             MOVS     R1,R7
   \       0xBE   0x0028             MOVS     R0,R5
   \       0xC0   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xD007             BEQ.N    ??HAL_I2C_Slave_Receive_9
   1578                {
   1579                  /* Disable Address Acknowledge */
   1580                  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0xC8   0x6828             LDR      R0,[R5, #+0]
   \       0xCA   0x6800             LDR      R0,[R0, #+0]
   \       0xCC   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0xD0   0x6829             LDR      R1,[R5, #+0]
   \       0xD2   0x6008             STR      R0,[R1, #+0]
   1581          
   1582                  return HAL_ERROR;
   \       0xD4   0x2001             MOVS     R0,#+1
   \       0xD6   0xE04E             B.N      ??HAL_I2C_Slave_Receive_3
   1583                }
   1584          
   1585                /* Read data from DR */
   1586                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \                     ??HAL_I2C_Slave_Receive_9: (+1)
   \       0xD8   0x6828             LDR      R0,[R5, #+0]
   \       0xDA   0x6900             LDR      R0,[R0, #+16]
   \       0xDC   0x6A69             LDR      R1,[R5, #+36]
   \       0xDE   0x7008             STRB     R0,[R1, #+0]
   1587          
   1588                /* Increment Buffer pointer */
   1589                hi2c->pBuffPtr++;
   \       0xE0   0x6A68             LDR      R0,[R5, #+36]
   \       0xE2   0x1C40             ADDS     R0,R0,#+1
   \       0xE4   0x6268             STR      R0,[R5, #+36]
   1590          
   1591                /* Update counter */
   1592                hi2c->XferSize--;
   \       0xE6   0x8D28             LDRH     R0,[R5, #+40]
   \       0xE8   0x1E40             SUBS     R0,R0,#+1
   \       0xEA   0x8528             STRH     R0,[R5, #+40]
   1593                hi2c->XferCount--;
   \       0xEC   0x8D68             LDRH     R0,[R5, #+42]
   \       0xEE   0x1E40             SUBS     R0,R0,#+1
   \       0xF0   0x8568             STRH     R0,[R5, #+42]
   1594          
   1595                if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
   \       0xF2   0x6828             LDR      R0,[R5, #+0]
   \       0xF4   0x6940             LDR      R0,[R0, #+20]
   \       0xF6   0x0740             LSLS     R0,R0,#+29
   \       0xF8   0xD5DC             BPL.N    ??HAL_I2C_Slave_Receive_7
   \       0xFA   0x8D28             LDRH     R0,[R5, #+40]
   \       0xFC   0x2800             CMP      R0,#+0
   \       0xFE   0xD0D9             BEQ.N    ??HAL_I2C_Slave_Receive_7
   1596                {
   1597                  /* Read data from DR */
   1598                  *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x100   0x6828             LDR      R0,[R5, #+0]
   \      0x102   0x6900             LDR      R0,[R0, #+16]
   \      0x104   0x6A69             LDR      R1,[R5, #+36]
   \      0x106   0x7008             STRB     R0,[R1, #+0]
   1599          
   1600                  /* Increment Buffer pointer */
   1601                  hi2c->pBuffPtr++;
   \      0x108   0x6A68             LDR      R0,[R5, #+36]
   \      0x10A   0x1C40             ADDS     R0,R0,#+1
   \      0x10C   0x6268             STR      R0,[R5, #+36]
   1602          
   1603                  /* Update counter */
   1604                  hi2c->XferSize--;
   \      0x10E   0x8D28             LDRH     R0,[R5, #+40]
   \      0x110   0x1E40             SUBS     R0,R0,#+1
   \      0x112   0x8528             STRH     R0,[R5, #+40]
   1605                  hi2c->XferCount--;
   \      0x114   0x8D68             LDRH     R0,[R5, #+42]
   \      0x116   0x1E40             SUBS     R0,R0,#+1
   \      0x118   0x8568             STRH     R0,[R5, #+42]
   \      0x11A   0xE7CB             B.N      ??HAL_I2C_Slave_Receive_7
   1606                }
   1607              }
   1608          
   1609              /* Wait until STOP flag is set */
   1610              if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Slave_Receive_8: (+1)
   \      0x11C   0x4642             MOV      R2,R8
   \      0x11E   0x0039             MOVS     R1,R7
   \      0x120   0x0028             MOVS     R0,R5
   \      0x122   0x.... 0x....      BL       I2C_WaitOnSTOPFlagUntilTimeout
   \      0x126   0x2800             CMP      R0,#+0
   \      0x128   0xD007             BEQ.N    ??HAL_I2C_Slave_Receive_10
   1611              {
   1612                /* Disable Address Acknowledge */
   1613                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \      0x12A   0x6828             LDR      R0,[R5, #+0]
   \      0x12C   0x6800             LDR      R0,[R0, #+0]
   \      0x12E   0xF430 0x6080      BICS     R0,R0,#0x400
   \      0x132   0x6829             LDR      R1,[R5, #+0]
   \      0x134   0x6008             STR      R0,[R1, #+0]
   1614          
   1615                return HAL_ERROR;
   \      0x136   0x2001             MOVS     R0,#+1
   \      0x138   0xE01D             B.N      ??HAL_I2C_Slave_Receive_3
   1616              }
   1617          
   1618              /* Clear STOP flag */
   1619              __HAL_I2C_CLEAR_STOPFLAG(hi2c);
   \                     ??HAL_I2C_Slave_Receive_10: (+1)
   \      0x13A   0x2000             MOVS     R0,#+0
   \      0x13C   0x9000             STR      R0,[SP, #+0]
   \      0x13E   0x6828             LDR      R0,[R5, #+0]
   \      0x140   0x6940             LDR      R0,[R0, #+20]
   \      0x142   0x9000             STR      R0,[SP, #+0]
   \      0x144   0x6828             LDR      R0,[R5, #+0]
   \      0x146   0x6800             LDR      R0,[R0, #+0]
   \      0x148   0xF050 0x0001      ORRS     R0,R0,#0x1
   \      0x14C   0x6829             LDR      R1,[R5, #+0]
   \      0x14E   0x6008             STR      R0,[R1, #+0]
   \      0x150   0x9800             LDR      R0,[SP, #+0]
   1620          
   1621              /* Disable Address Acknowledge */
   1622              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \      0x152   0x6828             LDR      R0,[R5, #+0]
   \      0x154   0x6800             LDR      R0,[R0, #+0]
   \      0x156   0xF430 0x6080      BICS     R0,R0,#0x400
   \      0x15A   0x6829             LDR      R1,[R5, #+0]
   \      0x15C   0x6008             STR      R0,[R1, #+0]
   1623          
   1624              hi2c->State = HAL_I2C_STATE_READY;
   \      0x15E   0x2020             MOVS     R0,#+32
   \      0x160   0xF885 0x003D      STRB     R0,[R5, #+61]
   1625              hi2c->Mode = HAL_I2C_MODE_NONE;
   \      0x164   0x2000             MOVS     R0,#+0
   \      0x166   0xF885 0x003E      STRB     R0,[R5, #+62]
   1626          
   1627              /* Process Unlocked */
   1628              __HAL_UNLOCK(hi2c);
   \      0x16A   0x2000             MOVS     R0,#+0
   \      0x16C   0xF885 0x003C      STRB     R0,[R5, #+60]
   1629          
   1630              return HAL_OK;
   \      0x170   0x2000             MOVS     R0,#+0
   \      0x172   0xE000             B.N      ??HAL_I2C_Slave_Receive_3
   1631            }
   1632            else
   1633            {
   1634              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_0: (+1)
   \      0x174   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_3: (+1)
   \      0x176   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   1635            }
   1636          }
   1637          
   1638          /**
   1639            * @brief  Transmit in master mode an amount of data in non-blocking mode with Interrupt
   1640            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1641            *                the configuration information for the specified I2C.
   1642            * @param  DevAddress Target device address: The device 7 bits address value
   1643            *         in datasheet must be shifted to the left before calling the interface
   1644            * @param  pData Pointer to data buffer
   1645            * @param  Size Amount of data to be sent
   1646            * @retval HAL status
   1647            */

   \                                 In section .text, align 2, keep-with-next
   1648          HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1649          {
   \                     HAL_I2C_Master_Transmit_IT: (+1)
   \        0x0   0xB438             PUSH     {R3-R5}
   \        0x2   0x0004             MOVS     R4,R0
   1650            __IO uint32_t count = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
   1651          
   1652            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x8   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \        0xC   0x2820             CMP      R0,#+32
   \        0xE   0xD163             BNE.N    ??HAL_I2C_Master_Transmit_IT_0
   1653            {
   1654              /* Wait until BUSY flag is reset */
   1655              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x2519             MOVS     R5,#+25
   \       0x18   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \       0x1C   0xF44F 0x757A      MOV      R5,#+1000
   \       0x20   0xFBB0 0xF5F5      UDIV     R5,R0,R5
   \       0x24   0x200A             MOVS     R0,#+10
   \       0x26   0x4345             MULS     R5,R0,R5
   \       0x28   0x9500             STR      R5,[SP, #+0]
   1656              do
   1657              {
   1658                count--;
   \                     ??HAL_I2C_Master_Transmit_IT_1: (+1)
   \       0x2A   0x9800             LDR      R0,[SP, #+0]
   \       0x2C   0x1E40             SUBS     R0,R0,#+1
   \       0x2E   0x9000             STR      R0,[SP, #+0]
   1659                if (count == 0U)
   \       0x30   0x9800             LDR      R0,[SP, #+0]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD110             BNE.N    ??HAL_I2C_Master_Transmit_IT_2
   1660                {
   1661                  hi2c->PreviousState       = I2C_STATE_NONE;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x6320             STR      R0,[R4, #+48]
   1662                  hi2c->State               = HAL_I2C_STATE_READY;
   \       0x3A   0x2020             MOVS     R0,#+32
   \       0x3C   0xF884 0x003D      STRB     R0,[R4, #+61]
   1663                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xF884 0x003E      STRB     R0,[R4, #+62]
   1664                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0x46   0x6C20             LDR      R0,[R4, #+64]
   \       0x48   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x4C   0x6420             STR      R0,[R4, #+64]
   1665          
   1666                  /* Process Unlocked */
   1667                  __HAL_UNLOCK(hi2c);
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xF884 0x003C      STRB     R0,[R4, #+60]
   1668          
   1669                  return HAL_ERROR;
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0xE040             B.N      ??HAL_I2C_Master_Transmit_IT_3
   1670                }
   1671              }
   1672              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Master_Transmit_IT_2: (+1)
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x6980             LDR      R0,[R0, #+24]
   \       0x5C   0x0780             LSLS     R0,R0,#+30
   \       0x5E   0xD4E4             BMI.N    ??HAL_I2C_Master_Transmit_IT_1
   1673          
   1674              /* Process Locked */
   1675              __HAL_LOCK(hi2c);
   \       0x60   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \       0x64   0x2801             CMP      R0,#+1
   \       0x66   0xD101             BNE.N    ??HAL_I2C_Master_Transmit_IT_4
   \       0x68   0x2002             MOVS     R0,#+2
   \       0x6A   0xE036             B.N      ??HAL_I2C_Master_Transmit_IT_3
   \                     ??HAL_I2C_Master_Transmit_IT_4: (+1)
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0xF884 0x003C      STRB     R0,[R4, #+60]
   1676          
   1677              /* Check if the I2C is already enabled */
   1678              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x6800             LDR      R0,[R0, #+0]
   \       0x76   0x07C0             LSLS     R0,R0,#+31
   \       0x78   0xD405             BMI.N    ??HAL_I2C_Master_Transmit_IT_5
   1679              {
   1680                /* Enable I2C peripheral */
   1681                __HAL_I2C_ENABLE(hi2c);
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x6800             LDR      R0,[R0, #+0]
   \       0x7E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x82   0x6825             LDR      R5,[R4, #+0]
   \       0x84   0x6028             STR      R0,[R5, #+0]
   1682              }
   1683          
   1684              /* Disable Pos */
   1685              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Master_Transmit_IT_5: (+1)
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x6800             LDR      R0,[R0, #+0]
   \       0x8A   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x8E   0x6825             LDR      R5,[R4, #+0]
   \       0x90   0x6028             STR      R0,[R5, #+0]
   1686          
   1687              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0x92   0x2021             MOVS     R0,#+33
   \       0x94   0xF884 0x003D      STRB     R0,[R4, #+61]
   1688              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \       0x98   0x2010             MOVS     R0,#+16
   \       0x9A   0xF884 0x003E      STRB     R0,[R4, #+62]
   1689              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x6420             STR      R0,[R4, #+64]
   1690          
   1691              /* Prepare transfer parameters */
   1692              hi2c->pBuffPtr    = pData;
   \       0xA2   0x6262             STR      R2,[R4, #+36]
   1693              hi2c->XferCount   = Size;
   \       0xA4   0x8563             STRH     R3,[R4, #+42]
   1694              hi2c->XferSize    = hi2c->XferCount;
   \       0xA6   0x8D60             LDRH     R0,[R4, #+42]
   \       0xA8   0x8520             STRH     R0,[R4, #+40]
   1695              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0xAA   0x.... 0x....      LDR.W    R0,??DataTable11
   \       0xAE   0x62E0             STR      R0,[R4, #+44]
   1696              hi2c->Devaddress  = DevAddress;
   \       0xB0   0x0008             MOVS     R0,R1
   \       0xB2   0xB280             UXTH     R0,R0
   \       0xB4   0x6460             STR      R0,[R4, #+68]
   1697          
   1698              /* Generate Start */
   1699              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \       0xB6   0x6820             LDR      R0,[R4, #+0]
   \       0xB8   0x6800             LDR      R0,[R0, #+0]
   \       0xBA   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0xBE   0x6825             LDR      R5,[R4, #+0]
   \       0xC0   0x6028             STR      R0,[R5, #+0]
   1700          
   1701              /* Process Unlocked */
   1702              __HAL_UNLOCK(hi2c);
   \       0xC2   0x2000             MOVS     R0,#+0
   \       0xC4   0xF884 0x003C      STRB     R0,[R4, #+60]
   1703          
   1704              /* Note : The I2C interrupts must be enabled after unlocking current process
   1705                        to avoid the risk of I2C interrupt handle execution before current
   1706                        process unlock */
   1707              /* Enable EVT, BUF and ERR interrupt */
   1708              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0xC8   0x6820             LDR      R0,[R4, #+0]
   \       0xCA   0x6840             LDR      R0,[R0, #+4]
   \       0xCC   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \       0xD0   0x6825             LDR      R5,[R4, #+0]
   \       0xD2   0x6068             STR      R0,[R5, #+4]
   1709          
   1710              return HAL_OK;
   \       0xD4   0x2000             MOVS     R0,#+0
   \       0xD6   0xE000             B.N      ??HAL_I2C_Master_Transmit_IT_3
   1711            }
   1712            else
   1713            {
   1714              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_IT_0: (+1)
   \       0xD8   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_IT_3: (+1)
   \       0xDA   0xBC32             POP      {R1,R4,R5}
   \       0xDC   0x4770             BX       LR
   1715            }
   1716          }
   1717          
   1718          /**
   1719            * @brief  Receive in master mode an amount of data in non-blocking mode with Interrupt
   1720            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1721            *                the configuration information for the specified I2C.
   1722            * @param  DevAddress Target device address: The device 7 bits address value
   1723            *         in datasheet must be shifted to the left before calling the interface
   1724            * @param  pData Pointer to data buffer
   1725            * @param  Size Amount of data to be sent
   1726            * @retval HAL status
   1727            */

   \                                 In section .text, align 2, keep-with-next
   1728          HAL_StatusTypeDef HAL_I2C_Master_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1729          {
   \                     HAL_I2C_Master_Receive_IT: (+1)
   \        0x0   0xB438             PUSH     {R3-R5}
   \        0x2   0x0004             MOVS     R4,R0
   1730            __IO uint32_t count = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
   1731          
   1732            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x8   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \        0xC   0x2820             CMP      R0,#+32
   \        0xE   0xD169             BNE.N    ??HAL_I2C_Master_Receive_IT_0
   1733            {
   1734              /* Wait until BUSY flag is reset */
   1735              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \       0x10   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x2519             MOVS     R5,#+25
   \       0x18   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \       0x1C   0xF44F 0x757A      MOV      R5,#+1000
   \       0x20   0xFBB0 0xF5F5      UDIV     R5,R0,R5
   \       0x24   0x200A             MOVS     R0,#+10
   \       0x26   0x4345             MULS     R5,R0,R5
   \       0x28   0x9500             STR      R5,[SP, #+0]
   1736              do
   1737              {
   1738                count--;
   \                     ??HAL_I2C_Master_Receive_IT_1: (+1)
   \       0x2A   0x9800             LDR      R0,[SP, #+0]
   \       0x2C   0x1E40             SUBS     R0,R0,#+1
   \       0x2E   0x9000             STR      R0,[SP, #+0]
   1739                if (count == 0U)
   \       0x30   0x9800             LDR      R0,[SP, #+0]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD110             BNE.N    ??HAL_I2C_Master_Receive_IT_2
   1740                {
   1741                  hi2c->PreviousState       = I2C_STATE_NONE;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x6320             STR      R0,[R4, #+48]
   1742                  hi2c->State               = HAL_I2C_STATE_READY;
   \       0x3A   0x2020             MOVS     R0,#+32
   \       0x3C   0xF884 0x003D      STRB     R0,[R4, #+61]
   1743                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xF884 0x003E      STRB     R0,[R4, #+62]
   1744                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0x46   0x6C20             LDR      R0,[R4, #+64]
   \       0x48   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x4C   0x6420             STR      R0,[R4, #+64]
   1745          
   1746                  /* Process Unlocked */
   1747                  __HAL_UNLOCK(hi2c);
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xF884 0x003C      STRB     R0,[R4, #+60]
   1748          
   1749                  return HAL_ERROR;
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0xE046             B.N      ??HAL_I2C_Master_Receive_IT_3
   1750                }
   1751              }
   1752              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Master_Receive_IT_2: (+1)
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x6980             LDR      R0,[R0, #+24]
   \       0x5C   0x0780             LSLS     R0,R0,#+30
   \       0x5E   0xD4E4             BMI.N    ??HAL_I2C_Master_Receive_IT_1
   1753          
   1754              /* Process Locked */
   1755              __HAL_LOCK(hi2c);
   \       0x60   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \       0x64   0x2801             CMP      R0,#+1
   \       0x66   0xD101             BNE.N    ??HAL_I2C_Master_Receive_IT_4
   \       0x68   0x2002             MOVS     R0,#+2
   \       0x6A   0xE03C             B.N      ??HAL_I2C_Master_Receive_IT_3
   \                     ??HAL_I2C_Master_Receive_IT_4: (+1)
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0xF884 0x003C      STRB     R0,[R4, #+60]
   1756          
   1757              /* Check if the I2C is already enabled */
   1758              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x6800             LDR      R0,[R0, #+0]
   \       0x76   0x07C0             LSLS     R0,R0,#+31
   \       0x78   0xD405             BMI.N    ??HAL_I2C_Master_Receive_IT_5
   1759              {
   1760                /* Enable I2C peripheral */
   1761                __HAL_I2C_ENABLE(hi2c);
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x6800             LDR      R0,[R0, #+0]
   \       0x7E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x82   0x6825             LDR      R5,[R4, #+0]
   \       0x84   0x6028             STR      R0,[R5, #+0]
   1762              }
   1763          
   1764              /* Disable Pos */
   1765              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Master_Receive_IT_5: (+1)
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x6800             LDR      R0,[R0, #+0]
   \       0x8A   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x8E   0x6825             LDR      R5,[R4, #+0]
   \       0x90   0x6028             STR      R0,[R5, #+0]
   1766          
   1767              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x92   0x2022             MOVS     R0,#+34
   \       0x94   0xF884 0x003D      STRB     R0,[R4, #+61]
   1768              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \       0x98   0x2010             MOVS     R0,#+16
   \       0x9A   0xF884 0x003E      STRB     R0,[R4, #+62]
   1769              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x6420             STR      R0,[R4, #+64]
   1770          
   1771              /* Prepare transfer parameters */
   1772              hi2c->pBuffPtr    = pData;
   \       0xA2   0x6262             STR      R2,[R4, #+36]
   1773              hi2c->XferCount   = Size;
   \       0xA4   0x8563             STRH     R3,[R4, #+42]
   1774              hi2c->XferSize    = hi2c->XferCount;
   \       0xA6   0x8D60             LDRH     R0,[R4, #+42]
   \       0xA8   0x8520             STRH     R0,[R4, #+40]
   1775              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0xAA   0x.... 0x....      LDR.W    R0,??DataTable11
   \       0xAE   0x62E0             STR      R0,[R4, #+44]
   1776              hi2c->Devaddress  = DevAddress;
   \       0xB0   0x0008             MOVS     R0,R1
   \       0xB2   0xB280             UXTH     R0,R0
   \       0xB4   0x6460             STR      R0,[R4, #+68]
   1777          
   1778              /* Enable Acknowledge */
   1779              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0xB6   0x6820             LDR      R0,[R4, #+0]
   \       0xB8   0x6800             LDR      R0,[R0, #+0]
   \       0xBA   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0xBE   0x6825             LDR      R5,[R4, #+0]
   \       0xC0   0x6028             STR      R0,[R5, #+0]
   1780          
   1781              /* Generate Start */
   1782              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \       0xC2   0x6820             LDR      R0,[R4, #+0]
   \       0xC4   0x6800             LDR      R0,[R0, #+0]
   \       0xC6   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0xCA   0x6825             LDR      R5,[R4, #+0]
   \       0xCC   0x6028             STR      R0,[R5, #+0]
   1783          
   1784              /* Process Unlocked */
   1785              __HAL_UNLOCK(hi2c);
   \       0xCE   0x2000             MOVS     R0,#+0
   \       0xD0   0xF884 0x003C      STRB     R0,[R4, #+60]
   1786          
   1787              /* Note : The I2C interrupts must be enabled after unlocking current process
   1788              to avoid the risk of I2C interrupt handle execution before current
   1789              process unlock */
   1790          
   1791              /* Enable EVT, BUF and ERR interrupt */
   1792              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0xD4   0x6820             LDR      R0,[R4, #+0]
   \       0xD6   0x6840             LDR      R0,[R0, #+4]
   \       0xD8   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \       0xDC   0x6825             LDR      R5,[R4, #+0]
   \       0xDE   0x6068             STR      R0,[R5, #+4]
   1793          
   1794              return HAL_OK;
   \       0xE0   0x2000             MOVS     R0,#+0
   \       0xE2   0xE000             B.N      ??HAL_I2C_Master_Receive_IT_3
   1795            }
   1796            else
   1797            {
   1798              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_IT_0: (+1)
   \       0xE4   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_IT_3: (+1)
   \       0xE6   0xBC32             POP      {R1,R4,R5}
   \       0xE8   0x4770             BX       LR
   1799            }
   1800          }
   1801          
   1802          /**
   1803            * @brief  Transmit in slave mode an amount of data in non-blocking mode with Interrupt
   1804            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1805            *         the configuration information for the specified I2C.
   1806            * @param  pData Pointer to data buffer
   1807            * @param  Size Amount of data to be sent
   1808            * @retval HAL status
   1809            */

   \                                 In section .text, align 2, keep-with-next
   1810          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1811          {
   \                     HAL_I2C_Slave_Transmit_IT: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0003             MOVS     R3,R0
   1812          
   1813            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x4   0xF893 0x003D      LDRB     R0,[R3, #+61]
   \        0x8   0x2820             CMP      R0,#+32
   \        0xA   0xD140             BNE.N    ??HAL_I2C_Slave_Transmit_IT_0
   1814            {
   1815              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD003             BEQ.N    ??HAL_I2C_Slave_Transmit_IT_1
   \       0x10   0x0010             MOVS     R0,R2
   \       0x12   0xB280             UXTH     R0,R0
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_IT_2
   1816              {
   1817                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Transmit_IT_1: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE039             B.N      ??HAL_I2C_Slave_Transmit_IT_3
   1818              }
   1819          
   1820              /* Process Locked */
   1821              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_IT_2: (+1)
   \       0x1C   0xF893 0x003C      LDRB     R0,[R3, #+60]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_IT_4
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0xE033             B.N      ??HAL_I2C_Slave_Transmit_IT_3
   \                     ??HAL_I2C_Slave_Transmit_IT_4: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xF883 0x003C      STRB     R0,[R3, #+60]
   1822          
   1823              /* Check if the I2C is already enabled */
   1824              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x2E   0x6818             LDR      R0,[R3, #+0]
   \       0x30   0x6800             LDR      R0,[R0, #+0]
   \       0x32   0x07C0             LSLS     R0,R0,#+31
   \       0x34   0xD405             BMI.N    ??HAL_I2C_Slave_Transmit_IT_5
   1825              {
   1826                /* Enable I2C peripheral */
   1827                __HAL_I2C_ENABLE(hi2c);
   \       0x36   0x6818             LDR      R0,[R3, #+0]
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x3E   0x681C             LDR      R4,[R3, #+0]
   \       0x40   0x6020             STR      R0,[R4, #+0]
   1828              }
   1829          
   1830              /* Disable Pos */
   1831              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Slave_Transmit_IT_5: (+1)
   \       0x42   0x6818             LDR      R0,[R3, #+0]
   \       0x44   0x6800             LDR      R0,[R0, #+0]
   \       0x46   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x4A   0x681C             LDR      R4,[R3, #+0]
   \       0x4C   0x6020             STR      R0,[R4, #+0]
   1832          
   1833              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0x4E   0x2021             MOVS     R0,#+33
   \       0x50   0xF883 0x003D      STRB     R0,[R3, #+61]
   1834              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \       0x54   0x2020             MOVS     R0,#+32
   \       0x56   0xF883 0x003E      STRB     R0,[R3, #+62]
   1835              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x6418             STR      R0,[R3, #+64]
   1836          
   1837              /* Prepare transfer parameters */
   1838              hi2c->pBuffPtr    = pData;
   \       0x5E   0x6259             STR      R1,[R3, #+36]
   1839              hi2c->XferCount   = Size;
   \       0x60   0x855A             STRH     R2,[R3, #+42]
   1840              hi2c->XferSize    = hi2c->XferCount;
   \       0x62   0x8D58             LDRH     R0,[R3, #+42]
   \       0x64   0x8518             STRH     R0,[R3, #+40]
   1841              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x66   0x.... 0x....      LDR.W    R0,??DataTable11
   \       0x6A   0x62D8             STR      R0,[R3, #+44]
   1842          
   1843              /* Enable Address Acknowledge */
   1844              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x6C   0x6818             LDR      R0,[R3, #+0]
   \       0x6E   0x6800             LDR      R0,[R0, #+0]
   \       0x70   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0x74   0x681C             LDR      R4,[R3, #+0]
   \       0x76   0x6020             STR      R0,[R4, #+0]
   1845          
   1846              /* Process Unlocked */
   1847              __HAL_UNLOCK(hi2c);
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0xF883 0x003C      STRB     R0,[R3, #+60]
   1848          
   1849              /* Note : The I2C interrupts must be enabled after unlocking current process
   1850                        to avoid the risk of I2C interrupt handle execution before current
   1851                        process unlock */
   1852          
   1853              /* Enable EVT, BUF and ERR interrupt */
   1854              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0x7E   0x6818             LDR      R0,[R3, #+0]
   \       0x80   0x6840             LDR      R0,[R0, #+4]
   \       0x82   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \       0x86   0x681C             LDR      R4,[R3, #+0]
   \       0x88   0x6060             STR      R0,[R4, #+4]
   1855          
   1856              return HAL_OK;
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0xE000             B.N      ??HAL_I2C_Slave_Transmit_IT_3
   1857            }
   1858            else
   1859            {
   1860              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_IT_0: (+1)
   \       0x8E   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_IT_3: (+1)
   \       0x90   0xBC10             POP      {R4}
   \       0x92   0x4770             BX       LR
   1861            }
   1862          }
   1863          
   1864          /**
   1865            * @brief  Receive in slave mode an amount of data in non-blocking mode with Interrupt
   1866            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1867            *                the configuration information for the specified I2C.
   1868            * @param  pData Pointer to data buffer
   1869            * @param  Size Amount of data to be sent
   1870            * @retval HAL status
   1871            */

   \                                 In section .text, align 2, keep-with-next
   1872          HAL_StatusTypeDef HAL_I2C_Slave_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   1873          {
   \                     HAL_I2C_Slave_Receive_IT: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0003             MOVS     R3,R0
   1874          
   1875            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x4   0xF893 0x003D      LDRB     R0,[R3, #+61]
   \        0x8   0x2820             CMP      R0,#+32
   \        0xA   0xD140             BNE.N    ??HAL_I2C_Slave_Receive_IT_0
   1876            {
   1877              if ((pData == NULL) || (Size == 0U))
   \        0xC   0x2900             CMP      R1,#+0
   \        0xE   0xD003             BEQ.N    ??HAL_I2C_Slave_Receive_IT_1
   \       0x10   0x0010             MOVS     R0,R2
   \       0x12   0xB280             UXTH     R0,R0
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_IT_2
   1878              {
   1879                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Receive_IT_1: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xE039             B.N      ??HAL_I2C_Slave_Receive_IT_3
   1880              }
   1881          
   1882              /* Process Locked */
   1883              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Receive_IT_2: (+1)
   \       0x1C   0xF893 0x003C      LDRB     R0,[R3, #+60]
   \       0x20   0x2801             CMP      R0,#+1
   \       0x22   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_IT_4
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0xE033             B.N      ??HAL_I2C_Slave_Receive_IT_3
   \                     ??HAL_I2C_Slave_Receive_IT_4: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xF883 0x003C      STRB     R0,[R3, #+60]
   1884          
   1885              /* Check if the I2C is already enabled */
   1886              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x2E   0x6818             LDR      R0,[R3, #+0]
   \       0x30   0x6800             LDR      R0,[R0, #+0]
   \       0x32   0x07C0             LSLS     R0,R0,#+31
   \       0x34   0xD405             BMI.N    ??HAL_I2C_Slave_Receive_IT_5
   1887              {
   1888                /* Enable I2C peripheral */
   1889                __HAL_I2C_ENABLE(hi2c);
   \       0x36   0x6818             LDR      R0,[R3, #+0]
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x3E   0x681C             LDR      R4,[R3, #+0]
   \       0x40   0x6020             STR      R0,[R4, #+0]
   1890              }
   1891          
   1892              /* Disable Pos */
   1893              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Slave_Receive_IT_5: (+1)
   \       0x42   0x6818             LDR      R0,[R3, #+0]
   \       0x44   0x6800             LDR      R0,[R0, #+0]
   \       0x46   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x4A   0x681C             LDR      R4,[R3, #+0]
   \       0x4C   0x6020             STR      R0,[R4, #+0]
   1894          
   1895              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x4E   0x2022             MOVS     R0,#+34
   \       0x50   0xF883 0x003D      STRB     R0,[R3, #+61]
   1896              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \       0x54   0x2020             MOVS     R0,#+32
   \       0x56   0xF883 0x003E      STRB     R0,[R3, #+62]
   1897              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x6418             STR      R0,[R3, #+64]
   1898          
   1899              /* Prepare transfer parameters */
   1900              hi2c->pBuffPtr    = pData;
   \       0x5E   0x6259             STR      R1,[R3, #+36]
   1901              hi2c->XferCount   = Size;
   \       0x60   0x855A             STRH     R2,[R3, #+42]
   1902              hi2c->XferSize    = hi2c->XferCount;
   \       0x62   0x8D58             LDRH     R0,[R3, #+42]
   \       0x64   0x8518             STRH     R0,[R3, #+40]
   1903              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x66   0x.... 0x....      LDR.W    R0,??DataTable11
   \       0x6A   0x62D8             STR      R0,[R3, #+44]
   1904          
   1905              /* Enable Address Acknowledge */
   1906              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x6C   0x6818             LDR      R0,[R3, #+0]
   \       0x6E   0x6800             LDR      R0,[R0, #+0]
   \       0x70   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0x74   0x681C             LDR      R4,[R3, #+0]
   \       0x76   0x6020             STR      R0,[R4, #+0]
   1907          
   1908              /* Process Unlocked */
   1909              __HAL_UNLOCK(hi2c);
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0xF883 0x003C      STRB     R0,[R3, #+60]
   1910          
   1911              /* Note : The I2C interrupts must be enabled after unlocking current process
   1912                        to avoid the risk of I2C interrupt handle execution before current
   1913                        process unlock */
   1914          
   1915              /* Enable EVT, BUF and ERR interrupt */
   1916              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0x7E   0x6818             LDR      R0,[R3, #+0]
   \       0x80   0x6840             LDR      R0,[R0, #+4]
   \       0x82   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \       0x86   0x681C             LDR      R4,[R3, #+0]
   \       0x88   0x6060             STR      R0,[R4, #+4]
   1917          
   1918              return HAL_OK;
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0xE000             B.N      ??HAL_I2C_Slave_Receive_IT_3
   1919            }
   1920            else
   1921            {
   1922              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_IT_0: (+1)
   \       0x8E   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_IT_3: (+1)
   \       0x90   0xBC10             POP      {R4}
   \       0x92   0x4770             BX       LR
   1923            }
   1924          }
   1925          
   1926          /**
   1927            * @brief  Transmit in master mode an amount of data in non-blocking mode with DMA
   1928            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   1929            *                the configuration information for the specified I2C.
   1930            * @param  DevAddress Target device address: The device 7 bits address value
   1931            *         in datasheet must be shifted to the left before calling the interface
   1932            * @param  pData Pointer to data buffer
   1933            * @param  Size Amount of data to be sent
   1934            * @retval HAL status
   1935            */

   \                                 In section .text, align 2, keep-with-next
   1936          HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   1937          {
   \                     HAL_I2C_Master_Transmit_DMA: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   1938            __IO uint32_t count = 0U;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x9000             STR      R0,[SP, #+0]
   1939            HAL_StatusTypeDef dmaxferstatus;
   1940          
   1941            if (hi2c->State == HAL_I2C_STATE_READY)
   \       0x10   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x14   0x2820             CMP      R0,#+32
   \       0x16   0xF040 0x80B9      BNE.W    ??HAL_I2C_Master_Transmit_DMA_0
   1942            {
   1943              /* Wait until BUSY flag is reset */
   1944              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x1E   0x6800             LDR      R0,[R0, #+0]
   \       0x20   0x2119             MOVS     R1,#+25
   \       0x22   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x26   0xF44F 0x717A      MOV      R1,#+1000
   \       0x2A   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x2E   0x200A             MOVS     R0,#+10
   \       0x30   0x4341             MULS     R1,R0,R1
   \       0x32   0x9100             STR      R1,[SP, #+0]
   1945              do
   1946              {
   1947                count--;
   \                     ??HAL_I2C_Master_Transmit_DMA_1: (+1)
   \       0x34   0x9800             LDR      R0,[SP, #+0]
   \       0x36   0x1E40             SUBS     R0,R0,#+1
   \       0x38   0x9000             STR      R0,[SP, #+0]
   1948                if (count == 0U)
   \       0x3A   0x9800             LDR      R0,[SP, #+0]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD110             BNE.N    ??HAL_I2C_Master_Transmit_DMA_2
   1949                {
   1950                  hi2c->PreviousState       = I2C_STATE_NONE;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x6328             STR      R0,[R5, #+48]
   1951                  hi2c->State               = HAL_I2C_STATE_READY;
   \       0x44   0x2020             MOVS     R0,#+32
   \       0x46   0xF885 0x003D      STRB     R0,[R5, #+61]
   1952                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xF885 0x003E      STRB     R0,[R5, #+62]
   1953                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0x50   0x6C28             LDR      R0,[R5, #+64]
   \       0x52   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x56   0x6428             STR      R0,[R5, #+64]
   1954          
   1955                  /* Process Unlocked */
   1956                  __HAL_UNLOCK(hi2c);
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xF885 0x003C      STRB     R0,[R5, #+60]
   1957          
   1958                  return HAL_ERROR;
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0xE095             B.N      ??HAL_I2C_Master_Transmit_DMA_3
   1959                }
   1960              }
   1961              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Master_Transmit_DMA_2: (+1)
   \       0x62   0x6828             LDR      R0,[R5, #+0]
   \       0x64   0x6980             LDR      R0,[R0, #+24]
   \       0x66   0x0780             LSLS     R0,R0,#+30
   \       0x68   0xD4E4             BMI.N    ??HAL_I2C_Master_Transmit_DMA_1
   1962          
   1963              /* Process Locked */
   1964              __HAL_LOCK(hi2c);
   \       0x6A   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0x6E   0x2801             CMP      R0,#+1
   \       0x70   0xD101             BNE.N    ??HAL_I2C_Master_Transmit_DMA_4
   \       0x72   0x2002             MOVS     R0,#+2
   \       0x74   0xE08B             B.N      ??HAL_I2C_Master_Transmit_DMA_3
   \                     ??HAL_I2C_Master_Transmit_DMA_4: (+1)
   \       0x76   0x2001             MOVS     R0,#+1
   \       0x78   0xF885 0x003C      STRB     R0,[R5, #+60]
   1965          
   1966              /* Check if the I2C is already enabled */
   1967              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x7C   0x6828             LDR      R0,[R5, #+0]
   \       0x7E   0x6800             LDR      R0,[R0, #+0]
   \       0x80   0x07C0             LSLS     R0,R0,#+31
   \       0x82   0xD405             BMI.N    ??HAL_I2C_Master_Transmit_DMA_5
   1968              {
   1969                /* Enable I2C peripheral */
   1970                __HAL_I2C_ENABLE(hi2c);
   \       0x84   0x6828             LDR      R0,[R5, #+0]
   \       0x86   0x6800             LDR      R0,[R0, #+0]
   \       0x88   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x8C   0x6829             LDR      R1,[R5, #+0]
   \       0x8E   0x6008             STR      R0,[R1, #+0]
   1971              }
   1972          
   1973              /* Disable Pos */
   1974              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Master_Transmit_DMA_5: (+1)
   \       0x90   0x6828             LDR      R0,[R5, #+0]
   \       0x92   0x6800             LDR      R0,[R0, #+0]
   \       0x94   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x98   0x6829             LDR      R1,[R5, #+0]
   \       0x9A   0x6008             STR      R0,[R1, #+0]
   1975          
   1976              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0x9C   0x2021             MOVS     R0,#+33
   \       0x9E   0xF885 0x003D      STRB     R0,[R5, #+61]
   1977              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \       0xA2   0x2010             MOVS     R0,#+16
   \       0xA4   0xF885 0x003E      STRB     R0,[R5, #+62]
   1978              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0x6428             STR      R0,[R5, #+64]
   1979          
   1980              /* Prepare transfer parameters */
   1981              hi2c->pBuffPtr    = pData;
   \       0xAC   0x626F             STR      R7,[R5, #+36]
   1982              hi2c->XferCount   = Size;
   \       0xAE   0xF8A5 0x802A      STRH     R8,[R5, #+42]
   1983              hi2c->XferSize    = hi2c->XferCount;
   \       0xB2   0x8D68             LDRH     R0,[R5, #+42]
   \       0xB4   0x8528             STRH     R0,[R5, #+40]
   1984              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0xB6   0x....             LDR.N    R0,??DataTable10
   \       0xB8   0x62E8             STR      R0,[R5, #+44]
   1985              hi2c->Devaddress  = DevAddress;
   \       0xBA   0x0030             MOVS     R0,R6
   \       0xBC   0xB280             UXTH     R0,R0
   \       0xBE   0x6468             STR      R0,[R5, #+68]
   1986          
   1987              if (hi2c->XferSize > 0U)
   \       0xC0   0x8D28             LDRH     R0,[R5, #+40]
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD04B             BEQ.N    ??HAL_I2C_Master_Transmit_DMA_6
   1988              {
   1989                /* Set the I2C DMA transfer complete callback */
   1990                hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
   \       0xC6   0x.... 0x....      LDR.W    R0,??DataTable17
   \       0xCA   0x6B69             LDR      R1,[R5, #+52]
   \       0xCC   0x63C8             STR      R0,[R1, #+60]
   1991          
   1992                /* Set the DMA error callback */
   1993                hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \       0xCE   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0xD2   0x6B69             LDR      R1,[R5, #+52]
   \       0xD4   0x64C8             STR      R0,[R1, #+76]
   1994          
   1995                /* Set the unused DMA callbacks to NULL */
   1996                hi2c->hdmatx->XferHalfCpltCallback = NULL;
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0x6B69             LDR      R1,[R5, #+52]
   \       0xDA   0x6408             STR      R0,[R1, #+64]
   1997                hi2c->hdmatx->XferM1CpltCallback = NULL;
   \       0xDC   0x2000             MOVS     R0,#+0
   \       0xDE   0x6B69             LDR      R1,[R5, #+52]
   \       0xE0   0x6448             STR      R0,[R1, #+68]
   1998                hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
   \       0xE2   0x2000             MOVS     R0,#+0
   \       0xE4   0x6B69             LDR      R1,[R5, #+52]
   \       0xE6   0x6488             STR      R0,[R1, #+72]
   1999                hi2c->hdmatx->XferAbortCallback = NULL;
   \       0xE8   0x2000             MOVS     R0,#+0
   \       0xEA   0x6B69             LDR      R1,[R5, #+52]
   \       0xEC   0x6508             STR      R0,[R1, #+80]
   2000          
   2001                /* Enable the DMA stream */
   2002                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
   \       0xEE   0x8D2B             LDRH     R3,[R5, #+40]
   \       0xF0   0x6828             LDR      R0,[R5, #+0]
   \       0xF2   0xF110 0x0210      ADDS     R2,R0,#+16
   \       0xF6   0x6A69             LDR      R1,[R5, #+36]
   \       0xF8   0x6B68             LDR      R0,[R5, #+52]
   \       0xFA   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xFE   0x0004             MOVS     R4,R0
   2003          
   2004                if (dmaxferstatus == HAL_OK)
   \      0x100   0x0020             MOVS     R0,R4
   \      0x102   0xB2C0             UXTB     R0,R0
   \      0x104   0x2800             CMP      R0,#+0
   \      0x106   0xD11B             BNE.N    ??HAL_I2C_Master_Transmit_DMA_7
   2005                {
   2006                  /* Enable Acknowledge */
   2007                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \      0x108   0x6828             LDR      R0,[R5, #+0]
   \      0x10A   0x6800             LDR      R0,[R0, #+0]
   \      0x10C   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x110   0x6829             LDR      R1,[R5, #+0]
   \      0x112   0x6008             STR      R0,[R1, #+0]
   2008          
   2009                  /* Generate Start */
   2010                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \      0x114   0x6828             LDR      R0,[R5, #+0]
   \      0x116   0x6800             LDR      R0,[R0, #+0]
   \      0x118   0xF450 0x7080      ORRS     R0,R0,#0x100
   \      0x11C   0x6829             LDR      R1,[R5, #+0]
   \      0x11E   0x6008             STR      R0,[R1, #+0]
   2011          
   2012                  /* Process Unlocked */
   2013                  __HAL_UNLOCK(hi2c);
   \      0x120   0x2000             MOVS     R0,#+0
   \      0x122   0xF885 0x003C      STRB     R0,[R5, #+60]
   2014          
   2015                  /* Note : The I2C interrupts must be enabled after unlocking current process
   2016                  to avoid the risk of I2C interrupt handle execution before current
   2017                  process unlock */
   2018          
   2019                  /* Enable EVT and ERR interrupt */
   2020                  __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \      0x126   0x6828             LDR      R0,[R5, #+0]
   \      0x128   0x6840             LDR      R0,[R0, #+4]
   \      0x12A   0xF450 0x7040      ORRS     R0,R0,#0x300
   \      0x12E   0x6829             LDR      R1,[R5, #+0]
   \      0x130   0x6048             STR      R0,[R1, #+4]
   2021          
   2022                  /* Enable DMA Request */
   2023                  SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \      0x132   0x6828             LDR      R0,[R5, #+0]
   \      0x134   0x6840             LDR      R0,[R0, #+4]
   \      0x136   0xF450 0x6000      ORRS     R0,R0,#0x800
   \      0x13A   0x6829             LDR      R1,[R5, #+0]
   \      0x13C   0x6048             STR      R0,[R1, #+4]
   \      0x13E   0xE023             B.N      ??HAL_I2C_Master_Transmit_DMA_8
   2024                }
   2025                else
   2026                {
   2027                  /* Update I2C state */
   2028                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Transmit_DMA_7: (+1)
   \      0x140   0x2020             MOVS     R0,#+32
   \      0x142   0xF885 0x003D      STRB     R0,[R5, #+61]
   2029                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   \      0x146   0x2000             MOVS     R0,#+0
   \      0x148   0xF885 0x003E      STRB     R0,[R5, #+62]
   2030          
   2031                  /* Update I2C error code */
   2032                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \      0x14C   0x6C28             LDR      R0,[R5, #+64]
   \      0x14E   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x152   0x6428             STR      R0,[R5, #+64]
   2033          
   2034                  /* Process Unlocked */
   2035                  __HAL_UNLOCK(hi2c);
   \      0x154   0x2000             MOVS     R0,#+0
   \      0x156   0xF885 0x003C      STRB     R0,[R5, #+60]
   2036          
   2037                  return HAL_ERROR;
   \      0x15A   0x2001             MOVS     R0,#+1
   \      0x15C   0xE017             B.N      ??HAL_I2C_Master_Transmit_DMA_3
   2038                }
   2039              }
   2040              else
   2041              {
   2042                /* Enable Acknowledge */
   2043                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Transmit_DMA_6: (+1)
   \      0x15E   0x6828             LDR      R0,[R5, #+0]
   \      0x160   0x6800             LDR      R0,[R0, #+0]
   \      0x162   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x166   0x6829             LDR      R1,[R5, #+0]
   \      0x168   0x6008             STR      R0,[R1, #+0]
   2044          
   2045                /* Generate Start */
   2046                SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \      0x16A   0x6828             LDR      R0,[R5, #+0]
   \      0x16C   0x6800             LDR      R0,[R0, #+0]
   \      0x16E   0xF450 0x7080      ORRS     R0,R0,#0x100
   \      0x172   0x6829             LDR      R1,[R5, #+0]
   \      0x174   0x6008             STR      R0,[R1, #+0]
   2047          
   2048                /* Process Unlocked */
   2049                __HAL_UNLOCK(hi2c);
   \      0x176   0x2000             MOVS     R0,#+0
   \      0x178   0xF885 0x003C      STRB     R0,[R5, #+60]
   2050          
   2051                /* Note : The I2C interrupts must be enabled after unlocking current process
   2052                to avoid the risk of I2C interrupt handle execution before current
   2053                process unlock */
   2054          
   2055                /* Enable EVT, BUF and ERR interrupt */
   2056                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \      0x17C   0x6828             LDR      R0,[R5, #+0]
   \      0x17E   0x6840             LDR      R0,[R0, #+4]
   \      0x180   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \      0x184   0x6829             LDR      R1,[R5, #+0]
   \      0x186   0x6048             STR      R0,[R1, #+4]
   2057              }
   2058          
   2059              return HAL_OK;
   \                     ??HAL_I2C_Master_Transmit_DMA_8: (+1)
   \      0x188   0x2000             MOVS     R0,#+0
   \      0x18A   0xE000             B.N      ??HAL_I2C_Master_Transmit_DMA_3
   2060            }
   2061            else
   2062            {
   2063              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Transmit_DMA_0: (+1)
   \      0x18C   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Transmit_DMA_3: (+1)
   \      0x18E   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   2064            }
   2065          }
   2066          
   2067          /**
   2068            * @brief  Receive in master mode an amount of data in non-blocking mode with DMA
   2069            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2070            *                the configuration information for the specified I2C.
   2071            * @param  DevAddress Target device address: The device 7 bits address value
   2072            *         in datasheet must be shifted to the left before calling the interface
   2073            * @param  pData Pointer to data buffer
   2074            * @param  Size Amount of data to be sent
   2075            * @retval HAL status
   2076            */

   \                                 In section .text, align 2, keep-with-next
   2077          HAL_StatusTypeDef HAL_I2C_Master_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size)
   2078          {
   \                     HAL_I2C_Master_Receive_DMA: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   2079            __IO uint32_t count = 0U;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x9000             STR      R0,[SP, #+0]
   2080            HAL_StatusTypeDef dmaxferstatus;
   2081          
   2082            if (hi2c->State == HAL_I2C_STATE_READY)
   \       0x10   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x14   0x2820             CMP      R0,#+32
   \       0x16   0xF040 0x80B9      BNE.W    ??HAL_I2C_Master_Receive_DMA_0
   2083            {
   2084              /* Wait until BUSY flag is reset */
   2085              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \       0x1A   0x.... 0x....      LDR.W    R0,??DataTable14
   \       0x1E   0x6800             LDR      R0,[R0, #+0]
   \       0x20   0x2119             MOVS     R1,#+25
   \       0x22   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x26   0xF44F 0x717A      MOV      R1,#+1000
   \       0x2A   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x2E   0x200A             MOVS     R0,#+10
   \       0x30   0x4341             MULS     R1,R0,R1
   \       0x32   0x9100             STR      R1,[SP, #+0]
   2086              do
   2087              {
   2088                count--;
   \                     ??HAL_I2C_Master_Receive_DMA_1: (+1)
   \       0x34   0x9800             LDR      R0,[SP, #+0]
   \       0x36   0x1E40             SUBS     R0,R0,#+1
   \       0x38   0x9000             STR      R0,[SP, #+0]
   2089                if (count == 0U)
   \       0x3A   0x9800             LDR      R0,[SP, #+0]
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD110             BNE.N    ??HAL_I2C_Master_Receive_DMA_2
   2090                {
   2091                  hi2c->PreviousState       = I2C_STATE_NONE;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0x6328             STR      R0,[R5, #+48]
   2092                  hi2c->State               = HAL_I2C_STATE_READY;
   \       0x44   0x2020             MOVS     R0,#+32
   \       0x46   0xF885 0x003D      STRB     R0,[R5, #+61]
   2093                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xF885 0x003E      STRB     R0,[R5, #+62]
   2094                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0x50   0x6C28             LDR      R0,[R5, #+64]
   \       0x52   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x56   0x6428             STR      R0,[R5, #+64]
   2095          
   2096                  /* Process Unlocked */
   2097                  __HAL_UNLOCK(hi2c);
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0xF885 0x003C      STRB     R0,[R5, #+60]
   2098          
   2099                  return HAL_ERROR;
   \       0x5E   0x2001             MOVS     R0,#+1
   \       0x60   0xE095             B.N      ??HAL_I2C_Master_Receive_DMA_3
   2100                }
   2101              }
   2102              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Master_Receive_DMA_2: (+1)
   \       0x62   0x6828             LDR      R0,[R5, #+0]
   \       0x64   0x6980             LDR      R0,[R0, #+24]
   \       0x66   0x0780             LSLS     R0,R0,#+30
   \       0x68   0xD4E4             BMI.N    ??HAL_I2C_Master_Receive_DMA_1
   2103          
   2104              /* Process Locked */
   2105              __HAL_LOCK(hi2c);
   \       0x6A   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0x6E   0x2801             CMP      R0,#+1
   \       0x70   0xD101             BNE.N    ??HAL_I2C_Master_Receive_DMA_4
   \       0x72   0x2002             MOVS     R0,#+2
   \       0x74   0xE08B             B.N      ??HAL_I2C_Master_Receive_DMA_3
   \                     ??HAL_I2C_Master_Receive_DMA_4: (+1)
   \       0x76   0x2001             MOVS     R0,#+1
   \       0x78   0xF885 0x003C      STRB     R0,[R5, #+60]
   2106          
   2107              /* Check if the I2C is already enabled */
   2108              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x7C   0x6828             LDR      R0,[R5, #+0]
   \       0x7E   0x6800             LDR      R0,[R0, #+0]
   \       0x80   0x07C0             LSLS     R0,R0,#+31
   \       0x82   0xD405             BMI.N    ??HAL_I2C_Master_Receive_DMA_5
   2109              {
   2110                /* Enable I2C peripheral */
   2111                __HAL_I2C_ENABLE(hi2c);
   \       0x84   0x6828             LDR      R0,[R5, #+0]
   \       0x86   0x6800             LDR      R0,[R0, #+0]
   \       0x88   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x8C   0x6829             LDR      R1,[R5, #+0]
   \       0x8E   0x6008             STR      R0,[R1, #+0]
   2112              }
   2113          
   2114              /* Disable Pos */
   2115              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Master_Receive_DMA_5: (+1)
   \       0x90   0x6828             LDR      R0,[R5, #+0]
   \       0x92   0x6800             LDR      R0,[R0, #+0]
   \       0x94   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x98   0x6829             LDR      R1,[R5, #+0]
   \       0x9A   0x6008             STR      R0,[R1, #+0]
   2116          
   2117              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x9C   0x2022             MOVS     R0,#+34
   \       0x9E   0xF885 0x003D      STRB     R0,[R5, #+61]
   2118              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \       0xA2   0x2010             MOVS     R0,#+16
   \       0xA4   0xF885 0x003E      STRB     R0,[R5, #+62]
   2119              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0x6428             STR      R0,[R5, #+64]
   2120          
   2121              /* Prepare transfer parameters */
   2122              hi2c->pBuffPtr    = pData;
   \       0xAC   0x626F             STR      R7,[R5, #+36]
   2123              hi2c->XferCount   = Size;
   \       0xAE   0xF8A5 0x802A      STRH     R8,[R5, #+42]
   2124              hi2c->XferSize    = hi2c->XferCount;
   \       0xB2   0x8D68             LDRH     R0,[R5, #+42]
   \       0xB4   0x8528             STRH     R0,[R5, #+40]
   2125              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0xB6   0x....             LDR.N    R0,??DataTable10
   \       0xB8   0x62E8             STR      R0,[R5, #+44]
   2126              hi2c->Devaddress  = DevAddress;
   \       0xBA   0x0030             MOVS     R0,R6
   \       0xBC   0xB280             UXTH     R0,R0
   \       0xBE   0x6468             STR      R0,[R5, #+68]
   2127          
   2128              if (hi2c->XferSize > 0U)
   \       0xC0   0x8D28             LDRH     R0,[R5, #+40]
   \       0xC2   0x2800             CMP      R0,#+0
   \       0xC4   0xD04B             BEQ.N    ??HAL_I2C_Master_Receive_DMA_6
   2129              {
   2130                /* Set the I2C DMA transfer complete callback */
   2131                hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
   \       0xC6   0x.... 0x....      LDR.W    R0,??DataTable17
   \       0xCA   0x6BA9             LDR      R1,[R5, #+56]
   \       0xCC   0x63C8             STR      R0,[R1, #+60]
   2132          
   2133                /* Set the DMA error callback */
   2134                hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \       0xCE   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0xD2   0x6BA9             LDR      R1,[R5, #+56]
   \       0xD4   0x64C8             STR      R0,[R1, #+76]
   2135          
   2136                /* Set the unused DMA callbacks to NULL */
   2137                hi2c->hdmarx->XferHalfCpltCallback = NULL;
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0x6BA9             LDR      R1,[R5, #+56]
   \       0xDA   0x6408             STR      R0,[R1, #+64]
   2138                hi2c->hdmarx->XferM1CpltCallback = NULL;
   \       0xDC   0x2000             MOVS     R0,#+0
   \       0xDE   0x6BA9             LDR      R1,[R5, #+56]
   \       0xE0   0x6448             STR      R0,[R1, #+68]
   2139                hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
   \       0xE2   0x2000             MOVS     R0,#+0
   \       0xE4   0x6BA9             LDR      R1,[R5, #+56]
   \       0xE6   0x6488             STR      R0,[R1, #+72]
   2140                hi2c->hdmarx->XferAbortCallback = NULL;
   \       0xE8   0x2000             MOVS     R0,#+0
   \       0xEA   0x6BA9             LDR      R1,[R5, #+56]
   \       0xEC   0x6508             STR      R0,[R1, #+80]
   2141          
   2142                /* Enable the DMA stream */
   2143                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   \       0xEE   0x8D2B             LDRH     R3,[R5, #+40]
   \       0xF0   0x6A6A             LDR      R2,[R5, #+36]
   \       0xF2   0x6828             LDR      R0,[R5, #+0]
   \       0xF4   0xF110 0x0110      ADDS     R1,R0,#+16
   \       0xF8   0x6BA8             LDR      R0,[R5, #+56]
   \       0xFA   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xFE   0x0004             MOVS     R4,R0
   2144          
   2145                if (dmaxferstatus == HAL_OK)
   \      0x100   0x0020             MOVS     R0,R4
   \      0x102   0xB2C0             UXTB     R0,R0
   \      0x104   0x2800             CMP      R0,#+0
   \      0x106   0xD11B             BNE.N    ??HAL_I2C_Master_Receive_DMA_7
   2146                {
   2147                  /* Enable Acknowledge */
   2148                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \      0x108   0x6828             LDR      R0,[R5, #+0]
   \      0x10A   0x6800             LDR      R0,[R0, #+0]
   \      0x10C   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x110   0x6829             LDR      R1,[R5, #+0]
   \      0x112   0x6008             STR      R0,[R1, #+0]
   2149          
   2150                  /* Generate Start */
   2151                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \      0x114   0x6828             LDR      R0,[R5, #+0]
   \      0x116   0x6800             LDR      R0,[R0, #+0]
   \      0x118   0xF450 0x7080      ORRS     R0,R0,#0x100
   \      0x11C   0x6829             LDR      R1,[R5, #+0]
   \      0x11E   0x6008             STR      R0,[R1, #+0]
   2152          
   2153                  /* Process Unlocked */
   2154                  __HAL_UNLOCK(hi2c);
   \      0x120   0x2000             MOVS     R0,#+0
   \      0x122   0xF885 0x003C      STRB     R0,[R5, #+60]
   2155          
   2156                  /* Note : The I2C interrupts must be enabled after unlocking current process
   2157                  to avoid the risk of I2C interrupt handle execution before current
   2158                  process unlock */
   2159          
   2160                  /* Enable EVT and ERR interrupt */
   2161                  __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \      0x126   0x6828             LDR      R0,[R5, #+0]
   \      0x128   0x6840             LDR      R0,[R0, #+4]
   \      0x12A   0xF450 0x7040      ORRS     R0,R0,#0x300
   \      0x12E   0x6829             LDR      R1,[R5, #+0]
   \      0x130   0x6048             STR      R0,[R1, #+4]
   2162          
   2163                  /* Enable DMA Request */
   2164                  SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \      0x132   0x6828             LDR      R0,[R5, #+0]
   \      0x134   0x6840             LDR      R0,[R0, #+4]
   \      0x136   0xF450 0x6000      ORRS     R0,R0,#0x800
   \      0x13A   0x6829             LDR      R1,[R5, #+0]
   \      0x13C   0x6048             STR      R0,[R1, #+4]
   \      0x13E   0xE023             B.N      ??HAL_I2C_Master_Receive_DMA_8
   2165                }
   2166                else
   2167                {
   2168                  /* Update I2C state */
   2169                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Receive_DMA_7: (+1)
   \      0x140   0x2020             MOVS     R0,#+32
   \      0x142   0xF885 0x003D      STRB     R0,[R5, #+61]
   2170                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   \      0x146   0x2000             MOVS     R0,#+0
   \      0x148   0xF885 0x003E      STRB     R0,[R5, #+62]
   2171          
   2172                  /* Update I2C error code */
   2173                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \      0x14C   0x6C28             LDR      R0,[R5, #+64]
   \      0x14E   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x152   0x6428             STR      R0,[R5, #+64]
   2174          
   2175                  /* Process Unlocked */
   2176                  __HAL_UNLOCK(hi2c);
   \      0x154   0x2000             MOVS     R0,#+0
   \      0x156   0xF885 0x003C      STRB     R0,[R5, #+60]
   2177          
   2178                  return HAL_ERROR;
   \      0x15A   0x2001             MOVS     R0,#+1
   \      0x15C   0xE017             B.N      ??HAL_I2C_Master_Receive_DMA_3
   2179                }
   2180              }
   2181              else
   2182              {
   2183                /* Enable Acknowledge */
   2184                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Receive_DMA_6: (+1)
   \      0x15E   0x6828             LDR      R0,[R5, #+0]
   \      0x160   0x6800             LDR      R0,[R0, #+0]
   \      0x162   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x166   0x6829             LDR      R1,[R5, #+0]
   \      0x168   0x6008             STR      R0,[R1, #+0]
   2185          
   2186                /* Generate Start */
   2187                SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \      0x16A   0x6828             LDR      R0,[R5, #+0]
   \      0x16C   0x6800             LDR      R0,[R0, #+0]
   \      0x16E   0xF450 0x7080      ORRS     R0,R0,#0x100
   \      0x172   0x6829             LDR      R1,[R5, #+0]
   \      0x174   0x6008             STR      R0,[R1, #+0]
   2188          
   2189                /* Process Unlocked */
   2190                __HAL_UNLOCK(hi2c);
   \      0x176   0x2000             MOVS     R0,#+0
   \      0x178   0xF885 0x003C      STRB     R0,[R5, #+60]
   2191          
   2192                /* Note : The I2C interrupts must be enabled after unlocking current process
   2193                to avoid the risk of I2C interrupt handle execution before current
   2194                process unlock */
   2195          
   2196                /* Enable EVT, BUF and ERR interrupt */
   2197                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \      0x17C   0x6828             LDR      R0,[R5, #+0]
   \      0x17E   0x6840             LDR      R0,[R0, #+4]
   \      0x180   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \      0x184   0x6829             LDR      R1,[R5, #+0]
   \      0x186   0x6048             STR      R0,[R1, #+4]
   2198              }
   2199          
   2200              return HAL_OK;
   \                     ??HAL_I2C_Master_Receive_DMA_8: (+1)
   \      0x188   0x2000             MOVS     R0,#+0
   \      0x18A   0xE000             B.N      ??HAL_I2C_Master_Receive_DMA_3
   2201            }
   2202            else
   2203            {
   2204              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Receive_DMA_0: (+1)
   \      0x18C   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Receive_DMA_3: (+1)
   \      0x18E   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   2205            }
   2206          }
   2207          
   2208          /**
   2209            * @brief  Transmit in slave mode an amount of data in non-blocking mode with DMA
   2210            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2211            *                the configuration information for the specified I2C.
   2212            * @param  pData Pointer to data buffer
   2213            * @param  Size Amount of data to be sent
   2214            * @retval HAL status
   2215            */

   \                                 In section .text, align 2, keep-with-next
   2216          HAL_StatusTypeDef HAL_I2C_Slave_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   2217          {
   \                     HAL_I2C_Slave_Transmit_DMA: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0016             MOVS     R6,R2
   2218            HAL_StatusTypeDef dmaxferstatus;
   2219          
   2220            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x8   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \        0xC   0x2820             CMP      R0,#+32
   \        0xE   0xD175             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_0
   2221            {
   2222              if ((pData == NULL) || (Size == 0U))
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD003             BEQ.N    ??HAL_I2C_Slave_Transmit_DMA_1
   \       0x14   0x0030             MOVS     R0,R6
   \       0x16   0xB280             UXTH     R0,R0
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_2
   2223              {
   2224                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Transmit_DMA_1: (+1)
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE06E             B.N      ??HAL_I2C_Slave_Transmit_DMA_3
   2225              }
   2226          
   2227              /* Process Locked */
   2228              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Transmit_DMA_2: (+1)
   \       0x20   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xD101             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_4
   \       0x28   0x2002             MOVS     R0,#+2
   \       0x2A   0xE068             B.N      ??HAL_I2C_Slave_Transmit_DMA_3
   \                     ??HAL_I2C_Slave_Transmit_DMA_4: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xF885 0x003C      STRB     R0,[R5, #+60]
   2229          
   2230              /* Check if the I2C is already enabled */
   2231              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x32   0x6828             LDR      R0,[R5, #+0]
   \       0x34   0x6800             LDR      R0,[R0, #+0]
   \       0x36   0x07C0             LSLS     R0,R0,#+31
   \       0x38   0xD405             BMI.N    ??HAL_I2C_Slave_Transmit_DMA_5
   2232              {
   2233                /* Enable I2C peripheral */
   2234                __HAL_I2C_ENABLE(hi2c);
   \       0x3A   0x6828             LDR      R0,[R5, #+0]
   \       0x3C   0x6800             LDR      R0,[R0, #+0]
   \       0x3E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x42   0x6829             LDR      R1,[R5, #+0]
   \       0x44   0x6008             STR      R0,[R1, #+0]
   2235              }
   2236          
   2237              /* Disable Pos */
   2238              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Slave_Transmit_DMA_5: (+1)
   \       0x46   0x6828             LDR      R0,[R5, #+0]
   \       0x48   0x6800             LDR      R0,[R0, #+0]
   \       0x4A   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x4E   0x6829             LDR      R1,[R5, #+0]
   \       0x50   0x6008             STR      R0,[R1, #+0]
   2239          
   2240              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0x52   0x2021             MOVS     R0,#+33
   \       0x54   0xF885 0x003D      STRB     R0,[R5, #+61]
   2241              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \       0x58   0x2020             MOVS     R0,#+32
   \       0x5A   0xF885 0x003E      STRB     R0,[R5, #+62]
   2242              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x6428             STR      R0,[R5, #+64]
   2243          
   2244              /* Prepare transfer parameters */
   2245              hi2c->pBuffPtr    = pData;
   \       0x62   0x626C             STR      R4,[R5, #+36]
   2246              hi2c->XferCount   = Size;
   \       0x64   0x856E             STRH     R6,[R5, #+42]
   2247              hi2c->XferSize    = hi2c->XferCount;
   \       0x66   0x8D68             LDRH     R0,[R5, #+42]
   \       0x68   0x8528             STRH     R0,[R5, #+40]
   2248              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x6A   0x....             LDR.N    R0,??DataTable11
   \       0x6C   0x62E8             STR      R0,[R5, #+44]
   2249          
   2250              /* Set the I2C DMA transfer complete callback */
   2251              hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
   \       0x6E   0x.... 0x....      LDR.W    R0,??DataTable17
   \       0x72   0x6B69             LDR      R1,[R5, #+52]
   \       0x74   0x63C8             STR      R0,[R1, #+60]
   2252          
   2253              /* Set the DMA error callback */
   2254              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \       0x76   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x7A   0x6B69             LDR      R1,[R5, #+52]
   \       0x7C   0x64C8             STR      R0,[R1, #+76]
   2255          
   2256              /* Set the unused DMA callbacks to NULL */
   2257              hi2c->hdmatx->XferHalfCpltCallback = NULL;
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0x6B69             LDR      R1,[R5, #+52]
   \       0x82   0x6408             STR      R0,[R1, #+64]
   2258              hi2c->hdmatx->XferM1CpltCallback = NULL;
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0x6B69             LDR      R1,[R5, #+52]
   \       0x88   0x6448             STR      R0,[R1, #+68]
   2259              hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0x6B69             LDR      R1,[R5, #+52]
   \       0x8E   0x6488             STR      R0,[R1, #+72]
   2260              hi2c->hdmatx->XferAbortCallback = NULL;
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0x6B69             LDR      R1,[R5, #+52]
   \       0x94   0x6508             STR      R0,[R1, #+80]
   2261          
   2262              /* Enable the DMA stream */
   2263              dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
   \       0x96   0x8D2B             LDRH     R3,[R5, #+40]
   \       0x98   0x6828             LDR      R0,[R5, #+0]
   \       0x9A   0xF110 0x0210      ADDS     R2,R0,#+16
   \       0x9E   0x6A69             LDR      R1,[R5, #+36]
   \       0xA0   0x6B68             LDR      R0,[R5, #+52]
   \       0xA2   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xA6   0x0001             MOVS     R1,R0
   2264          
   2265              if (dmaxferstatus == HAL_OK)
   \       0xA8   0x0008             MOVS     R0,R1
   \       0xAA   0xB2C0             UXTB     R0,R0
   \       0xAC   0x2800             CMP      R0,#+0
   \       0xAE   0xD116             BNE.N    ??HAL_I2C_Slave_Transmit_DMA_6
   2266              {
   2267                /* Enable Address Acknowledge */
   2268                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0xB0   0x6828             LDR      R0,[R5, #+0]
   \       0xB2   0x6800             LDR      R0,[R0, #+0]
   \       0xB4   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0xB8   0x682A             LDR      R2,[R5, #+0]
   \       0xBA   0x6010             STR      R0,[R2, #+0]
   2269          
   2270                /* Process Unlocked */
   2271                __HAL_UNLOCK(hi2c);
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0xF885 0x003C      STRB     R0,[R5, #+60]
   2272          
   2273                /* Note : The I2C interrupts must be enabled after unlocking current process
   2274                to avoid the risk of I2C interrupt handle execution before current
   2275                process unlock */
   2276                /* Enable EVT and ERR interrupt */
   2277                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \       0xC2   0x6828             LDR      R0,[R5, #+0]
   \       0xC4   0x6840             LDR      R0,[R0, #+4]
   \       0xC6   0xF450 0x7040      ORRS     R0,R0,#0x300
   \       0xCA   0x682A             LDR      R2,[R5, #+0]
   \       0xCC   0x6050             STR      R0,[R2, #+4]
   2278          
   2279                /* Enable DMA Request */
   2280                hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
   \       0xCE   0x6828             LDR      R0,[R5, #+0]
   \       0xD0   0x6840             LDR      R0,[R0, #+4]
   \       0xD2   0xF450 0x6000      ORRS     R0,R0,#0x800
   \       0xD6   0x682A             LDR      R2,[R5, #+0]
   \       0xD8   0x6050             STR      R0,[R2, #+4]
   2281          
   2282                return HAL_OK;
   \       0xDA   0x2000             MOVS     R0,#+0
   \       0xDC   0xE00F             B.N      ??HAL_I2C_Slave_Transmit_DMA_3
   2283              }
   2284              else
   2285              {
   2286                /* Update I2C state */
   2287                hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Slave_Transmit_DMA_6: (+1)
   \       0xDE   0x2020             MOVS     R0,#+32
   \       0xE0   0xF885 0x003D      STRB     R0,[R5, #+61]
   2288                hi2c->Mode      = HAL_I2C_MODE_NONE;
   \       0xE4   0x2000             MOVS     R0,#+0
   \       0xE6   0xF885 0x003E      STRB     R0,[R5, #+62]
   2289          
   2290                /* Update I2C error code */
   2291                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \       0xEA   0x6C28             LDR      R0,[R5, #+64]
   \       0xEC   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xF0   0x6428             STR      R0,[R5, #+64]
   2292          
   2293                /* Process Unlocked */
   2294                __HAL_UNLOCK(hi2c);
   \       0xF2   0x2000             MOVS     R0,#+0
   \       0xF4   0xF885 0x003C      STRB     R0,[R5, #+60]
   2295          
   2296                return HAL_ERROR;
   \       0xF8   0x2001             MOVS     R0,#+1
   \       0xFA   0xE000             B.N      ??HAL_I2C_Slave_Transmit_DMA_3
   2297              }
   2298            }
   2299            else
   2300            {
   2301              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Transmit_DMA_0: (+1)
   \       0xFC   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Transmit_DMA_3: (+1)
   \       0xFE   0xBD70             POP      {R4-R6,PC}
   2302            }
   2303          }
   2304          
   2305          /**
   2306            * @brief  Receive in slave mode an amount of data in non-blocking mode with DMA
   2307            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2308            *                the configuration information for the specified I2C.
   2309            * @param  pData Pointer to data buffer
   2310            * @param  Size Amount of data to be sent
   2311            * @retval HAL status
   2312            */

   \                                 In section .text, align 2, keep-with-next
   2313          HAL_StatusTypeDef HAL_I2C_Slave_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size)
   2314          {
   \                     HAL_I2C_Slave_Receive_DMA: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0016             MOVS     R6,R2
   2315            HAL_StatusTypeDef dmaxferstatus;
   2316          
   2317            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x8   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \        0xC   0x2820             CMP      R0,#+32
   \        0xE   0xD176             BNE.N    ??HAL_I2C_Slave_Receive_DMA_0
   2318            {
   2319              if ((pData == NULL) || (Size == 0U))
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD003             BEQ.N    ??HAL_I2C_Slave_Receive_DMA_1
   \       0x14   0x0030             MOVS     R0,R6
   \       0x16   0xB280             UXTH     R0,R0
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_DMA_2
   2320              {
   2321                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Receive_DMA_1: (+1)
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE06F             B.N      ??HAL_I2C_Slave_Receive_DMA_3
   2322              }
   2323          
   2324              /* Process Locked */
   2325              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Receive_DMA_2: (+1)
   \       0x20   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xD101             BNE.N    ??HAL_I2C_Slave_Receive_DMA_4
   \       0x28   0x2002             MOVS     R0,#+2
   \       0x2A   0xE069             B.N      ??HAL_I2C_Slave_Receive_DMA_3
   \                     ??HAL_I2C_Slave_Receive_DMA_4: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xF885 0x003C      STRB     R0,[R5, #+60]
   2326          
   2327              /* Check if the I2C is already enabled */
   2328              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x32   0x6828             LDR      R0,[R5, #+0]
   \       0x34   0x6800             LDR      R0,[R0, #+0]
   \       0x36   0x07C0             LSLS     R0,R0,#+31
   \       0x38   0xD405             BMI.N    ??HAL_I2C_Slave_Receive_DMA_5
   2329              {
   2330                /* Enable I2C peripheral */
   2331                __HAL_I2C_ENABLE(hi2c);
   \       0x3A   0x6828             LDR      R0,[R5, #+0]
   \       0x3C   0x6800             LDR      R0,[R0, #+0]
   \       0x3E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x42   0x6829             LDR      R1,[R5, #+0]
   \       0x44   0x6008             STR      R0,[R1, #+0]
   2332              }
   2333          
   2334              /* Disable Pos */
   2335              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Slave_Receive_DMA_5: (+1)
   \       0x46   0x6828             LDR      R0,[R5, #+0]
   \       0x48   0x6800             LDR      R0,[R0, #+0]
   \       0x4A   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x4E   0x6829             LDR      R1,[R5, #+0]
   \       0x50   0x6008             STR      R0,[R1, #+0]
   2336          
   2337              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x52   0x2022             MOVS     R0,#+34
   \       0x54   0xF885 0x003D      STRB     R0,[R5, #+61]
   2338              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \       0x58   0x2020             MOVS     R0,#+32
   \       0x5A   0xF885 0x003E      STRB     R0,[R5, #+62]
   2339              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x6428             STR      R0,[R5, #+64]
   2340          
   2341              /* Prepare transfer parameters */
   2342              hi2c->pBuffPtr    = pData;
   \       0x62   0x626C             STR      R4,[R5, #+36]
   2343              hi2c->XferCount   = Size;
   \       0x64   0x856E             STRH     R6,[R5, #+42]
   2344              hi2c->XferSize    = hi2c->XferCount;
   \       0x66   0x8D68             LDRH     R0,[R5, #+42]
   \       0x68   0x8528             STRH     R0,[R5, #+40]
   2345              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x6A   0x.... 0x....      LDR.W    R0,??DataTable19
   \       0x6E   0x62E8             STR      R0,[R5, #+44]
   2346          
   2347              /* Set the I2C DMA transfer complete callback */
   2348              hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
   \       0x70   0x.... 0x....      LDR.W    R0,??DataTable17
   \       0x74   0x6BA9             LDR      R1,[R5, #+56]
   \       0x76   0x63C8             STR      R0,[R1, #+60]
   2349          
   2350              /* Set the DMA error callback */
   2351              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \       0x78   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \       0x7C   0x6BA9             LDR      R1,[R5, #+56]
   \       0x7E   0x64C8             STR      R0,[R1, #+76]
   2352          
   2353              /* Set the unused DMA callbacks to NULL */
   2354              hi2c->hdmarx->XferHalfCpltCallback = NULL;
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0x6BA9             LDR      R1,[R5, #+56]
   \       0x84   0x6408             STR      R0,[R1, #+64]
   2355              hi2c->hdmarx->XferM1CpltCallback = NULL;
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0x6BA9             LDR      R1,[R5, #+56]
   \       0x8A   0x6448             STR      R0,[R1, #+68]
   2356              hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0x6BA9             LDR      R1,[R5, #+56]
   \       0x90   0x6488             STR      R0,[R1, #+72]
   2357              hi2c->hdmarx->XferAbortCallback = NULL;
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0x6BA9             LDR      R1,[R5, #+56]
   \       0x96   0x6508             STR      R0,[R1, #+80]
   2358          
   2359              /* Enable the DMA stream */
   2360              dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   \       0x98   0x8D2B             LDRH     R3,[R5, #+40]
   \       0x9A   0x6A6A             LDR      R2,[R5, #+36]
   \       0x9C   0x6828             LDR      R0,[R5, #+0]
   \       0x9E   0xF110 0x0110      ADDS     R1,R0,#+16
   \       0xA2   0x6BA8             LDR      R0,[R5, #+56]
   \       0xA4   0x.... 0x....      BL       HAL_DMA_Start_IT
   \       0xA8   0x0001             MOVS     R1,R0
   2361          
   2362              if (dmaxferstatus == HAL_OK)
   \       0xAA   0x0008             MOVS     R0,R1
   \       0xAC   0xB2C0             UXTB     R0,R0
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD116             BNE.N    ??HAL_I2C_Slave_Receive_DMA_6
   2363              {
   2364                /* Enable Address Acknowledge */
   2365                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0xB2   0x6828             LDR      R0,[R5, #+0]
   \       0xB4   0x6800             LDR      R0,[R0, #+0]
   \       0xB6   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0xBA   0x682A             LDR      R2,[R5, #+0]
   \       0xBC   0x6010             STR      R0,[R2, #+0]
   2366          
   2367                /* Process Unlocked */
   2368                __HAL_UNLOCK(hi2c);
   \       0xBE   0x2000             MOVS     R0,#+0
   \       0xC0   0xF885 0x003C      STRB     R0,[R5, #+60]
   2369          
   2370                /* Note : The I2C interrupts must be enabled after unlocking current process
   2371                to avoid the risk of I2C interrupt handle execution before current
   2372                process unlock */
   2373                /* Enable EVT and ERR interrupt */
   2374                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \       0xC4   0x6828             LDR      R0,[R5, #+0]
   \       0xC6   0x6840             LDR      R0,[R0, #+4]
   \       0xC8   0xF450 0x7040      ORRS     R0,R0,#0x300
   \       0xCC   0x682A             LDR      R2,[R5, #+0]
   \       0xCE   0x6050             STR      R0,[R2, #+4]
   2375          
   2376                /* Enable DMA Request */
   2377                SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \       0xD0   0x6828             LDR      R0,[R5, #+0]
   \       0xD2   0x6840             LDR      R0,[R0, #+4]
   \       0xD4   0xF450 0x6000      ORRS     R0,R0,#0x800
   \       0xD8   0x682A             LDR      R2,[R5, #+0]
   \       0xDA   0x6050             STR      R0,[R2, #+4]
   2378          
   2379                return HAL_OK;
   \       0xDC   0x2000             MOVS     R0,#+0
   \       0xDE   0xE00F             B.N      ??HAL_I2C_Slave_Receive_DMA_3
   2380              }
   2381              else
   2382              {
   2383                /* Update I2C state */
   2384                hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Slave_Receive_DMA_6: (+1)
   \       0xE0   0x2020             MOVS     R0,#+32
   \       0xE2   0xF885 0x003D      STRB     R0,[R5, #+61]
   2385                hi2c->Mode      = HAL_I2C_MODE_NONE;
   \       0xE6   0x2000             MOVS     R0,#+0
   \       0xE8   0xF885 0x003E      STRB     R0,[R5, #+62]
   2386          
   2387                /* Update I2C error code */
   2388                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \       0xEC   0x6C28             LDR      R0,[R5, #+64]
   \       0xEE   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0xF2   0x6428             STR      R0,[R5, #+64]
   2389          
   2390                /* Process Unlocked */
   2391                __HAL_UNLOCK(hi2c);
   \       0xF4   0x2000             MOVS     R0,#+0
   \       0xF6   0xF885 0x003C      STRB     R0,[R5, #+60]
   2392          
   2393                return HAL_ERROR;
   \       0xFA   0x2001             MOVS     R0,#+1
   \       0xFC   0xE000             B.N      ??HAL_I2C_Slave_Receive_DMA_3
   2394              }
   2395            }
   2396            else
   2397            {
   2398              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Receive_DMA_0: (+1)
   \       0xFE   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Receive_DMA_3: (+1)
   \      0x100   0xBD70             POP      {R4-R6,PC}
   2399            }
   2400          }
   2401          
   2402          /**
   2403            * @brief  Write an amount of data in blocking mode to a specific memory address
   2404            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2405            *                the configuration information for the specified I2C.
   2406            * @param  DevAddress Target device address: The device 7 bits address value
   2407            *         in datasheet must be shifted to the left before calling the interface
   2408            * @param  MemAddress Internal memory address
   2409            * @param  MemAddSize Size of internal memory address
   2410            * @param  pData Pointer to data buffer
   2411            * @param  Size Amount of data to be sent
   2412            * @param  Timeout Timeout duration
   2413            * @retval HAL status
   2414            */

   \                                 In section .text, align 2, keep-with-next
   2415          HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   2416          {
   \                     HAL_I2C_Mem_Write: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   \        0xC   0xF8DD 0x9030      LDR      R9,[SP, #+48]
   \       0x10   0x9C0D             LDR      R4,[SP, #+52]
   \       0x12   0xF8DD 0xA038      LDR      R10,[SP, #+56]
   2417            /* Init tickstart for timeout management*/
   2418            uint32_t tickstart = HAL_GetTick();
   \       0x16   0x.... 0x....      BL       HAL_GetTick
   \       0x1A   0x4683             MOV      R11,R0
   2419          
   2420            /* Check the parameters */
   2421            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2422          
   2423            if (hi2c->State == HAL_I2C_STATE_READY)
   \       0x1C   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x20   0x2820             CMP      R0,#+32
   \       0x22   0xF040 0x80A1      BNE.W    ??HAL_I2C_Mem_Write_0
   2424            {
   2425              /* Wait until BUSY flag is reset */
   2426              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \       0x26   0xF8CD 0xB000      STR      R11,[SP, #+0]
   \       0x2A   0x230A             MOVS     R3,#+10
   \       0x2C   0x2201             MOVS     R2,#+1
   \       0x2E   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \       0x32   0x0028             MOVS     R0,R5
   \       0x34   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD001             BEQ.N    ??HAL_I2C_Mem_Write_1
   2427              {
   2428                return HAL_BUSY;
   \       0x3C   0x2002             MOVS     R0,#+2
   \       0x3E   0xE094             B.N      ??HAL_I2C_Mem_Write_2
   2429              }
   2430          
   2431              /* Process Locked */
   2432              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Mem_Write_1: (+1)
   \       0x40   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0x44   0x2801             CMP      R0,#+1
   \       0x46   0xD101             BNE.N    ??HAL_I2C_Mem_Write_3
   \       0x48   0x2002             MOVS     R0,#+2
   \       0x4A   0xE08E             B.N      ??HAL_I2C_Mem_Write_2
   \                     ??HAL_I2C_Mem_Write_3: (+1)
   \       0x4C   0x2001             MOVS     R0,#+1
   \       0x4E   0xF885 0x003C      STRB     R0,[R5, #+60]
   2433          
   2434              /* Check if the I2C is already enabled */
   2435              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x52   0x6828             LDR      R0,[R5, #+0]
   \       0x54   0x6800             LDR      R0,[R0, #+0]
   \       0x56   0x07C0             LSLS     R0,R0,#+31
   \       0x58   0xD405             BMI.N    ??HAL_I2C_Mem_Write_4
   2436              {
   2437                /* Enable I2C peripheral */
   2438                __HAL_I2C_ENABLE(hi2c);
   \       0x5A   0x6828             LDR      R0,[R5, #+0]
   \       0x5C   0x6800             LDR      R0,[R0, #+0]
   \       0x5E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x62   0x6829             LDR      R1,[R5, #+0]
   \       0x64   0x6008             STR      R0,[R1, #+0]
   2439              }
   2440          
   2441              /* Disable Pos */
   2442              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Mem_Write_4: (+1)
   \       0x66   0x6828             LDR      R0,[R5, #+0]
   \       0x68   0x6800             LDR      R0,[R0, #+0]
   \       0x6A   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x6E   0x6829             LDR      R1,[R5, #+0]
   \       0x70   0x6008             STR      R0,[R1, #+0]
   2443          
   2444              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0x72   0x2021             MOVS     R0,#+33
   \       0x74   0xF885 0x003D      STRB     R0,[R5, #+61]
   2445              hi2c->Mode      = HAL_I2C_MODE_MEM;
   \       0x78   0x2040             MOVS     R0,#+64
   \       0x7A   0xF885 0x003E      STRB     R0,[R5, #+62]
   2446              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0x6428             STR      R0,[R5, #+64]
   2447          
   2448              /* Prepare transfer parameters */
   2449              hi2c->pBuffPtr    = pData;
   \       0x82   0xF8C5 0x9024      STR      R9,[R5, #+36]
   2450              hi2c->XferCount   = Size;
   \       0x86   0x856C             STRH     R4,[R5, #+42]
   2451              hi2c->XferSize    = hi2c->XferCount;
   \       0x88   0x8D68             LDRH     R0,[R5, #+42]
   \       0x8A   0x8528             STRH     R0,[R5, #+40]
   2452              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x8C   0x.... 0x....      LDR.W    R0,??DataTable19
   \       0x90   0x62E8             STR      R0,[R5, #+44]
   2453          
   2454              /* Send Slave Address and Memory Address */
   2455              if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
   \       0x92   0xF8CD 0xB004      STR      R11,[SP, #+4]
   \       0x96   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \       0x9A   0x4643             MOV      R3,R8
   \       0x9C   0xB29B             UXTH     R3,R3
   \       0x9E   0x003A             MOVS     R2,R7
   \       0xA0   0xB292             UXTH     R2,R2
   \       0xA2   0x0031             MOVS     R1,R6
   \       0xA4   0xB289             UXTH     R1,R1
   \       0xA6   0x0028             MOVS     R0,R5
   \       0xA8   0x.... 0x....      BL       I2C_RequestMemoryWrite
   \       0xAC   0x2800             CMP      R0,#+0
   \       0xAE   0xD001             BEQ.N    ??HAL_I2C_Mem_Write_5
   2456              {
   2457                return HAL_ERROR;
   \       0xB0   0x2001             MOVS     R0,#+1
   \       0xB2   0xE05A             B.N      ??HAL_I2C_Mem_Write_2
   2458              }
   2459          
   2460              while (hi2c->XferSize > 0U)
   \                     ??HAL_I2C_Mem_Write_5: (+1)
   \       0xB4   0x8D28             LDRH     R0,[R5, #+40]
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD033             BEQ.N    ??HAL_I2C_Mem_Write_6
   2461              {
   2462                /* Wait until TXE flag is set */
   2463                if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \       0xBA   0x465A             MOV      R2,R11
   \       0xBC   0x4651             MOV      R1,R10
   \       0xBE   0x0028             MOVS     R0,R5
   \       0xC0   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xD00A             BEQ.N    ??HAL_I2C_Mem_Write_7
   2464                {
   2465                  if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \       0xC8   0x6C28             LDR      R0,[R5, #+64]
   \       0xCA   0x2804             CMP      R0,#+4
   \       0xCC   0xD105             BNE.N    ??HAL_I2C_Mem_Write_8
   2466                  {
   2467                    /* Generate Stop */
   2468                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0xCE   0x6828             LDR      R0,[R5, #+0]
   \       0xD0   0x6800             LDR      R0,[R0, #+0]
   \       0xD2   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0xD6   0x6829             LDR      R1,[R5, #+0]
   \       0xD8   0x6008             STR      R0,[R1, #+0]
   2469                  }
   2470                  return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_8: (+1)
   \       0xDA   0x2001             MOVS     R0,#+1
   \       0xDC   0xE045             B.N      ??HAL_I2C_Mem_Write_2
   2471                }
   2472          
   2473                /* Write data to DR */
   2474                hi2c->Instance->DR = *hi2c->pBuffPtr;
   \                     ??HAL_I2C_Mem_Write_7: (+1)
   \       0xDE   0x6A68             LDR      R0,[R5, #+36]
   \       0xE0   0x7800             LDRB     R0,[R0, #+0]
   \       0xE2   0x6829             LDR      R1,[R5, #+0]
   \       0xE4   0x6108             STR      R0,[R1, #+16]
   2475          
   2476                /* Increment Buffer pointer */
   2477                hi2c->pBuffPtr++;
   \       0xE6   0x6A68             LDR      R0,[R5, #+36]
   \       0xE8   0x1C40             ADDS     R0,R0,#+1
   \       0xEA   0x6268             STR      R0,[R5, #+36]
   2478          
   2479                /* Update counter */
   2480                hi2c->XferSize--;
   \       0xEC   0x8D28             LDRH     R0,[R5, #+40]
   \       0xEE   0x1E40             SUBS     R0,R0,#+1
   \       0xF0   0x8528             STRH     R0,[R5, #+40]
   2481                hi2c->XferCount--;
   \       0xF2   0x8D68             LDRH     R0,[R5, #+42]
   \       0xF4   0x1E40             SUBS     R0,R0,#+1
   \       0xF6   0x8568             STRH     R0,[R5, #+42]
   2482          
   2483                if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
   \       0xF8   0x6828             LDR      R0,[R5, #+0]
   \       0xFA   0x6940             LDR      R0,[R0, #+20]
   \       0xFC   0x0740             LSLS     R0,R0,#+29
   \       0xFE   0xD5D9             BPL.N    ??HAL_I2C_Mem_Write_5
   \      0x100   0x8D28             LDRH     R0,[R5, #+40]
   \      0x102   0x2800             CMP      R0,#+0
   \      0x104   0xD0D6             BEQ.N    ??HAL_I2C_Mem_Write_5
   2484                {
   2485                  /* Write data to DR */
   2486                  hi2c->Instance->DR = *hi2c->pBuffPtr;
   \      0x106   0x6A68             LDR      R0,[R5, #+36]
   \      0x108   0x7800             LDRB     R0,[R0, #+0]
   \      0x10A   0x6829             LDR      R1,[R5, #+0]
   \      0x10C   0x6108             STR      R0,[R1, #+16]
   2487          
   2488                  /* Increment Buffer pointer */
   2489                  hi2c->pBuffPtr++;
   \      0x10E   0x6A68             LDR      R0,[R5, #+36]
   \      0x110   0x1C40             ADDS     R0,R0,#+1
   \      0x112   0x6268             STR      R0,[R5, #+36]
   2490          
   2491                  /* Update counter */
   2492                  hi2c->XferSize--;
   \      0x114   0x8D28             LDRH     R0,[R5, #+40]
   \      0x116   0x1E40             SUBS     R0,R0,#+1
   \      0x118   0x8528             STRH     R0,[R5, #+40]
   2493                  hi2c->XferCount--;
   \      0x11A   0x8D68             LDRH     R0,[R5, #+42]
   \      0x11C   0x1E40             SUBS     R0,R0,#+1
   \      0x11E   0x8568             STRH     R0,[R5, #+42]
   \      0x120   0xE7C8             B.N      ??HAL_I2C_Mem_Write_5
   2494                }
   2495              }
   2496          
   2497              /* Wait until BTF flag is set */
   2498              if (I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Mem_Write_6: (+1)
   \      0x122   0x465A             MOV      R2,R11
   \      0x124   0x4651             MOV      R1,R10
   \      0x126   0x0028             MOVS     R0,R5
   \      0x128   0x.... 0x....      BL       I2C_WaitOnBTFFlagUntilTimeout
   \      0x12C   0x2800             CMP      R0,#+0
   \      0x12E   0xD00A             BEQ.N    ??HAL_I2C_Mem_Write_9
   2499              {
   2500                if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \      0x130   0x6C28             LDR      R0,[R5, #+64]
   \      0x132   0x2804             CMP      R0,#+4
   \      0x134   0xD105             BNE.N    ??HAL_I2C_Mem_Write_10
   2501                {
   2502                  /* Generate Stop */
   2503                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \      0x136   0x6828             LDR      R0,[R5, #+0]
   \      0x138   0x6800             LDR      R0,[R0, #+0]
   \      0x13A   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x13E   0x6829             LDR      R1,[R5, #+0]
   \      0x140   0x6008             STR      R0,[R1, #+0]
   2504                }
   2505                return HAL_ERROR;
   \                     ??HAL_I2C_Mem_Write_10: (+1)
   \      0x142   0x2001             MOVS     R0,#+1
   \      0x144   0xE011             B.N      ??HAL_I2C_Mem_Write_2
   2506              }
   2507          
   2508              /* Generate Stop */
   2509              SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??HAL_I2C_Mem_Write_9: (+1)
   \      0x146   0x6828             LDR      R0,[R5, #+0]
   \      0x148   0x6800             LDR      R0,[R0, #+0]
   \      0x14A   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x14E   0x6829             LDR      R1,[R5, #+0]
   \      0x150   0x6008             STR      R0,[R1, #+0]
   2510          
   2511              hi2c->State = HAL_I2C_STATE_READY;
   \      0x152   0x2020             MOVS     R0,#+32
   \      0x154   0xF885 0x003D      STRB     R0,[R5, #+61]
   2512              hi2c->Mode = HAL_I2C_MODE_NONE;
   \      0x158   0x2000             MOVS     R0,#+0
   \      0x15A   0xF885 0x003E      STRB     R0,[R5, #+62]
   2513          
   2514              /* Process Unlocked */
   2515              __HAL_UNLOCK(hi2c);
   \      0x15E   0x2000             MOVS     R0,#+0
   \      0x160   0xF885 0x003C      STRB     R0,[R5, #+60]
   2516          
   2517              return HAL_OK;
   \      0x164   0x2000             MOVS     R0,#+0
   \      0x166   0xE000             B.N      ??HAL_I2C_Mem_Write_2
   2518            }
   2519            else
   2520            {
   2521              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_0: (+1)
   \      0x168   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_2: (+1)
   \      0x16A   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   2522            }
   2523          }
   2524          
   2525          /**
   2526            * @brief  Read an amount of data in blocking mode from a specific memory address
   2527            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2528            *                the configuration information for the specified I2C.
   2529            * @param  DevAddress Target device address: The device 7 bits address value
   2530            *         in datasheet must be shifted to the left before calling the interface
   2531            * @param  MemAddress Internal memory address
   2532            * @param  MemAddSize Size of internal memory address
   2533            * @param  pData Pointer to data buffer
   2534            * @param  Size Amount of data to be sent
   2535            * @param  Timeout Timeout duration
   2536            * @retval HAL status
   2537            */

   \                                 In section .text, align 2, keep-with-next
   2538          HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
   2539          {
   \                     HAL_I2C_Mem_Read: (+1)
   \        0x0   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \        0x4   0xB082             SUB      SP,SP,#+8
   \        0x6   0x0005             MOVS     R5,R0
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8030      LDR      R8,[SP, #+48]
   \       0x10   0x9C0D             LDR      R4,[SP, #+52]
   \       0x12   0xF8DD 0x9038      LDR      R9,[SP, #+56]
   2540            /* Init tickstart for timeout management*/
   2541            uint32_t tickstart = HAL_GetTick();
   \       0x16   0x.... 0x....      BL       HAL_GetTick
   \       0x1A   0x4682             MOV      R10,R0
   2542          
   2543            /* Check the parameters */
   2544            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2545          
   2546            if (hi2c->State == HAL_I2C_STATE_READY)
   \       0x1C   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x20   0x2820             CMP      R0,#+32
   \       0x22   0xF040 0x816A      BNE.W    ??HAL_I2C_Mem_Read_0
   2547            {
   2548              /* Wait until BUSY flag is reset */
   2549              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \       0x26   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \       0x2A   0x230A             MOVS     R3,#+10
   \       0x2C   0x2201             MOVS     R2,#+1
   \       0x2E   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \       0x32   0x0028             MOVS     R0,R5
   \       0x34   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_1
   2550              {
   2551                return HAL_BUSY;
   \       0x3C   0x2002             MOVS     R0,#+2
   \       0x3E   0xE15D             B.N      ??HAL_I2C_Mem_Read_2
   2552              }
   2553          
   2554              /* Process Locked */
   2555              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Mem_Read_1: (+1)
   \       0x40   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0x44   0x2801             CMP      R0,#+1
   \       0x46   0xD101             BNE.N    ??HAL_I2C_Mem_Read_3
   \       0x48   0x2002             MOVS     R0,#+2
   \       0x4A   0xE157             B.N      ??HAL_I2C_Mem_Read_2
   \                     ??HAL_I2C_Mem_Read_3: (+1)
   \       0x4C   0x2001             MOVS     R0,#+1
   \       0x4E   0xF885 0x003C      STRB     R0,[R5, #+60]
   2556          
   2557              /* Check if the I2C is already enabled */
   2558              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x52   0x6828             LDR      R0,[R5, #+0]
   \       0x54   0x6800             LDR      R0,[R0, #+0]
   \       0x56   0x07C0             LSLS     R0,R0,#+31
   \       0x58   0xD405             BMI.N    ??HAL_I2C_Mem_Read_4
   2559              {
   2560                /* Enable I2C peripheral */
   2561                __HAL_I2C_ENABLE(hi2c);
   \       0x5A   0x6828             LDR      R0,[R5, #+0]
   \       0x5C   0x6800             LDR      R0,[R0, #+0]
   \       0x5E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x62   0x6829             LDR      R1,[R5, #+0]
   \       0x64   0x6008             STR      R0,[R1, #+0]
   2562              }
   2563          
   2564              /* Disable Pos */
   2565              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Mem_Read_4: (+1)
   \       0x66   0x6828             LDR      R0,[R5, #+0]
   \       0x68   0x6800             LDR      R0,[R0, #+0]
   \       0x6A   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x6E   0x6829             LDR      R1,[R5, #+0]
   \       0x70   0x6008             STR      R0,[R1, #+0]
   2566          
   2567              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x72   0x2022             MOVS     R0,#+34
   \       0x74   0xF885 0x003D      STRB     R0,[R5, #+61]
   2568              hi2c->Mode      = HAL_I2C_MODE_MEM;
   \       0x78   0x2040             MOVS     R0,#+64
   \       0x7A   0xF885 0x003E      STRB     R0,[R5, #+62]
   2569              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0x6428             STR      R0,[R5, #+64]
   2570          
   2571              /* Prepare transfer parameters */
   2572              hi2c->pBuffPtr    = pData;
   \       0x82   0xF8C5 0x8024      STR      R8,[R5, #+36]
   2573              hi2c->XferCount   = Size;
   \       0x86   0x856C             STRH     R4,[R5, #+42]
   2574              hi2c->XferSize    = hi2c->XferCount;
   \       0x88   0x8D68             LDRH     R0,[R5, #+42]
   \       0x8A   0x8528             STRH     R0,[R5, #+40]
   2575              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x8C   0x.... 0x....      LDR.W    R0,??DataTable19
   \       0x90   0x62E8             STR      R0,[R5, #+44]
   2576          
   2577              /* Send Slave Address and Memory Address */
   2578              if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
   \       0x92   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \       0x96   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0x9A   0x003B             MOVS     R3,R7
   \       0x9C   0xB29B             UXTH     R3,R3
   \       0x9E   0x0032             MOVS     R2,R6
   \       0xA0   0xB292             UXTH     R2,R2
   \       0xA2   0xF8BD 0x1008      LDRH     R1,[SP, #+8]
   \       0xA6   0x0028             MOVS     R0,R5
   \       0xA8   0x.... 0x....      BL       I2C_RequestMemoryRead
   \       0xAC   0x2800             CMP      R0,#+0
   \       0xAE   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_5
   2579              {
   2580                return HAL_ERROR;
   \       0xB0   0x2001             MOVS     R0,#+1
   \       0xB2   0xE123             B.N      ??HAL_I2C_Mem_Read_2
   2581              }
   2582          
   2583              if (hi2c->XferSize == 0U)
   \                     ??HAL_I2C_Mem_Read_5: (+1)
   \       0xB4   0x8D28             LDRH     R0,[R5, #+40]
   \       0xB6   0x2800             CMP      R0,#+0
   \       0xB8   0xD10F             BNE.N    ??HAL_I2C_Mem_Read_6
   2584              {
   2585                /* Clear ADDR flag */
   2586                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \       0xBA   0x2000             MOVS     R0,#+0
   \       0xBC   0x9000             STR      R0,[SP, #+0]
   \       0xBE   0x6828             LDR      R0,[R5, #+0]
   \       0xC0   0x6940             LDR      R0,[R0, #+20]
   \       0xC2   0x9000             STR      R0,[SP, #+0]
   \       0xC4   0x6828             LDR      R0,[R5, #+0]
   \       0xC6   0x6980             LDR      R0,[R0, #+24]
   \       0xC8   0x9000             STR      R0,[SP, #+0]
   \       0xCA   0x9800             LDR      R0,[SP, #+0]
   2587          
   2588                /* Generate Stop */
   2589                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0xCC   0x6828             LDR      R0,[R5, #+0]
   \       0xCE   0x6800             LDR      R0,[R0, #+0]
   \       0xD0   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0xD4   0x6829             LDR      R1,[R5, #+0]
   \       0xD6   0x6008             STR      R0,[R1, #+0]
   \       0xD8   0xE03A             B.N      ??HAL_I2C_Mem_Read_7
   2590              }
   2591              else if (hi2c->XferSize == 1U)
   \                     ??HAL_I2C_Mem_Read_6: (+1)
   \       0xDA   0x8D28             LDRH     R0,[R5, #+40]
   \       0xDC   0x2801             CMP      R0,#+1
   \       0xDE   0xD115             BNE.N    ??HAL_I2C_Mem_Read_8
   2592              {
   2593                /* Disable Acknowledge */
   2594                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0xE0   0x6828             LDR      R0,[R5, #+0]
   \       0xE2   0x6800             LDR      R0,[R0, #+0]
   \       0xE4   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0xE8   0x6829             LDR      R1,[R5, #+0]
   \       0xEA   0x6008             STR      R0,[R1, #+0]
   2595          
   2596                /* Clear ADDR flag */
   2597                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \       0xEC   0x2000             MOVS     R0,#+0
   \       0xEE   0x9000             STR      R0,[SP, #+0]
   \       0xF0   0x6828             LDR      R0,[R5, #+0]
   \       0xF2   0x6940             LDR      R0,[R0, #+20]
   \       0xF4   0x9000             STR      R0,[SP, #+0]
   \       0xF6   0x6828             LDR      R0,[R5, #+0]
   \       0xF8   0x6980             LDR      R0,[R0, #+24]
   \       0xFA   0x9000             STR      R0,[SP, #+0]
   \       0xFC   0x9800             LDR      R0,[SP, #+0]
   2598          
   2599                /* Generate Stop */
   2600                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0xFE   0x6828             LDR      R0,[R5, #+0]
   \      0x100   0x6800             LDR      R0,[R0, #+0]
   \      0x102   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x106   0x6829             LDR      R1,[R5, #+0]
   \      0x108   0x6008             STR      R0,[R1, #+0]
   \      0x10A   0xE021             B.N      ??HAL_I2C_Mem_Read_7
   2601              }
   2602              else if (hi2c->XferSize == 2U)
   \                     ??HAL_I2C_Mem_Read_8: (+1)
   \      0x10C   0x8D28             LDRH     R0,[R5, #+40]
   \      0x10E   0x2802             CMP      R0,#+2
   \      0x110   0xD115             BNE.N    ??HAL_I2C_Mem_Read_9
   2603              {
   2604                /* Disable Acknowledge */
   2605                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \      0x112   0x6828             LDR      R0,[R5, #+0]
   \      0x114   0x6800             LDR      R0,[R0, #+0]
   \      0x116   0xF430 0x6080      BICS     R0,R0,#0x400
   \      0x11A   0x6829             LDR      R1,[R5, #+0]
   \      0x11C   0x6008             STR      R0,[R1, #+0]
   2606          
   2607                /* Enable Pos */
   2608                SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \      0x11E   0x6828             LDR      R0,[R5, #+0]
   \      0x120   0x6800             LDR      R0,[R0, #+0]
   \      0x122   0xF450 0x6000      ORRS     R0,R0,#0x800
   \      0x126   0x6829             LDR      R1,[R5, #+0]
   \      0x128   0x6008             STR      R0,[R1, #+0]
   2609          
   2610                /* Clear ADDR flag */
   2611                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \      0x12A   0x2000             MOVS     R0,#+0
   \      0x12C   0x9000             STR      R0,[SP, #+0]
   \      0x12E   0x6828             LDR      R0,[R5, #+0]
   \      0x130   0x6940             LDR      R0,[R0, #+20]
   \      0x132   0x9000             STR      R0,[SP, #+0]
   \      0x134   0x6828             LDR      R0,[R5, #+0]
   \      0x136   0x6980             LDR      R0,[R0, #+24]
   \      0x138   0x9000             STR      R0,[SP, #+0]
   \      0x13A   0x9800             LDR      R0,[SP, #+0]
   \      0x13C   0xE008             B.N      ??HAL_I2C_Mem_Read_7
   2612              }
   2613              else
   2614              {
   2615                /* Clear ADDR flag */
   2616                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Mem_Read_9: (+1)
   \      0x13E   0x2000             MOVS     R0,#+0
   \      0x140   0x9000             STR      R0,[SP, #+0]
   \      0x142   0x6828             LDR      R0,[R5, #+0]
   \      0x144   0x6940             LDR      R0,[R0, #+20]
   \      0x146   0x9000             STR      R0,[SP, #+0]
   \      0x148   0x6828             LDR      R0,[R5, #+0]
   \      0x14A   0x6980             LDR      R0,[R0, #+24]
   \      0x14C   0x9000             STR      R0,[SP, #+0]
   \      0x14E   0x9800             LDR      R0,[SP, #+0]
   2617              }
   2618          
   2619              while (hi2c->XferSize > 0U)
   \                     ??HAL_I2C_Mem_Read_7: (+1)
   \      0x150   0x8D28             LDRH     R0,[R5, #+40]
   \      0x152   0x2800             CMP      R0,#+0
   \      0x154   0xF000 0x80C6      BEQ.W    ??HAL_I2C_Mem_Read_10
   2620              {
   2621                if (hi2c->XferSize <= 3U)
   \      0x158   0x8D28             LDRH     R0,[R5, #+40]
   \      0x15A   0x2804             CMP      R0,#+4
   \      0x15C   0xF080 0x8099      BCS.W    ??HAL_I2C_Mem_Read_11
   2622                {
   2623                  /* One byte */
   2624                  if (hi2c->XferSize == 1U)
   \      0x160   0x8D28             LDRH     R0,[R5, #+40]
   \      0x162   0x2801             CMP      R0,#+1
   \      0x164   0xD116             BNE.N    ??HAL_I2C_Mem_Read_12
   2625                  {
   2626                    /* Wait until RXNE flag is set */
   2627                    if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \      0x166   0x4652             MOV      R2,R10
   \      0x168   0x4649             MOV      R1,R9
   \      0x16A   0x0028             MOVS     R0,R5
   \      0x16C   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \      0x170   0x2800             CMP      R0,#+0
   \      0x172   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_13
   2628                    {
   2629                      return HAL_ERROR;
   \      0x174   0x2001             MOVS     R0,#+1
   \      0x176   0xE0C1             B.N      ??HAL_I2C_Mem_Read_2
   2630                    }
   2631          
   2632                    /* Read data from DR */
   2633                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \                     ??HAL_I2C_Mem_Read_13: (+1)
   \      0x178   0x6828             LDR      R0,[R5, #+0]
   \      0x17A   0x6900             LDR      R0,[R0, #+16]
   \      0x17C   0x6A69             LDR      R1,[R5, #+36]
   \      0x17E   0x7008             STRB     R0,[R1, #+0]
   2634          
   2635                    /* Increment Buffer pointer */
   2636                    hi2c->pBuffPtr++;
   \      0x180   0x6A68             LDR      R0,[R5, #+36]
   \      0x182   0x1C40             ADDS     R0,R0,#+1
   \      0x184   0x6268             STR      R0,[R5, #+36]
   2637          
   2638                    /* Update counter */
   2639                    hi2c->XferSize--;
   \      0x186   0x8D28             LDRH     R0,[R5, #+40]
   \      0x188   0x1E40             SUBS     R0,R0,#+1
   \      0x18A   0x8528             STRH     R0,[R5, #+40]
   2640                    hi2c->XferCount--;
   \      0x18C   0x8D68             LDRH     R0,[R5, #+42]
   \      0x18E   0x1E40             SUBS     R0,R0,#+1
   \      0x190   0x8568             STRH     R0,[R5, #+42]
   \      0x192   0xE7DD             B.N      ??HAL_I2C_Mem_Read_7
   2641                  }
   2642                  /* Two bytes */
   2643                  else if (hi2c->XferSize == 2U)
   \                     ??HAL_I2C_Mem_Read_12: (+1)
   \      0x194   0x8D28             LDRH     R0,[R5, #+40]
   \      0x196   0x2802             CMP      R0,#+2
   \      0x198   0xD12D             BNE.N    ??HAL_I2C_Mem_Read_14
   2644                  {
   2645                    /* Wait until BTF flag is set */
   2646                    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \      0x19A   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \      0x19E   0x464B             MOV      R3,R9
   \      0x1A0   0x2200             MOVS     R2,#+0
   \      0x1A2   0x.... 0x....      LDR.W    R1,??DataTable21
   \      0x1A6   0x0028             MOVS     R0,R5
   \      0x1A8   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \      0x1AC   0x2800             CMP      R0,#+0
   \      0x1AE   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_15
   2647                    {
   2648                      return HAL_ERROR;
   \      0x1B0   0x2001             MOVS     R0,#+1
   \      0x1B2   0xE0A3             B.N      ??HAL_I2C_Mem_Read_2
   2649                    }
   2650          
   2651                    /* Generate Stop */
   2652                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??HAL_I2C_Mem_Read_15: (+1)
   \      0x1B4   0x6828             LDR      R0,[R5, #+0]
   \      0x1B6   0x6800             LDR      R0,[R0, #+0]
   \      0x1B8   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x1BC   0x6829             LDR      R1,[R5, #+0]
   \      0x1BE   0x6008             STR      R0,[R1, #+0]
   2653          
   2654                    /* Read data from DR */
   2655                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x1C0   0x6828             LDR      R0,[R5, #+0]
   \      0x1C2   0x6900             LDR      R0,[R0, #+16]
   \      0x1C4   0x6A69             LDR      R1,[R5, #+36]
   \      0x1C6   0x7008             STRB     R0,[R1, #+0]
   2656          
   2657                    /* Increment Buffer pointer */
   2658                    hi2c->pBuffPtr++;
   \      0x1C8   0x6A68             LDR      R0,[R5, #+36]
   \      0x1CA   0x1C40             ADDS     R0,R0,#+1
   \      0x1CC   0x6268             STR      R0,[R5, #+36]
   2659          
   2660                    /* Update counter */
   2661                    hi2c->XferSize--;
   \      0x1CE   0x8D28             LDRH     R0,[R5, #+40]
   \      0x1D0   0x1E40             SUBS     R0,R0,#+1
   \      0x1D2   0x8528             STRH     R0,[R5, #+40]
   2662                    hi2c->XferCount--;
   \      0x1D4   0x8D68             LDRH     R0,[R5, #+42]
   \      0x1D6   0x1E40             SUBS     R0,R0,#+1
   \      0x1D8   0x8568             STRH     R0,[R5, #+42]
   2663          
   2664                    /* Read data from DR */
   2665                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x1DA   0x6828             LDR      R0,[R5, #+0]
   \      0x1DC   0x6900             LDR      R0,[R0, #+16]
   \      0x1DE   0x6A69             LDR      R1,[R5, #+36]
   \      0x1E0   0x7008             STRB     R0,[R1, #+0]
   2666          
   2667                    /* Increment Buffer pointer */
   2668                    hi2c->pBuffPtr++;
   \      0x1E2   0x6A68             LDR      R0,[R5, #+36]
   \      0x1E4   0x1C40             ADDS     R0,R0,#+1
   \      0x1E6   0x6268             STR      R0,[R5, #+36]
   2669          
   2670                    /* Update counter */
   2671                    hi2c->XferSize--;
   \      0x1E8   0x8D28             LDRH     R0,[R5, #+40]
   \      0x1EA   0x1E40             SUBS     R0,R0,#+1
   \      0x1EC   0x8528             STRH     R0,[R5, #+40]
   2672                    hi2c->XferCount--;
   \      0x1EE   0x8D68             LDRH     R0,[R5, #+42]
   \      0x1F0   0x1E40             SUBS     R0,R0,#+1
   \      0x1F2   0x8568             STRH     R0,[R5, #+42]
   \      0x1F4   0xE7AC             B.N      ??HAL_I2C_Mem_Read_7
   2673                  }
   2674                  /* 3 Last bytes */
   2675                  else
   2676                  {
   2677                    /* Wait until BTF flag is set */
   2678                    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_14: (+1)
   \      0x1F6   0x.... 0x....      LDR.W    R11,??DataTable21
   \      0x1FA   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \      0x1FE   0x464B             MOV      R3,R9
   \      0x200   0x2200             MOVS     R2,#+0
   \      0x202   0x4659             MOV      R1,R11
   \      0x204   0x0028             MOVS     R0,R5
   \      0x206   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \      0x20A   0x2800             CMP      R0,#+0
   \      0x20C   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_16
   2679                    {
   2680                      return HAL_ERROR;
   \      0x20E   0x2001             MOVS     R0,#+1
   \      0x210   0xE074             B.N      ??HAL_I2C_Mem_Read_2
   2681                    }
   2682          
   2683                    /* Disable Acknowledge */
   2684                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Mem_Read_16: (+1)
   \      0x212   0x6828             LDR      R0,[R5, #+0]
   \      0x214   0x6800             LDR      R0,[R0, #+0]
   \      0x216   0xF430 0x6080      BICS     R0,R0,#0x400
   \      0x21A   0x6829             LDR      R1,[R5, #+0]
   \      0x21C   0x6008             STR      R0,[R1, #+0]
   2685          
   2686                    /* Read data from DR */
   2687                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x21E   0x6828             LDR      R0,[R5, #+0]
   \      0x220   0x6900             LDR      R0,[R0, #+16]
   \      0x222   0x6A69             LDR      R1,[R5, #+36]
   \      0x224   0x7008             STRB     R0,[R1, #+0]
   2688          
   2689                    /* Increment Buffer pointer */
   2690                    hi2c->pBuffPtr++;
   \      0x226   0x6A68             LDR      R0,[R5, #+36]
   \      0x228   0x1C40             ADDS     R0,R0,#+1
   \      0x22A   0x6268             STR      R0,[R5, #+36]
   2691          
   2692                    /* Update counter */
   2693                    hi2c->XferSize--;
   \      0x22C   0x8D28             LDRH     R0,[R5, #+40]
   \      0x22E   0x1E40             SUBS     R0,R0,#+1
   \      0x230   0x8528             STRH     R0,[R5, #+40]
   2694                    hi2c->XferCount--;
   \      0x232   0x8D68             LDRH     R0,[R5, #+42]
   \      0x234   0x1E40             SUBS     R0,R0,#+1
   \      0x236   0x8568             STRH     R0,[R5, #+42]
   2695          
   2696                    /* Wait until BTF flag is set */
   2697                    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
   \      0x238   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \      0x23C   0x464B             MOV      R3,R9
   \      0x23E   0x2200             MOVS     R2,#+0
   \      0x240   0x4659             MOV      R1,R11
   \      0x242   0x0028             MOVS     R0,R5
   \      0x244   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \      0x248   0x2800             CMP      R0,#+0
   \      0x24A   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_17
   2698                    {
   2699                      return HAL_ERROR;
   \      0x24C   0x2001             MOVS     R0,#+1
   \      0x24E   0xE055             B.N      ??HAL_I2C_Mem_Read_2
   2700                    }
   2701          
   2702                    /* Generate Stop */
   2703                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??HAL_I2C_Mem_Read_17: (+1)
   \      0x250   0x6828             LDR      R0,[R5, #+0]
   \      0x252   0x6800             LDR      R0,[R0, #+0]
   \      0x254   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x258   0x6829             LDR      R1,[R5, #+0]
   \      0x25A   0x6008             STR      R0,[R1, #+0]
   2704          
   2705                    /* Read data from DR */
   2706                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x25C   0x6828             LDR      R0,[R5, #+0]
   \      0x25E   0x6900             LDR      R0,[R0, #+16]
   \      0x260   0x6A69             LDR      R1,[R5, #+36]
   \      0x262   0x7008             STRB     R0,[R1, #+0]
   2707          
   2708                    /* Increment Buffer pointer */
   2709                    hi2c->pBuffPtr++;
   \      0x264   0x6A68             LDR      R0,[R5, #+36]
   \      0x266   0x1C40             ADDS     R0,R0,#+1
   \      0x268   0x6268             STR      R0,[R5, #+36]
   2710          
   2711                    /* Update counter */
   2712                    hi2c->XferSize--;
   \      0x26A   0x8D28             LDRH     R0,[R5, #+40]
   \      0x26C   0x1E40             SUBS     R0,R0,#+1
   \      0x26E   0x8528             STRH     R0,[R5, #+40]
   2713                    hi2c->XferCount--;
   \      0x270   0x8D68             LDRH     R0,[R5, #+42]
   \      0x272   0x1E40             SUBS     R0,R0,#+1
   \      0x274   0x8568             STRH     R0,[R5, #+42]
   2714          
   2715                    /* Read data from DR */
   2716                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x276   0x6828             LDR      R0,[R5, #+0]
   \      0x278   0x6900             LDR      R0,[R0, #+16]
   \      0x27A   0x6A69             LDR      R1,[R5, #+36]
   \      0x27C   0x7008             STRB     R0,[R1, #+0]
   2717          
   2718                    /* Increment Buffer pointer */
   2719                    hi2c->pBuffPtr++;
   \      0x27E   0x6A68             LDR      R0,[R5, #+36]
   \      0x280   0x1C40             ADDS     R0,R0,#+1
   \      0x282   0x6268             STR      R0,[R5, #+36]
   2720          
   2721                    /* Update counter */
   2722                    hi2c->XferSize--;
   \      0x284   0x8D28             LDRH     R0,[R5, #+40]
   \      0x286   0x1E40             SUBS     R0,R0,#+1
   \      0x288   0x8528             STRH     R0,[R5, #+40]
   2723                    hi2c->XferCount--;
   \      0x28A   0x8D68             LDRH     R0,[R5, #+42]
   \      0x28C   0x1E40             SUBS     R0,R0,#+1
   \      0x28E   0x8568             STRH     R0,[R5, #+42]
   \      0x290   0xE75E             B.N      ??HAL_I2C_Mem_Read_7
   2724                  }
   2725                }
   2726                else
   2727                {
   2728                  /* Wait until RXNE flag is set */
   2729                  if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_11: (+1)
   \      0x292   0x4652             MOV      R2,R10
   \      0x294   0x4649             MOV      R1,R9
   \      0x296   0x0028             MOVS     R0,R5
   \      0x298   0x.... 0x....      BL       I2C_WaitOnRXNEFlagUntilTimeout
   \      0x29C   0x2800             CMP      R0,#+0
   \      0x29E   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_18
   2730                  {
   2731                    return HAL_ERROR;
   \      0x2A0   0x2001             MOVS     R0,#+1
   \      0x2A2   0xE02B             B.N      ??HAL_I2C_Mem_Read_2
   2732                  }
   2733          
   2734                  /* Read data from DR */
   2735                  *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \                     ??HAL_I2C_Mem_Read_18: (+1)
   \      0x2A4   0x6828             LDR      R0,[R5, #+0]
   \      0x2A6   0x6900             LDR      R0,[R0, #+16]
   \      0x2A8   0x6A69             LDR      R1,[R5, #+36]
   \      0x2AA   0x7008             STRB     R0,[R1, #+0]
   2736          
   2737                  /* Increment Buffer pointer */
   2738                  hi2c->pBuffPtr++;
   \      0x2AC   0x6A68             LDR      R0,[R5, #+36]
   \      0x2AE   0x1C40             ADDS     R0,R0,#+1
   \      0x2B0   0x6268             STR      R0,[R5, #+36]
   2739          
   2740                  /* Update counter */
   2741                  hi2c->XferSize--;
   \      0x2B2   0x8D28             LDRH     R0,[R5, #+40]
   \      0x2B4   0x1E40             SUBS     R0,R0,#+1
   \      0x2B6   0x8528             STRH     R0,[R5, #+40]
   2742                  hi2c->XferCount--;
   \      0x2B8   0x8D68             LDRH     R0,[R5, #+42]
   \      0x2BA   0x1E40             SUBS     R0,R0,#+1
   \      0x2BC   0x8568             STRH     R0,[R5, #+42]
   2743          
   2744                  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
   \      0x2BE   0x6828             LDR      R0,[R5, #+0]
   \      0x2C0   0x6940             LDR      R0,[R0, #+20]
   \      0x2C2   0x0740             LSLS     R0,R0,#+29
   \      0x2C4   0xF57F 0xAF44      BPL.W    ??HAL_I2C_Mem_Read_7
   2745                  {
   2746                    /* Read data from DR */
   2747                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x2C8   0x6828             LDR      R0,[R5, #+0]
   \      0x2CA   0x6900             LDR      R0,[R0, #+16]
   \      0x2CC   0x6A69             LDR      R1,[R5, #+36]
   \      0x2CE   0x7008             STRB     R0,[R1, #+0]
   2748          
   2749                    /* Increment Buffer pointer */
   2750                    hi2c->pBuffPtr++;
   \      0x2D0   0x6A68             LDR      R0,[R5, #+36]
   \      0x2D2   0x1C40             ADDS     R0,R0,#+1
   \      0x2D4   0x6268             STR      R0,[R5, #+36]
   2751          
   2752                    /* Update counter */
   2753                    hi2c->XferSize--;
   \      0x2D6   0x8D28             LDRH     R0,[R5, #+40]
   \      0x2D8   0x1E40             SUBS     R0,R0,#+1
   \      0x2DA   0x8528             STRH     R0,[R5, #+40]
   2754                    hi2c->XferCount--;
   \      0x2DC   0x8D68             LDRH     R0,[R5, #+42]
   \      0x2DE   0x1E40             SUBS     R0,R0,#+1
   \      0x2E0   0x8568             STRH     R0,[R5, #+42]
   \      0x2E2   0xE735             B.N      ??HAL_I2C_Mem_Read_7
   2755                  }
   2756                }
   2757              }
   2758          
   2759              hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Mem_Read_10: (+1)
   \      0x2E4   0x2020             MOVS     R0,#+32
   \      0x2E6   0xF885 0x003D      STRB     R0,[R5, #+61]
   2760              hi2c->Mode = HAL_I2C_MODE_NONE;
   \      0x2EA   0x2000             MOVS     R0,#+0
   \      0x2EC   0xF885 0x003E      STRB     R0,[R5, #+62]
   2761          
   2762              /* Process Unlocked */
   2763              __HAL_UNLOCK(hi2c);
   \      0x2F0   0x2000             MOVS     R0,#+0
   \      0x2F2   0xF885 0x003C      STRB     R0,[R5, #+60]
   2764          
   2765              return HAL_OK;
   \      0x2F6   0x2000             MOVS     R0,#+0
   \      0x2F8   0xE000             B.N      ??HAL_I2C_Mem_Read_2
   2766            }
   2767            else
   2768            {
   2769              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_0: (+1)
   \      0x2FA   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_2: (+1)
   \      0x2FC   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   2770            }
   2771          }
   2772          
   2773          /**
   2774            * @brief  Write an amount of data in non-blocking mode with Interrupt to a specific memory address
   2775            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2776            *                the configuration information for the specified I2C.
   2777            * @param  DevAddress Target device address: The device 7 bits address value
   2778            *         in datasheet must be shifted to the left before calling the interface
   2779            * @param  MemAddress Internal memory address
   2780            * @param  MemAddSize Size of internal memory address
   2781            * @param  pData Pointer to data buffer
   2782            * @param  Size Amount of data to be sent
   2783            * @retval HAL status
   2784            */

   \                                 In section .text, align 2, keep-with-next
   2785          HAL_StatusTypeDef HAL_I2C_Mem_Write_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2786          {
   \                     HAL_I2C_Mem_Write_IT: (+1)
   \        0x0   0xB4F8             PUSH     {R3-R7}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x9E05             LDR      R6,[SP, #+20]
   \        0x6   0x9C06             LDR      R4,[SP, #+24]
   2787            __IO uint32_t count = 0U;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9000             STR      R0,[SP, #+0]
   2788          
   2789            /* Check the parameters */
   2790            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2791          
   2792            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0xC   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x10   0x2820             CMP      R0,#+32
   \       0x12   0xD16B             BNE.N    ??HAL_I2C_Mem_Write_IT_0
   2793            {
   2794              /* Wait until BUSY flag is reset */
   2795              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x2719             MOVS     R7,#+25
   \       0x1C   0xFBB0 0xF0F7      UDIV     R0,R0,R7
   \       0x20   0xF44F 0x777A      MOV      R7,#+1000
   \       0x24   0xFBB0 0xF7F7      UDIV     R7,R0,R7
   \       0x28   0x200A             MOVS     R0,#+10
   \       0x2A   0x4347             MULS     R7,R0,R7
   \       0x2C   0x9700             STR      R7,[SP, #+0]
   2796              do
   2797              {
   2798                count--;
   \                     ??HAL_I2C_Mem_Write_IT_1: (+1)
   \       0x2E   0x9800             LDR      R0,[SP, #+0]
   \       0x30   0x1E40             SUBS     R0,R0,#+1
   \       0x32   0x9000             STR      R0,[SP, #+0]
   2799                if (count == 0U)
   \       0x34   0x9800             LDR      R0,[SP, #+0]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD110             BNE.N    ??HAL_I2C_Mem_Write_IT_2
   2800                {
   2801                  hi2c->PreviousState       = I2C_STATE_NONE;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x6328             STR      R0,[R5, #+48]
   2802                  hi2c->State               = HAL_I2C_STATE_READY;
   \       0x3E   0x2020             MOVS     R0,#+32
   \       0x40   0xF885 0x003D      STRB     R0,[R5, #+61]
   2803                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xF885 0x003E      STRB     R0,[R5, #+62]
   2804                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0x4A   0x6C28             LDR      R0,[R5, #+64]
   \       0x4C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x50   0x6428             STR      R0,[R5, #+64]
   2805          
   2806                  /* Process Unlocked */
   2807                  __HAL_UNLOCK(hi2c);
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xF885 0x003C      STRB     R0,[R5, #+60]
   2808          
   2809                  return HAL_ERROR;
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0xE048             B.N      ??HAL_I2C_Mem_Write_IT_3
   2810                }
   2811              }
   2812              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Mem_Write_IT_2: (+1)
   \       0x5C   0x6828             LDR      R0,[R5, #+0]
   \       0x5E   0x6980             LDR      R0,[R0, #+24]
   \       0x60   0x0780             LSLS     R0,R0,#+30
   \       0x62   0xD4E4             BMI.N    ??HAL_I2C_Mem_Write_IT_1
   2813          
   2814              /* Process Locked */
   2815              __HAL_LOCK(hi2c);
   \       0x64   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0x68   0x2801             CMP      R0,#+1
   \       0x6A   0xD101             BNE.N    ??HAL_I2C_Mem_Write_IT_4
   \       0x6C   0x2002             MOVS     R0,#+2
   \       0x6E   0xE03E             B.N      ??HAL_I2C_Mem_Write_IT_3
   \                     ??HAL_I2C_Mem_Write_IT_4: (+1)
   \       0x70   0x2001             MOVS     R0,#+1
   \       0x72   0xF885 0x003C      STRB     R0,[R5, #+60]
   2816          
   2817              /* Check if the I2C is already enabled */
   2818              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x76   0x6828             LDR      R0,[R5, #+0]
   \       0x78   0x6800             LDR      R0,[R0, #+0]
   \       0x7A   0x07C0             LSLS     R0,R0,#+31
   \       0x7C   0xD405             BMI.N    ??HAL_I2C_Mem_Write_IT_5
   2819              {
   2820                /* Enable I2C peripheral */
   2821                __HAL_I2C_ENABLE(hi2c);
   \       0x7E   0x6828             LDR      R0,[R5, #+0]
   \       0x80   0x6800             LDR      R0,[R0, #+0]
   \       0x82   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x86   0x682F             LDR      R7,[R5, #+0]
   \       0x88   0x6038             STR      R0,[R7, #+0]
   2822              }
   2823          
   2824              /* Disable Pos */
   2825              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Mem_Write_IT_5: (+1)
   \       0x8A   0x6828             LDR      R0,[R5, #+0]
   \       0x8C   0x6800             LDR      R0,[R0, #+0]
   \       0x8E   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x92   0x682F             LDR      R7,[R5, #+0]
   \       0x94   0x6038             STR      R0,[R7, #+0]
   2826          
   2827              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0x96   0x2021             MOVS     R0,#+33
   \       0x98   0xF885 0x003D      STRB     R0,[R5, #+61]
   2828              hi2c->Mode      = HAL_I2C_MODE_MEM;
   \       0x9C   0x2040             MOVS     R0,#+64
   \       0x9E   0xF885 0x003E      STRB     R0,[R5, #+62]
   2829              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0x6428             STR      R0,[R5, #+64]
   2830          
   2831              /* Prepare transfer parameters */
   2832              hi2c->pBuffPtr    = pData;
   \       0xA6   0x626E             STR      R6,[R5, #+36]
   2833              hi2c->XferCount   = Size;
   \       0xA8   0x856C             STRH     R4,[R5, #+42]
   2834              hi2c->XferSize    = hi2c->XferCount;
   \       0xAA   0x8D68             LDRH     R0,[R5, #+42]
   \       0xAC   0x8528             STRH     R0,[R5, #+40]
   2835              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0xAE   0x.... 0x....      LDR.W    R0,??DataTable19
   \       0xB2   0x62E8             STR      R0,[R5, #+44]
   2836              hi2c->Devaddress  = DevAddress;
   \       0xB4   0x0008             MOVS     R0,R1
   \       0xB6   0xB280             UXTH     R0,R0
   \       0xB8   0x6468             STR      R0,[R5, #+68]
   2837              hi2c->Memaddress  = MemAddress;
   \       0xBA   0x0010             MOVS     R0,R2
   \       0xBC   0xB280             UXTH     R0,R0
   \       0xBE   0x64A8             STR      R0,[R5, #+72]
   2838              hi2c->MemaddSize  = MemAddSize;
   \       0xC0   0x0018             MOVS     R0,R3
   \       0xC2   0xB280             UXTH     R0,R0
   \       0xC4   0x64E8             STR      R0,[R5, #+76]
   2839              hi2c->EventCount  = 0U;
   \       0xC6   0x2000             MOVS     R0,#+0
   \       0xC8   0x6528             STR      R0,[R5, #+80]
   2840          
   2841              /* Generate Start */
   2842              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \       0xCA   0x6828             LDR      R0,[R5, #+0]
   \       0xCC   0x6800             LDR      R0,[R0, #+0]
   \       0xCE   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0xD2   0x682F             LDR      R7,[R5, #+0]
   \       0xD4   0x6038             STR      R0,[R7, #+0]
   2843          
   2844              /* Process Unlocked */
   2845              __HAL_UNLOCK(hi2c);
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0xF885 0x003C      STRB     R0,[R5, #+60]
   2846          
   2847              /* Note : The I2C interrupts must be enabled after unlocking current process
   2848              to avoid the risk of I2C interrupt handle execution before current
   2849              process unlock */
   2850          
   2851              /* Enable EVT, BUF and ERR interrupt */
   2852              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0xDC   0x6828             LDR      R0,[R5, #+0]
   \       0xDE   0x6840             LDR      R0,[R0, #+4]
   \       0xE0   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \       0xE4   0x682F             LDR      R7,[R5, #+0]
   \       0xE6   0x6078             STR      R0,[R7, #+4]
   2853          
   2854              return HAL_OK;
   \       0xE8   0x2000             MOVS     R0,#+0
   \       0xEA   0xE000             B.N      ??HAL_I2C_Mem_Write_IT_3
   2855            }
   2856            else
   2857            {
   2858              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_IT_0: (+1)
   \       0xEC   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_IT_3: (+1)
   \       0xEE   0xBCF2             POP      {R1,R4-R7}
   \       0xF0   0x4770             BX       LR
   2859            }
   2860          }
   2861          
   2862          /**
   2863            * @brief  Read an amount of data in non-blocking mode with Interrupt from a specific memory address
   2864            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2865            *                the configuration information for the specified I2C.
   2866            * @param  DevAddress Target device address
   2867            * @param  MemAddress Internal memory address
   2868            * @param  MemAddSize Size of internal memory address
   2869            * @param  pData Pointer to data buffer
   2870            * @param  Size Amount of data to be sent
   2871            * @retval HAL status
   2872            */

   \                                 In section .text, align 2, keep-with-next
   2873          HAL_StatusTypeDef HAL_I2C_Mem_Read_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2874          {
   \                     HAL_I2C_Mem_Read_IT: (+1)
   \        0x0   0xB4F8             PUSH     {R3-R7}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x9E05             LDR      R6,[SP, #+20]
   \        0x6   0x9C06             LDR      R4,[SP, #+24]
   2875            __IO uint32_t count = 0U;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x9000             STR      R0,[SP, #+0]
   2876          
   2877            /* Check the parameters */
   2878            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2879          
   2880            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0xC   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x10   0x2820             CMP      R0,#+32
   \       0x12   0xD174             BNE.N    ??HAL_I2C_Mem_Read_IT_0
   2881            {
   2882              /* Wait until BUSY flag is reset */
   2883              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \       0x14   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x2719             MOVS     R7,#+25
   \       0x1C   0xFBB0 0xF0F7      UDIV     R0,R0,R7
   \       0x20   0xF44F 0x777A      MOV      R7,#+1000
   \       0x24   0xFBB0 0xF7F7      UDIV     R7,R0,R7
   \       0x28   0x200A             MOVS     R0,#+10
   \       0x2A   0x4347             MULS     R7,R0,R7
   \       0x2C   0x9700             STR      R7,[SP, #+0]
   2884              do
   2885              {
   2886                count--;
   \                     ??HAL_I2C_Mem_Read_IT_1: (+1)
   \       0x2E   0x9800             LDR      R0,[SP, #+0]
   \       0x30   0x1E40             SUBS     R0,R0,#+1
   \       0x32   0x9000             STR      R0,[SP, #+0]
   2887                if (count == 0U)
   \       0x34   0x9800             LDR      R0,[SP, #+0]
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD110             BNE.N    ??HAL_I2C_Mem_Read_IT_2
   2888                {
   2889                  hi2c->PreviousState       = I2C_STATE_NONE;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x6328             STR      R0,[R5, #+48]
   2890                  hi2c->State               = HAL_I2C_STATE_READY;
   \       0x3E   0x2020             MOVS     R0,#+32
   \       0x40   0xF885 0x003D      STRB     R0,[R5, #+61]
   2891                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xF885 0x003E      STRB     R0,[R5, #+62]
   2892                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0x4A   0x6C28             LDR      R0,[R5, #+64]
   \       0x4C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x50   0x6428             STR      R0,[R5, #+64]
   2893          
   2894                  /* Process Unlocked */
   2895                  __HAL_UNLOCK(hi2c);
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xF885 0x003C      STRB     R0,[R5, #+60]
   2896          
   2897                  return HAL_ERROR;
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0xE051             B.N      ??HAL_I2C_Mem_Read_IT_3
   2898                }
   2899              }
   2900              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Mem_Read_IT_2: (+1)
   \       0x5C   0x6828             LDR      R0,[R5, #+0]
   \       0x5E   0x6980             LDR      R0,[R0, #+24]
   \       0x60   0x0780             LSLS     R0,R0,#+30
   \       0x62   0xD4E4             BMI.N    ??HAL_I2C_Mem_Read_IT_1
   2901          
   2902              /* Process Locked */
   2903              __HAL_LOCK(hi2c);
   \       0x64   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0x68   0x2801             CMP      R0,#+1
   \       0x6A   0xD101             BNE.N    ??HAL_I2C_Mem_Read_IT_4
   \       0x6C   0x2002             MOVS     R0,#+2
   \       0x6E   0xE047             B.N      ??HAL_I2C_Mem_Read_IT_3
   \                     ??HAL_I2C_Mem_Read_IT_4: (+1)
   \       0x70   0x2001             MOVS     R0,#+1
   \       0x72   0xF885 0x003C      STRB     R0,[R5, #+60]
   2904          
   2905              /* Check if the I2C is already enabled */
   2906              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x76   0x6828             LDR      R0,[R5, #+0]
   \       0x78   0x6800             LDR      R0,[R0, #+0]
   \       0x7A   0x07C0             LSLS     R0,R0,#+31
   \       0x7C   0xD405             BMI.N    ??HAL_I2C_Mem_Read_IT_5
   2907              {
   2908                /* Enable I2C peripheral */
   2909                __HAL_I2C_ENABLE(hi2c);
   \       0x7E   0x6828             LDR      R0,[R5, #+0]
   \       0x80   0x6800             LDR      R0,[R0, #+0]
   \       0x82   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x86   0x682F             LDR      R7,[R5, #+0]
   \       0x88   0x6038             STR      R0,[R7, #+0]
   2910              }
   2911          
   2912              /* Disable Pos */
   2913              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Mem_Read_IT_5: (+1)
   \       0x8A   0x6828             LDR      R0,[R5, #+0]
   \       0x8C   0x6800             LDR      R0,[R0, #+0]
   \       0x8E   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x92   0x682F             LDR      R7,[R5, #+0]
   \       0x94   0x6038             STR      R0,[R7, #+0]
   2914          
   2915              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0x96   0x2022             MOVS     R0,#+34
   \       0x98   0xF885 0x003D      STRB     R0,[R5, #+61]
   2916              hi2c->Mode      = HAL_I2C_MODE_MEM;
   \       0x9C   0x2040             MOVS     R0,#+64
   \       0x9E   0xF885 0x003E      STRB     R0,[R5, #+62]
   2917              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0x6428             STR      R0,[R5, #+64]
   2918          
   2919              /* Prepare transfer parameters */
   2920              hi2c->pBuffPtr    = pData;
   \       0xA6   0x626E             STR      R6,[R5, #+36]
   2921              hi2c->XferCount   = Size;
   \       0xA8   0x856C             STRH     R4,[R5, #+42]
   2922              hi2c->XferSize    = hi2c->XferCount;
   \       0xAA   0x8D68             LDRH     R0,[R5, #+42]
   \       0xAC   0x8528             STRH     R0,[R5, #+40]
   2923              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0xAE   0x.... 0x....      LDR.W    R0,??DataTable19
   \       0xB2   0x62E8             STR      R0,[R5, #+44]
   2924              hi2c->Devaddress  = DevAddress;
   \       0xB4   0x0008             MOVS     R0,R1
   \       0xB6   0xB280             UXTH     R0,R0
   \       0xB8   0x6468             STR      R0,[R5, #+68]
   2925              hi2c->Memaddress  = MemAddress;
   \       0xBA   0x0010             MOVS     R0,R2
   \       0xBC   0xB280             UXTH     R0,R0
   \       0xBE   0x64A8             STR      R0,[R5, #+72]
   2926              hi2c->MemaddSize  = MemAddSize;
   \       0xC0   0x0018             MOVS     R0,R3
   \       0xC2   0xB280             UXTH     R0,R0
   \       0xC4   0x64E8             STR      R0,[R5, #+76]
   2927              hi2c->EventCount  = 0U;
   \       0xC6   0x2000             MOVS     R0,#+0
   \       0xC8   0x6528             STR      R0,[R5, #+80]
   2928          
   2929              /* Enable Acknowledge */
   2930              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0xCA   0x6828             LDR      R0,[R5, #+0]
   \       0xCC   0x6800             LDR      R0,[R0, #+0]
   \       0xCE   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0xD2   0x682F             LDR      R7,[R5, #+0]
   \       0xD4   0x6038             STR      R0,[R7, #+0]
   2931          
   2932              /* Generate Start */
   2933              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \       0xD6   0x6828             LDR      R0,[R5, #+0]
   \       0xD8   0x6800             LDR      R0,[R0, #+0]
   \       0xDA   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0xDE   0x682F             LDR      R7,[R5, #+0]
   \       0xE0   0x6038             STR      R0,[R7, #+0]
   2934          
   2935              /* Process Unlocked */
   2936              __HAL_UNLOCK(hi2c);
   \       0xE2   0x2000             MOVS     R0,#+0
   \       0xE4   0xF885 0x003C      STRB     R0,[R5, #+60]
   2937          
   2938              if (hi2c->XferSize > 0U)
   \       0xE8   0x8D28             LDRH     R0,[R5, #+40]
   \       0xEA   0x2800             CMP      R0,#+0
   \       0xEC   0xD005             BEQ.N    ??HAL_I2C_Mem_Read_IT_6
   2939              {
   2940                /* Note : The I2C interrupts must be enabled after unlocking current process
   2941                to avoid the risk of I2C interrupt handle execution before current
   2942                process unlock */
   2943          
   2944                /* Enable EVT, BUF and ERR interrupt */
   2945                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0xEE   0x6828             LDR      R0,[R5, #+0]
   \       0xF0   0x6840             LDR      R0,[R0, #+4]
   \       0xF2   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \       0xF6   0x682F             LDR      R7,[R5, #+0]
   \       0xF8   0x6078             STR      R0,[R7, #+4]
   2946              }
   2947              return HAL_OK;
   \                     ??HAL_I2C_Mem_Read_IT_6: (+1)
   \       0xFA   0x2000             MOVS     R0,#+0
   \       0xFC   0xE000             B.N      ??HAL_I2C_Mem_Read_IT_3
   2948            }
   2949            else
   2950            {
   2951              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_IT_0: (+1)
   \       0xFE   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_IT_3: (+1)
   \      0x100   0xBCF2             POP      {R1,R4-R7}
   \      0x102   0x4770             BX       LR
   2952            }
   2953          }
   2954          
   2955          /**
   2956            * @brief  Write an amount of data in non-blocking mode with DMA to a specific memory address
   2957            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   2958            *                the configuration information for the specified I2C.
   2959            * @param  DevAddress Target device address: The device 7 bits address value
   2960            *         in datasheet must be shifted to the left before calling the interface
   2961            * @param  MemAddress Internal memory address
   2962            * @param  MemAddSize Size of internal memory address
   2963            * @param  pData Pointer to data buffer
   2964            * @param  Size Amount of data to be sent
   2965            * @retval HAL status
   2966            */

   \                                 In section .text, align 2, keep-with-next
   2967          HAL_StatusTypeDef HAL_I2C_Mem_Write_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   2968          {
   \                     HAL_I2C_Mem_Write_DMA: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   \        0xC   0xF8DD 0x9030      LDR      R9,[SP, #+48]
   \       0x10   0x9C0D             LDR      R4,[SP, #+52]
   2969            __IO uint32_t count = 0U;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x9002             STR      R0,[SP, #+8]
   2970            HAL_StatusTypeDef dmaxferstatus;
   2971          
   2972            /* Init tickstart for timeout management*/
   2973            uint32_t tickstart = HAL_GetTick();
   \       0x16   0x.... 0x....      BL       HAL_GetTick
   \       0x1A   0x4682             MOV      R10,R0
   2974          
   2975            /* Check the parameters */
   2976            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   2977          
   2978            if (hi2c->State == HAL_I2C_STATE_READY)
   \       0x1C   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x20   0x2820             CMP      R0,#+32
   \       0x22   0xF040 0x80D6      BNE.W    ??HAL_I2C_Mem_Write_DMA_0
   2979            {
   2980              /* Wait until BUSY flag is reset */
   2981              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0x2119             MOVS     R1,#+25
   \       0x2E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x32   0xF44F 0x717A      MOV      R1,#+1000
   \       0x36   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x3A   0x200A             MOVS     R0,#+10
   \       0x3C   0x4341             MULS     R1,R0,R1
   \       0x3E   0x9102             STR      R1,[SP, #+8]
   2982              do
   2983              {
   2984                count--;
   \                     ??HAL_I2C_Mem_Write_DMA_1: (+1)
   \       0x40   0x9802             LDR      R0,[SP, #+8]
   \       0x42   0x1E40             SUBS     R0,R0,#+1
   \       0x44   0x9002             STR      R0,[SP, #+8]
   2985                if (count == 0U)
   \       0x46   0x9802             LDR      R0,[SP, #+8]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD110             BNE.N    ??HAL_I2C_Mem_Write_DMA_2
   2986                {
   2987                  hi2c->PreviousState       = I2C_STATE_NONE;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x6328             STR      R0,[R5, #+48]
   2988                  hi2c->State               = HAL_I2C_STATE_READY;
   \       0x50   0x2020             MOVS     R0,#+32
   \       0x52   0xF885 0x003D      STRB     R0,[R5, #+61]
   2989                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xF885 0x003E      STRB     R0,[R5, #+62]
   2990                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0x5C   0x6C28             LDR      R0,[R5, #+64]
   \       0x5E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x62   0x6428             STR      R0,[R5, #+64]
   2991          
   2992                  /* Process Unlocked */
   2993                  __HAL_UNLOCK(hi2c);
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xF885 0x003C      STRB     R0,[R5, #+60]
   2994          
   2995                  return HAL_ERROR;
   \       0x6A   0x2001             MOVS     R0,#+1
   \       0x6C   0xE0B2             B.N      ??HAL_I2C_Mem_Write_DMA_3
   2996                }
   2997              }
   2998              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Mem_Write_DMA_2: (+1)
   \       0x6E   0x6828             LDR      R0,[R5, #+0]
   \       0x70   0x6980             LDR      R0,[R0, #+24]
   \       0x72   0x0780             LSLS     R0,R0,#+30
   \       0x74   0xD4E4             BMI.N    ??HAL_I2C_Mem_Write_DMA_1
   2999          
   3000              /* Process Locked */
   3001              __HAL_LOCK(hi2c);
   \       0x76   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0x7A   0x2801             CMP      R0,#+1
   \       0x7C   0xD101             BNE.N    ??HAL_I2C_Mem_Write_DMA_4
   \       0x7E   0x2002             MOVS     R0,#+2
   \       0x80   0xE0A8             B.N      ??HAL_I2C_Mem_Write_DMA_3
   \                     ??HAL_I2C_Mem_Write_DMA_4: (+1)
   \       0x82   0x2001             MOVS     R0,#+1
   \       0x84   0xF885 0x003C      STRB     R0,[R5, #+60]
   3002          
   3003              /* Check if the I2C is already enabled */
   3004              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x88   0x6828             LDR      R0,[R5, #+0]
   \       0x8A   0x6800             LDR      R0,[R0, #+0]
   \       0x8C   0x07C0             LSLS     R0,R0,#+31
   \       0x8E   0xD405             BMI.N    ??HAL_I2C_Mem_Write_DMA_5
   3005              {
   3006                /* Enable I2C peripheral */
   3007                __HAL_I2C_ENABLE(hi2c);
   \       0x90   0x6828             LDR      R0,[R5, #+0]
   \       0x92   0x6800             LDR      R0,[R0, #+0]
   \       0x94   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x98   0x6829             LDR      R1,[R5, #+0]
   \       0x9A   0x6008             STR      R0,[R1, #+0]
   3008              }
   3009          
   3010              /* Disable Pos */
   3011              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Mem_Write_DMA_5: (+1)
   \       0x9C   0x6828             LDR      R0,[R5, #+0]
   \       0x9E   0x6800             LDR      R0,[R0, #+0]
   \       0xA0   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0xA4   0x6829             LDR      R1,[R5, #+0]
   \       0xA6   0x6008             STR      R0,[R1, #+0]
   3012          
   3013              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0xA8   0x2021             MOVS     R0,#+33
   \       0xAA   0xF885 0x003D      STRB     R0,[R5, #+61]
   3014              hi2c->Mode      = HAL_I2C_MODE_MEM;
   \       0xAE   0x2040             MOVS     R0,#+64
   \       0xB0   0xF885 0x003E      STRB     R0,[R5, #+62]
   3015              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0x6428             STR      R0,[R5, #+64]
   3016          
   3017              /* Prepare transfer parameters */
   3018              hi2c->pBuffPtr    = pData;
   \       0xB8   0xF8C5 0x9024      STR      R9,[R5, #+36]
   3019              hi2c->XferCount   = Size;
   \       0xBC   0x856C             STRH     R4,[R5, #+42]
   3020              hi2c->XferSize    = hi2c->XferCount;
   \       0xBE   0x8D68             LDRH     R0,[R5, #+42]
   \       0xC0   0x8528             STRH     R0,[R5, #+40]
   3021              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0xC2   0x.... 0x....      LDR.W    R0,??DataTable19
   \       0xC6   0x62E8             STR      R0,[R5, #+44]
   3022          
   3023              if (hi2c->XferSize > 0U)
   \       0xC8   0x8D28             LDRH     R0,[R5, #+40]
   \       0xCA   0x2800             CMP      R0,#+0
   \       0xCC   0xD072             BEQ.N    ??HAL_I2C_Mem_Write_DMA_6
   3024              {
   3025                /* Set the I2C DMA transfer complete callback */
   3026                hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
   \       0xCE   0x....             LDR.N    R0,??DataTable17
   \       0xD0   0x6B69             LDR      R1,[R5, #+52]
   \       0xD2   0x63C8             STR      R0,[R1, #+60]
   3027          
   3028                /* Set the DMA error callback */
   3029                hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \       0xD4   0x....             LDR.N    R0,??DataTable17_1
   \       0xD6   0x6B69             LDR      R1,[R5, #+52]
   \       0xD8   0x64C8             STR      R0,[R1, #+76]
   3030          
   3031                /* Set the unused DMA callbacks to NULL */
   3032                hi2c->hdmatx->XferHalfCpltCallback = NULL;
   \       0xDA   0x2000             MOVS     R0,#+0
   \       0xDC   0x6B69             LDR      R1,[R5, #+52]
   \       0xDE   0x6408             STR      R0,[R1, #+64]
   3033                hi2c->hdmatx->XferM1CpltCallback = NULL;
   \       0xE0   0x2000             MOVS     R0,#+0
   \       0xE2   0x6B69             LDR      R1,[R5, #+52]
   \       0xE4   0x6448             STR      R0,[R1, #+68]
   3034                hi2c->hdmatx->XferM1HalfCpltCallback = NULL;
   \       0xE6   0x2000             MOVS     R0,#+0
   \       0xE8   0x6B69             LDR      R1,[R5, #+52]
   \       0xEA   0x6488             STR      R0,[R1, #+72]
   3035                hi2c->hdmatx->XferAbortCallback = NULL;
   \       0xEC   0x2000             MOVS     R0,#+0
   \       0xEE   0x6B69             LDR      R1,[R5, #+52]
   \       0xF0   0x6508             STR      R0,[R1, #+80]
   3036          
   3037                /* Enable the DMA stream */
   3038                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
   \       0xF2   0x8D2B             LDRH     R3,[R5, #+40]
   \       0xF4   0x6828             LDR      R0,[R5, #+0]
   \       0xF6   0xF110 0x0210      ADDS     R2,R0,#+16
   \       0xFA   0x6A69             LDR      R1,[R5, #+36]
   \       0xFC   0x6B68             LDR      R0,[R5, #+52]
   \       0xFE   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x102   0x4683             MOV      R11,R0
   3039          
   3040                if (dmaxferstatus == HAL_OK)
   \      0x104   0x4658             MOV      R0,R11
   \      0x106   0xB2C0             UXTB     R0,R0
   \      0x108   0x2800             CMP      R0,#+0
   \      0x10A   0xD144             BNE.N    ??HAL_I2C_Mem_Write_DMA_7
   3041                {
   3042                  /* Send Slave Address and Memory Address */
   3043                  if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
   \      0x10C   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \      0x110   0x200F             MOVS     R0,#+15
   \      0x112   0x9000             STR      R0,[SP, #+0]
   \      0x114   0x4643             MOV      R3,R8
   \      0x116   0xB29B             UXTH     R3,R3
   \      0x118   0x003A             MOVS     R2,R7
   \      0x11A   0xB292             UXTH     R2,R2
   \      0x11C   0x0031             MOVS     R1,R6
   \      0x11E   0xB289             UXTH     R1,R1
   \      0x120   0x0028             MOVS     R0,R5
   \      0x122   0x.... 0x....      BL       I2C_RequestMemoryWrite
   \      0x126   0x2800             CMP      R0,#+0
   \      0x128   0xD01B             BEQ.N    ??HAL_I2C_Mem_Write_DMA_8
   3044                  {
   3045                    /* Abort the ongoing DMA */
   3046                    dmaxferstatus = HAL_DMA_Abort_IT(hi2c->hdmatx);
   \      0x12A   0x6B68             LDR      R0,[R5, #+52]
   \      0x12C   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \      0x130   0x0001             MOVS     R1,R0
   3047          
   3048                    /* Prevent unused argument(s) compilation and MISRA warning */
   3049                    UNUSED(dmaxferstatus);
   3050          
   3051                    /* Clear directly Complete callback as no XferAbortCallback is used to finalize Abort treatment */
   3052                    if (hi2c->hdmatx != NULL)
   \      0x132   0x6B68             LDR      R0,[R5, #+52]
   \      0x134   0x2800             CMP      R0,#+0
   \      0x136   0xD002             BEQ.N    ??HAL_I2C_Mem_Write_DMA_9
   3053                    {
   3054                      hi2c->hdmatx->XferCpltCallback = NULL;
   \      0x138   0x2000             MOVS     R0,#+0
   \      0x13A   0x6B6A             LDR      R2,[R5, #+52]
   \      0x13C   0x63D0             STR      R0,[R2, #+60]
   3055                    }
   3056          
   3057                    /* Disable Acknowledge */
   3058                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Mem_Write_DMA_9: (+1)
   \      0x13E   0x6828             LDR      R0,[R5, #+0]
   \      0x140   0x6800             LDR      R0,[R0, #+0]
   \      0x142   0xF430 0x6080      BICS     R0,R0,#0x400
   \      0x146   0x682A             LDR      R2,[R5, #+0]
   \      0x148   0x6010             STR      R0,[R2, #+0]
   3059          
   3060                    hi2c->XferSize = 0U;
   \      0x14A   0x2000             MOVS     R0,#+0
   \      0x14C   0x8528             STRH     R0,[R5, #+40]
   3061                    hi2c->XferCount = 0U;
   \      0x14E   0x2000             MOVS     R0,#+0
   \      0x150   0x8568             STRH     R0,[R5, #+42]
   3062          
   3063                    /* Disable I2C peripheral to prevent dummy data in buffer */
   3064                    __HAL_I2C_DISABLE(hi2c);
   \      0x152   0x6828             LDR      R0,[R5, #+0]
   \      0x154   0x6800             LDR      R0,[R0, #+0]
   \      0x156   0x0840             LSRS     R0,R0,#+1
   \      0x158   0x0040             LSLS     R0,R0,#+1
   \      0x15A   0x682A             LDR      R2,[R5, #+0]
   \      0x15C   0x6010             STR      R0,[R2, #+0]
   3065          
   3066                    return HAL_ERROR;
   \      0x15E   0x2001             MOVS     R0,#+1
   \      0x160   0xE038             B.N      ??HAL_I2C_Mem_Write_DMA_3
   3067                  }
   3068          
   3069                  /* Clear ADDR flag */
   3070                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Mem_Write_DMA_8: (+1)
   \      0x162   0x2000             MOVS     R0,#+0
   \      0x164   0x9000             STR      R0,[SP, #+0]
   \      0x166   0x6828             LDR      R0,[R5, #+0]
   \      0x168   0x6940             LDR      R0,[R0, #+20]
   \      0x16A   0x9000             STR      R0,[SP, #+0]
   \      0x16C   0x6828             LDR      R0,[R5, #+0]
   \      0x16E   0x6980             LDR      R0,[R0, #+24]
   \      0x170   0x9000             STR      R0,[SP, #+0]
   \      0x172   0x9800             LDR      R0,[SP, #+0]
   3071          
   3072                  /* Process Unlocked */
   3073                  __HAL_UNLOCK(hi2c);
   \      0x174   0x2000             MOVS     R0,#+0
   \      0x176   0xF885 0x003C      STRB     R0,[R5, #+60]
   3074          
   3075                  /* Note : The I2C interrupts must be enabled after unlocking current process
   3076                  to avoid the risk of I2C interrupt handle execution before current
   3077                  process unlock */
   3078                  /* Enable ERR interrupt */
   3079                  __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERR);
   \      0x17A   0x6828             LDR      R0,[R5, #+0]
   \      0x17C   0x6840             LDR      R0,[R0, #+4]
   \      0x17E   0xF450 0x7080      ORRS     R0,R0,#0x100
   \      0x182   0x6829             LDR      R1,[R5, #+0]
   \      0x184   0x6048             STR      R0,[R1, #+4]
   3080          
   3081                  /* Enable DMA Request */
   3082                  SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \      0x186   0x6828             LDR      R0,[R5, #+0]
   \      0x188   0x6840             LDR      R0,[R0, #+4]
   \      0x18A   0xF450 0x6000      ORRS     R0,R0,#0x800
   \      0x18E   0x6829             LDR      R1,[R5, #+0]
   \      0x190   0x6048             STR      R0,[R1, #+4]
   3083          
   3084                  return HAL_OK;
   \      0x192   0x2000             MOVS     R0,#+0
   \      0x194   0xE01E             B.N      ??HAL_I2C_Mem_Write_DMA_3
   3085                }
   3086                else
   3087                {
   3088                  /* Update I2C state */
   3089                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Mem_Write_DMA_7: (+1)
   \      0x196   0x2020             MOVS     R0,#+32
   \      0x198   0xF885 0x003D      STRB     R0,[R5, #+61]
   3090                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   \      0x19C   0x2000             MOVS     R0,#+0
   \      0x19E   0xF885 0x003E      STRB     R0,[R5, #+62]
   3091          
   3092                  /* Update I2C error code */
   3093                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \      0x1A2   0x6C28             LDR      R0,[R5, #+64]
   \      0x1A4   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x1A8   0x6428             STR      R0,[R5, #+64]
   3094          
   3095                  /* Process Unlocked */
   3096                  __HAL_UNLOCK(hi2c);
   \      0x1AA   0x2000             MOVS     R0,#+0
   \      0x1AC   0xF885 0x003C      STRB     R0,[R5, #+60]
   3097          
   3098                  return HAL_ERROR;
   \      0x1B0   0x2001             MOVS     R0,#+1
   \      0x1B2   0xE00F             B.N      ??HAL_I2C_Mem_Write_DMA_3
   3099                }
   3100              }
   3101              else
   3102              {
   3103                /* Update I2C state */
   3104                hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Mem_Write_DMA_6: (+1)
   \      0x1B4   0x2020             MOVS     R0,#+32
   \      0x1B6   0xF885 0x003D      STRB     R0,[R5, #+61]
   3105                hi2c->Mode      = HAL_I2C_MODE_NONE;
   \      0x1BA   0x2000             MOVS     R0,#+0
   \      0x1BC   0xF885 0x003E      STRB     R0,[R5, #+62]
   3106          
   3107                /* Update I2C error code */
   3108                hi2c->ErrorCode |= HAL_I2C_ERROR_SIZE;
   \      0x1C0   0x6C28             LDR      R0,[R5, #+64]
   \      0x1C2   0xF050 0x0040      ORRS     R0,R0,#0x40
   \      0x1C6   0x6428             STR      R0,[R5, #+64]
   3109          
   3110                /* Process Unlocked */
   3111                __HAL_UNLOCK(hi2c);
   \      0x1C8   0x2000             MOVS     R0,#+0
   \      0x1CA   0xF885 0x003C      STRB     R0,[R5, #+60]
   3112          
   3113                return HAL_ERROR;
   \      0x1CE   0x2001             MOVS     R0,#+1
   \      0x1D0   0xE000             B.N      ??HAL_I2C_Mem_Write_DMA_3
   3114              }
   3115            }
   3116            else
   3117            {
   3118              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Write_DMA_0: (+1)
   \      0x1D2   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Write_DMA_3: (+1)
   \      0x1D4   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   3119            }
   3120          }
   3121          
   3122          /**
   3123            * @brief  Reads an amount of data in non-blocking mode with DMA from a specific memory address.
   3124            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3125            *                the configuration information for the specified I2C.
   3126            * @param  DevAddress Target device address: The device 7 bits address value
   3127            *         in datasheet must be shifted to the left before calling the interface
   3128            * @param  MemAddress Internal memory address
   3129            * @param  MemAddSize Size of internal memory address
   3130            * @param  pData Pointer to data buffer
   3131            * @param  Size Amount of data to be read
   3132            * @retval HAL status
   3133            */

   \                                 In section .text, align 2, keep-with-next
   3134          HAL_StatusTypeDef HAL_I2C_Mem_Read_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size)
   3135          {
   \                     HAL_I2C_Mem_Read_DMA: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x0006             MOVS     R6,R0
   \        0x6   0x000F             MOVS     R7,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x4699             MOV      R9,R3
   \        0xC   0xF8DD 0xA030      LDR      R10,[SP, #+48]
   \       0x10   0x9C0D             LDR      R4,[SP, #+52]
   3136            /* Init tickstart for timeout management*/
   3137            uint32_t tickstart = HAL_GetTick();
   \       0x12   0x.... 0x....      BL       HAL_GetTick
   \       0x16   0x4683             MOV      R11,R0
   3138            __IO uint32_t count = 0U;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x9002             STR      R0,[SP, #+8]
   3139            HAL_StatusTypeDef dmaxferstatus;
   3140          
   3141            /* Check the parameters */
   3142            assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));
   3143          
   3144            if (hi2c->State == HAL_I2C_STATE_READY)
   \       0x1C   0xF896 0x003D      LDRB     R0,[R6, #+61]
   \       0x20   0x2820             CMP      R0,#+32
   \       0x22   0xF040 0x8100      BNE.W    ??HAL_I2C_Mem_Read_DMA_0
   3145            {
   3146              /* Wait until BUSY flag is reset */
   3147              count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0x2119             MOVS     R1,#+25
   \       0x2E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x32   0xF44F 0x717A      MOV      R1,#+1000
   \       0x36   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x3A   0x200A             MOVS     R0,#+10
   \       0x3C   0x4341             MULS     R1,R0,R1
   \       0x3E   0x9102             STR      R1,[SP, #+8]
   3148              do
   3149              {
   3150                count--;
   \                     ??HAL_I2C_Mem_Read_DMA_1: (+1)
   \       0x40   0x9802             LDR      R0,[SP, #+8]
   \       0x42   0x1E40             SUBS     R0,R0,#+1
   \       0x44   0x9002             STR      R0,[SP, #+8]
   3151                if (count == 0U)
   \       0x46   0x9802             LDR      R0,[SP, #+8]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD110             BNE.N    ??HAL_I2C_Mem_Read_DMA_2
   3152                {
   3153                  hi2c->PreviousState       = I2C_STATE_NONE;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x6330             STR      R0,[R6, #+48]
   3154                  hi2c->State               = HAL_I2C_STATE_READY;
   \       0x50   0x2020             MOVS     R0,#+32
   \       0x52   0xF886 0x003D      STRB     R0,[R6, #+61]
   3155                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xF886 0x003E      STRB     R0,[R6, #+62]
   3156                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0x5C   0x6C30             LDR      R0,[R6, #+64]
   \       0x5E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x62   0x6430             STR      R0,[R6, #+64]
   3157          
   3158                  /* Process Unlocked */
   3159                  __HAL_UNLOCK(hi2c);
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xF886 0x003C      STRB     R0,[R6, #+60]
   3160          
   3161                  return HAL_ERROR;
   \       0x6A   0x2001             MOVS     R0,#+1
   \       0x6C   0xE0DC             B.N      ??HAL_I2C_Mem_Read_DMA_3
   3162                }
   3163              }
   3164              while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Mem_Read_DMA_2: (+1)
   \       0x6E   0x6830             LDR      R0,[R6, #+0]
   \       0x70   0x6980             LDR      R0,[R0, #+24]
   \       0x72   0x0780             LSLS     R0,R0,#+30
   \       0x74   0xD4E4             BMI.N    ??HAL_I2C_Mem_Read_DMA_1
   3165          
   3166              /* Process Locked */
   3167              __HAL_LOCK(hi2c);
   \       0x76   0xF896 0x003C      LDRB     R0,[R6, #+60]
   \       0x7A   0x2801             CMP      R0,#+1
   \       0x7C   0xD101             BNE.N    ??HAL_I2C_Mem_Read_DMA_4
   \       0x7E   0x2002             MOVS     R0,#+2
   \       0x80   0xE0D2             B.N      ??HAL_I2C_Mem_Read_DMA_3
   \                     ??HAL_I2C_Mem_Read_DMA_4: (+1)
   \       0x82   0x2001             MOVS     R0,#+1
   \       0x84   0xF886 0x003C      STRB     R0,[R6, #+60]
   3168          
   3169              /* Check if the I2C is already enabled */
   3170              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x88   0x6830             LDR      R0,[R6, #+0]
   \       0x8A   0x6800             LDR      R0,[R0, #+0]
   \       0x8C   0x07C0             LSLS     R0,R0,#+31
   \       0x8E   0xD405             BMI.N    ??HAL_I2C_Mem_Read_DMA_5
   3171              {
   3172                /* Enable I2C peripheral */
   3173                __HAL_I2C_ENABLE(hi2c);
   \       0x90   0x6830             LDR      R0,[R6, #+0]
   \       0x92   0x6800             LDR      R0,[R0, #+0]
   \       0x94   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x98   0x6831             LDR      R1,[R6, #+0]
   \       0x9A   0x6008             STR      R0,[R1, #+0]
   3174              }
   3175          
   3176              /* Disable Pos */
   3177              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Mem_Read_DMA_5: (+1)
   \       0x9C   0x6830             LDR      R0,[R6, #+0]
   \       0x9E   0x6800             LDR      R0,[R0, #+0]
   \       0xA0   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0xA4   0x6831             LDR      R1,[R6, #+0]
   \       0xA6   0x6008             STR      R0,[R1, #+0]
   3178          
   3179              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0xA8   0x2022             MOVS     R0,#+34
   \       0xAA   0xF886 0x003D      STRB     R0,[R6, #+61]
   3180              hi2c->Mode      = HAL_I2C_MODE_MEM;
   \       0xAE   0x2040             MOVS     R0,#+64
   \       0xB0   0xF886 0x003E      STRB     R0,[R6, #+62]
   3181              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0x6430             STR      R0,[R6, #+64]
   3182          
   3183              /* Prepare transfer parameters */
   3184              hi2c->pBuffPtr    = pData;
   \       0xB8   0xF8C6 0xA024      STR      R10,[R6, #+36]
   3185              hi2c->XferCount   = Size;
   \       0xBC   0x8574             STRH     R4,[R6, #+42]
   3186              hi2c->XferSize    = hi2c->XferCount;
   \       0xBE   0x8D70             LDRH     R0,[R6, #+42]
   \       0xC0   0x8530             STRH     R0,[R6, #+40]
   3187              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0xC2   0x....             LDR.N    R0,??DataTable19
   \       0xC4   0x62F0             STR      R0,[R6, #+44]
   3188          
   3189              if (hi2c->XferSize > 0U)
   \       0xC6   0x8D30             LDRH     R0,[R6, #+40]
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xF000 0x8084      BEQ.W    ??HAL_I2C_Mem_Read_DMA_6
   3190              {
   3191                /* Set the I2C DMA transfer complete callback */
   3192                hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
   \       0xCE   0x.... 0x....      LDR.W    R0,??DataTable24
   \       0xD2   0x6BB1             LDR      R1,[R6, #+56]
   \       0xD4   0x63C8             STR      R0,[R1, #+60]
   3193          
   3194                /* Set the DMA error callback */
   3195                hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \       0xD6   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \       0xDA   0x6BB1             LDR      R1,[R6, #+56]
   \       0xDC   0x64C8             STR      R0,[R1, #+76]
   3196          
   3197                /* Set the unused DMA callbacks to NULL */
   3198                hi2c->hdmarx->XferHalfCpltCallback = NULL;
   \       0xDE   0x2000             MOVS     R0,#+0
   \       0xE0   0x6BB1             LDR      R1,[R6, #+56]
   \       0xE2   0x6408             STR      R0,[R1, #+64]
   3199                hi2c->hdmarx->XferM1CpltCallback = NULL;
   \       0xE4   0x2000             MOVS     R0,#+0
   \       0xE6   0x6BB1             LDR      R1,[R6, #+56]
   \       0xE8   0x6448             STR      R0,[R1, #+68]
   3200                hi2c->hdmarx->XferM1HalfCpltCallback = NULL;
   \       0xEA   0x2000             MOVS     R0,#+0
   \       0xEC   0x6BB1             LDR      R1,[R6, #+56]
   \       0xEE   0x6488             STR      R0,[R1, #+72]
   3201                hi2c->hdmarx->XferAbortCallback = NULL;
   \       0xF0   0x2000             MOVS     R0,#+0
   \       0xF2   0x6BB1             LDR      R1,[R6, #+56]
   \       0xF4   0x6508             STR      R0,[R1, #+80]
   3202          
   3203                /* Enable the DMA stream */
   3204                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   \       0xF6   0x8D33             LDRH     R3,[R6, #+40]
   \       0xF8   0x6A72             LDR      R2,[R6, #+36]
   \       0xFA   0x6830             LDR      R0,[R6, #+0]
   \       0xFC   0xF110 0x0110      ADDS     R1,R0,#+16
   \      0x100   0x6BB0             LDR      R0,[R6, #+56]
   \      0x102   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x106   0x0005             MOVS     R5,R0
   3205          
   3206                if (dmaxferstatus == HAL_OK)
   \      0x108   0x0028             MOVS     R0,R5
   \      0x10A   0xB2C0             UXTB     R0,R0
   \      0x10C   0x2800             CMP      R0,#+0
   \      0x10E   0xD153             BNE.N    ??HAL_I2C_Mem_Read_DMA_7
   3207                {
   3208                  /* Send Slave Address and Memory Address */
   3209                  if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
   \      0x110   0xF8CD 0xB004      STR      R11,[SP, #+4]
   \      0x114   0x200F             MOVS     R0,#+15
   \      0x116   0x9000             STR      R0,[SP, #+0]
   \      0x118   0x464B             MOV      R3,R9
   \      0x11A   0xB29B             UXTH     R3,R3
   \      0x11C   0x4642             MOV      R2,R8
   \      0x11E   0xB292             UXTH     R2,R2
   \      0x120   0x0039             MOVS     R1,R7
   \      0x122   0xB289             UXTH     R1,R1
   \      0x124   0x0030             MOVS     R0,R6
   \      0x126   0x.... 0x....      BL       I2C_RequestMemoryRead
   \      0x12A   0x2800             CMP      R0,#+0
   \      0x12C   0xD01B             BEQ.N    ??HAL_I2C_Mem_Read_DMA_8
   3210                  {
   3211                    /* Abort the ongoing DMA */
   3212                    dmaxferstatus = HAL_DMA_Abort_IT(hi2c->hdmarx);
   \      0x12E   0x6BB0             LDR      R0,[R6, #+56]
   \      0x130   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \      0x134   0x0001             MOVS     R1,R0
   3213          
   3214                    /* Prevent unused argument(s) compilation and MISRA warning */
   3215                    UNUSED(dmaxferstatus);
   3216          
   3217                    /* Clear directly Complete callback as no XferAbortCallback is used to finalize Abort treatment */
   3218                    if (hi2c->hdmarx != NULL)
   \      0x136   0x6BB0             LDR      R0,[R6, #+56]
   \      0x138   0x2800             CMP      R0,#+0
   \      0x13A   0xD002             BEQ.N    ??HAL_I2C_Mem_Read_DMA_9
   3219                    {
   3220                      hi2c->hdmarx->XferCpltCallback = NULL;
   \      0x13C   0x2000             MOVS     R0,#+0
   \      0x13E   0x6BB2             LDR      R2,[R6, #+56]
   \      0x140   0x63D0             STR      R0,[R2, #+60]
   3221                    }
   3222          
   3223                    /* Disable Acknowledge */
   3224                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Mem_Read_DMA_9: (+1)
   \      0x142   0x6830             LDR      R0,[R6, #+0]
   \      0x144   0x6800             LDR      R0,[R0, #+0]
   \      0x146   0xF430 0x6080      BICS     R0,R0,#0x400
   \      0x14A   0x6832             LDR      R2,[R6, #+0]
   \      0x14C   0x6010             STR      R0,[R2, #+0]
   3225          
   3226                    hi2c->XferSize = 0U;
   \      0x14E   0x2000             MOVS     R0,#+0
   \      0x150   0x8530             STRH     R0,[R6, #+40]
   3227                    hi2c->XferCount = 0U;
   \      0x152   0x2000             MOVS     R0,#+0
   \      0x154   0x8570             STRH     R0,[R6, #+42]
   3228          
   3229                    /* Disable I2C peripheral to prevent dummy data in buffer */
   3230                    __HAL_I2C_DISABLE(hi2c);
   \      0x156   0x6830             LDR      R0,[R6, #+0]
   \      0x158   0x6800             LDR      R0,[R0, #+0]
   \      0x15A   0x0840             LSRS     R0,R0,#+1
   \      0x15C   0x0040             LSLS     R0,R0,#+1
   \      0x15E   0x6832             LDR      R2,[R6, #+0]
   \      0x160   0x6010             STR      R0,[R2, #+0]
   3231          
   3232                    return HAL_ERROR;
   \      0x162   0x2001             MOVS     R0,#+1
   \      0x164   0xE060             B.N      ??HAL_I2C_Mem_Read_DMA_3
   3233                  }
   3234          
   3235                  if (hi2c->XferSize == 1U)
   \                     ??HAL_I2C_Mem_Read_DMA_8: (+1)
   \      0x166   0x8D30             LDRH     R0,[R6, #+40]
   \      0x168   0x2801             CMP      R0,#+1
   \      0x16A   0xD106             BNE.N    ??HAL_I2C_Mem_Read_DMA_10
   3236                  {
   3237                    /* Disable Acknowledge */
   3238                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \      0x16C   0x6830             LDR      R0,[R6, #+0]
   \      0x16E   0x6800             LDR      R0,[R0, #+0]
   \      0x170   0xF430 0x6080      BICS     R0,R0,#0x400
   \      0x174   0x6831             LDR      R1,[R6, #+0]
   \      0x176   0x6008             STR      R0,[R1, #+0]
   \      0x178   0xE005             B.N      ??HAL_I2C_Mem_Read_DMA_11
   3239                  }
   3240                  else
   3241                  {
   3242                    /* Enable Last DMA bit */
   3243                    SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \                     ??HAL_I2C_Mem_Read_DMA_10: (+1)
   \      0x17A   0x6830             LDR      R0,[R6, #+0]
   \      0x17C   0x6840             LDR      R0,[R0, #+4]
   \      0x17E   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \      0x182   0x6831             LDR      R1,[R6, #+0]
   \      0x184   0x6048             STR      R0,[R1, #+4]
   3244                  }
   3245          
   3246                  /* Clear ADDR flag */
   3247                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Mem_Read_DMA_11: (+1)
   \      0x186   0x2000             MOVS     R0,#+0
   \      0x188   0x9000             STR      R0,[SP, #+0]
   \      0x18A   0x6830             LDR      R0,[R6, #+0]
   \      0x18C   0x6940             LDR      R0,[R0, #+20]
   \      0x18E   0x9000             STR      R0,[SP, #+0]
   \      0x190   0x6830             LDR      R0,[R6, #+0]
   \      0x192   0x6980             LDR      R0,[R0, #+24]
   \      0x194   0x9000             STR      R0,[SP, #+0]
   \      0x196   0x9800             LDR      R0,[SP, #+0]
   3248          
   3249                  /* Process Unlocked */
   3250                  __HAL_UNLOCK(hi2c);
   \      0x198   0x2000             MOVS     R0,#+0
   \      0x19A   0xF886 0x003C      STRB     R0,[R6, #+60]
   3251          
   3252                  /* Note : The I2C interrupts must be enabled after unlocking current process
   3253                  to avoid the risk of I2C interrupt handle execution before current
   3254                  process unlock */
   3255                  /* Enable ERR interrupt */
   3256                  __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_ERR);
   \      0x19E   0x6830             LDR      R0,[R6, #+0]
   \      0x1A0   0x6840             LDR      R0,[R0, #+4]
   \      0x1A2   0xF450 0x7080      ORRS     R0,R0,#0x100
   \      0x1A6   0x6831             LDR      R1,[R6, #+0]
   \      0x1A8   0x6048             STR      R0,[R1, #+4]
   3257          
   3258                  /* Enable DMA Request */
   3259                  hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
   \      0x1AA   0x6830             LDR      R0,[R6, #+0]
   \      0x1AC   0x6840             LDR      R0,[R0, #+4]
   \      0x1AE   0xF450 0x6000      ORRS     R0,R0,#0x800
   \      0x1B2   0x6831             LDR      R1,[R6, #+0]
   \      0x1B4   0x6048             STR      R0,[R1, #+4]
   \      0x1B6   0xE034             B.N      ??HAL_I2C_Mem_Read_DMA_12
   3260                }
   3261                else
   3262                {
   3263                  /* Update I2C state */
   3264                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Mem_Read_DMA_7: (+1)
   \      0x1B8   0x2020             MOVS     R0,#+32
   \      0x1BA   0xF886 0x003D      STRB     R0,[R6, #+61]
   3265                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   \      0x1BE   0x2000             MOVS     R0,#+0
   \      0x1C0   0xF886 0x003E      STRB     R0,[R6, #+62]
   3266          
   3267                  /* Update I2C error code */
   3268                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \      0x1C4   0x6C30             LDR      R0,[R6, #+64]
   \      0x1C6   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x1CA   0x6430             STR      R0,[R6, #+64]
   3269          
   3270                  /* Process Unlocked */
   3271                  __HAL_UNLOCK(hi2c);
   \      0x1CC   0x2000             MOVS     R0,#+0
   \      0x1CE   0xF886 0x003C      STRB     R0,[R6, #+60]
   3272          
   3273                  return HAL_ERROR;
   \      0x1D2   0x2001             MOVS     R0,#+1
   \      0x1D4   0xE028             B.N      ??HAL_I2C_Mem_Read_DMA_3
   3274                }
   3275              }
   3276              else
   3277              {
   3278                /* Send Slave Address and Memory Address */
   3279                if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, I2C_TIMEOUT_FLAG, tickstart) != HAL_OK)
   \                     ??HAL_I2C_Mem_Read_DMA_6: (+1)
   \      0x1D6   0xF8CD 0xB004      STR      R11,[SP, #+4]
   \      0x1DA   0x200F             MOVS     R0,#+15
   \      0x1DC   0x9000             STR      R0,[SP, #+0]
   \      0x1DE   0x464B             MOV      R3,R9
   \      0x1E0   0xB29B             UXTH     R3,R3
   \      0x1E2   0x4642             MOV      R2,R8
   \      0x1E4   0xB292             UXTH     R2,R2
   \      0x1E6   0x0039             MOVS     R1,R7
   \      0x1E8   0xB289             UXTH     R1,R1
   \      0x1EA   0x0030             MOVS     R0,R6
   \      0x1EC   0x.... 0x....      BL       I2C_RequestMemoryRead
   \      0x1F0   0x2800             CMP      R0,#+0
   \      0x1F2   0xD001             BEQ.N    ??HAL_I2C_Mem_Read_DMA_13
   3280                {
   3281                  return HAL_ERROR;
   \      0x1F4   0x2001             MOVS     R0,#+1
   \      0x1F6   0xE017             B.N      ??HAL_I2C_Mem_Read_DMA_3
   3282                }
   3283          
   3284                /* Clear ADDR flag */
   3285                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??HAL_I2C_Mem_Read_DMA_13: (+1)
   \      0x1F8   0x2000             MOVS     R0,#+0
   \      0x1FA   0x9000             STR      R0,[SP, #+0]
   \      0x1FC   0x6830             LDR      R0,[R6, #+0]
   \      0x1FE   0x6940             LDR      R0,[R0, #+20]
   \      0x200   0x9000             STR      R0,[SP, #+0]
   \      0x202   0x6830             LDR      R0,[R6, #+0]
   \      0x204   0x6980             LDR      R0,[R0, #+24]
   \      0x206   0x9000             STR      R0,[SP, #+0]
   \      0x208   0x9800             LDR      R0,[SP, #+0]
   3286          
   3287                /* Generate Stop */
   3288                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \      0x20A   0x6830             LDR      R0,[R6, #+0]
   \      0x20C   0x6800             LDR      R0,[R0, #+0]
   \      0x20E   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x212   0x6831             LDR      R1,[R6, #+0]
   \      0x214   0x6008             STR      R0,[R1, #+0]
   3289          
   3290                hi2c->State = HAL_I2C_STATE_READY;
   \      0x216   0x2020             MOVS     R0,#+32
   \      0x218   0xF886 0x003D      STRB     R0,[R6, #+61]
   3291          
   3292                /* Process Unlocked */
   3293                __HAL_UNLOCK(hi2c);
   \      0x21C   0x2000             MOVS     R0,#+0
   \      0x21E   0xF886 0x003C      STRB     R0,[R6, #+60]
   3294              }
   3295          
   3296              return HAL_OK;
   \                     ??HAL_I2C_Mem_Read_DMA_12: (+1)
   \      0x222   0x2000             MOVS     R0,#+0
   \      0x224   0xE000             B.N      ??HAL_I2C_Mem_Read_DMA_3
   3297            }
   3298            else
   3299            {
   3300              return HAL_BUSY;
   \                     ??HAL_I2C_Mem_Read_DMA_0: (+1)
   \      0x226   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Mem_Read_DMA_3: (+1)
   \      0x228   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   3301            }
   3302          }
   3303          
   3304          /**
   3305            * @brief  Checks if target device is ready for communication.
   3306            * @note   This function is used with Memory devices
   3307            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3308            *                the configuration information for the specified I2C.
   3309            * @param  DevAddress Target device address: The device 7 bits address value
   3310            *         in datasheet must be shifted to the left before calling the interface
   3311            * @param  Trials Number of trials
   3312            * @param  Timeout Timeout duration
   3313            * @retval HAL status
   3314            */

   \                                 In section .text, align 2, keep-with-next
   3315          HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
   3316          {
   \                     HAL_I2C_IsDeviceReady: (+1)
   \        0x0   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \        0x4   0xB081             SUB      SP,SP,#+4
   \        0x6   0x4683             MOV      R11,R0
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x001C             MOVS     R4,R3
   3317            /* Get tick */
   3318            uint32_t tickstart = HAL_GetTick();
   \        0xC   0x.... 0x....      BL       HAL_GetTick
   \       0x10   0x4680             MOV      R8,R0
   3319            uint32_t I2C_Trials = 1U;
   \       0x12   0xF05F 0x0901      MOVS     R9,#+1
   3320            FlagStatus tmp1;
   3321            FlagStatus tmp2;
   3322          
   3323            if (hi2c->State == HAL_I2C_STATE_READY)
   \       0x16   0xF89B 0x003D      LDRB     R0,[R11, #+61]
   \       0x1A   0x2820             CMP      R0,#+32
   \       0x1C   0xF040 0x80E7      BNE.W    ??HAL_I2C_IsDeviceReady_0
   3324            {
   3325              /* Wait until BUSY flag is reset */
   3326              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \       0x20   0x.... 0x....      LDR.W    R10,??DataTable19_1
   \       0x24   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x28   0x230A             MOVS     R3,#+10
   \       0x2A   0x2201             MOVS     R2,#+1
   \       0x2C   0x4651             MOV      R1,R10
   \       0x2E   0x4658             MOV      R0,R11
   \       0x30   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD001             BEQ.N    ??HAL_I2C_IsDeviceReady_1
   3327              {
   3328                return HAL_BUSY;
   \       0x38   0x2002             MOVS     R0,#+2
   \       0x3A   0xE0D9             B.N      ??HAL_I2C_IsDeviceReady_2
   3329              }
   3330          
   3331              /* Process Locked */
   3332              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_IsDeviceReady_1: (+1)
   \       0x3C   0xF89B 0x003C      LDRB     R0,[R11, #+60]
   \       0x40   0x2801             CMP      R0,#+1
   \       0x42   0xD101             BNE.N    ??HAL_I2C_IsDeviceReady_3
   \       0x44   0x2002             MOVS     R0,#+2
   \       0x46   0xE0D3             B.N      ??HAL_I2C_IsDeviceReady_2
   \                     ??HAL_I2C_IsDeviceReady_3: (+1)
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0xF88B 0x003C      STRB     R0,[R11, #+60]
   3333          
   3334              /* Check if the I2C is already enabled */
   3335              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x4E   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x52   0x6800             LDR      R0,[R0, #+0]
   \       0x54   0x07C0             LSLS     R0,R0,#+31
   \       0x56   0xD407             BMI.N    ??HAL_I2C_IsDeviceReady_4
   3336              {
   3337                /* Enable I2C peripheral */
   3338                __HAL_I2C_ENABLE(hi2c);
   \       0x58   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x5C   0x6800             LDR      R0,[R0, #+0]
   \       0x5E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x62   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \       0x66   0x6008             STR      R0,[R1, #+0]
   3339              }
   3340          
   3341              /* Disable Pos */
   3342              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_IsDeviceReady_4: (+1)
   \       0x68   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x6C   0x6800             LDR      R0,[R0, #+0]
   \       0x6E   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x72   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \       0x76   0x6008             STR      R0,[R1, #+0]
   3343          
   3344              hi2c->State = HAL_I2C_STATE_BUSY;
   \       0x78   0x2024             MOVS     R0,#+36
   \       0x7A   0xF88B 0x003D      STRB     R0,[R11, #+61]
   3345              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0xF8CB 0x0040      STR      R0,[R11, #+64]
   3346              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x84   0x....             LDR.N    R0,??DataTable19
   \       0x86   0xF8CB 0x002C      STR      R0,[R11, #+44]
   3347          
   3348              do
   3349              {
   3350                /* Generate Start */
   3351                SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??HAL_I2C_IsDeviceReady_5: (+1)
   \       0x8A   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0x8E   0x6800             LDR      R0,[R0, #+0]
   \       0x90   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x94   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \       0x98   0x6008             STR      R0,[R1, #+0]
   3352          
   3353                /* Wait until SB flag is set */
   3354                if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, tickstart) != HAL_OK)
   \       0x9A   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \       0x9E   0x0023             MOVS     R3,R4
   \       0xA0   0x2200             MOVS     R2,#+0
   \       0xA2   0xF05F 0x1101      MOVS     R1,#+65537
   \       0xA6   0x4658             MOV      R0,R11
   \       0xA8   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \       0xAC   0x2800             CMP      R0,#+0
   \       0xAE   0xD00A             BEQ.N    ??HAL_I2C_IsDeviceReady_6
   3355                {
   3356                  if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
   \       0xB0   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0xB4   0x6800             LDR      R0,[R0, #+0]
   \       0xB6   0x05C0             LSLS     R0,R0,#+23
   \       0xB8   0xD503             BPL.N    ??HAL_I2C_IsDeviceReady_7
   3357                  {
   3358                    hi2c->ErrorCode = HAL_I2C_WRONG_START;
   \       0xBA   0xF44F 0x7000      MOV      R0,#+512
   \       0xBE   0xF8CB 0x0040      STR      R0,[R11, #+64]
   3359                  }
   3360                  return HAL_TIMEOUT;
   \                     ??HAL_I2C_IsDeviceReady_7: (+1)
   \       0xC2   0x2003             MOVS     R0,#+3
   \       0xC4   0xE094             B.N      ??HAL_I2C_IsDeviceReady_2
   3361                }
   3362          
   3363                /* Send slave address */
   3364                hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \                     ??HAL_I2C_IsDeviceReady_6: (+1)
   \       0xC6   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \       0xCA   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \       0xCE   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \       0xD2   0x6108             STR      R0,[R1, #+16]
   3365          
   3366                /* Wait until ADDR or AF flag are set */
   3367                /* Get tick */
   3368                tickstart = HAL_GetTick();
   \       0xD4   0x.... 0x....      BL       HAL_GetTick
   \       0xD8   0x4680             MOV      R8,R0
   3369          
   3370                tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
   \       0xDA   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0xDE   0x6940             LDR      R0,[R0, #+20]
   \       0xE0   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \       0xE4   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0xE8   0x0005             MOVS     R5,R0
   3371                tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
   \       0xEA   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \       0xEE   0x6940             LDR      R0,[R0, #+20]
   \       0xF0   0xF3C0 0x2080      UBFX     R0,R0,#+10,#+1
   \       0xF4   0xF010 0x0001      ANDS     R0,R0,#0x1
   \       0xF8   0x0006             MOVS     R6,R0
   3372                while ((hi2c->State != HAL_I2C_STATE_TIMEOUT) && (tmp1 == RESET) && (tmp2 == RESET))
   \                     ??HAL_I2C_IsDeviceReady_8: (+1)
   \       0xFA   0xF89B 0x003D      LDRB     R0,[R11, #+61]
   \       0xFE   0x28A0             CMP      R0,#+160
   \      0x100   0xD020             BEQ.N    ??HAL_I2C_IsDeviceReady_9
   \      0x102   0xEA56 0x0005      ORRS     R0,R6,R5
   \      0x106   0xB2C0             UXTB     R0,R0
   \      0x108   0x2800             CMP      R0,#+0
   \      0x10A   0xD11B             BNE.N    ??HAL_I2C_IsDeviceReady_9
   3373                {
   3374                  if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
   \      0x10C   0x.... 0x....      BL       HAL_GetTick
   \      0x110   0xEBB0 0x0008      SUBS     R0,R0,R8
   \      0x114   0x4284             CMP      R4,R0
   \      0x116   0xD301             BCC.N    ??HAL_I2C_IsDeviceReady_10
   \      0x118   0x2C00             CMP      R4,#+0
   \      0x11A   0xD102             BNE.N    ??HAL_I2C_IsDeviceReady_11
   3375                  {
   3376                    hi2c->State = HAL_I2C_STATE_TIMEOUT;
   \                     ??HAL_I2C_IsDeviceReady_10: (+1)
   \      0x11C   0x20A0             MOVS     R0,#+160
   \      0x11E   0xF88B 0x003D      STRB     R0,[R11, #+61]
   3377                  }
   3378                  tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
   \                     ??HAL_I2C_IsDeviceReady_11: (+1)
   \      0x122   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x126   0x6940             LDR      R0,[R0, #+20]
   \      0x128   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \      0x12C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x130   0x0005             MOVS     R5,R0
   3379                  tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
   \      0x132   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x136   0x6940             LDR      R0,[R0, #+20]
   \      0x138   0xF3C0 0x2080      UBFX     R0,R0,#+10,#+1
   \      0x13C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \      0x140   0x0006             MOVS     R6,R0
   \      0x142   0xE7DA             B.N      ??HAL_I2C_IsDeviceReady_8
   3380                }
   3381          
   3382                hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_IsDeviceReady_9: (+1)
   \      0x144   0x2020             MOVS     R0,#+32
   \      0x146   0xF88B 0x003D      STRB     R0,[R11, #+61]
   3383          
   3384                /* Check if the ADDR flag has been set */
   3385                if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
   \      0x14A   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x14E   0x6940             LDR      R0,[R0, #+20]
   \      0x150   0x0780             LSLS     R0,R0,#+30
   \      0x152   0xD526             BPL.N    ??HAL_I2C_IsDeviceReady_12
   3386                {
   3387                  /* Generate Stop */
   3388                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \      0x154   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x158   0x6800             LDR      R0,[R0, #+0]
   \      0x15A   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x15E   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \      0x162   0x6008             STR      R0,[R1, #+0]
   3389          
   3390                  /* Clear ADDR Flag */
   3391                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \      0x164   0x2000             MOVS     R0,#+0
   \      0x166   0x9000             STR      R0,[SP, #+0]
   \      0x168   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x16C   0x6940             LDR      R0,[R0, #+20]
   \      0x16E   0x9000             STR      R0,[SP, #+0]
   \      0x170   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x174   0x6980             LDR      R0,[R0, #+24]
   \      0x176   0x9000             STR      R0,[SP, #+0]
   \      0x178   0x9800             LDR      R0,[SP, #+0]
   3392          
   3393                  /* Wait until BUSY flag is reset */
   3394                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \      0x17A   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \      0x17E   0x230A             MOVS     R3,#+10
   \      0x180   0x2201             MOVS     R2,#+1
   \      0x182   0x4651             MOV      R1,R10
   \      0x184   0x4658             MOV      R0,R11
   \      0x186   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \      0x18A   0x2800             CMP      R0,#+0
   \      0x18C   0xD001             BEQ.N    ??HAL_I2C_IsDeviceReady_13
   3395                  {
   3396                    return HAL_ERROR;
   \      0x18E   0x2001             MOVS     R0,#+1
   \      0x190   0xE02E             B.N      ??HAL_I2C_IsDeviceReady_2
   3397                  }
   3398          
   3399                  hi2c->State = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_IsDeviceReady_13: (+1)
   \      0x192   0x2020             MOVS     R0,#+32
   \      0x194   0xF88B 0x003D      STRB     R0,[R11, #+61]
   3400          
   3401                  /* Process Unlocked */
   3402                  __HAL_UNLOCK(hi2c);
   \      0x198   0x2000             MOVS     R0,#+0
   \      0x19A   0xF88B 0x003C      STRB     R0,[R11, #+60]
   3403          
   3404                  return HAL_OK;
   \      0x19E   0x2000             MOVS     R0,#+0
   \      0x1A0   0xE026             B.N      ??HAL_I2C_IsDeviceReady_2
   3405                }
   3406                else
   3407                {
   3408                  /* Generate Stop */
   3409                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??HAL_I2C_IsDeviceReady_12: (+1)
   \      0x1A2   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \      0x1A6   0x6800             LDR      R0,[R0, #+0]
   \      0x1A8   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x1AC   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \      0x1B0   0x6008             STR      R0,[R1, #+0]
   3410          
   3411                  /* Clear AF Flag */
   3412                  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \      0x1B2   0xF47F 0x6080      MVNS     R0,#+1024
   \      0x1B6   0xF8DB 0x1000      LDR      R1,[R11, #+0]
   \      0x1BA   0x6148             STR      R0,[R1, #+20]
   3413          
   3414                  /* Wait until BUSY flag is reset */
   3415                  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
   \      0x1BC   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \      0x1C0   0x230A             MOVS     R3,#+10
   \      0x1C2   0x2201             MOVS     R2,#+1
   \      0x1C4   0x4651             MOV      R1,R10
   \      0x1C6   0x4658             MOV      R0,R11
   \      0x1C8   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \      0x1CC   0x2800             CMP      R0,#+0
   \      0x1CE   0xD001             BEQ.N    ??HAL_I2C_IsDeviceReady_14
   3416                  {
   3417                    return HAL_ERROR;
   \      0x1D0   0x2001             MOVS     R0,#+1
   \      0x1D2   0xE00D             B.N      ??HAL_I2C_IsDeviceReady_2
   3418                  }
   3419                }
   3420          
   3421                /* Increment Trials */
   3422                I2C_Trials++;
   \                     ??HAL_I2C_IsDeviceReady_14: (+1)
   \      0x1D4   0xF119 0x0901      ADDS     R9,R9,#+1
   3423              }
   3424              while (I2C_Trials < Trials);
   \      0x1D8   0x45B9             CMP      R9,R7
   \      0x1DA   0xF4FF 0xAF56      BCC.W    ??HAL_I2C_IsDeviceReady_5
   3425          
   3426              hi2c->State = HAL_I2C_STATE_READY;
   \      0x1DE   0x2020             MOVS     R0,#+32
   \      0x1E0   0xF88B 0x003D      STRB     R0,[R11, #+61]
   3427          
   3428              /* Process Unlocked */
   3429              __HAL_UNLOCK(hi2c);
   \      0x1E4   0x2000             MOVS     R0,#+0
   \      0x1E6   0xF88B 0x003C      STRB     R0,[R11, #+60]
   3430          
   3431              return HAL_ERROR;
   \      0x1EA   0x2001             MOVS     R0,#+1
   \      0x1EC   0xE000             B.N      ??HAL_I2C_IsDeviceReady_2
   3432            }
   3433            else
   3434            {
   3435              return HAL_BUSY;
   \                     ??HAL_I2C_IsDeviceReady_0: (+1)
   \      0x1EE   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_IsDeviceReady_2: (+1)
   \      0x1F0   0xE8BD 0x8FFE      POP      {R1-R11,PC}
   3436            }
   3437          }
   3438          
   3439          /**
   3440            * @brief  Sequential transmit in master I2C mode an amount of data in non-blocking mode with Interrupt.
   3441            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3442            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3443            *         the configuration information for the specified I2C.
   3444            * @param  DevAddress Target device address: The device 7 bits address value
   3445            *         in datasheet must be shifted to the left before calling the interface
   3446            * @param  pData Pointer to data buffer
   3447            * @param  Size Amount of data to be sent
   3448            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   3449            * @retval HAL status
   3450            */

   \                                 In section .text, align 2, keep-with-next
   3451          HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3452          {
   \                     HAL_I2C_Master_Seq_Transmit_IT: (+1)
   \        0x0   0xB47C             PUSH     {R2-R6}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x9D05             LDR      R5,[SP, #+20]
   3453            __IO uint32_t Prev_State = 0x00U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9001             STR      R0,[SP, #+4]
   3454            __IO uint32_t count      = 0x00U;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x9000             STR      R0,[SP, #+0]
   3455          
   3456            /* Check the parameters */
   3457            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3458          
   3459            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0xE   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \       0x12   0x2820             CMP      R0,#+32
   \       0x14   0xD17A             BNE.N    ??HAL_I2C_Master_Seq_Transmit_IT_0
   3460            {
   3461              /* Check Busy Flag only if FIRST call of Master interface */
   3462              if ((READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP) || (XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6800             LDR      R0,[R0, #+0]
   \       0x1A   0x0580             LSLS     R0,R0,#+22
   \       0x1C   0xD403             BMI.N    ??HAL_I2C_Master_Seq_Transmit_IT_1
   \       0x1E   0x2D08             CMP      R5,#+8
   \       0x20   0xD001             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_IT_1
   \       0x22   0x2D01             CMP      R5,#+1
   \       0x24   0xD127             BNE.N    ??HAL_I2C_Master_Seq_Transmit_IT_2
   3463              {
   3464                /* Wait until BUSY flag is reset */
   3465                count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_1: (+1)
   \       0x26   0x.... 0x....      LDR.W    R0,??DataTable22
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0x2619             MOVS     R6,#+25
   \       0x2E   0xFBB0 0xF0F6      UDIV     R0,R0,R6
   \       0x32   0xF44F 0x767A      MOV      R6,#+1000
   \       0x36   0xFBB0 0xF6F6      UDIV     R6,R0,R6
   \       0x3A   0x200A             MOVS     R0,#+10
   \       0x3C   0x4346             MULS     R6,R0,R6
   \       0x3E   0x9600             STR      R6,[SP, #+0]
   3466                do
   3467                {
   3468                  count--;
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_3: (+1)
   \       0x40   0x9800             LDR      R0,[SP, #+0]
   \       0x42   0x1E40             SUBS     R0,R0,#+1
   \       0x44   0x9000             STR      R0,[SP, #+0]
   3469                  if (count == 0U)
   \       0x46   0x9800             LDR      R0,[SP, #+0]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD110             BNE.N    ??HAL_I2C_Master_Seq_Transmit_IT_4
   3470                  {
   3471                    hi2c->PreviousState       = I2C_STATE_NONE;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x6320             STR      R0,[R4, #+48]
   3472                    hi2c->State               = HAL_I2C_STATE_READY;
   \       0x50   0x2020             MOVS     R0,#+32
   \       0x52   0xF884 0x003D      STRB     R0,[R4, #+61]
   3473                    hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xF884 0x003E      STRB     R0,[R4, #+62]
   3474                    hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0x5C   0x6C20             LDR      R0,[R4, #+64]
   \       0x5E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x62   0x6420             STR      R0,[R4, #+64]
   3475          
   3476                    /* Process Unlocked */
   3477                    __HAL_UNLOCK(hi2c);
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xF884 0x003C      STRB     R0,[R4, #+60]
   3478          
   3479                    return HAL_ERROR;
   \       0x6A   0x2001             MOVS     R0,#+1
   \       0x6C   0xE04F             B.N      ??HAL_I2C_Master_Seq_Transmit_IT_5
   3480                  }
   3481                }
   3482                while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_4: (+1)
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x6980             LDR      R0,[R0, #+24]
   \       0x72   0x0780             LSLS     R0,R0,#+30
   \       0x74   0xD4E4             BMI.N    ??HAL_I2C_Master_Seq_Transmit_IT_3
   3483              }
   3484          
   3485              /* Process Locked */
   3486              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_2: (+1)
   \       0x76   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \       0x7A   0x2801             CMP      R0,#+1
   \       0x7C   0xD101             BNE.N    ??HAL_I2C_Master_Seq_Transmit_IT_6
   \       0x7E   0x2002             MOVS     R0,#+2
   \       0x80   0xE045             B.N      ??HAL_I2C_Master_Seq_Transmit_IT_5
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_6: (+1)
   \       0x82   0x2001             MOVS     R0,#+1
   \       0x84   0xF884 0x003C      STRB     R0,[R4, #+60]
   3487          
   3488              /* Check if the I2C is already enabled */
   3489              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6800             LDR      R0,[R0, #+0]
   \       0x8C   0x07C0             LSLS     R0,R0,#+31
   \       0x8E   0xD405             BMI.N    ??HAL_I2C_Master_Seq_Transmit_IT_7
   3490              {
   3491                /* Enable I2C peripheral */
   3492                __HAL_I2C_ENABLE(hi2c);
   \       0x90   0x6820             LDR      R0,[R4, #+0]
   \       0x92   0x6800             LDR      R0,[R0, #+0]
   \       0x94   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x98   0x6826             LDR      R6,[R4, #+0]
   \       0x9A   0x6030             STR      R0,[R6, #+0]
   3493              }
   3494          
   3495              /* Disable Pos */
   3496              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_7: (+1)
   \       0x9C   0x6820             LDR      R0,[R4, #+0]
   \       0x9E   0x6800             LDR      R0,[R0, #+0]
   \       0xA0   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0xA4   0x6826             LDR      R6,[R4, #+0]
   \       0xA6   0x6030             STR      R0,[R6, #+0]
   3497          
   3498              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0xA8   0x2021             MOVS     R0,#+33
   \       0xAA   0xF884 0x003D      STRB     R0,[R4, #+61]
   3499              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \       0xAE   0x2010             MOVS     R0,#+16
   \       0xB0   0xF884 0x003E      STRB     R0,[R4, #+62]
   3500              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0x6420             STR      R0,[R4, #+64]
   3501          
   3502              /* Prepare transfer parameters */
   3503              hi2c->pBuffPtr    = pData;
   \       0xB8   0x6262             STR      R2,[R4, #+36]
   3504              hi2c->XferCount   = Size;
   \       0xBA   0x8563             STRH     R3,[R4, #+42]
   3505              hi2c->XferSize    = hi2c->XferCount;
   \       0xBC   0x8D60             LDRH     R0,[R4, #+42]
   \       0xBE   0x8520             STRH     R0,[R4, #+40]
   3506              hi2c->XferOptions = XferOptions;
   \       0xC0   0x62E5             STR      R5,[R4, #+44]
   3507              hi2c->Devaddress  = DevAddress;
   \       0xC2   0x0008             MOVS     R0,R1
   \       0xC4   0xB280             UXTH     R0,R0
   \       0xC6   0x6460             STR      R0,[R4, #+68]
   3508          
   3509              Prev_State = hi2c->PreviousState;
   \       0xC8   0x6B20             LDR      R0,[R4, #+48]
   \       0xCA   0x9001             STR      R0,[SP, #+4]
   3510          
   3511              /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3512              /* Mean Previous state is same as current state */
   3513              if ((Prev_State != I2C_STATE_MASTER_BUSY_TX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
   \       0xCC   0x9801             LDR      R0,[SP, #+4]
   \       0xCE   0x2811             CMP      R0,#+17
   \       0xD0   0xD10B             BNE.N    ??HAL_I2C_Master_Seq_Transmit_IT_8
   \       0xD2   0xF5B5 0x0F2A      CMP      R5,#+11141120
   \       0xD6   0xD002             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_IT_9
   \       0xD8   0xF1B5 0x4F2A      CMP      R5,#+2852126720
   \       0xDC   0xD101             BNE.N    ??HAL_I2C_Master_Seq_Transmit_IT_10
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_9: (+1)
   \       0xDE   0x2001             MOVS     R0,#+1
   \       0xE0   0xE000             B.N      ??HAL_I2C_Master_Seq_Transmit_IT_11
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_10: (+1)
   \       0xE2   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_11: (+1)
   \       0xE4   0xB2C0             UXTB     R0,R0
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0xD005             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_IT_12
   3514              {
   3515                /* Generate Start */
   3516                SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_8: (+1)
   \       0xEA   0x6820             LDR      R0,[R4, #+0]
   \       0xEC   0x6800             LDR      R0,[R0, #+0]
   \       0xEE   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0xF2   0x6826             LDR      R6,[R4, #+0]
   \       0xF4   0x6030             STR      R0,[R6, #+0]
   3517              }
   3518          
   3519              /* Process Unlocked */
   3520              __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_12: (+1)
   \       0xF6   0x2000             MOVS     R0,#+0
   \       0xF8   0xF884 0x003C      STRB     R0,[R4, #+60]
   3521          
   3522              /* Note : The I2C interrupts must be enabled after unlocking current process
   3523              to avoid the risk of I2C interrupt handle execution before current
   3524              process unlock */
   3525          
   3526              /* Enable EVT, BUF and ERR interrupt */
   3527              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0xFC   0x6820             LDR      R0,[R4, #+0]
   \       0xFE   0x6840             LDR      R0,[R0, #+4]
   \      0x100   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \      0x104   0x6826             LDR      R6,[R4, #+0]
   \      0x106   0x6070             STR      R0,[R6, #+4]
   3528          
   3529              return HAL_OK;
   \      0x108   0x2000             MOVS     R0,#+0
   \      0x10A   0xE000             B.N      ??HAL_I2C_Master_Seq_Transmit_IT_5
   3530            }
   3531            else
   3532            {
   3533              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_0: (+1)
   \      0x10C   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Seq_Transmit_IT_5: (+1)
   \      0x10E   0xBC76             POP      {R1,R2,R4-R6}
   \      0x110   0x4770             BX       LR
   3534            }
   3535          }
   3536          
   3537          /**
   3538            * @brief  Sequential transmit in master I2C mode an amount of data in non-blocking mode with DMA.
   3539            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3540            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3541            *         the configuration information for the specified I2C.
   3542            * @param  DevAddress Target device address: The device 7 bits address value
   3543            *         in datasheet must be shifted to the left before calling the interface
   3544            * @param  pData Pointer to data buffer
   3545            * @param  Size Amount of data to be sent
   3546            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   3547            * @retval HAL status
   3548            */

   \                                 In section .text, align 2, keep-with-next
   3549          HAL_StatusTypeDef HAL_I2C_Master_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3550          {
   \                     HAL_I2C_Master_Seq_Transmit_DMA: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   \        0xC   0xF8DD 0x9028      LDR      R9,[SP, #+40]
   3551            __IO uint32_t Prev_State = 0x00U;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x9001             STR      R0,[SP, #+4]
   3552            __IO uint32_t count      = 0x00U;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x9000             STR      R0,[SP, #+0]
   3553            HAL_StatusTypeDef dmaxferstatus;
   3554          
   3555            /* Check the parameters */
   3556            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3557          
   3558            if (hi2c->State == HAL_I2C_STATE_READY)
   \       0x18   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x1C   0x2820             CMP      R0,#+32
   \       0x1E   0xF040 0x80E5      BNE.W    ??HAL_I2C_Master_Seq_Transmit_DMA_0
   3559            {
   3560              /* Check Busy Flag only if FIRST call of Master interface */
   3561              if ((READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP) || (XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
   \       0x22   0x6828             LDR      R0,[R5, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x0580             LSLS     R0,R0,#+22
   \       0x28   0xD405             BMI.N    ??HAL_I2C_Master_Seq_Transmit_DMA_1
   \       0x2A   0xF1B9 0x0F08      CMP      R9,#+8
   \       0x2E   0xD002             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_DMA_1
   \       0x30   0xF1B9 0x0F01      CMP      R9,#+1
   \       0x34   0xD126             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_2
   3562              {
   3563                /* Wait until BUSY flag is reset */
   3564                count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_1: (+1)
   \       0x36   0x....             LDR.N    R0,??DataTable22
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0x2119             MOVS     R1,#+25
   \       0x3C   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x40   0xF44F 0x717A      MOV      R1,#+1000
   \       0x44   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x48   0x200A             MOVS     R0,#+10
   \       0x4A   0x4341             MULS     R1,R0,R1
   \       0x4C   0x9100             STR      R1,[SP, #+0]
   3565                do
   3566                {
   3567                  count--;
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_3: (+1)
   \       0x4E   0x9800             LDR      R0,[SP, #+0]
   \       0x50   0x1E40             SUBS     R0,R0,#+1
   \       0x52   0x9000             STR      R0,[SP, #+0]
   3568                  if (count == 0U)
   \       0x54   0x9800             LDR      R0,[SP, #+0]
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD110             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_4
   3569                  {
   3570                    hi2c->PreviousState       = I2C_STATE_NONE;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0x6328             STR      R0,[R5, #+48]
   3571                    hi2c->State               = HAL_I2C_STATE_READY;
   \       0x5E   0x2020             MOVS     R0,#+32
   \       0x60   0xF885 0x003D      STRB     R0,[R5, #+61]
   3572                    hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xF885 0x003E      STRB     R0,[R5, #+62]
   3573                    hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0x6A   0x6C28             LDR      R0,[R5, #+64]
   \       0x6C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x70   0x6428             STR      R0,[R5, #+64]
   3574          
   3575                    /* Process Unlocked */
   3576                    __HAL_UNLOCK(hi2c);
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0xF885 0x003C      STRB     R0,[R5, #+60]
   3577          
   3578                    return HAL_ERROR;
   \       0x78   0x2001             MOVS     R0,#+1
   \       0x7A   0xE0B8             B.N      ??HAL_I2C_Master_Seq_Transmit_DMA_5
   3579                  }
   3580                }
   3581                while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_4: (+1)
   \       0x7C   0x6828             LDR      R0,[R5, #+0]
   \       0x7E   0x6980             LDR      R0,[R0, #+24]
   \       0x80   0x0780             LSLS     R0,R0,#+30
   \       0x82   0xD4E4             BMI.N    ??HAL_I2C_Master_Seq_Transmit_DMA_3
   3582              }
   3583          
   3584              /* Process Locked */
   3585              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_2: (+1)
   \       0x84   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0x88   0x2801             CMP      R0,#+1
   \       0x8A   0xD101             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_6
   \       0x8C   0x2002             MOVS     R0,#+2
   \       0x8E   0xE0AE             B.N      ??HAL_I2C_Master_Seq_Transmit_DMA_5
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_6: (+1)
   \       0x90   0x2001             MOVS     R0,#+1
   \       0x92   0xF885 0x003C      STRB     R0,[R5, #+60]
   3586          
   3587              /* Check if the I2C is already enabled */
   3588              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x96   0x6828             LDR      R0,[R5, #+0]
   \       0x98   0x6800             LDR      R0,[R0, #+0]
   \       0x9A   0x07C0             LSLS     R0,R0,#+31
   \       0x9C   0xD405             BMI.N    ??HAL_I2C_Master_Seq_Transmit_DMA_7
   3589              {
   3590                /* Enable I2C peripheral */
   3591                __HAL_I2C_ENABLE(hi2c);
   \       0x9E   0x6828             LDR      R0,[R5, #+0]
   \       0xA0   0x6800             LDR      R0,[R0, #+0]
   \       0xA2   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xA6   0x6829             LDR      R1,[R5, #+0]
   \       0xA8   0x6008             STR      R0,[R1, #+0]
   3592              }
   3593          
   3594              /* Disable Pos */
   3595              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_7: (+1)
   \       0xAA   0x6828             LDR      R0,[R5, #+0]
   \       0xAC   0x6800             LDR      R0,[R0, #+0]
   \       0xAE   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0xB2   0x6829             LDR      R1,[R5, #+0]
   \       0xB4   0x6008             STR      R0,[R1, #+0]
   3596          
   3597              hi2c->State     = HAL_I2C_STATE_BUSY_TX;
   \       0xB6   0x2021             MOVS     R0,#+33
   \       0xB8   0xF885 0x003D      STRB     R0,[R5, #+61]
   3598              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \       0xBC   0x2010             MOVS     R0,#+16
   \       0xBE   0xF885 0x003E      STRB     R0,[R5, #+62]
   3599              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0xC2   0x2000             MOVS     R0,#+0
   \       0xC4   0x6428             STR      R0,[R5, #+64]
   3600          
   3601              /* Prepare transfer parameters */
   3602              hi2c->pBuffPtr    = pData;
   \       0xC6   0x626F             STR      R7,[R5, #+36]
   3603              hi2c->XferCount   = Size;
   \       0xC8   0xF8A5 0x802A      STRH     R8,[R5, #+42]
   3604              hi2c->XferSize    = hi2c->XferCount;
   \       0xCC   0x8D68             LDRH     R0,[R5, #+42]
   \       0xCE   0x8528             STRH     R0,[R5, #+40]
   3605              hi2c->XferOptions = XferOptions;
   \       0xD0   0xF8C5 0x902C      STR      R9,[R5, #+44]
   3606              hi2c->Devaddress  = DevAddress;
   \       0xD4   0x0030             MOVS     R0,R6
   \       0xD6   0xB280             UXTH     R0,R0
   \       0xD8   0x6468             STR      R0,[R5, #+68]
   3607          
   3608              Prev_State = hi2c->PreviousState;
   \       0xDA   0x6B28             LDR      R0,[R5, #+48]
   \       0xDC   0x9001             STR      R0,[SP, #+4]
   3609          
   3610              if (hi2c->XferSize > 0U)
   \       0xDE   0x8D28             LDRH     R0,[R5, #+40]
   \       0xE0   0x2800             CMP      R0,#+0
   \       0xE2   0xD05D             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_DMA_8
   3611              {
   3612                /* Set the I2C DMA transfer complete callback */
   3613                hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
   \       0xE4   0x.... 0x....      LDR.W    R0,??DataTable24
   \       0xE8   0x6B69             LDR      R1,[R5, #+52]
   \       0xEA   0x63C8             STR      R0,[R1, #+60]
   3614          
   3615                /* Set the DMA error callback */
   3616                hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \       0xEC   0x.... 0x....      LDR.W    R0,??DataTable24_1
   \       0xF0   0x6B69             LDR      R1,[R5, #+52]
   \       0xF2   0x64C8             STR      R0,[R1, #+76]
   3617          
   3618                /* Set the unused DMA callbacks to NULL */
   3619                hi2c->hdmatx->XferHalfCpltCallback = NULL;
   \       0xF4   0x2000             MOVS     R0,#+0
   \       0xF6   0x6B69             LDR      R1,[R5, #+52]
   \       0xF8   0x6408             STR      R0,[R1, #+64]
   3620                hi2c->hdmatx->XferAbortCallback = NULL;
   \       0xFA   0x2000             MOVS     R0,#+0
   \       0xFC   0x6B69             LDR      R1,[R5, #+52]
   \       0xFE   0x6508             STR      R0,[R1, #+80]
   3621          
   3622                /* Enable the DMA stream */
   3623                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
   \      0x100   0x8D2B             LDRH     R3,[R5, #+40]
   \      0x102   0x6828             LDR      R0,[R5, #+0]
   \      0x104   0xF110 0x0210      ADDS     R2,R0,#+16
   \      0x108   0x6A69             LDR      R1,[R5, #+36]
   \      0x10A   0x6B68             LDR      R0,[R5, #+52]
   \      0x10C   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x110   0x0004             MOVS     R4,R0
   3624          
   3625                if (dmaxferstatus == HAL_OK)
   \      0x112   0x0020             MOVS     R0,R4
   \      0x114   0xB2C0             UXTB     R0,R0
   \      0x116   0x2800             CMP      R0,#+0
   \      0x118   0xD133             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_9
   3626                {
   3627                  /* Enable Acknowledge */
   3628                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \      0x11A   0x6828             LDR      R0,[R5, #+0]
   \      0x11C   0x6800             LDR      R0,[R0, #+0]
   \      0x11E   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x122   0x6829             LDR      R1,[R5, #+0]
   \      0x124   0x6008             STR      R0,[R1, #+0]
   3629          
   3630                  /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3631                  /* Mean Previous state is same as current state */
   3632                  if ((Prev_State != I2C_STATE_MASTER_BUSY_TX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
   \      0x126   0x9801             LDR      R0,[SP, #+4]
   \      0x128   0x2811             CMP      R0,#+17
   \      0x12A   0xD10B             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_10
   \      0x12C   0xF5B9 0x0F2A      CMP      R9,#+11141120
   \      0x130   0xD002             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_DMA_11
   \      0x132   0xF1B9 0x4F2A      CMP      R9,#+2852126720
   \      0x136   0xD101             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_12
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_11: (+1)
   \      0x138   0x2001             MOVS     R0,#+1
   \      0x13A   0xE000             B.N      ??HAL_I2C_Master_Seq_Transmit_DMA_13
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_12: (+1)
   \      0x13C   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_13: (+1)
   \      0x13E   0xB2C0             UXTB     R0,R0
   \      0x140   0x2800             CMP      R0,#+0
   \      0x142   0xD005             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_DMA_14
   3633                  {
   3634                    /* Generate Start */
   3635                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_10: (+1)
   \      0x144   0x6828             LDR      R0,[R5, #+0]
   \      0x146   0x6800             LDR      R0,[R0, #+0]
   \      0x148   0xF450 0x7080      ORRS     R0,R0,#0x100
   \      0x14C   0x6829             LDR      R1,[R5, #+0]
   \      0x14E   0x6008             STR      R0,[R1, #+0]
   3636                  }
   3637          
   3638                  /* Process Unlocked */
   3639                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_14: (+1)
   \      0x150   0x2000             MOVS     R0,#+0
   \      0x152   0xF885 0x003C      STRB     R0,[R5, #+60]
   3640          
   3641                  /* Note : The I2C interrupts must be enabled after unlocking current process
   3642                  to avoid the risk of I2C interrupt handle execution before current
   3643                  process unlock */
   3644          
   3645                  /* If XferOptions is not associated to a new frame, mean no start bit is request, enable directly the DMA request */
   3646                  /* In other cases, DMA request is enabled after Slave address treatment in IRQHandler */
   3647                  if ((XferOptions == I2C_NEXT_FRAME) || (XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP))
   \      0x156   0xF1B9 0x0F04      CMP      R9,#+4
   \      0x15A   0xD005             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_DMA_15
   \      0x15C   0xF1B9 0x0F20      CMP      R9,#+32
   \      0x160   0xD002             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_DMA_15
   \      0x162   0xF1B9 0x0F10      CMP      R9,#+16
   \      0x166   0xD105             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_16
   3648                  {
   3649                    /* Enable DMA Request */
   3650                    SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_15: (+1)
   \      0x168   0x6828             LDR      R0,[R5, #+0]
   \      0x16A   0x6840             LDR      R0,[R0, #+4]
   \      0x16C   0xF450 0x6000      ORRS     R0,R0,#0x800
   \      0x170   0x6829             LDR      R1,[R5, #+0]
   \      0x172   0x6048             STR      R0,[R1, #+4]
   3651                  }
   3652          
   3653                  /* Enable EVT and ERR interrupt */
   3654                  __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_16: (+1)
   \      0x174   0x6828             LDR      R0,[R5, #+0]
   \      0x176   0x6840             LDR      R0,[R0, #+4]
   \      0x178   0xF450 0x7040      ORRS     R0,R0,#0x300
   \      0x17C   0x6829             LDR      R1,[R5, #+0]
   \      0x17E   0x6048             STR      R0,[R1, #+4]
   \      0x180   0xE032             B.N      ??HAL_I2C_Master_Seq_Transmit_DMA_17
   3655                }
   3656                else
   3657                {
   3658                  /* Update I2C state */
   3659                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_9: (+1)
   \      0x182   0x2020             MOVS     R0,#+32
   \      0x184   0xF885 0x003D      STRB     R0,[R5, #+61]
   3660                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   \      0x188   0x2000             MOVS     R0,#+0
   \      0x18A   0xF885 0x003E      STRB     R0,[R5, #+62]
   3661          
   3662                  /* Update I2C error code */
   3663                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \      0x18E   0x6C28             LDR      R0,[R5, #+64]
   \      0x190   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x194   0x6428             STR      R0,[R5, #+64]
   3664          
   3665                  /* Process Unlocked */
   3666                  __HAL_UNLOCK(hi2c);
   \      0x196   0x2000             MOVS     R0,#+0
   \      0x198   0xF885 0x003C      STRB     R0,[R5, #+60]
   3667          
   3668                  return HAL_ERROR;
   \      0x19C   0x2001             MOVS     R0,#+1
   \      0x19E   0xE026             B.N      ??HAL_I2C_Master_Seq_Transmit_DMA_5
   3669                }
   3670              }
   3671              else
   3672              {
   3673                /* Enable Acknowledge */
   3674                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_8: (+1)
   \      0x1A0   0x6828             LDR      R0,[R5, #+0]
   \      0x1A2   0x6800             LDR      R0,[R0, #+0]
   \      0x1A4   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x1A8   0x6829             LDR      R1,[R5, #+0]
   \      0x1AA   0x6008             STR      R0,[R1, #+0]
   3675          
   3676                /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3677                /* Mean Previous state is same as current state */
   3678                if ((Prev_State != I2C_STATE_MASTER_BUSY_TX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
   \      0x1AC   0x9801             LDR      R0,[SP, #+4]
   \      0x1AE   0x2811             CMP      R0,#+17
   \      0x1B0   0xD10B             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_18
   \      0x1B2   0xF5B9 0x0F2A      CMP      R9,#+11141120
   \      0x1B6   0xD002             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_DMA_19
   \      0x1B8   0xF1B9 0x4F2A      CMP      R9,#+2852126720
   \      0x1BC   0xD101             BNE.N    ??HAL_I2C_Master_Seq_Transmit_DMA_20
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_19: (+1)
   \      0x1BE   0x2001             MOVS     R0,#+1
   \      0x1C0   0xE000             B.N      ??HAL_I2C_Master_Seq_Transmit_DMA_21
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_20: (+1)
   \      0x1C2   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_21: (+1)
   \      0x1C4   0xB2C0             UXTB     R0,R0
   \      0x1C6   0x2800             CMP      R0,#+0
   \      0x1C8   0xD005             BEQ.N    ??HAL_I2C_Master_Seq_Transmit_DMA_22
   3679                {
   3680                  /* Generate Start */
   3681                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_18: (+1)
   \      0x1CA   0x6828             LDR      R0,[R5, #+0]
   \      0x1CC   0x6800             LDR      R0,[R0, #+0]
   \      0x1CE   0xF450 0x7080      ORRS     R0,R0,#0x100
   \      0x1D2   0x6829             LDR      R1,[R5, #+0]
   \      0x1D4   0x6008             STR      R0,[R1, #+0]
   3682                }
   3683          
   3684                /* Process Unlocked */
   3685                __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_22: (+1)
   \      0x1D6   0x2000             MOVS     R0,#+0
   \      0x1D8   0xF885 0x003C      STRB     R0,[R5, #+60]
   3686          
   3687                /* Note : The I2C interrupts must be enabled after unlocking current process
   3688                to avoid the risk of I2C interrupt handle execution before current
   3689                process unlock */
   3690          
   3691                /* Enable EVT, BUF and ERR interrupt */
   3692                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \      0x1DC   0x6828             LDR      R0,[R5, #+0]
   \      0x1DE   0x6840             LDR      R0,[R0, #+4]
   \      0x1E0   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \      0x1E4   0x6829             LDR      R1,[R5, #+0]
   \      0x1E6   0x6048             STR      R0,[R1, #+4]
   3693              }
   3694          
   3695              return HAL_OK;
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_17: (+1)
   \      0x1E8   0x2000             MOVS     R0,#+0
   \      0x1EA   0xE000             B.N      ??HAL_I2C_Master_Seq_Transmit_DMA_5
   3696            }
   3697            else
   3698            {
   3699              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_0: (+1)
   \      0x1EC   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Seq_Transmit_DMA_5: (+1)
   \      0x1EE   0xE8BD 0x83FE      POP      {R1-R9,PC}
   3700            }
   3701          }
   3702          
   3703          /**
   3704            * @brief  Sequential receive in master I2C mode an amount of data in non-blocking mode with Interrupt
   3705            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3706            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3707            *         the configuration information for the specified I2C.
   3708            * @param  DevAddress Target device address: The device 7 bits address value
   3709            *         in datasheet must be shifted to the left before calling the interface
   3710            * @param  pData Pointer to data buffer
   3711            * @param  Size Amount of data to be sent
   3712            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   3713            * @retval HAL status
   3714            */

   \                                 In section .text, align 2, keep-with-next
   3715          HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3716          {
   \                     HAL_I2C_Master_Seq_Receive_IT: (+1)
   \        0x0   0xB4FC             PUSH     {R2-R7}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x9D06             LDR      R5,[SP, #+24]
   3717            __IO uint32_t Prev_State = 0x00U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9001             STR      R0,[SP, #+4]
   3718            __IO uint32_t count = 0U;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x9000             STR      R0,[SP, #+0]
   3719            uint32_t enableIT = (I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \        0xE   0xF44F 0x66E0      MOV      R6,#+1792
   3720          
   3721            /* Check the parameters */
   3722            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3723          
   3724            if (hi2c->State == HAL_I2C_STATE_READY)
   \       0x12   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \       0x16   0x2820             CMP      R0,#+32
   \       0x18   0xF040 0x809F      BNE.W    ??HAL_I2C_Master_Seq_Receive_IT_0
   3725            {
   3726              /* Check Busy Flag only if FIRST call of Master interface */
   3727              if ((READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP) || (XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x6800             LDR      R0,[R0, #+0]
   \       0x20   0x0580             LSLS     R0,R0,#+22
   \       0x22   0xD403             BMI.N    ??HAL_I2C_Master_Seq_Receive_IT_1
   \       0x24   0x2D08             CMP      R5,#+8
   \       0x26   0xD001             BEQ.N    ??HAL_I2C_Master_Seq_Receive_IT_1
   \       0x28   0x2D01             CMP      R5,#+1
   \       0x2A   0xD126             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_2
   3728              {
   3729                /* Wait until BUSY flag is reset */
   3730                count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \                     ??HAL_I2C_Master_Seq_Receive_IT_1: (+1)
   \       0x2C   0x....             LDR.N    R0,??DataTable22
   \       0x2E   0x6800             LDR      R0,[R0, #+0]
   \       0x30   0x2719             MOVS     R7,#+25
   \       0x32   0xFBB0 0xF0F7      UDIV     R0,R0,R7
   \       0x36   0xF44F 0x777A      MOV      R7,#+1000
   \       0x3A   0xFBB0 0xF7F7      UDIV     R7,R0,R7
   \       0x3E   0x200A             MOVS     R0,#+10
   \       0x40   0x4347             MULS     R7,R0,R7
   \       0x42   0x9700             STR      R7,[SP, #+0]
   3731                do
   3732                {
   3733                  count--;
   \                     ??HAL_I2C_Master_Seq_Receive_IT_3: (+1)
   \       0x44   0x9800             LDR      R0,[SP, #+0]
   \       0x46   0x1E40             SUBS     R0,R0,#+1
   \       0x48   0x9000             STR      R0,[SP, #+0]
   3734                  if (count == 0U)
   \       0x4A   0x9800             LDR      R0,[SP, #+0]
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD110             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_4
   3735                  {
   3736                    hi2c->PreviousState       = I2C_STATE_NONE;
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x6320             STR      R0,[R4, #+48]
   3737                    hi2c->State               = HAL_I2C_STATE_READY;
   \       0x54   0x2020             MOVS     R0,#+32
   \       0x56   0xF884 0x003D      STRB     R0,[R4, #+61]
   3738                    hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xF884 0x003E      STRB     R0,[R4, #+62]
   3739                    hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0x60   0x6C20             LDR      R0,[R4, #+64]
   \       0x62   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x66   0x6420             STR      R0,[R4, #+64]
   3740          
   3741                    /* Process Unlocked */
   3742                    __HAL_UNLOCK(hi2c);
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xF884 0x003C      STRB     R0,[R4, #+60]
   3743          
   3744                    return HAL_ERROR;
   \       0x6E   0x2001             MOVS     R0,#+1
   \       0x70   0xE074             B.N      ??HAL_I2C_Master_Seq_Receive_IT_5
   3745                  }
   3746                }
   3747                while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Master_Seq_Receive_IT_4: (+1)
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x6980             LDR      R0,[R0, #+24]
   \       0x76   0x0780             LSLS     R0,R0,#+30
   \       0x78   0xD4E4             BMI.N    ??HAL_I2C_Master_Seq_Receive_IT_3
   3748              }
   3749          
   3750              /* Process Locked */
   3751              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Seq_Receive_IT_2: (+1)
   \       0x7A   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \       0x7E   0x2801             CMP      R0,#+1
   \       0x80   0xD101             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_6
   \       0x82   0x2002             MOVS     R0,#+2
   \       0x84   0xE06A             B.N      ??HAL_I2C_Master_Seq_Receive_IT_5
   \                     ??HAL_I2C_Master_Seq_Receive_IT_6: (+1)
   \       0x86   0x2001             MOVS     R0,#+1
   \       0x88   0xF884 0x003C      STRB     R0,[R4, #+60]
   3752          
   3753              /* Check if the I2C is already enabled */
   3754              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x6800             LDR      R0,[R0, #+0]
   \       0x90   0x07C0             LSLS     R0,R0,#+31
   \       0x92   0xD405             BMI.N    ??HAL_I2C_Master_Seq_Receive_IT_7
   3755              {
   3756                /* Enable I2C peripheral */
   3757                __HAL_I2C_ENABLE(hi2c);
   \       0x94   0x6820             LDR      R0,[R4, #+0]
   \       0x96   0x6800             LDR      R0,[R0, #+0]
   \       0x98   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x9C   0x6827             LDR      R7,[R4, #+0]
   \       0x9E   0x6038             STR      R0,[R7, #+0]
   3758              }
   3759          
   3760              /* Disable Pos */
   3761              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Master_Seq_Receive_IT_7: (+1)
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x6800             LDR      R0,[R0, #+0]
   \       0xA4   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0xA8   0x6827             LDR      R7,[R4, #+0]
   \       0xAA   0x6038             STR      R0,[R7, #+0]
   3762          
   3763              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0xAC   0x2022             MOVS     R0,#+34
   \       0xAE   0xF884 0x003D      STRB     R0,[R4, #+61]
   3764              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \       0xB2   0x2010             MOVS     R0,#+16
   \       0xB4   0xF884 0x003E      STRB     R0,[R4, #+62]
   3765              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0xB8   0x2000             MOVS     R0,#+0
   \       0xBA   0x6420             STR      R0,[R4, #+64]
   3766          
   3767              /* Prepare transfer parameters */
   3768              hi2c->pBuffPtr    = pData;
   \       0xBC   0x6262             STR      R2,[R4, #+36]
   3769              hi2c->XferCount   = Size;
   \       0xBE   0x8563             STRH     R3,[R4, #+42]
   3770              hi2c->XferSize    = hi2c->XferCount;
   \       0xC0   0x8D60             LDRH     R0,[R4, #+42]
   \       0xC2   0x8520             STRH     R0,[R4, #+40]
   3771              hi2c->XferOptions = XferOptions;
   \       0xC4   0x62E5             STR      R5,[R4, #+44]
   3772              hi2c->Devaddress  = DevAddress;
   \       0xC6   0x0008             MOVS     R0,R1
   \       0xC8   0xB280             UXTH     R0,R0
   \       0xCA   0x6460             STR      R0,[R4, #+68]
   3773          
   3774              Prev_State = hi2c->PreviousState;
   \       0xCC   0x6B20             LDR      R0,[R4, #+48]
   \       0xCE   0x9001             STR      R0,[SP, #+4]
   3775          
   3776              if ((hi2c->XferCount == 2U) && ((XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP)))
   \       0xD0   0x8D60             LDRH     R0,[R4, #+42]
   \       0xD2   0x2802             CMP      R0,#+2
   \       0xD4   0xD11C             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_8
   \       0xD6   0x2D20             CMP      R5,#+32
   \       0xD8   0xD001             BEQ.N    ??HAL_I2C_Master_Seq_Receive_IT_9
   \       0xDA   0x2D10             CMP      R5,#+16
   \       0xDC   0xD118             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_8
   3777              {
   3778                if (Prev_State == I2C_STATE_MASTER_BUSY_RX)
   \                     ??HAL_I2C_Master_Seq_Receive_IT_9: (+1)
   \       0xDE   0x9801             LDR      R0,[SP, #+4]
   \       0xE0   0x2812             CMP      R0,#+18
   \       0xE2   0xD10E             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_10
   3779                {
   3780                  /* Disable Acknowledge */
   3781                  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0xE4   0x6820             LDR      R0,[R4, #+0]
   \       0xE6   0x6800             LDR      R0,[R0, #+0]
   \       0xE8   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0xEC   0x6827             LDR      R7,[R4, #+0]
   \       0xEE   0x6038             STR      R0,[R7, #+0]
   3782          
   3783                  /* Enable Pos */
   3784                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \       0xF0   0x6820             LDR      R0,[R4, #+0]
   \       0xF2   0x6800             LDR      R0,[R0, #+0]
   \       0xF4   0xF450 0x6000      ORRS     R0,R0,#0x800
   \       0xF8   0x6827             LDR      R7,[R4, #+0]
   \       0xFA   0x6038             STR      R0,[R7, #+0]
   3785          
   3786                  /* Remove Enabling of IT_BUF, mean RXNE treatment, treat the 2 bytes through BTF */
   3787                  enableIT &= ~I2C_IT_BUF;
   \       0xFC   0xF436 0x6680      BICS     R6,R6,#0x400
   \      0x100   0xE00C             B.N      ??HAL_I2C_Master_Seq_Receive_IT_11
   3788                }
   3789                else
   3790                {
   3791                  /* Enable Acknowledge */
   3792                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Seq_Receive_IT_10: (+1)
   \      0x102   0x6820             LDR      R0,[R4, #+0]
   \      0x104   0x6800             LDR      R0,[R0, #+0]
   \      0x106   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x10A   0x6827             LDR      R7,[R4, #+0]
   \      0x10C   0x6038             STR      R0,[R7, #+0]
   \      0x10E   0xE005             B.N      ??HAL_I2C_Master_Seq_Receive_IT_11
   3793                }
   3794              }
   3795              else
   3796              {
   3797                /* Enable Acknowledge */
   3798                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Seq_Receive_IT_8: (+1)
   \      0x110   0x6820             LDR      R0,[R4, #+0]
   \      0x112   0x6800             LDR      R0,[R0, #+0]
   \      0x114   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x118   0x6827             LDR      R7,[R4, #+0]
   \      0x11A   0x6038             STR      R0,[R7, #+0]
   3799              }
   3800          
   3801              /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3802              /* Mean Previous state is same as current state */
   3803              if ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
   \                     ??HAL_I2C_Master_Seq_Receive_IT_11: (+1)
   \      0x11C   0x9801             LDR      R0,[SP, #+4]
   \      0x11E   0x2812             CMP      R0,#+18
   \      0x120   0xD10B             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_12
   \      0x122   0xF5B5 0x0F2A      CMP      R5,#+11141120
   \      0x126   0xD002             BEQ.N    ??HAL_I2C_Master_Seq_Receive_IT_13
   \      0x128   0xF1B5 0x4F2A      CMP      R5,#+2852126720
   \      0x12C   0xD101             BNE.N    ??HAL_I2C_Master_Seq_Receive_IT_14
   \                     ??HAL_I2C_Master_Seq_Receive_IT_13: (+1)
   \      0x12E   0x2001             MOVS     R0,#+1
   \      0x130   0xE000             B.N      ??HAL_I2C_Master_Seq_Receive_IT_15
   \                     ??HAL_I2C_Master_Seq_Receive_IT_14: (+1)
   \      0x132   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_Master_Seq_Receive_IT_15: (+1)
   \      0x134   0xB2C0             UXTB     R0,R0
   \      0x136   0x2800             CMP      R0,#+0
   \      0x138   0xD005             BEQ.N    ??HAL_I2C_Master_Seq_Receive_IT_16
   3804              {
   3805                /* Generate Start */
   3806                SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??HAL_I2C_Master_Seq_Receive_IT_12: (+1)
   \      0x13A   0x6820             LDR      R0,[R4, #+0]
   \      0x13C   0x6800             LDR      R0,[R0, #+0]
   \      0x13E   0xF450 0x7080      ORRS     R0,R0,#0x100
   \      0x142   0x6827             LDR      R7,[R4, #+0]
   \      0x144   0x6038             STR      R0,[R7, #+0]
   3807              }
   3808          
   3809              /* Process Unlocked */
   3810              __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Seq_Receive_IT_16: (+1)
   \      0x146   0x2000             MOVS     R0,#+0
   \      0x148   0xF884 0x003C      STRB     R0,[R4, #+60]
   3811          
   3812              /* Note : The I2C interrupts must be enabled after unlocking current process
   3813              to avoid the risk of I2C interrupt handle execution before current
   3814              process unlock */
   3815          
   3816              /* Enable interrupts */
   3817              __HAL_I2C_ENABLE_IT(hi2c, enableIT);
   \      0x14C   0x6820             LDR      R0,[R4, #+0]
   \      0x14E   0x6840             LDR      R0,[R0, #+4]
   \      0x150   0x4330             ORRS     R0,R6,R0
   \      0x152   0x6827             LDR      R7,[R4, #+0]
   \      0x154   0x6078             STR      R0,[R7, #+4]
   3818          
   3819              return HAL_OK;
   \      0x156   0x2000             MOVS     R0,#+0
   \      0x158   0xE000             B.N      ??HAL_I2C_Master_Seq_Receive_IT_5
   3820            }
   3821            else
   3822            {
   3823              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Seq_Receive_IT_0: (+1)
   \      0x15A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Seq_Receive_IT_5: (+1)
   \      0x15C   0xBCF6             POP      {R1,R2,R4-R7}
   \      0x15E   0x4770             BX       LR
   3824            }
   3825          }
   3826          
   3827          /**
   3828            * @brief  Sequential receive in master mode an amount of data in non-blocking mode with DMA
   3829            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   3830            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   3831            *         the configuration information for the specified I2C.
   3832            * @param  DevAddress Target device address: The device 7 bits address value
   3833            *         in datasheet must be shifted to the left before calling the interface
   3834            * @param  pData Pointer to data buffer
   3835            * @param  Size Amount of data to be sent
   3836            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   3837            * @retval HAL status
   3838            */

   \                                 In section .text, align 2, keep-with-next
   3839          HAL_StatusTypeDef HAL_I2C_Master_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   3840          {
   \                     HAL_I2C_Master_Seq_Receive_DMA: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x4698             MOV      R8,R3
   \        0xC   0xF8DD 0x9028      LDR      R9,[SP, #+40]
   3841            __IO uint32_t Prev_State = 0x00U;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x9000             STR      R0,[SP, #+0]
   3842            __IO uint32_t count = 0U;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x9001             STR      R0,[SP, #+4]
   3843            uint32_t enableIT = (I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0x18   0xF44F 0x6AE0      MOV      R10,#+1792
   3844            HAL_StatusTypeDef dmaxferstatus;
   3845          
   3846            /* Check the parameters */
   3847            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   3848          
   3849            if (hi2c->State == HAL_I2C_STATE_READY)
   \       0x1C   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x20   0x2820             CMP      R0,#+32
   \       0x22   0xF040 0x8127      BNE.W    ??HAL_I2C_Master_Seq_Receive_DMA_0
   3850            {
   3851              /* Check Busy Flag only if FIRST call of Master interface */
   3852              if ((READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP) || (XferOptions == I2C_FIRST_AND_LAST_FRAME) || (XferOptions == I2C_FIRST_FRAME))
   \       0x26   0x6828             LDR      R0,[R5, #+0]
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0x0580             LSLS     R0,R0,#+22
   \       0x2C   0xD405             BMI.N    ??HAL_I2C_Master_Seq_Receive_DMA_1
   \       0x2E   0xF1B9 0x0F08      CMP      R9,#+8
   \       0x32   0xD002             BEQ.N    ??HAL_I2C_Master_Seq_Receive_DMA_1
   \       0x34   0xF1B9 0x0F01      CMP      R9,#+1
   \       0x38   0xD127             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_2
   3853              {
   3854                /* Wait until BUSY flag is reset */
   3855                count = I2C_TIMEOUT_BUSY_FLAG * (SystemCoreClock / 25U / 1000U);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_1: (+1)
   \       0x3A   0x.... 0x....      LDR.W    R0,??DataTable27
   \       0x3E   0x6800             LDR      R0,[R0, #+0]
   \       0x40   0x2119             MOVS     R1,#+25
   \       0x42   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x46   0xF44F 0x717A      MOV      R1,#+1000
   \       0x4A   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x4E   0x200A             MOVS     R0,#+10
   \       0x50   0x4341             MULS     R1,R0,R1
   \       0x52   0x9101             STR      R1,[SP, #+4]
   3856                do
   3857                {
   3858                  count--;
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_3: (+1)
   \       0x54   0x9801             LDR      R0,[SP, #+4]
   \       0x56   0x1E40             SUBS     R0,R0,#+1
   \       0x58   0x9001             STR      R0,[SP, #+4]
   3859                  if (count == 0U)
   \       0x5A   0x9801             LDR      R0,[SP, #+4]
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD110             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_4
   3860                  {
   3861                    hi2c->PreviousState       = I2C_STATE_NONE;
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0x6328             STR      R0,[R5, #+48]
   3862                    hi2c->State               = HAL_I2C_STATE_READY;
   \       0x64   0x2020             MOVS     R0,#+32
   \       0x66   0xF885 0x003D      STRB     R0,[R5, #+61]
   3863                    hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0xF885 0x003E      STRB     R0,[R5, #+62]
   3864                    hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0x70   0x6C28             LDR      R0,[R5, #+64]
   \       0x72   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x76   0x6428             STR      R0,[R5, #+64]
   3865          
   3866                    /* Process Unlocked */
   3867                    __HAL_UNLOCK(hi2c);
   \       0x78   0x2000             MOVS     R0,#+0
   \       0x7A   0xF885 0x003C      STRB     R0,[R5, #+60]
   3868          
   3869                    return HAL_ERROR;
   \       0x7E   0x2001             MOVS     R0,#+1
   \       0x80   0xE0F9             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_5
   3870                  }
   3871                }
   3872                while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_4: (+1)
   \       0x82   0x6828             LDR      R0,[R5, #+0]
   \       0x84   0x6980             LDR      R0,[R0, #+24]
   \       0x86   0x0780             LSLS     R0,R0,#+30
   \       0x88   0xD4E4             BMI.N    ??HAL_I2C_Master_Seq_Receive_DMA_3
   3873              }
   3874          
   3875              /* Process Locked */
   3876              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_2: (+1)
   \       0x8A   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0x8E   0x2801             CMP      R0,#+1
   \       0x90   0xD101             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_6
   \       0x92   0x2002             MOVS     R0,#+2
   \       0x94   0xE0EF             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_5
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_6: (+1)
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0xF885 0x003C      STRB     R0,[R5, #+60]
   3877          
   3878              /* Check if the I2C is already enabled */
   3879              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x9C   0x6828             LDR      R0,[R5, #+0]
   \       0x9E   0x6800             LDR      R0,[R0, #+0]
   \       0xA0   0x07C0             LSLS     R0,R0,#+31
   \       0xA2   0xD405             BMI.N    ??HAL_I2C_Master_Seq_Receive_DMA_7
   3880              {
   3881                /* Enable I2C peripheral */
   3882                __HAL_I2C_ENABLE(hi2c);
   \       0xA4   0x6828             LDR      R0,[R5, #+0]
   \       0xA6   0x6800             LDR      R0,[R0, #+0]
   \       0xA8   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xAC   0x6829             LDR      R1,[R5, #+0]
   \       0xAE   0x6008             STR      R0,[R1, #+0]
   3883              }
   3884          
   3885              /* Disable Pos */
   3886              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_7: (+1)
   \       0xB0   0x6828             LDR      R0,[R5, #+0]
   \       0xB2   0x6800             LDR      R0,[R0, #+0]
   \       0xB4   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0xB8   0x6829             LDR      R1,[R5, #+0]
   \       0xBA   0x6008             STR      R0,[R1, #+0]
   3887          
   3888              /* Clear Last DMA bit */
   3889              CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \       0xBC   0x6828             LDR      R0,[R5, #+0]
   \       0xBE   0x6840             LDR      R0,[R0, #+4]
   \       0xC0   0xF430 0x5080      BICS     R0,R0,#0x1000
   \       0xC4   0x6829             LDR      R1,[R5, #+0]
   \       0xC6   0x6048             STR      R0,[R1, #+4]
   3890          
   3891              hi2c->State     = HAL_I2C_STATE_BUSY_RX;
   \       0xC8   0x2022             MOVS     R0,#+34
   \       0xCA   0xF885 0x003D      STRB     R0,[R5, #+61]
   3892              hi2c->Mode      = HAL_I2C_MODE_MASTER;
   \       0xCE   0x2010             MOVS     R0,#+16
   \       0xD0   0xF885 0x003E      STRB     R0,[R5, #+62]
   3893              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0xD4   0x2000             MOVS     R0,#+0
   \       0xD6   0x6428             STR      R0,[R5, #+64]
   3894          
   3895              /* Prepare transfer parameters */
   3896              hi2c->pBuffPtr    = pData;
   \       0xD8   0x626F             STR      R7,[R5, #+36]
   3897              hi2c->XferCount   = Size;
   \       0xDA   0xF8A5 0x802A      STRH     R8,[R5, #+42]
   3898              hi2c->XferSize    = hi2c->XferCount;
   \       0xDE   0x8D68             LDRH     R0,[R5, #+42]
   \       0xE0   0x8528             STRH     R0,[R5, #+40]
   3899              hi2c->XferOptions = XferOptions;
   \       0xE2   0xF8C5 0x902C      STR      R9,[R5, #+44]
   3900              hi2c->Devaddress  = DevAddress;
   \       0xE6   0x0030             MOVS     R0,R6
   \       0xE8   0xB280             UXTH     R0,R0
   \       0xEA   0x6468             STR      R0,[R5, #+68]
   3901          
   3902              Prev_State = hi2c->PreviousState;
   \       0xEC   0x6B28             LDR      R0,[R5, #+48]
   \       0xEE   0x9000             STR      R0,[SP, #+0]
   3903          
   3904              if (hi2c->XferSize > 0U)
   \       0xF0   0x8D28             LDRH     R0,[R5, #+40]
   \       0xF2   0x2800             CMP      R0,#+0
   \       0xF4   0xF000 0x8098      BEQ.W    ??HAL_I2C_Master_Seq_Receive_DMA_8
   3905              {
   3906                if ((hi2c->XferCount == 2U) && ((XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP)))
   \       0xF8   0x8D68             LDRH     R0,[R5, #+42]
   \       0xFA   0x2802             CMP      R0,#+2
   \       0xFC   0xD122             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_9
   \       0xFE   0xF1B9 0x0F20      CMP      R9,#+32
   \      0x102   0xD002             BEQ.N    ??HAL_I2C_Master_Seq_Receive_DMA_10
   \      0x104   0xF1B9 0x0F10      CMP      R9,#+16
   \      0x108   0xD11C             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_9
   3907                {
   3908                  if (Prev_State == I2C_STATE_MASTER_BUSY_RX)
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_10: (+1)
   \      0x10A   0x9800             LDR      R0,[SP, #+0]
   \      0x10C   0x2812             CMP      R0,#+18
   \      0x10E   0xD112             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_11
   3909                  {
   3910                    /* Disable Acknowledge */
   3911                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \      0x110   0x6828             LDR      R0,[R5, #+0]
   \      0x112   0x6800             LDR      R0,[R0, #+0]
   \      0x114   0xF430 0x6080      BICS     R0,R0,#0x400
   \      0x118   0x6829             LDR      R1,[R5, #+0]
   \      0x11A   0x6008             STR      R0,[R1, #+0]
   3912          
   3913                    /* Enable Pos */
   3914                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \      0x11C   0x6828             LDR      R0,[R5, #+0]
   \      0x11E   0x6800             LDR      R0,[R0, #+0]
   \      0x120   0xF450 0x6000      ORRS     R0,R0,#0x800
   \      0x124   0x6829             LDR      R1,[R5, #+0]
   \      0x126   0x6008             STR      R0,[R1, #+0]
   3915          
   3916                    /* Enable Last DMA bit */
   3917                    SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \      0x128   0x6828             LDR      R0,[R5, #+0]
   \      0x12A   0x6840             LDR      R0,[R0, #+4]
   \      0x12C   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \      0x130   0x6829             LDR      R1,[R5, #+0]
   \      0x132   0x6048             STR      R0,[R1, #+4]
   \      0x134   0xE01B             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_12
   3918                  }
   3919                  else
   3920                  {
   3921                    /* Enable Acknowledge */
   3922                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_11: (+1)
   \      0x136   0x6828             LDR      R0,[R5, #+0]
   \      0x138   0x6800             LDR      R0,[R0, #+0]
   \      0x13A   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x13E   0x6829             LDR      R1,[R5, #+0]
   \      0x140   0x6008             STR      R0,[R1, #+0]
   \      0x142   0xE014             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_12
   3923                  }
   3924                }
   3925                else
   3926                {
   3927                  /* Enable Acknowledge */
   3928                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_9: (+1)
   \      0x144   0x6828             LDR      R0,[R5, #+0]
   \      0x146   0x6800             LDR      R0,[R0, #+0]
   \      0x148   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x14C   0x6829             LDR      R1,[R5, #+0]
   \      0x14E   0x6008             STR      R0,[R1, #+0]
   3929          
   3930                  if ((XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_OTHER_AND_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP))
   \      0x150   0xF1B9 0x0F20      CMP      R9,#+32
   \      0x154   0xD005             BEQ.N    ??HAL_I2C_Master_Seq_Receive_DMA_13
   \      0x156   0xF1B9 0x4F2A      CMP      R9,#+2852126720
   \      0x15A   0xD002             BEQ.N    ??HAL_I2C_Master_Seq_Receive_DMA_13
   \      0x15C   0xF1B9 0x0F10      CMP      R9,#+16
   \      0x160   0xD105             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_12
   3931                  {
   3932                    /* Enable Last DMA bit */
   3933                    SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_13: (+1)
   \      0x162   0x6828             LDR      R0,[R5, #+0]
   \      0x164   0x6840             LDR      R0,[R0, #+4]
   \      0x166   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \      0x16A   0x6829             LDR      R1,[R5, #+0]
   \      0x16C   0x6048             STR      R0,[R1, #+4]
   3934                  }
   3935                }
   3936          
   3937                /* Set the I2C DMA transfer complete callback */
   3938                hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_12: (+1)
   \      0x16E   0x....             LDR.N    R0,??DataTable24
   \      0x170   0x6BA9             LDR      R1,[R5, #+56]
   \      0x172   0x63C8             STR      R0,[R1, #+60]
   3939          
   3940                /* Set the DMA error callback */
   3941                hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \      0x174   0x....             LDR.N    R0,??DataTable24_1
   \      0x176   0x6BA9             LDR      R1,[R5, #+56]
   \      0x178   0x64C8             STR      R0,[R1, #+76]
   3942          
   3943                /* Set the unused DMA callbacks to NULL */
   3944                hi2c->hdmarx->XferHalfCpltCallback = NULL;
   \      0x17A   0x2000             MOVS     R0,#+0
   \      0x17C   0x6BA9             LDR      R1,[R5, #+56]
   \      0x17E   0x6408             STR      R0,[R1, #+64]
   3945                hi2c->hdmarx->XferAbortCallback = NULL;
   \      0x180   0x2000             MOVS     R0,#+0
   \      0x182   0x6BA9             LDR      R1,[R5, #+56]
   \      0x184   0x6508             STR      R0,[R1, #+80]
   3946          
   3947                /* Enable the DMA stream */
   3948                dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   \      0x186   0x8D2B             LDRH     R3,[R5, #+40]
   \      0x188   0x6A6A             LDR      R2,[R5, #+36]
   \      0x18A   0x6828             LDR      R0,[R5, #+0]
   \      0x18C   0xF110 0x0110      ADDS     R1,R0,#+16
   \      0x190   0x6BA8             LDR      R0,[R5, #+56]
   \      0x192   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x196   0x0004             MOVS     R4,R0
   3949          
   3950                if (dmaxferstatus == HAL_OK)
   \      0x198   0x0020             MOVS     R0,R4
   \      0x19A   0xB2C0             UXTB     R0,R0
   \      0x19C   0x2800             CMP      R0,#+0
   \      0x19E   0xD134             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_14
   3951                {
   3952                  /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   3953                  /* Mean Previous state is same as current state */
   3954                  if ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
   \      0x1A0   0x9800             LDR      R0,[SP, #+0]
   \      0x1A2   0x2812             CMP      R0,#+18
   \      0x1A4   0xD10B             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_15
   \      0x1A6   0xF5B9 0x0F2A      CMP      R9,#+11141120
   \      0x1AA   0xD002             BEQ.N    ??HAL_I2C_Master_Seq_Receive_DMA_16
   \      0x1AC   0xF1B9 0x4F2A      CMP      R9,#+2852126720
   \      0x1B0   0xD101             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_17
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_16: (+1)
   \      0x1B2   0x2001             MOVS     R0,#+1
   \      0x1B4   0xE000             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_18
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_17: (+1)
   \      0x1B6   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_18: (+1)
   \      0x1B8   0xB2C0             UXTB     R0,R0
   \      0x1BA   0x2800             CMP      R0,#+0
   \      0x1BC   0xD009             BEQ.N    ??HAL_I2C_Master_Seq_Receive_DMA_19
   3955                  {
   3956                    /* Generate Start */
   3957                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_15: (+1)
   \      0x1BE   0x6828             LDR      R0,[R5, #+0]
   \      0x1C0   0x6800             LDR      R0,[R0, #+0]
   \      0x1C2   0xF450 0x7080      ORRS     R0,R0,#0x100
   \      0x1C6   0x6829             LDR      R1,[R5, #+0]
   \      0x1C8   0x6008             STR      R0,[R1, #+0]
   3958          
   3959                    /* Update interrupt for only EVT and ERR */
   3960                    enableIT = (I2C_IT_EVT | I2C_IT_ERR);
   \      0x1CA   0xF44F 0x7040      MOV      R0,#+768
   \      0x1CE   0x4682             MOV      R10,R0
   \      0x1D0   0xE002             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_20
   3961                  }
   3962                  else
   3963                  {
   3964                    /* Update interrupt for only ERR */
   3965                    enableIT = I2C_IT_ERR;
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_19: (+1)
   \      0x1D2   0xF44F 0x7080      MOV      R0,#+256
   \      0x1D6   0x4682             MOV      R10,R0
   3966                  }
   3967          
   3968                  /* Process Unlocked */
   3969                  __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_20: (+1)
   \      0x1D8   0x2000             MOVS     R0,#+0
   \      0x1DA   0xF885 0x003C      STRB     R0,[R5, #+60]
   3970          
   3971                  /* Note : The I2C interrupts must be enabled after unlocking current process
   3972                  to avoid the risk of I2C interrupt handle execution before current
   3973                  process unlock */
   3974          
   3975                  /* If XferOptions is not associated to a new frame, mean no start bit is request, enable directly the DMA request */
   3976                  /* In other cases, DMA request is enabled after Slave address treatment in IRQHandler */
   3977                  if ((XferOptions == I2C_NEXT_FRAME) || (XferOptions == I2C_LAST_FRAME) || (XferOptions == I2C_LAST_FRAME_NO_STOP))
   \      0x1DE   0xF1B9 0x0F04      CMP      R9,#+4
   \      0x1E2   0xD005             BEQ.N    ??HAL_I2C_Master_Seq_Receive_DMA_21
   \      0x1E4   0xF1B9 0x0F20      CMP      R9,#+32
   \      0x1E8   0xD002             BEQ.N    ??HAL_I2C_Master_Seq_Receive_DMA_21
   \      0x1EA   0xF1B9 0x0F10      CMP      R9,#+16
   \      0x1EE   0xD105             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_22
   3978                  {
   3979                    /* Enable DMA Request */
   3980                    SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_21: (+1)
   \      0x1F0   0x6828             LDR      R0,[R5, #+0]
   \      0x1F2   0x6840             LDR      R0,[R0, #+4]
   \      0x1F4   0xF450 0x6000      ORRS     R0,R0,#0x800
   \      0x1F8   0x6829             LDR      R1,[R5, #+0]
   \      0x1FA   0x6048             STR      R0,[R1, #+4]
   3981                  }
   3982          
   3983                  /* Enable EVT and ERR interrupt */
   3984                  __HAL_I2C_ENABLE_IT(hi2c, enableIT);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_22: (+1)
   \      0x1FC   0x6828             LDR      R0,[R5, #+0]
   \      0x1FE   0x6840             LDR      R0,[R0, #+4]
   \      0x200   0xEA5A 0x0000      ORRS     R0,R10,R0
   \      0x204   0x6829             LDR      R1,[R5, #+0]
   \      0x206   0x6048             STR      R0,[R1, #+4]
   \      0x208   0xE032             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_23
   3985                }
   3986                else
   3987                {
   3988                  /* Update I2C state */
   3989                  hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_14: (+1)
   \      0x20A   0x2020             MOVS     R0,#+32
   \      0x20C   0xF885 0x003D      STRB     R0,[R5, #+61]
   3990                  hi2c->Mode      = HAL_I2C_MODE_NONE;
   \      0x210   0x2000             MOVS     R0,#+0
   \      0x212   0xF885 0x003E      STRB     R0,[R5, #+62]
   3991          
   3992                  /* Update I2C error code */
   3993                  hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \      0x216   0x6C28             LDR      R0,[R5, #+64]
   \      0x218   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x21C   0x6428             STR      R0,[R5, #+64]
   3994          
   3995                  /* Process Unlocked */
   3996                  __HAL_UNLOCK(hi2c);
   \      0x21E   0x2000             MOVS     R0,#+0
   \      0x220   0xF885 0x003C      STRB     R0,[R5, #+60]
   3997          
   3998                  return HAL_ERROR;
   \      0x224   0x2001             MOVS     R0,#+1
   \      0x226   0xE026             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_5
   3999                }
   4000              }
   4001              else
   4002              {
   4003                /* Enable Acknowledge */
   4004                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_8: (+1)
   \      0x228   0x6828             LDR      R0,[R5, #+0]
   \      0x22A   0x6800             LDR      R0,[R0, #+0]
   \      0x22C   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x230   0x6829             LDR      R1,[R5, #+0]
   \      0x232   0x6008             STR      R0,[R1, #+0]
   4005          
   4006                /* If transfer direction not change and there is no request to start another frame, do not generate Restart Condition */
   4007                /* Mean Previous state is same as current state */
   4008                if ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(XferOptions) == 1))
   \      0x234   0x9800             LDR      R0,[SP, #+0]
   \      0x236   0x2812             CMP      R0,#+18
   \      0x238   0xD10B             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_24
   \      0x23A   0xF5B9 0x0F2A      CMP      R9,#+11141120
   \      0x23E   0xD002             BEQ.N    ??HAL_I2C_Master_Seq_Receive_DMA_25
   \      0x240   0xF1B9 0x4F2A      CMP      R9,#+2852126720
   \      0x244   0xD101             BNE.N    ??HAL_I2C_Master_Seq_Receive_DMA_26
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_25: (+1)
   \      0x246   0x2001             MOVS     R0,#+1
   \      0x248   0xE000             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_27
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_26: (+1)
   \      0x24A   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_27: (+1)
   \      0x24C   0xB2C0             UXTB     R0,R0
   \      0x24E   0x2800             CMP      R0,#+0
   \      0x250   0xD005             BEQ.N    ??HAL_I2C_Master_Seq_Receive_DMA_28
   4009                {
   4010                  /* Generate Start */
   4011                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_24: (+1)
   \      0x252   0x6828             LDR      R0,[R5, #+0]
   \      0x254   0x6800             LDR      R0,[R0, #+0]
   \      0x256   0xF450 0x7080      ORRS     R0,R0,#0x100
   \      0x25A   0x6829             LDR      R1,[R5, #+0]
   \      0x25C   0x6008             STR      R0,[R1, #+0]
   4012                }
   4013          
   4014                /* Process Unlocked */
   4015                __HAL_UNLOCK(hi2c);
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_28: (+1)
   \      0x25E   0x2000             MOVS     R0,#+0
   \      0x260   0xF885 0x003C      STRB     R0,[R5, #+60]
   4016          
   4017                /* Note : The I2C interrupts must be enabled after unlocking current process
   4018                to avoid the risk of I2C interrupt handle execution before current
   4019                process unlock */
   4020          
   4021                /* Enable interrupts */
   4022                __HAL_I2C_ENABLE_IT(hi2c, enableIT);
   \      0x264   0x6828             LDR      R0,[R5, #+0]
   \      0x266   0x6840             LDR      R0,[R0, #+4]
   \      0x268   0xEA5A 0x0000      ORRS     R0,R10,R0
   \      0x26C   0x6829             LDR      R1,[R5, #+0]
   \      0x26E   0x6048             STR      R0,[R1, #+4]
   4023              }
   4024              return HAL_OK;
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_23: (+1)
   \      0x270   0x2000             MOVS     R0,#+0
   \      0x272   0xE000             B.N      ??HAL_I2C_Master_Seq_Receive_DMA_5
   4025            }
   4026            else
   4027            {
   4028              return HAL_BUSY;
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_0: (+1)
   \      0x274   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Master_Seq_Receive_DMA_5: (+1)
   \      0x276   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   4029            }
   4030          }
   4031          
   4032          /**
   4033            * @brief  Sequential transmit in slave mode an amount of data in non-blocking mode with Interrupt
   4034            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   4035            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4036            *         the configuration information for the specified I2C.
   4037            * @param  pData Pointer to data buffer
   4038            * @param  Size Amount of data to be sent
   4039            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   4040            * @retval HAL status
   4041            */

   \                                 In section .text, align 2, keep-with-next
   4042          HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   4043          {
   \                     HAL_I2C_Slave_Seq_Transmit_IT: (+1)
   \        0x0   0xB438             PUSH     {R3-R5}
   \        0x2   0x0004             MOVS     R4,R0
   4044            /* Check the parameters */
   4045            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   4046          
   4047            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \        0x4   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \        0x8   0xF010 0x0028      ANDS     R0,R0,#0x28
   \        0xC   0x2828             CMP      R0,#+40
   \        0xE   0xD141             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_IT_0
   4048            {
   4049              if ((pData == NULL) || (Size == 0U))
   \       0x10   0x2900             CMP      R1,#+0
   \       0x12   0xD003             BEQ.N    ??HAL_I2C_Slave_Seq_Transmit_IT_1
   \       0x14   0x0010             MOVS     R0,R2
   \       0x16   0xB280             UXTH     R0,R0
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD101             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_IT_2
   4050              {
   4051                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_1: (+1)
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE03A             B.N      ??HAL_I2C_Slave_Seq_Transmit_IT_3
   4052              }
   4053          
   4054              /* Process Locked */
   4055              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_2: (+1)
   \       0x20   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xD101             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_IT_4
   \       0x28   0x2002             MOVS     R0,#+2
   \       0x2A   0xE034             B.N      ??HAL_I2C_Slave_Seq_Transmit_IT_3
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_4: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xF884 0x003C      STRB     R0,[R4, #+60]
   4056          
   4057              /* Check if the I2C is already enabled */
   4058              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x6800             LDR      R0,[R0, #+0]
   \       0x36   0x07C0             LSLS     R0,R0,#+31
   \       0x38   0xD405             BMI.N    ??HAL_I2C_Slave_Seq_Transmit_IT_5
   4059              {
   4060                /* Enable I2C peripheral */
   4061                __HAL_I2C_ENABLE(hi2c);
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x6800             LDR      R0,[R0, #+0]
   \       0x3E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x42   0x6825             LDR      R5,[R4, #+0]
   \       0x44   0x6028             STR      R0,[R5, #+0]
   4062              }
   4063          
   4064              /* Disable Pos */
   4065              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_5: (+1)
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x6800             LDR      R0,[R0, #+0]
   \       0x4A   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x4E   0x6825             LDR      R5,[R4, #+0]
   \       0x50   0x6028             STR      R0,[R5, #+0]
   4066          
   4067              hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
   \       0x52   0x2029             MOVS     R0,#+41
   \       0x54   0xF884 0x003D      STRB     R0,[R4, #+61]
   4068              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \       0x58   0x2020             MOVS     R0,#+32
   \       0x5A   0xF884 0x003E      STRB     R0,[R4, #+62]
   4069              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x6420             STR      R0,[R4, #+64]
   4070          
   4071              /* Prepare transfer parameters */
   4072              hi2c->pBuffPtr    = pData;
   \       0x62   0x6261             STR      R1,[R4, #+36]
   4073              hi2c->XferCount   = Size;
   \       0x64   0x8562             STRH     R2,[R4, #+42]
   4074              hi2c->XferSize    = hi2c->XferCount;
   \       0x66   0x8D60             LDRH     R0,[R4, #+42]
   \       0x68   0x8520             STRH     R0,[R4, #+40]
   4075              hi2c->XferOptions = XferOptions;
   \       0x6A   0x62E3             STR      R3,[R4, #+44]
   4076          
   4077              /* Clear ADDR flag */
   4078              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x9000             STR      R0,[SP, #+0]
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x6940             LDR      R0,[R0, #+20]
   \       0x74   0x9000             STR      R0,[SP, #+0]
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x6980             LDR      R0,[R0, #+24]
   \       0x7A   0x9000             STR      R0,[SP, #+0]
   \       0x7C   0x9800             LDR      R0,[SP, #+0]
   4079          
   4080              /* Process Unlocked */
   4081              __HAL_UNLOCK(hi2c);
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0xF884 0x003C      STRB     R0,[R4, #+60]
   4082          
   4083              /* Note : The I2C interrupts must be enabled after unlocking current process
   4084                        to avoid the risk of I2C interrupt handle execution before current
   4085                        process unlock */
   4086          
   4087              /* Enable EVT, BUF and ERR interrupt */
   4088              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0x84   0x6820             LDR      R0,[R4, #+0]
   \       0x86   0x6840             LDR      R0,[R0, #+4]
   \       0x88   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \       0x8C   0x6825             LDR      R5,[R4, #+0]
   \       0x8E   0x6068             STR      R0,[R5, #+4]
   4089          
   4090              return HAL_OK;
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0xE000             B.N      ??HAL_I2C_Slave_Seq_Transmit_IT_3
   4091            }
   4092            else
   4093            {
   4094              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_0: (+1)
   \       0x94   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Seq_Transmit_IT_3: (+1)
   \       0x96   0xBC32             POP      {R1,R4,R5}
   \       0x98   0x4770             BX       LR
   4095            }
   4096          }
   4097          
   4098          /**
   4099            * @brief  Sequential transmit in slave mode an amount of data in non-blocking mode with DMA
   4100            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   4101            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4102            *         the configuration information for the specified I2C.
   4103            * @param  pData Pointer to data buffer
   4104            * @param  Size Amount of data to be sent
   4105            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   4106            * @retval HAL status
   4107            */

   \                                 In section .text, align 2, keep-with-next
   4108          HAL_StatusTypeDef HAL_I2C_Slave_Seq_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   4109          {
   \                     HAL_I2C_Slave_Seq_Transmit_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
   4110            HAL_StatusTypeDef dmaxferstatus;
   4111          
   4112            /* Check the parameters */
   4113            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   4114          
   4115            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \        0xA   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \        0xE   0xF010 0x0028      ANDS     R0,R0,#0x28
   \       0x12   0x2828             CMP      R0,#+40
   \       0x14   0xF040 0x80B9      BNE.W    ??HAL_I2C_Slave_Seq_Transmit_DMA_0
   4116            {
   4117              if ((pData == NULL) || (Size == 0U))
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD003             BEQ.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_1
   \       0x1C   0x0030             MOVS     R0,R6
   \       0x1E   0xB280             UXTH     R0,R0
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD101             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_2
   4118              {
   4119                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_1: (+1)
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xE0B1             B.N      ??HAL_I2C_Slave_Seq_Transmit_DMA_3
   4120              }
   4121          
   4122              /* Process Locked */
   4123              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_2: (+1)
   \       0x28   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD101             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_4
   \       0x30   0x2002             MOVS     R0,#+2
   \       0x32   0xE0AB             B.N      ??HAL_I2C_Slave_Seq_Transmit_DMA_3
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_4: (+1)
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xF885 0x003C      STRB     R0,[R5, #+60]
   4124          
   4125              /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
   4126              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \       0x3A   0x6828             LDR      R0,[R5, #+0]
   \       0x3C   0x6840             LDR      R0,[R0, #+4]
   \       0x3E   0xF430 0x7040      BICS     R0,R0,#0x300
   \       0x42   0x6829             LDR      R1,[R5, #+0]
   \       0x44   0x6048             STR      R0,[R1, #+4]
   4127          
   4128              /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
   4129              /* and then toggle the HAL slave RX state to TX state */
   4130              if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
   \       0x46   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x4A   0x282A             CMP      R0,#+42
   \       0x4C   0xD11A             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_5
   4131              {
   4132                if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   \       0x4E   0x6828             LDR      R0,[R5, #+0]
   \       0x50   0x6840             LDR      R0,[R0, #+4]
   \       0x52   0x0500             LSLS     R0,R0,#+20
   \       0x54   0xD534             BPL.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_6
   4133                {
   4134                  /* Abort DMA Xfer if any */
   4135                  if (hi2c->hdmarx != NULL)
   \       0x56   0x6BA8             LDR      R0,[R5, #+56]
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD031             BEQ.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_6
   4136                  {
   4137                    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \       0x5C   0x6828             LDR      R0,[R5, #+0]
   \       0x5E   0x6840             LDR      R0,[R0, #+4]
   \       0x60   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x64   0x6829             LDR      R1,[R5, #+0]
   \       0x66   0x6048             STR      R0,[R1, #+4]
   4138          
   4139                    /* Set the I2C DMA Abort callback :
   4140                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   4141                    hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
   \       0x68   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \       0x6C   0x6BA9             LDR      R1,[R5, #+56]
   \       0x6E   0x6508             STR      R0,[R1, #+80]
   4142          
   4143                    /* Abort DMA RX */
   4144                    if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
   \       0x70   0x6BA8             LDR      R0,[R5, #+56]
   \       0x72   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD022             BEQ.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_6
   4145                    {
   4146                      /* Call Directly XferAbortCallback function in case of error */
   4147                      hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
   \       0x7A   0x6BA8             LDR      R0,[R5, #+56]
   \       0x7C   0x6BA9             LDR      R1,[R5, #+56]
   \       0x7E   0x6D09             LDR      R1,[R1, #+80]
   \       0x80   0x4788             BLX      R1
   \       0x82   0xE01D             B.N      ??HAL_I2C_Slave_Seq_Transmit_DMA_6
   4148                    }
   4149                  }
   4150                }
   4151              }
   4152              else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_5: (+1)
   \       0x84   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x88   0x2829             CMP      R0,#+41
   \       0x8A   0xD119             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_6
   4153              {
   4154                if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   \       0x8C   0x6828             LDR      R0,[R5, #+0]
   \       0x8E   0x6840             LDR      R0,[R0, #+4]
   \       0x90   0x0500             LSLS     R0,R0,#+20
   \       0x92   0xD515             BPL.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_6
   4155                {
   4156                  CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \       0x94   0x6828             LDR      R0,[R5, #+0]
   \       0x96   0x6840             LDR      R0,[R0, #+4]
   \       0x98   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x9C   0x6829             LDR      R1,[R5, #+0]
   \       0x9E   0x6048             STR      R0,[R1, #+4]
   4157          
   4158                  /* Abort DMA Xfer if any */
   4159                  if (hi2c->hdmatx != NULL)
   \       0xA0   0x6B68             LDR      R0,[R5, #+52]
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD00C             BEQ.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_6
   4160                  {
   4161                    /* Set the I2C DMA Abort callback :
   4162                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   4163                    hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
   \       0xA6   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \       0xAA   0x6B69             LDR      R1,[R5, #+52]
   \       0xAC   0x6508             STR      R0,[R1, #+80]
   4164          
   4165                    /* Abort DMA TX */
   4166                    if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
   \       0xAE   0x6B68             LDR      R0,[R5, #+52]
   \       0xB0   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD003             BEQ.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_6
   4167                    {
   4168                      /* Call Directly XferAbortCallback function in case of error */
   4169                      hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
   \       0xB8   0x6B68             LDR      R0,[R5, #+52]
   \       0xBA   0x6B69             LDR      R1,[R5, #+52]
   \       0xBC   0x6D09             LDR      R1,[R1, #+80]
   \       0xBE   0x4788             BLX      R1
   4170                    }
   4171                  }
   4172                }
   4173              }
   4174              else
   4175              {
   4176                /* Nothing to do */
   4177              }
   4178          
   4179              /* Check if the I2C is already enabled */
   4180              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_6: (+1)
   \       0xC0   0x6828             LDR      R0,[R5, #+0]
   \       0xC2   0x6800             LDR      R0,[R0, #+0]
   \       0xC4   0x07C0             LSLS     R0,R0,#+31
   \       0xC6   0xD405             BMI.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_7
   4181              {
   4182                /* Enable I2C peripheral */
   4183                __HAL_I2C_ENABLE(hi2c);
   \       0xC8   0x6828             LDR      R0,[R5, #+0]
   \       0xCA   0x6800             LDR      R0,[R0, #+0]
   \       0xCC   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xD0   0x6829             LDR      R1,[R5, #+0]
   \       0xD2   0x6008             STR      R0,[R1, #+0]
   4184              }
   4185          
   4186              /* Disable Pos */
   4187              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_7: (+1)
   \       0xD4   0x6828             LDR      R0,[R5, #+0]
   \       0xD6   0x6800             LDR      R0,[R0, #+0]
   \       0xD8   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0xDC   0x6829             LDR      R1,[R5, #+0]
   \       0xDE   0x6008             STR      R0,[R1, #+0]
   4188          
   4189              hi2c->State     = HAL_I2C_STATE_BUSY_TX_LISTEN;
   \       0xE0   0x2029             MOVS     R0,#+41
   \       0xE2   0xF885 0x003D      STRB     R0,[R5, #+61]
   4190              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \       0xE6   0x2020             MOVS     R0,#+32
   \       0xE8   0xF885 0x003E      STRB     R0,[R5, #+62]
   4191              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0xEC   0x2000             MOVS     R0,#+0
   \       0xEE   0x6428             STR      R0,[R5, #+64]
   4192          
   4193              /* Prepare transfer parameters */
   4194              hi2c->pBuffPtr    = pData;
   \       0xF0   0x626C             STR      R4,[R5, #+36]
   4195              hi2c->XferCount   = Size;
   \       0xF2   0x856E             STRH     R6,[R5, #+42]
   4196              hi2c->XferSize    = hi2c->XferCount;
   \       0xF4   0x8D68             LDRH     R0,[R5, #+42]
   \       0xF6   0x8528             STRH     R0,[R5, #+40]
   4197              hi2c->XferOptions = XferOptions;
   \       0xF8   0x62EF             STR      R7,[R5, #+44]
   4198          
   4199              /* Set the I2C DMA transfer complete callback */
   4200              hi2c->hdmatx->XferCpltCallback = I2C_DMAXferCplt;
   \       0xFA   0x....             LDR.N    R0,??DataTable24
   \       0xFC   0x6B69             LDR      R1,[R5, #+52]
   \       0xFE   0x63C8             STR      R0,[R1, #+60]
   4201          
   4202              /* Set the DMA error callback */
   4203              hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
   \      0x100   0x....             LDR.N    R0,??DataTable24_1
   \      0x102   0x6B69             LDR      R1,[R5, #+52]
   \      0x104   0x64C8             STR      R0,[R1, #+76]
   4204          
   4205              /* Set the unused DMA callbacks to NULL */
   4206              hi2c->hdmatx->XferHalfCpltCallback = NULL;
   \      0x106   0x2000             MOVS     R0,#+0
   \      0x108   0x6B69             LDR      R1,[R5, #+52]
   \      0x10A   0x6408             STR      R0,[R1, #+64]
   4207              hi2c->hdmatx->XferAbortCallback = NULL;
   \      0x10C   0x2000             MOVS     R0,#+0
   \      0x10E   0x6B69             LDR      R1,[R5, #+52]
   \      0x110   0x6508             STR      R0,[R1, #+80]
   4208          
   4209              /* Enable the DMA stream */
   4210              dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->DR, hi2c->XferSize);
   \      0x112   0x8D2B             LDRH     R3,[R5, #+40]
   \      0x114   0x6828             LDR      R0,[R5, #+0]
   \      0x116   0xF110 0x0210      ADDS     R2,R0,#+16
   \      0x11A   0x6A69             LDR      R1,[R5, #+36]
   \      0x11C   0x6B68             LDR      R0,[R5, #+52]
   \      0x11E   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x122   0x0001             MOVS     R1,R0
   4211          
   4212              if (dmaxferstatus == HAL_OK)
   \      0x124   0x0008             MOVS     R0,R1
   \      0x126   0xB2C0             UXTB     R0,R0
   \      0x128   0x2800             CMP      R0,#+0
   \      0x12A   0xD11F             BNE.N    ??HAL_I2C_Slave_Seq_Transmit_DMA_8
   4213              {
   4214                /* Enable Address Acknowledge */
   4215                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \      0x12C   0x6828             LDR      R0,[R5, #+0]
   \      0x12E   0x6800             LDR      R0,[R0, #+0]
   \      0x130   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x134   0x682A             LDR      R2,[R5, #+0]
   \      0x136   0x6010             STR      R0,[R2, #+0]
   4216          
   4217                /* Clear ADDR flag */
   4218                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \      0x138   0x2000             MOVS     R0,#+0
   \      0x13A   0x9000             STR      R0,[SP, #+0]
   \      0x13C   0x6828             LDR      R0,[R5, #+0]
   \      0x13E   0x6940             LDR      R0,[R0, #+20]
   \      0x140   0x9000             STR      R0,[SP, #+0]
   \      0x142   0x6828             LDR      R0,[R5, #+0]
   \      0x144   0x6980             LDR      R0,[R0, #+24]
   \      0x146   0x9000             STR      R0,[SP, #+0]
   \      0x148   0x9800             LDR      R0,[SP, #+0]
   4219          
   4220                /* Process Unlocked */
   4221                __HAL_UNLOCK(hi2c);
   \      0x14A   0x2000             MOVS     R0,#+0
   \      0x14C   0xF885 0x003C      STRB     R0,[R5, #+60]
   4222          
   4223                /* Note : The I2C interrupts must be enabled after unlocking current process
   4224                to avoid the risk of I2C interrupt handle execution before current
   4225                process unlock */
   4226                /* Enable EVT and ERR interrupt */
   4227                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \      0x150   0x6828             LDR      R0,[R5, #+0]
   \      0x152   0x6840             LDR      R0,[R0, #+4]
   \      0x154   0xF450 0x7040      ORRS     R0,R0,#0x300
   \      0x158   0x682A             LDR      R2,[R5, #+0]
   \      0x15A   0x6050             STR      R0,[R2, #+4]
   4228          
   4229                /* Enable DMA Request */
   4230                hi2c->Instance->CR2 |= I2C_CR2_DMAEN;
   \      0x15C   0x6828             LDR      R0,[R5, #+0]
   \      0x15E   0x6840             LDR      R0,[R0, #+4]
   \      0x160   0xF450 0x6000      ORRS     R0,R0,#0x800
   \      0x164   0x682A             LDR      R2,[R5, #+0]
   \      0x166   0x6050             STR      R0,[R2, #+4]
   4231          
   4232                return HAL_OK;
   \      0x168   0x2000             MOVS     R0,#+0
   \      0x16A   0xE00F             B.N      ??HAL_I2C_Slave_Seq_Transmit_DMA_3
   4233              }
   4234              else
   4235              {
   4236                /* Update I2C state */
   4237                hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_8: (+1)
   \      0x16C   0x2020             MOVS     R0,#+32
   \      0x16E   0xF885 0x003D      STRB     R0,[R5, #+61]
   4238                hi2c->Mode      = HAL_I2C_MODE_NONE;
   \      0x172   0x2000             MOVS     R0,#+0
   \      0x174   0xF885 0x003E      STRB     R0,[R5, #+62]
   4239          
   4240                /* Update I2C error code */
   4241                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \      0x178   0x6C28             LDR      R0,[R5, #+64]
   \      0x17A   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x17E   0x6428             STR      R0,[R5, #+64]
   4242          
   4243                /* Process Unlocked */
   4244                __HAL_UNLOCK(hi2c);
   \      0x180   0x2000             MOVS     R0,#+0
   \      0x182   0xF885 0x003C      STRB     R0,[R5, #+60]
   4245          
   4246                return HAL_ERROR;
   \      0x186   0x2001             MOVS     R0,#+1
   \      0x188   0xE000             B.N      ??HAL_I2C_Slave_Seq_Transmit_DMA_3
   4247              }
   4248            }
   4249            else
   4250            {
   4251              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_0: (+1)
   \      0x18A   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Seq_Transmit_DMA_3: (+1)
   \      0x18C   0xBDF2             POP      {R1,R4-R7,PC}
   4252            }
   4253          }
   4254          
   4255          /**
   4256            * @brief  Sequential receive in slave mode an amount of data in non-blocking mode with Interrupt
   4257            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   4258            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4259            *         the configuration information for the specified I2C.
   4260            * @param  pData Pointer to data buffer
   4261            * @param  Size Amount of data to be sent
   4262            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   4263            * @retval HAL status
   4264            */

   \                                 In section .text, align 2, keep-with-next
   4265          HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_IT(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   4266          {
   \                     HAL_I2C_Slave_Seq_Receive_IT: (+1)
   \        0x0   0xB438             PUSH     {R3-R5}
   \        0x2   0x0004             MOVS     R4,R0
   4267            /* Check the parameters */
   4268            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   4269          
   4270            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \        0x4   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \        0x8   0xF010 0x0028      ANDS     R0,R0,#0x28
   \        0xC   0x2828             CMP      R0,#+40
   \        0xE   0xD141             BNE.N    ??HAL_I2C_Slave_Seq_Receive_IT_0
   4271            {
   4272              if ((pData == NULL) || (Size == 0U))
   \       0x10   0x2900             CMP      R1,#+0
   \       0x12   0xD003             BEQ.N    ??HAL_I2C_Slave_Seq_Receive_IT_1
   \       0x14   0x0010             MOVS     R0,R2
   \       0x16   0xB280             UXTH     R0,R0
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD101             BNE.N    ??HAL_I2C_Slave_Seq_Receive_IT_2
   4273              {
   4274                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_1: (+1)
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0xE03A             B.N      ??HAL_I2C_Slave_Seq_Receive_IT_3
   4275              }
   4276          
   4277              /* Process Locked */
   4278              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_2: (+1)
   \       0x20   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xD101             BNE.N    ??HAL_I2C_Slave_Seq_Receive_IT_4
   \       0x28   0x2002             MOVS     R0,#+2
   \       0x2A   0xE034             B.N      ??HAL_I2C_Slave_Seq_Receive_IT_3
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_4: (+1)
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xF884 0x003C      STRB     R0,[R4, #+60]
   4279          
   4280              /* Check if the I2C is already enabled */
   4281              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x6800             LDR      R0,[R0, #+0]
   \       0x36   0x07C0             LSLS     R0,R0,#+31
   \       0x38   0xD405             BMI.N    ??HAL_I2C_Slave_Seq_Receive_IT_5
   4282              {
   4283                /* Enable I2C peripheral */
   4284                __HAL_I2C_ENABLE(hi2c);
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x6800             LDR      R0,[R0, #+0]
   \       0x3E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x42   0x6825             LDR      R5,[R4, #+0]
   \       0x44   0x6028             STR      R0,[R5, #+0]
   4285              }
   4286          
   4287              /* Disable Pos */
   4288              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_5: (+1)
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x6800             LDR      R0,[R0, #+0]
   \       0x4A   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x4E   0x6825             LDR      R5,[R4, #+0]
   \       0x50   0x6028             STR      R0,[R5, #+0]
   4289          
   4290              hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
   \       0x52   0x202A             MOVS     R0,#+42
   \       0x54   0xF884 0x003D      STRB     R0,[R4, #+61]
   4291              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \       0x58   0x2020             MOVS     R0,#+32
   \       0x5A   0xF884 0x003E      STRB     R0,[R4, #+62]
   4292              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x6420             STR      R0,[R4, #+64]
   4293          
   4294              /* Prepare transfer parameters */
   4295              hi2c->pBuffPtr    = pData;
   \       0x62   0x6261             STR      R1,[R4, #+36]
   4296              hi2c->XferCount   = Size;
   \       0x64   0x8562             STRH     R2,[R4, #+42]
   4297              hi2c->XferSize    = hi2c->XferCount;
   \       0x66   0x8D60             LDRH     R0,[R4, #+42]
   \       0x68   0x8520             STRH     R0,[R4, #+40]
   4298              hi2c->XferOptions = XferOptions;
   \       0x6A   0x62E3             STR      R3,[R4, #+44]
   4299          
   4300              /* Clear ADDR flag */
   4301              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0x9000             STR      R0,[SP, #+0]
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x6940             LDR      R0,[R0, #+20]
   \       0x74   0x9000             STR      R0,[SP, #+0]
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x6980             LDR      R0,[R0, #+24]
   \       0x7A   0x9000             STR      R0,[SP, #+0]
   \       0x7C   0x9800             LDR      R0,[SP, #+0]
   4302          
   4303              /* Process Unlocked */
   4304              __HAL_UNLOCK(hi2c);
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0xF884 0x003C      STRB     R0,[R4, #+60]
   4305          
   4306              /* Note : The I2C interrupts must be enabled after unlocking current process
   4307                        to avoid the risk of I2C interrupt handle execution before current
   4308                        process unlock */
   4309          
   4310              /* Enable EVT, BUF and ERR interrupt */
   4311              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0x84   0x6820             LDR      R0,[R4, #+0]
   \       0x86   0x6840             LDR      R0,[R0, #+4]
   \       0x88   0xF450 0x60E0      ORRS     R0,R0,#0x700
   \       0x8C   0x6825             LDR      R5,[R4, #+0]
   \       0x8E   0x6068             STR      R0,[R5, #+4]
   4312          
   4313              return HAL_OK;
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0xE000             B.N      ??HAL_I2C_Slave_Seq_Receive_IT_3
   4314            }
   4315            else
   4316            {
   4317              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_0: (+1)
   \       0x94   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Seq_Receive_IT_3: (+1)
   \       0x96   0xBC32             POP      {R1,R4,R5}
   \       0x98   0x4770             BX       LR
   4318            }
   4319          }
   4320          
   4321          /**
   4322            * @brief  Sequential receive in slave mode an amount of data in non-blocking mode with DMA
   4323            * @note   This interface allow to manage repeated start condition when a direction change during transfer
   4324            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4325            *         the configuration information for the specified I2C.
   4326            * @param  pData Pointer to data buffer
   4327            * @param  Size Amount of data to be sent
   4328            * @param  XferOptions Options of Transfer, value of @ref I2C_XferOptions_definition
   4329            * @retval HAL status
   4330            */

   \                                 In section .text, align 2, keep-with-next
   4331          HAL_StatusTypeDef HAL_I2C_Slave_Seq_Receive_DMA(I2C_HandleTypeDef *hi2c, uint8_t *pData, uint16_t Size, uint32_t XferOptions)
   4332          {
   \                     HAL_I2C_Slave_Seq_Receive_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
   4333            HAL_StatusTypeDef dmaxferstatus;
   4334          
   4335            /* Check the parameters */
   4336            assert_param(IS_I2C_TRANSFER_OPTIONS_REQUEST(XferOptions));
   4337          
   4338            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \        0xA   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \        0xE   0xF010 0x0028      ANDS     R0,R0,#0x28
   \       0x12   0x2828             CMP      R0,#+40
   \       0x14   0xF040 0x80BB      BNE.W    ??HAL_I2C_Slave_Seq_Receive_DMA_0
   4339            {
   4340              if ((pData == NULL) || (Size == 0U))
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD003             BEQ.N    ??HAL_I2C_Slave_Seq_Receive_DMA_1
   \       0x1C   0x0030             MOVS     R0,R6
   \       0x1E   0xB280             UXTH     R0,R0
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD101             BNE.N    ??HAL_I2C_Slave_Seq_Receive_DMA_2
   4341              {
   4342                return  HAL_ERROR;
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_1: (+1)
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xE0B3             B.N      ??HAL_I2C_Slave_Seq_Receive_DMA_3
   4343              }
   4344          
   4345              /* Process Locked */
   4346              __HAL_LOCK(hi2c);
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_2: (+1)
   \       0x28   0xF895 0x003C      LDRB     R0,[R5, #+60]
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD101             BNE.N    ??HAL_I2C_Slave_Seq_Receive_DMA_4
   \       0x30   0x2002             MOVS     R0,#+2
   \       0x32   0xE0AD             B.N      ??HAL_I2C_Slave_Seq_Receive_DMA_3
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_4: (+1)
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xF885 0x003C      STRB     R0,[R5, #+60]
   4347          
   4348              /* Disable Interrupts, to prevent preemption during treatment in case of multicall */
   4349              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \       0x3A   0x6828             LDR      R0,[R5, #+0]
   \       0x3C   0x6840             LDR      R0,[R0, #+4]
   \       0x3E   0xF430 0x7040      BICS     R0,R0,#0x300
   \       0x42   0x6829             LDR      R1,[R5, #+0]
   \       0x44   0x6048             STR      R0,[R1, #+4]
   4350          
   4351              /* I2C cannot manage full duplex exchange so disable previous IT enabled if any */
   4352              /* and then toggle the HAL slave RX state to TX state */
   4353              if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
   \       0x46   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x4A   0x282A             CMP      R0,#+42
   \       0x4C   0xD11A             BNE.N    ??HAL_I2C_Slave_Seq_Receive_DMA_5
   4354              {
   4355                if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   \       0x4E   0x6828             LDR      R0,[R5, #+0]
   \       0x50   0x6840             LDR      R0,[R0, #+4]
   \       0x52   0x0500             LSLS     R0,R0,#+20
   \       0x54   0xD534             BPL.N    ??HAL_I2C_Slave_Seq_Receive_DMA_6
   4356                {
   4357                  /* Abort DMA Xfer if any */
   4358                  if (hi2c->hdmarx != NULL)
   \       0x56   0x6BA8             LDR      R0,[R5, #+56]
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD031             BEQ.N    ??HAL_I2C_Slave_Seq_Receive_DMA_6
   4359                  {
   4360                    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \       0x5C   0x6828             LDR      R0,[R5, #+0]
   \       0x5E   0x6840             LDR      R0,[R0, #+4]
   \       0x60   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x64   0x6829             LDR      R1,[R5, #+0]
   \       0x66   0x6048             STR      R0,[R1, #+4]
   4361          
   4362                    /* Set the I2C DMA Abort callback :
   4363                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   4364                    hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
   \       0x68   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \       0x6C   0x6BA9             LDR      R1,[R5, #+56]
   \       0x6E   0x6508             STR      R0,[R1, #+80]
   4365          
   4366                    /* Abort DMA RX */
   4367                    if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
   \       0x70   0x6BA8             LDR      R0,[R5, #+56]
   \       0x72   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD022             BEQ.N    ??HAL_I2C_Slave_Seq_Receive_DMA_6
   4368                    {
   4369                      /* Call Directly XferAbortCallback function in case of error */
   4370                      hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
   \       0x7A   0x6BA8             LDR      R0,[R5, #+56]
   \       0x7C   0x6BA9             LDR      R1,[R5, #+56]
   \       0x7E   0x6D09             LDR      R1,[R1, #+80]
   \       0x80   0x4788             BLX      R1
   \       0x82   0xE01D             B.N      ??HAL_I2C_Slave_Seq_Receive_DMA_6
   4371                    }
   4372                  }
   4373                }
   4374              }
   4375              else if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_5: (+1)
   \       0x84   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x88   0x2829             CMP      R0,#+41
   \       0x8A   0xD119             BNE.N    ??HAL_I2C_Slave_Seq_Receive_DMA_6
   4376              {
   4377                if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   \       0x8C   0x6828             LDR      R0,[R5, #+0]
   \       0x8E   0x6840             LDR      R0,[R0, #+4]
   \       0x90   0x0500             LSLS     R0,R0,#+20
   \       0x92   0xD515             BPL.N    ??HAL_I2C_Slave_Seq_Receive_DMA_6
   4378                {
   4379                  CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \       0x94   0x6828             LDR      R0,[R5, #+0]
   \       0x96   0x6840             LDR      R0,[R0, #+4]
   \       0x98   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x9C   0x6829             LDR      R1,[R5, #+0]
   \       0x9E   0x6048             STR      R0,[R1, #+4]
   4380          
   4381                  /* Abort DMA Xfer if any */
   4382                  if (hi2c->hdmatx != NULL)
   \       0xA0   0x6B68             LDR      R0,[R5, #+52]
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD00C             BEQ.N    ??HAL_I2C_Slave_Seq_Receive_DMA_6
   4383                  {
   4384                    /* Set the I2C DMA Abort callback :
   4385                     will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   4386                    hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
   \       0xA6   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \       0xAA   0x6B69             LDR      R1,[R5, #+52]
   \       0xAC   0x6508             STR      R0,[R1, #+80]
   4387          
   4388                    /* Abort DMA TX */
   4389                    if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
   \       0xAE   0x6B68             LDR      R0,[R5, #+52]
   \       0xB0   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD003             BEQ.N    ??HAL_I2C_Slave_Seq_Receive_DMA_6
   4390                    {
   4391                      /* Call Directly XferAbortCallback function in case of error */
   4392                      hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
   \       0xB8   0x6B68             LDR      R0,[R5, #+52]
   \       0xBA   0x6B69             LDR      R1,[R5, #+52]
   \       0xBC   0x6D09             LDR      R1,[R1, #+80]
   \       0xBE   0x4788             BLX      R1
   4393                    }
   4394                  }
   4395                }
   4396              }
   4397              else
   4398              {
   4399                /* Nothing to do */
   4400              }
   4401          
   4402              /* Check if the I2C is already enabled */
   4403              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_6: (+1)
   \       0xC0   0x6828             LDR      R0,[R5, #+0]
   \       0xC2   0x6800             LDR      R0,[R0, #+0]
   \       0xC4   0x07C0             LSLS     R0,R0,#+31
   \       0xC6   0xD405             BMI.N    ??HAL_I2C_Slave_Seq_Receive_DMA_7
   4404              {
   4405                /* Enable I2C peripheral */
   4406                __HAL_I2C_ENABLE(hi2c);
   \       0xC8   0x6828             LDR      R0,[R5, #+0]
   \       0xCA   0x6800             LDR      R0,[R0, #+0]
   \       0xCC   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xD0   0x6829             LDR      R1,[R5, #+0]
   \       0xD2   0x6008             STR      R0,[R1, #+0]
   4407              }
   4408          
   4409              /* Disable Pos */
   4410              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_7: (+1)
   \       0xD4   0x6828             LDR      R0,[R5, #+0]
   \       0xD6   0x6800             LDR      R0,[R0, #+0]
   \       0xD8   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0xDC   0x6829             LDR      R1,[R5, #+0]
   \       0xDE   0x6008             STR      R0,[R1, #+0]
   4411          
   4412              hi2c->State     = HAL_I2C_STATE_BUSY_RX_LISTEN;
   \       0xE0   0x202A             MOVS     R0,#+42
   \       0xE2   0xF885 0x003D      STRB     R0,[R5, #+61]
   4413              hi2c->Mode      = HAL_I2C_MODE_SLAVE;
   \       0xE6   0x2020             MOVS     R0,#+32
   \       0xE8   0xF885 0x003E      STRB     R0,[R5, #+62]
   4414              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \       0xEC   0x2000             MOVS     R0,#+0
   \       0xEE   0x6428             STR      R0,[R5, #+64]
   4415          
   4416              /* Prepare transfer parameters */
   4417              hi2c->pBuffPtr    = pData;
   \       0xF0   0x626C             STR      R4,[R5, #+36]
   4418              hi2c->XferCount   = Size;
   \       0xF2   0x856E             STRH     R6,[R5, #+42]
   4419              hi2c->XferSize    = hi2c->XferCount;
   \       0xF4   0x8D68             LDRH     R0,[R5, #+42]
   \       0xF6   0x8528             STRH     R0,[R5, #+40]
   4420              hi2c->XferOptions = XferOptions;
   \       0xF8   0x62EF             STR      R7,[R5, #+44]
   4421          
   4422              /* Set the I2C DMA transfer complete callback */
   4423              hi2c->hdmarx->XferCpltCallback = I2C_DMAXferCplt;
   \       0xFA   0x.... 0x....      LDR.W    R0,??DataTable28
   \       0xFE   0x6BA9             LDR      R1,[R5, #+56]
   \      0x100   0x63C8             STR      R0,[R1, #+60]
   4424          
   4425              /* Set the DMA error callback */
   4426              hi2c->hdmarx->XferErrorCallback = I2C_DMAError;
   \      0x102   0x.... 0x....      LDR.W    R0,??DataTable28_1
   \      0x106   0x6BA9             LDR      R1,[R5, #+56]
   \      0x108   0x64C8             STR      R0,[R1, #+76]
   4427          
   4428              /* Set the unused DMA callbacks to NULL */
   4429              hi2c->hdmarx->XferHalfCpltCallback = NULL;
   \      0x10A   0x2000             MOVS     R0,#+0
   \      0x10C   0x6BA9             LDR      R1,[R5, #+56]
   \      0x10E   0x6408             STR      R0,[R1, #+64]
   4430              hi2c->hdmarx->XferAbortCallback = NULL;
   \      0x110   0x2000             MOVS     R0,#+0
   \      0x112   0x6BA9             LDR      R1,[R5, #+56]
   \      0x114   0x6508             STR      R0,[R1, #+80]
   4431          
   4432              /* Enable the DMA stream */
   4433              dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmarx, (uint32_t)&hi2c->Instance->DR, (uint32_t)hi2c->pBuffPtr, hi2c->XferSize);
   \      0x116   0x8D2B             LDRH     R3,[R5, #+40]
   \      0x118   0x6A6A             LDR      R2,[R5, #+36]
   \      0x11A   0x6828             LDR      R0,[R5, #+0]
   \      0x11C   0xF110 0x0110      ADDS     R1,R0,#+16
   \      0x120   0x6BA8             LDR      R0,[R5, #+56]
   \      0x122   0x.... 0x....      BL       HAL_DMA_Start_IT
   \      0x126   0x0001             MOVS     R1,R0
   4434          
   4435              if (dmaxferstatus == HAL_OK)
   \      0x128   0x0008             MOVS     R0,R1
   \      0x12A   0xB2C0             UXTB     R0,R0
   \      0x12C   0x2800             CMP      R0,#+0
   \      0x12E   0xD11F             BNE.N    ??HAL_I2C_Slave_Seq_Receive_DMA_8
   4436              {
   4437                /* Enable Address Acknowledge */
   4438                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \      0x130   0x6828             LDR      R0,[R5, #+0]
   \      0x132   0x6800             LDR      R0,[R0, #+0]
   \      0x134   0xF450 0x6080      ORRS     R0,R0,#0x400
   \      0x138   0x682A             LDR      R2,[R5, #+0]
   \      0x13A   0x6010             STR      R0,[R2, #+0]
   4439          
   4440                /* Clear ADDR flag */
   4441                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \      0x13C   0x2000             MOVS     R0,#+0
   \      0x13E   0x9000             STR      R0,[SP, #+0]
   \      0x140   0x6828             LDR      R0,[R5, #+0]
   \      0x142   0x6940             LDR      R0,[R0, #+20]
   \      0x144   0x9000             STR      R0,[SP, #+0]
   \      0x146   0x6828             LDR      R0,[R5, #+0]
   \      0x148   0x6980             LDR      R0,[R0, #+24]
   \      0x14A   0x9000             STR      R0,[SP, #+0]
   \      0x14C   0x9800             LDR      R0,[SP, #+0]
   4442          
   4443                /* Process Unlocked */
   4444                __HAL_UNLOCK(hi2c);
   \      0x14E   0x2000             MOVS     R0,#+0
   \      0x150   0xF885 0x003C      STRB     R0,[R5, #+60]
   4445          
   4446                /* Enable DMA Request */
   4447                SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \      0x154   0x6828             LDR      R0,[R5, #+0]
   \      0x156   0x6840             LDR      R0,[R0, #+4]
   \      0x158   0xF450 0x6000      ORRS     R0,R0,#0x800
   \      0x15C   0x682A             LDR      R2,[R5, #+0]
   \      0x15E   0x6050             STR      R0,[R2, #+4]
   4448          
   4449                /* Note : The I2C interrupts must be enabled after unlocking current process
   4450                to avoid the risk of I2C interrupt handle execution before current
   4451                process unlock */
   4452                /* Enable EVT and ERR interrupt */
   4453                __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \      0x160   0x6828             LDR      R0,[R5, #+0]
   \      0x162   0x6840             LDR      R0,[R0, #+4]
   \      0x164   0xF450 0x7040      ORRS     R0,R0,#0x300
   \      0x168   0x682A             LDR      R2,[R5, #+0]
   \      0x16A   0x6050             STR      R0,[R2, #+4]
   4454          
   4455                return HAL_OK;
   \      0x16C   0x2000             MOVS     R0,#+0
   \      0x16E   0xE00F             B.N      ??HAL_I2C_Slave_Seq_Receive_DMA_3
   4456              }
   4457              else
   4458              {
   4459                /* Update I2C state */
   4460                hi2c->State     = HAL_I2C_STATE_READY;
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_8: (+1)
   \      0x170   0x2020             MOVS     R0,#+32
   \      0x172   0xF885 0x003D      STRB     R0,[R5, #+61]
   4461                hi2c->Mode      = HAL_I2C_MODE_NONE;
   \      0x176   0x2000             MOVS     R0,#+0
   \      0x178   0xF885 0x003E      STRB     R0,[R5, #+62]
   4462          
   4463                /* Update I2C error code */
   4464                hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \      0x17C   0x6C28             LDR      R0,[R5, #+64]
   \      0x17E   0xF050 0x0010      ORRS     R0,R0,#0x10
   \      0x182   0x6428             STR      R0,[R5, #+64]
   4465          
   4466                /* Process Unlocked */
   4467                __HAL_UNLOCK(hi2c);
   \      0x184   0x2000             MOVS     R0,#+0
   \      0x186   0xF885 0x003C      STRB     R0,[R5, #+60]
   4468          
   4469                return HAL_ERROR;
   \      0x18A   0x2001             MOVS     R0,#+1
   \      0x18C   0xE000             B.N      ??HAL_I2C_Slave_Seq_Receive_DMA_3
   4470              }
   4471            }
   4472            else
   4473            {
   4474              return HAL_BUSY;
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_0: (+1)
   \      0x18E   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_Slave_Seq_Receive_DMA_3: (+1)
   \      0x190   0xBDF2             POP      {R1,R4-R7,PC}
   4475            }
   4476          }
   4477          
   4478          /**
   4479            * @brief  Enable the Address listen mode with Interrupt.
   4480            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4481            *                the configuration information for the specified I2C.
   4482            * @retval HAL status
   4483            */

   \                                 In section .text, align 2, keep-with-next
   4484          HAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)
   4485          {
   \                     HAL_I2C_EnableListen_IT: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   4486            if (hi2c->State == HAL_I2C_STATE_READY)
   \        0x2   0xF891 0x003D      LDRB     R0,[R1, #+61]
   \        0x6   0x2820             CMP      R0,#+32
   \        0x8   0xD11A             BNE.N    ??HAL_I2C_EnableListen_IT_0
   4487            {
   4488              hi2c->State = HAL_I2C_STATE_LISTEN;
   \        0xA   0x2028             MOVS     R0,#+40
   \        0xC   0xF881 0x003D      STRB     R0,[R1, #+61]
   4489          
   4490              /* Check if the I2C is already enabled */
   4491              if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
   \       0x10   0x6808             LDR      R0,[R1, #+0]
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x07C0             LSLS     R0,R0,#+31
   \       0x16   0xD405             BMI.N    ??HAL_I2C_EnableListen_IT_1
   4492              {
   4493                /* Enable I2C peripheral */
   4494                __HAL_I2C_ENABLE(hi2c);
   \       0x18   0x6808             LDR      R0,[R1, #+0]
   \       0x1A   0x6800             LDR      R0,[R0, #+0]
   \       0x1C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x20   0x680A             LDR      R2,[R1, #+0]
   \       0x22   0x6010             STR      R0,[R2, #+0]
   4495              }
   4496          
   4497              /* Enable Address Acknowledge */
   4498              SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??HAL_I2C_EnableListen_IT_1: (+1)
   \       0x24   0x6808             LDR      R0,[R1, #+0]
   \       0x26   0x6800             LDR      R0,[R0, #+0]
   \       0x28   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0x2C   0x680A             LDR      R2,[R1, #+0]
   \       0x2E   0x6010             STR      R0,[R2, #+0]
   4499          
   4500              /* Enable EVT and ERR interrupt */
   4501              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \       0x30   0x6808             LDR      R0,[R1, #+0]
   \       0x32   0x6840             LDR      R0,[R0, #+4]
   \       0x34   0xF450 0x7040      ORRS     R0,R0,#0x300
   \       0x38   0x680A             LDR      R2,[R1, #+0]
   \       0x3A   0x6050             STR      R0,[R2, #+4]
   4502          
   4503              return HAL_OK;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xE000             B.N      ??HAL_I2C_EnableListen_IT_2
   4504            }
   4505            else
   4506            {
   4507              return HAL_BUSY;
   \                     ??HAL_I2C_EnableListen_IT_0: (+1)
   \       0x40   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_EnableListen_IT_2: (+1)
   \       0x42   0x4770             BX       LR
   4508            }
   4509          }
   4510          
   4511          /**
   4512            * @brief  Disable the Address listen mode with Interrupt.
   4513            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4514            *                the configuration information for the specified I2C.
   4515            * @retval HAL status
   4516            */

   \                                 In section .text, align 2, keep-with-next
   4517          HAL_StatusTypeDef HAL_I2C_DisableListen_IT(I2C_HandleTypeDef *hi2c)
   4518          {
   \                     HAL_I2C_DisableListen_IT: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   4519            /* Declaration of tmp to prevent undefined behavior of volatile usage */
   4520            uint32_t tmp;
   4521          
   4522            /* Disable Address listen mode only if a transfer is not ongoing */
   4523            if (hi2c->State == HAL_I2C_STATE_LISTEN)
   \        0x2   0xF891 0x003D      LDRB     R0,[R1, #+61]
   \        0x6   0x2828             CMP      R0,#+40
   \        0x8   0xD11B             BNE.N    ??HAL_I2C_DisableListen_IT_0
   4524            {
   4525              tmp = (uint32_t)(hi2c->State) & I2C_STATE_MSK;
   \        0xA   0xF891 0x203D      LDRB     R2,[R1, #+61]
   \        0xE   0xF012 0x0203      ANDS     R2,R2,#0x3
   4526              hi2c->PreviousState = tmp | (uint32_t)(hi2c->Mode);
   \       0x12   0xF891 0x003E      LDRB     R0,[R1, #+62]
   \       0x16   0x4310             ORRS     R0,R0,R2
   \       0x18   0x6308             STR      R0,[R1, #+48]
   4527              hi2c->State = HAL_I2C_STATE_READY;
   \       0x1A   0x2020             MOVS     R0,#+32
   \       0x1C   0xF881 0x003D      STRB     R0,[R1, #+61]
   4528              hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xF881 0x003E      STRB     R0,[R1, #+62]
   4529          
   4530              /* Disable Address Acknowledge */
   4531              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x26   0x6808             LDR      R0,[R1, #+0]
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x2E   0x680B             LDR      R3,[R1, #+0]
   \       0x30   0x6018             STR      R0,[R3, #+0]
   4532          
   4533              /* Disable EVT and ERR interrupt */
   4534              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \       0x32   0x6808             LDR      R0,[R1, #+0]
   \       0x34   0x6840             LDR      R0,[R0, #+4]
   \       0x36   0xF430 0x7040      BICS     R0,R0,#0x300
   \       0x3A   0x680B             LDR      R3,[R1, #+0]
   \       0x3C   0x6058             STR      R0,[R3, #+4]
   4535          
   4536              return HAL_OK;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xE000             B.N      ??HAL_I2C_DisableListen_IT_1
   4537            }
   4538            else
   4539            {
   4540              return HAL_BUSY;
   \                     ??HAL_I2C_DisableListen_IT_0: (+1)
   \       0x42   0x2002             MOVS     R0,#+2
   \                     ??HAL_I2C_DisableListen_IT_1: (+1)
   \       0x44   0x4770             BX       LR
   4541            }
   4542          }
   4543          
   4544          /**
   4545            * @brief  Abort a master I2C IT or DMA process communication with Interrupt.
   4546            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4547            *         the configuration information for the specified I2C.
   4548            * @param  DevAddress Target device address: The device 7 bits address value
   4549            *         in datasheet must be shifted to the left before calling the interface
   4550            * @retval HAL status
   4551            */

   \                                 In section .text, align 2, keep-with-next
   4552          HAL_StatusTypeDef HAL_I2C_Master_Abort_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress)
   4553          {
   \                     HAL_I2C_Master_Abort_IT: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   4554            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   4555            HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
   \        0x6   0xF894 0x603E      LDRB     R6,[R4, #+62]
   4556          
   4557            /* Prevent unused argument(s) compilation warning */
   4558            UNUSED(DevAddress);
   4559          
   4560            /* Abort Master transfer during Receive or Transmit process    */
   4561            if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && (CurrentMode == HAL_I2C_MODE_MASTER))
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6980             LDR      R0,[R0, #+24]
   \        0xE   0x0780             LSLS     R0,R0,#+30
   \       0x10   0xD52D             BPL.N    ??HAL_I2C_Master_Abort_IT_0
   \       0x12   0x0030             MOVS     R0,R6
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x2810             CMP      R0,#+16
   \       0x18   0xD129             BNE.N    ??HAL_I2C_Master_Abort_IT_0
   4562            {
   4563              /* Process Locked */
   4564              __HAL_LOCK(hi2c);
   \       0x1A   0xF894 0x003C      LDRB     R0,[R4, #+60]
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xD101             BNE.N    ??HAL_I2C_Master_Abort_IT_1
   \       0x22   0x2002             MOVS     R0,#+2
   \       0x24   0xE024             B.N      ??HAL_I2C_Master_Abort_IT_2
   \                     ??HAL_I2C_Master_Abort_IT_1: (+1)
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xF884 0x003C      STRB     R0,[R4, #+60]
   4565          
   4566              hi2c->PreviousState = I2C_STATE_NONE;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x6320             STR      R0,[R4, #+48]
   4567              hi2c->State = HAL_I2C_STATE_ABORT;
   \       0x30   0x2060             MOVS     R0,#+96
   \       0x32   0xF884 0x003D      STRB     R0,[R4, #+61]
   4568          
   4569              /* Disable Acknowledge */
   4570              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x3E   0x6821             LDR      R1,[R4, #+0]
   \       0x40   0x6008             STR      R0,[R1, #+0]
   4571          
   4572              /* Generate Stop */
   4573              SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x6800             LDR      R0,[R0, #+0]
   \       0x46   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0x4A   0x6821             LDR      R1,[R4, #+0]
   \       0x4C   0x6008             STR      R0,[R1, #+0]
   4574          
   4575              hi2c->XferCount = 0U;
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0x8560             STRH     R0,[R4, #+42]
   4576          
   4577              /* Disable EVT, BUF and ERR interrupt */
   4578              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x6840             LDR      R0,[R0, #+4]
   \       0x56   0xF430 0x60E0      BICS     R0,R0,#0x700
   \       0x5A   0x6821             LDR      R1,[R4, #+0]
   \       0x5C   0x6048             STR      R0,[R1, #+4]
   4579          
   4580              /* Process Unlocked */
   4581              __HAL_UNLOCK(hi2c);
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0xF884 0x003C      STRB     R0,[R4, #+60]
   4582          
   4583              /* Call the corresponding callback to inform upper layer of End of Transfer */
   4584              I2C_ITError(hi2c);
   \       0x64   0x0020             MOVS     R0,R4
   \       0x66   0x.... 0x....      BL       I2C_ITError
   4585          
   4586              return HAL_OK;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0xE000             B.N      ??HAL_I2C_Master_Abort_IT_2
   4587            }
   4588            else
   4589            {
   4590              /* Wrong usage of abort function */
   4591              /* This function should be used only in case of abort monitored by master device */
   4592              /* Or periphal is not in busy state, mean there is no active sequence to be abort */
   4593              return HAL_ERROR;
   \                     ??HAL_I2C_Master_Abort_IT_0: (+1)
   \       0x6E   0x2001             MOVS     R0,#+1
   \                     ??HAL_I2C_Master_Abort_IT_2: (+1)
   \       0x70   0xBD70             POP      {R4-R6,PC}
   4594            }
   4595          }
   4596          
   4597          /**
   4598            * @}
   4599            */
   4600          
   4601          /** @defgroup I2C_IRQ_Handler_and_Callbacks IRQ Handler and Callbacks
   4602           * @{
   4603           */
   4604          
   4605          /**
   4606            * @brief  This function handles I2C event interrupt request.
   4607            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4608            *                the configuration information for the specified I2C.
   4609            * @retval None
   4610            */

   \                                 In section .text, align 2, keep-with-next
   4611          void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
   4612          {
   \                     HAL_I2C_EV_IRQHandler: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   4613            uint32_t sr1itflags;
   4614            uint32_t sr2itflags               = 0U;
   \        0x6   0x2500             MOVS     R5,#+0
   4615            uint32_t itsources                = READ_REG(hi2c->Instance->CR2);
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x6846             LDR      R6,[R0, #+4]
   4616            uint32_t CurrentXferOptions       = hi2c->XferOptions;
   \        0xC   0x6AE7             LDR      R7,[R4, #+44]
   4617            HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
   \        0xE   0xF894 0x803E      LDRB     R8,[R4, #+62]
   4618            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   \       0x12   0xF894 0x903D      LDRB     R9,[R4, #+61]
   4619          
   4620            /* Master or Memory mode selected */
   4621            if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
   \       0x16   0x4640             MOV      R0,R8
   \       0x18   0xB2C0             UXTB     R0,R0
   \       0x1A   0x2810             CMP      R0,#+16
   \       0x1C   0xD003             BEQ.N    ??HAL_I2C_EV_IRQHandler_0
   \       0x1E   0x4640             MOV      R0,R8
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2840             CMP      R0,#+64
   \       0x24   0xD172             BNE.N    ??HAL_I2C_EV_IRQHandler_1
   4622            {
   4623              sr2itflags   = READ_REG(hi2c->Instance->SR2);
   \                     ??HAL_I2C_EV_IRQHandler_0: (+1)
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6980             LDR      R0,[R0, #+24]
   \       0x2A   0x0005             MOVS     R5,R0
   4624              sr1itflags   = READ_REG(hi2c->Instance->SR1);
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0xF8D0 0xA014      LDR      R10,[R0, #+20]
   4625          
   4626              /* Exit IRQ event until Start Bit detected in case of Other frame requested */
   4627              if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) == RESET) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(CurrentXferOptions) == 1U))
   \       0x32   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \       0x36   0xD40C             BMI.N    ??HAL_I2C_EV_IRQHandler_2
   \       0x38   0xF5B7 0x0F2A      CMP      R7,#+11141120
   \       0x3C   0xD002             BEQ.N    ??HAL_I2C_EV_IRQHandler_3
   \       0x3E   0xF1B7 0x4F2A      CMP      R7,#+2852126720
   \       0x42   0xD101             BNE.N    ??HAL_I2C_EV_IRQHandler_4
   \                     ??HAL_I2C_EV_IRQHandler_3: (+1)
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xE000             B.N      ??HAL_I2C_EV_IRQHandler_5
   \                     ??HAL_I2C_EV_IRQHandler_4: (+1)
   \       0x48   0x2000             MOVS     R0,#+0
   \                     ??HAL_I2C_EV_IRQHandler_5: (+1)
   \       0x4A   0xB2C0             UXTB     R0,R0
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xF040 0x80B4      BNE.W    ??HAL_I2C_EV_IRQHandler_6
   4628              {
   4629                return;
   4630              }
   4631          
   4632              /* SB Set ----------------------------------------------------------------*/
   4633              if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_2: (+1)
   \       0x52   0xF01A 0x0001      ANDS     R0,R10,#0x1
   \       0x56   0xB2C0             UXTB     R0,R0
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD008             BEQ.N    ??HAL_I2C_EV_IRQHandler_7
   \       0x5C   0x05B0             LSLS     R0,R6,#+22
   \       0x5E   0xD506             BPL.N    ??HAL_I2C_EV_IRQHandler_7
   4634              {
   4635                /* Convert OTHER_xxx XferOptions if any */
   4636                I2C_ConvertOtherXferOptions(hi2c);
   \       0x60   0x0020             MOVS     R0,R4
   \       0x62   0x.... 0x....      BL       I2C_ConvertOtherXferOptions
   4637          
   4638                I2C_Master_SB(hi2c);
   \       0x66   0x0020             MOVS     R0,R4
   \       0x68   0x.... 0x....      BL       I2C_Master_SB
   \       0x6C   0xE0A5             B.N      ??HAL_I2C_EV_IRQHandler_8
   4639              }
   4640              /* ADD10 Set -------------------------------------------------------------*/
   4641              else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADD10) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_7: (+1)
   \       0x6E   0xEA5F 0x700A      LSLS     R0,R10,#+28
   \       0x72   0xD505             BPL.N    ??HAL_I2C_EV_IRQHandler_9
   \       0x74   0x05B0             LSLS     R0,R6,#+22
   \       0x76   0xD503             BPL.N    ??HAL_I2C_EV_IRQHandler_9
   4642              {
   4643                I2C_Master_ADD10(hi2c);
   \       0x78   0x0020             MOVS     R0,R4
   \       0x7A   0x.... 0x....      BL       I2C_Master_ADD10
   \       0x7E   0xE09C             B.N      ??HAL_I2C_EV_IRQHandler_8
   4644              }
   4645              /* ADDR Set --------------------------------------------------------------*/
   4646              else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_9: (+1)
   \       0x80   0xEA5F 0x708A      LSLS     R0,R10,#+30
   \       0x84   0xD505             BPL.N    ??HAL_I2C_EV_IRQHandler_10
   \       0x86   0x05B0             LSLS     R0,R6,#+22
   \       0x88   0xD503             BPL.N    ??HAL_I2C_EV_IRQHandler_10
   4647              {
   4648                I2C_Master_ADDR(hi2c);
   \       0x8A   0x0020             MOVS     R0,R4
   \       0x8C   0x.... 0x....      BL       I2C_Master_ADDR
   \       0x90   0xE093             B.N      ??HAL_I2C_EV_IRQHandler_8
   4649              }
   4650              /* I2C in mode Transmitter -----------------------------------------------*/
   4651              else if (I2C_CHECK_FLAG(sr2itflags, I2C_FLAG_TRA) != RESET)
   \                     ??HAL_I2C_EV_IRQHandler_10: (+1)
   \       0x92   0x0768             LSLS     R0,R5,#+29
   \       0x94   0xD521             BPL.N    ??HAL_I2C_EV_IRQHandler_11
   4652              {
   4653                /* Do not check buffer and BTF flag if a Xfer DMA is on going */
   4654                if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
   \       0x96   0x6820             LDR      R0,[R4, #+0]
   \       0x98   0x6840             LDR      R0,[R0, #+4]
   \       0x9A   0x0500             LSLS     R0,R0,#+20
   \       0x9C   0xF100 0x808D      BMI.W    ??HAL_I2C_EV_IRQHandler_8
   4655                {
   4656                  /* TXE set and BTF reset -----------------------------------------------*/
   4657                  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
   \       0xA0   0xEA5F 0x600A      LSLS     R0,R10,#+24
   \       0xA4   0xD508             BPL.N    ??HAL_I2C_EV_IRQHandler_12
   \       0xA6   0x0570             LSLS     R0,R6,#+21
   \       0xA8   0xD506             BPL.N    ??HAL_I2C_EV_IRQHandler_12
   \       0xAA   0xEA5F 0x704A      LSLS     R0,R10,#+29
   \       0xAE   0xD403             BMI.N    ??HAL_I2C_EV_IRQHandler_12
   4658                  {
   4659                    I2C_MasterTransmit_TXE(hi2c);
   \       0xB0   0x0020             MOVS     R0,R4
   \       0xB2   0x.... 0x....      BL       I2C_MasterTransmit_TXE
   \       0xB6   0xE080             B.N      ??HAL_I2C_EV_IRQHandler_8
   4660                  }
   4661                  /* BTF set -------------------------------------------------------------*/
   4662                  else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_12: (+1)
   \       0xB8   0xEA5F 0x704A      LSLS     R0,R10,#+29
   \       0xBC   0xD57D             BPL.N    ??HAL_I2C_EV_IRQHandler_8
   \       0xBE   0x05B0             LSLS     R0,R6,#+22
   \       0xC0   0xD57B             BPL.N    ??HAL_I2C_EV_IRQHandler_8
   4663                  {
   4664                    if (CurrentMode == HAL_I2C_MODE_MASTER)
   \       0xC2   0x4640             MOV      R0,R8
   \       0xC4   0xB2C0             UXTB     R0,R0
   \       0xC6   0x2810             CMP      R0,#+16
   \       0xC8   0xD103             BNE.N    ??HAL_I2C_EV_IRQHandler_13
   4665                    {
   4666                      I2C_MasterTransmit_BTF(hi2c);
   \       0xCA   0x0020             MOVS     R0,R4
   \       0xCC   0x.... 0x....      BL       I2C_MasterTransmit_BTF
   \       0xD0   0xE073             B.N      ??HAL_I2C_EV_IRQHandler_8
   4667                    }
   4668                    else /* HAL_I2C_MODE_MEM */
   4669                    {
   4670                      I2C_MemoryTransmit_TXE_BTF(hi2c);
   \                     ??HAL_I2C_EV_IRQHandler_13: (+1)
   \       0xD2   0x0020             MOVS     R0,R4
   \       0xD4   0x.... 0x....      BL       I2C_MemoryTransmit_TXE_BTF
   \       0xD8   0xE06F             B.N      ??HAL_I2C_EV_IRQHandler_8
   4671                    }
   4672                  }
   4673                  else
   4674                  {
   4675                    /* Do nothing */
   4676                  }
   4677                }
   4678              }
   4679              /* I2C in mode Receiver --------------------------------------------------*/
   4680              else
   4681              {
   4682                /* Do not check buffer and BTF flag if a Xfer DMA is on going */
   4683                if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
   \                     ??HAL_I2C_EV_IRQHandler_11: (+1)
   \       0xDA   0x6820             LDR      R0,[R4, #+0]
   \       0xDC   0x6840             LDR      R0,[R0, #+4]
   \       0xDE   0x0500             LSLS     R0,R0,#+20
   \       0xE0   0xD46B             BMI.N    ??HAL_I2C_EV_IRQHandler_8
   4684                {
   4685                  /* RXNE set and BTF reset -----------------------------------------------*/
   4686                  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
   \       0xE2   0xEA5F 0x604A      LSLS     R0,R10,#+25
   \       0xE6   0xD508             BPL.N    ??HAL_I2C_EV_IRQHandler_14
   \       0xE8   0x0570             LSLS     R0,R6,#+21
   \       0xEA   0xD506             BPL.N    ??HAL_I2C_EV_IRQHandler_14
   \       0xEC   0xEA5F 0x704A      LSLS     R0,R10,#+29
   \       0xF0   0xD403             BMI.N    ??HAL_I2C_EV_IRQHandler_14
   4687                  {
   4688                    I2C_MasterReceive_RXNE(hi2c);
   \       0xF2   0x0020             MOVS     R0,R4
   \       0xF4   0x.... 0x....      BL       I2C_MasterReceive_RXNE
   \       0xF8   0xE05F             B.N      ??HAL_I2C_EV_IRQHandler_8
   4689                  }
   4690                  /* BTF set -------------------------------------------------------------*/
   4691                  else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_14: (+1)
   \       0xFA   0xEA5F 0x704A      LSLS     R0,R10,#+29
   \       0xFE   0xD55C             BPL.N    ??HAL_I2C_EV_IRQHandler_8
   \      0x100   0x05B0             LSLS     R0,R6,#+22
   \      0x102   0xD55A             BPL.N    ??HAL_I2C_EV_IRQHandler_8
   4692                  {
   4693                    I2C_MasterReceive_BTF(hi2c);
   \      0x104   0x0020             MOVS     R0,R4
   \      0x106   0x.... 0x....      BL       I2C_MasterReceive_BTF
   \      0x10A   0xE056             B.N      ??HAL_I2C_EV_IRQHandler_8
   4694                  }
   4695                  else
   4696                  {
   4697                    /* Do nothing */
   4698                  }
   4699                }
   4700              }
   4701            }
   4702            /* Slave mode selected */
   4703            else
   4704            {
   4705              /* If an error is detected, read only SR1 register to prevent */
   4706              /* a clear of ADDR flags by reading SR2 after reading SR1 in Error treatment */
   4707              if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \                     ??HAL_I2C_EV_IRQHandler_1: (+1)
   \      0x10C   0x6C20             LDR      R0,[R4, #+64]
   \      0x10E   0x2800             CMP      R0,#+0
   \      0x110   0xD003             BEQ.N    ??HAL_I2C_EV_IRQHandler_15
   4708              {
   4709                sr1itflags   = READ_REG(hi2c->Instance->SR1);
   \      0x112   0x6820             LDR      R0,[R4, #+0]
   \      0x114   0xF8D0 0xA014      LDR      R10,[R0, #+20]
   \      0x118   0xE005             B.N      ??HAL_I2C_EV_IRQHandler_16
   4710              }
   4711              else
   4712              {
   4713                sr2itflags   = READ_REG(hi2c->Instance->SR2);
   \                     ??HAL_I2C_EV_IRQHandler_15: (+1)
   \      0x11A   0x6820             LDR      R0,[R4, #+0]
   \      0x11C   0x6980             LDR      R0,[R0, #+24]
   \      0x11E   0x0005             MOVS     R5,R0
   4714                sr1itflags   = READ_REG(hi2c->Instance->SR1);
   \      0x120   0x6820             LDR      R0,[R4, #+0]
   \      0x122   0xF8D0 0xA014      LDR      R10,[R0, #+20]
   4715              }
   4716          
   4717              /* ADDR set --------------------------------------------------------------*/
   4718              if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_16: (+1)
   \      0x126   0xEA5F 0x708A      LSLS     R0,R10,#+30
   \      0x12A   0xD50C             BPL.N    ??HAL_I2C_EV_IRQHandler_17
   \      0x12C   0x05B0             LSLS     R0,R6,#+22
   \      0x12E   0xD50A             BPL.N    ??HAL_I2C_EV_IRQHandler_17
   4719              {
   4720                /* Now time to read SR2, this will clear ADDR flag automatically */
   4721                if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \      0x130   0x6C20             LDR      R0,[R4, #+64]
   \      0x132   0x2800             CMP      R0,#+0
   \      0x134   0xD002             BEQ.N    ??HAL_I2C_EV_IRQHandler_18
   4722                {
   4723                  sr2itflags   = READ_REG(hi2c->Instance->SR2);
   \      0x136   0x6820             LDR      R0,[R4, #+0]
   \      0x138   0x6980             LDR      R0,[R0, #+24]
   \      0x13A   0x0005             MOVS     R5,R0
   4724                }
   4725                I2C_Slave_ADDR(hi2c, sr2itflags);
   \                     ??HAL_I2C_EV_IRQHandler_18: (+1)
   \      0x13C   0x0029             MOVS     R1,R5
   \      0x13E   0x0020             MOVS     R0,R4
   \      0x140   0x.... 0x....      BL       I2C_Slave_ADDR
   \      0x144   0xE039             B.N      ??HAL_I2C_EV_IRQHandler_8
   4726              }
   4727              /* STOPF set --------------------------------------------------------------*/
   4728              else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_17: (+1)
   \      0x146   0xEA5F 0x60CA      LSLS     R0,R10,#+27
   \      0x14A   0xD505             BPL.N    ??HAL_I2C_EV_IRQHandler_19
   \      0x14C   0x05B0             LSLS     R0,R6,#+22
   \      0x14E   0xD503             BPL.N    ??HAL_I2C_EV_IRQHandler_19
   4729              {
   4730                I2C_Slave_STOPF(hi2c);
   \      0x150   0x0020             MOVS     R0,R4
   \      0x152   0x.... 0x....      BL       I2C_Slave_STOPF
   \      0x156   0xE030             B.N      ??HAL_I2C_EV_IRQHandler_8
   4731              }
   4732              /* I2C in mode Transmitter -----------------------------------------------*/
   4733              else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
   \                     ??HAL_I2C_EV_IRQHandler_19: (+1)
   \      0x158   0x4648             MOV      R0,R9
   \      0x15A   0xB2C0             UXTB     R0,R0
   \      0x15C   0x2821             CMP      R0,#+33
   \      0x15E   0xD003             BEQ.N    ??HAL_I2C_EV_IRQHandler_20
   \      0x160   0x4648             MOV      R0,R9
   \      0x162   0xB2C0             UXTB     R0,R0
   \      0x164   0x2829             CMP      R0,#+41
   \      0x166   0xD114             BNE.N    ??HAL_I2C_EV_IRQHandler_21
   4734              {
   4735                /* TXE set and BTF reset -----------------------------------------------*/
   4736                if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
   \                     ??HAL_I2C_EV_IRQHandler_20: (+1)
   \      0x168   0xEA5F 0x600A      LSLS     R0,R10,#+24
   \      0x16C   0xD508             BPL.N    ??HAL_I2C_EV_IRQHandler_22
   \      0x16E   0x0570             LSLS     R0,R6,#+21
   \      0x170   0xD506             BPL.N    ??HAL_I2C_EV_IRQHandler_22
   \      0x172   0xEA5F 0x704A      LSLS     R0,R10,#+29
   \      0x176   0xD403             BMI.N    ??HAL_I2C_EV_IRQHandler_22
   4737                {
   4738                  I2C_SlaveTransmit_TXE(hi2c);
   \      0x178   0x0020             MOVS     R0,R4
   \      0x17A   0x.... 0x....      BL       I2C_SlaveTransmit_TXE
   \      0x17E   0xE01C             B.N      ??HAL_I2C_EV_IRQHandler_8
   4739                }
   4740                /* BTF set -------------------------------------------------------------*/
   4741                else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_22: (+1)
   \      0x180   0xEA5F 0x704A      LSLS     R0,R10,#+29
   \      0x184   0xD519             BPL.N    ??HAL_I2C_EV_IRQHandler_8
   \      0x186   0x05B0             LSLS     R0,R6,#+22
   \      0x188   0xD517             BPL.N    ??HAL_I2C_EV_IRQHandler_8
   4742                {
   4743                  I2C_SlaveTransmit_BTF(hi2c);
   \      0x18A   0x0020             MOVS     R0,R4
   \      0x18C   0x.... 0x....      BL       I2C_SlaveTransmit_BTF
   \      0x190   0xE013             B.N      ??HAL_I2C_EV_IRQHandler_8
   4744                }
   4745                else
   4746                {
   4747                  /* Do nothing */
   4748                }
   4749              }
   4750              /* I2C in mode Receiver --------------------------------------------------*/
   4751              else
   4752              {
   4753                /* RXNE set and BTF reset ----------------------------------------------*/
   4754                if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
   \                     ??HAL_I2C_EV_IRQHandler_21: (+1)
   \      0x192   0xEA5F 0x604A      LSLS     R0,R10,#+25
   \      0x196   0xD508             BPL.N    ??HAL_I2C_EV_IRQHandler_23
   \      0x198   0x0570             LSLS     R0,R6,#+21
   \      0x19A   0xD506             BPL.N    ??HAL_I2C_EV_IRQHandler_23
   \      0x19C   0xEA5F 0x704A      LSLS     R0,R10,#+29
   \      0x1A0   0xD403             BMI.N    ??HAL_I2C_EV_IRQHandler_23
   4755                {
   4756                  I2C_SlaveReceive_RXNE(hi2c);
   \      0x1A2   0x0020             MOVS     R0,R4
   \      0x1A4   0x.... 0x....      BL       I2C_SlaveReceive_RXNE
   \      0x1A8   0xE007             B.N      ??HAL_I2C_EV_IRQHandler_8
   4757                }
   4758                /* BTF set -------------------------------------------------------------*/
   4759                else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
   \                     ??HAL_I2C_EV_IRQHandler_23: (+1)
   \      0x1AA   0xEA5F 0x704A      LSLS     R0,R10,#+29
   \      0x1AE   0xD504             BPL.N    ??HAL_I2C_EV_IRQHandler_8
   \      0x1B0   0x05B0             LSLS     R0,R6,#+22
   \      0x1B2   0xD502             BPL.N    ??HAL_I2C_EV_IRQHandler_8
   4760                {
   4761                  I2C_SlaveReceive_BTF(hi2c);
   \      0x1B4   0x0020             MOVS     R0,R4
   \      0x1B6   0x.... 0x....      BL       I2C_SlaveReceive_BTF
   4762                }
   4763                else
   4764                {
   4765                  /* Do nothing */
   4766                }
   4767              }
   4768            }
   4769          }
   \                     ??HAL_I2C_EV_IRQHandler_8: (+1)
   \                     ??HAL_I2C_EV_IRQHandler_6: (+1)
   \      0x1BA   0xE8BD 0x87F0      POP      {R4-R10,PC}
   4770          
   4771          /**
   4772            * @brief  This function handles I2C error interrupt request.
   4773            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4774            *                the configuration information for the specified I2C.
   4775            * @retval None
   4776            */

   \                                 In section .text, align 2, keep-with-next
   4777          void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
   4778          {
   \                     HAL_I2C_ER_IRQHandler: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x0006             MOVS     R6,R0
   4779            HAL_I2C_ModeTypeDef tmp1;
   4780            uint32_t tmp2;
   4781            HAL_I2C_StateTypeDef tmp3;
   4782            uint32_t tmp4;
   4783            uint32_t sr1itflags = READ_REG(hi2c->Instance->SR1);
   \        0x6   0x6830             LDR      R0,[R6, #+0]
   \        0x8   0xF8D0 0x9014      LDR      R9,[R0, #+20]
   4784            uint32_t itsources  = READ_REG(hi2c->Instance->CR2);
   \        0xC   0x6830             LDR      R0,[R6, #+0]
   \        0xE   0xF8D0 0xA004      LDR      R10,[R0, #+4]
   4785            uint32_t error      = HAL_I2C_ERROR_NONE;
   \       0x12   0x2500             MOVS     R5,#+0
   4786            HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
   \       0x14   0xF896 0xB03E      LDRB     R11,[R6, #+62]
   4787          
   4788            /* I2C Bus error interrupt occurred ----------------------------------------*/
   4789            if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
   \       0x18   0xEA5F 0x50C9      LSLS     R0,R9,#+23
   \       0x1C   0xD508             BPL.N    ??HAL_I2C_ER_IRQHandler_0
   \       0x1E   0xEA5F 0x50CA      LSLS     R0,R10,#+23
   \       0x22   0xD505             BPL.N    ??HAL_I2C_ER_IRQHandler_0
   4790            {
   4791              error |= HAL_I2C_ERROR_BERR;
   \       0x24   0xF055 0x0501      ORRS     R5,R5,#0x1
   4792          
   4793              /* Clear BERR flag */
   4794              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
   \       0x28   0xF47F 0x7080      MVNS     R0,#+256
   \       0x2C   0x6831             LDR      R1,[R6, #+0]
   \       0x2E   0x6148             STR      R0,[R1, #+20]
   4795            }
   4796          
   4797            /* I2C Arbitration Lost error interrupt occurred ---------------------------*/
   4798            if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
   \                     ??HAL_I2C_ER_IRQHandler_0: (+1)
   \       0x30   0xEA5F 0x5089      LSLS     R0,R9,#+22
   \       0x34   0xD508             BPL.N    ??HAL_I2C_ER_IRQHandler_1
   \       0x36   0xEA5F 0x50CA      LSLS     R0,R10,#+23
   \       0x3A   0xD505             BPL.N    ??HAL_I2C_ER_IRQHandler_1
   4799            {
   4800              error |= HAL_I2C_ERROR_ARLO;
   \       0x3C   0xF055 0x0502      ORRS     R5,R5,#0x2
   4801          
   4802              /* Clear ARLO flag */
   4803              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
   \       0x40   0xF47F 0x7000      MVNS     R0,#+512
   \       0x44   0x6831             LDR      R1,[R6, #+0]
   \       0x46   0x6148             STR      R0,[R1, #+20]
   4804            }
   4805          
   4806            /* I2C Acknowledge failure error interrupt occurred ------------------------*/
   4807            if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
   \                     ??HAL_I2C_ER_IRQHandler_1: (+1)
   \       0x48   0xEA5F 0x5049      LSLS     R0,R9,#+21
   \       0x4C   0xD538             BPL.N    ??HAL_I2C_ER_IRQHandler_2
   \       0x4E   0xEA5F 0x50CA      LSLS     R0,R10,#+23
   \       0x52   0xD535             BPL.N    ??HAL_I2C_ER_IRQHandler_2
   4808            {
   4809              tmp1 = CurrentMode;
   \       0x54   0xF88D 0xB000      STRB     R11,[SP, #+0]
   4810              tmp2 = hi2c->XferCount;
   \       0x58   0x8D70             LDRH     R0,[R6, #+42]
   \       0x5A   0x0004             MOVS     R4,R0
   4811              tmp3 = hi2c->State;
   \       0x5C   0xF896 0x003D      LDRB     R0,[R6, #+61]
   \       0x60   0x0007             MOVS     R7,R0
   4812              tmp4 = hi2c->PreviousState;
   \       0x62   0x6B30             LDR      R0,[R6, #+48]
   \       0x64   0x4680             MOV      R8,R0
   4813              if ((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
   4814                  ((tmp3 == HAL_I2C_STATE_BUSY_TX) || (tmp3 == HAL_I2C_STATE_BUSY_TX_LISTEN) || \
   4815                   ((tmp3 == HAL_I2C_STATE_LISTEN) && (tmp4 == I2C_STATE_SLAVE_BUSY_TX))))
   \       0x66   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x6A   0x2820             CMP      R0,#+32
   \       0x6C   0xD114             BNE.N    ??HAL_I2C_ER_IRQHandler_3
   \       0x6E   0x2C00             CMP      R4,#+0
   \       0x70   0xD112             BNE.N    ??HAL_I2C_ER_IRQHandler_3
   \       0x72   0x0038             MOVS     R0,R7
   \       0x74   0xB2C0             UXTB     R0,R0
   \       0x76   0x2821             CMP      R0,#+33
   \       0x78   0xD00A             BEQ.N    ??HAL_I2C_ER_IRQHandler_4
   \       0x7A   0x0038             MOVS     R0,R7
   \       0x7C   0xB2C0             UXTB     R0,R0
   \       0x7E   0x2829             CMP      R0,#+41
   \       0x80   0xD006             BEQ.N    ??HAL_I2C_ER_IRQHandler_4
   \       0x82   0x0038             MOVS     R0,R7
   \       0x84   0xB2C0             UXTB     R0,R0
   \       0x86   0x2828             CMP      R0,#+40
   \       0x88   0xD106             BNE.N    ??HAL_I2C_ER_IRQHandler_3
   \       0x8A   0xF1B8 0x0F21      CMP      R8,#+33
   \       0x8E   0xD103             BNE.N    ??HAL_I2C_ER_IRQHandler_3
   4816              {
   4817                I2C_Slave_AF(hi2c);
   \                     ??HAL_I2C_ER_IRQHandler_4: (+1)
   \       0x90   0x0030             MOVS     R0,R6
   \       0x92   0x.... 0x....      BL       I2C_Slave_AF
   \       0x96   0xE013             B.N      ??HAL_I2C_ER_IRQHandler_2
   4818              }
   4819              else
   4820              {
   4821                /* Clear AF flag */
   4822                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??HAL_I2C_ER_IRQHandler_3: (+1)
   \       0x98   0xF47F 0x6080      MVNS     R0,#+1024
   \       0x9C   0x6831             LDR      R1,[R6, #+0]
   \       0x9E   0x6148             STR      R0,[R1, #+20]
   4823          
   4824                error |= HAL_I2C_ERROR_AF;
   \       0xA0   0xF055 0x0504      ORRS     R5,R5,#0x4
   4825          
   4826                /* Do not generate a STOP in case of Slave receive non acknowledge during transfer (mean not at the end of transfer) */
   4827                if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
   \       0xA4   0x4658             MOV      R0,R11
   \       0xA6   0xB2C0             UXTB     R0,R0
   \       0xA8   0x2810             CMP      R0,#+16
   \       0xAA   0xD003             BEQ.N    ??HAL_I2C_ER_IRQHandler_5
   \       0xAC   0x4658             MOV      R0,R11
   \       0xAE   0xB2C0             UXTB     R0,R0
   \       0xB0   0x2840             CMP      R0,#+64
   \       0xB2   0xD105             BNE.N    ??HAL_I2C_ER_IRQHandler_2
   4828                {
   4829                  /* Generate Stop */
   4830                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??HAL_I2C_ER_IRQHandler_5: (+1)
   \       0xB4   0x6830             LDR      R0,[R6, #+0]
   \       0xB6   0x6800             LDR      R0,[R0, #+0]
   \       0xB8   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0xBC   0x6831             LDR      R1,[R6, #+0]
   \       0xBE   0x6008             STR      R0,[R1, #+0]
   4831                }
   4832              }
   4833            }
   4834          
   4835            /* I2C Over-Run/Under-Run interrupt occurred -------------------------------*/
   4836            if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
   \                     ??HAL_I2C_ER_IRQHandler_2: (+1)
   \       0xC0   0xEA5F 0x5009      LSLS     R0,R9,#+20
   \       0xC4   0xD508             BPL.N    ??HAL_I2C_ER_IRQHandler_6
   \       0xC6   0xEA5F 0x50CA      LSLS     R0,R10,#+23
   \       0xCA   0xD505             BPL.N    ??HAL_I2C_ER_IRQHandler_6
   4837            {
   4838              error |= HAL_I2C_ERROR_OVR;
   \       0xCC   0xF055 0x0508      ORRS     R5,R5,#0x8
   4839              /* Clear OVR flag */
   4840              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
   \       0xD0   0xF47F 0x6000      MVNS     R0,#+2048
   \       0xD4   0x6831             LDR      R1,[R6, #+0]
   \       0xD6   0x6148             STR      R0,[R1, #+20]
   4841            }
   4842          
   4843            /* Call the Error Callback in case of Error detected -----------------------*/
   4844            if (error != HAL_I2C_ERROR_NONE)
   \                     ??HAL_I2C_ER_IRQHandler_6: (+1)
   \       0xD8   0x2D00             CMP      R5,#+0
   \       0xDA   0xD005             BEQ.N    ??HAL_I2C_ER_IRQHandler_7
   4845            {
   4846              hi2c->ErrorCode |= error;
   \       0xDC   0x6C30             LDR      R0,[R6, #+64]
   \       0xDE   0x4328             ORRS     R0,R5,R0
   \       0xE0   0x6430             STR      R0,[R6, #+64]
   4847              I2C_ITError(hi2c);
   \       0xE2   0x0030             MOVS     R0,R6
   \       0xE4   0x.... 0x....      BL       I2C_ITError
   4848            }
   4849          }
   \                     ??HAL_I2C_ER_IRQHandler_7: (+1)
   \       0xE8   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}
   4850          
   4851          /**
   4852            * @brief  Master Tx Transfer completed callback.
   4853            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4854            *                the configuration information for the specified I2C.
   4855            * @retval None
   4856            */

   \                                 In section .text, align 2
   4857          __weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
   4858          {
   4859            /* Prevent unused argument(s) compilation warning */
   4860            UNUSED(hi2c);
   4861          
   4862            /* NOTE : This function should not be modified, when the callback is needed,
   4863                      the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
   4864             */
   4865          }
   \                     HAL_I2C_MasterTxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   4866          
   4867          /**
   4868            * @brief  Master Rx Transfer completed callback.
   4869            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4870            *                the configuration information for the specified I2C.
   4871            * @retval None
   4872            */

   \                                 In section .text, align 2
   4873          __weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
   4874          {
   4875            /* Prevent unused argument(s) compilation warning */
   4876            UNUSED(hi2c);
   4877          
   4878            /* NOTE : This function should not be modified, when the callback is needed,
   4879                      the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
   4880             */
   4881          }
   \                     HAL_I2C_MasterRxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   4882          
   4883          /** @brief  Slave Tx Transfer completed callback.
   4884            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4885            *                the configuration information for the specified I2C.
   4886            * @retval None
   4887            */

   \                                 In section .text, align 2
   4888          __weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
   4889          {
   4890            /* Prevent unused argument(s) compilation warning */
   4891            UNUSED(hi2c);
   4892          
   4893            /* NOTE : This function should not be modified, when the callback is needed,
   4894                      the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
   4895             */
   4896          }
   \                     HAL_I2C_SlaveTxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   4897          
   4898          /**
   4899            * @brief  Slave Rx Transfer completed callback.
   4900            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4901            *                the configuration information for the specified I2C.
   4902            * @retval None
   4903            */

   \                                 In section .text, align 2
   4904          __weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
   4905          {
   4906            /* Prevent unused argument(s) compilation warning */
   4907            UNUSED(hi2c);
   4908          
   4909            /* NOTE : This function should not be modified, when the callback is needed,
   4910                      the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
   4911             */
   4912          }
   \                     HAL_I2C_SlaveRxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   4913          
   4914          /**
   4915            * @brief  Slave Address Match callback.
   4916            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4917            *                the configuration information for the specified I2C.
   4918            * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XferDirection_definition
   4919            * @param  AddrMatchCode Address Match Code
   4920            * @retval None
   4921            */

   \                                 In section .text, align 2
   4922          __weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
   4923          {
   4924            /* Prevent unused argument(s) compilation warning */
   4925            UNUSED(hi2c);
   4926            UNUSED(TransferDirection);
   4927            UNUSED(AddrMatchCode);
   4928          
   4929            /* NOTE : This function should not be modified, when the callback is needed,
   4930                      the HAL_I2C_AddrCallback() could be implemented in the user file
   4931             */
   4932          }
   \                     HAL_I2C_AddrCallback: (+1)
   \        0x0   0x4770             BX       LR
   4933          
   4934          /**
   4935            * @brief  Listen Complete callback.
   4936            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4937            *                the configuration information for the specified I2C.
   4938            * @retval None
   4939            */

   \                                 In section .text, align 2
   4940          __weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
   4941          {
   4942            /* Prevent unused argument(s) compilation warning */
   4943            UNUSED(hi2c);
   4944          
   4945            /* NOTE : This function should not be modified, when the callback is needed,
   4946                      the HAL_I2C_ListenCpltCallback() could be implemented in the user file
   4947            */
   4948          }
   \                     HAL_I2C_ListenCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   4949          
   4950          /**
   4951            * @brief  Memory Tx Transfer completed callback.
   4952            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4953            *                the configuration information for the specified I2C.
   4954            * @retval None
   4955            */

   \                                 In section .text, align 2
   4956          __weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
   4957          {
   4958            /* Prevent unused argument(s) compilation warning */
   4959            UNUSED(hi2c);
   4960          
   4961            /* NOTE : This function should not be modified, when the callback is needed,
   4962                      the HAL_I2C_MemTxCpltCallback could be implemented in the user file
   4963             */
   4964          }
   \                     HAL_I2C_MemTxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   4965          
   4966          /**
   4967            * @brief  Memory Rx Transfer completed callback.
   4968            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4969            *                the configuration information for the specified I2C.
   4970            * @retval None
   4971            */

   \                                 In section .text, align 2
   4972          __weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
   4973          {
   4974            /* Prevent unused argument(s) compilation warning */
   4975            UNUSED(hi2c);
   4976          
   4977            /* NOTE : This function should not be modified, when the callback is needed,
   4978                      the HAL_I2C_MemRxCpltCallback could be implemented in the user file
   4979             */
   4980          }
   \                     HAL_I2C_MemRxCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   4981          
   4982          /**
   4983            * @brief  I2C error callback.
   4984            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   4985            *                the configuration information for the specified I2C.
   4986            * @retval None
   4987            */

   \                                 In section .text, align 2
   4988          __weak void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
   4989          {
   4990            /* Prevent unused argument(s) compilation warning */
   4991            UNUSED(hi2c);
   4992          
   4993            /* NOTE : This function should not be modified, when the callback is needed,
   4994                      the HAL_I2C_ErrorCallback could be implemented in the user file
   4995             */
   4996          }
   \                     HAL_I2C_ErrorCallback: (+1)
   \        0x0   0x4770             BX       LR
   4997          
   4998          /**
   4999            * @brief  I2C abort callback.
   5000            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5001            *                the configuration information for the specified I2C.
   5002            * @retval None
   5003            */

   \                                 In section .text, align 2
   5004          __weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
   5005          {
   5006            /* Prevent unused argument(s) compilation warning */
   5007            UNUSED(hi2c);
   5008          
   5009            /* NOTE : This function should not be modified, when the callback is needed,
   5010                      the HAL_I2C_AbortCpltCallback could be implemented in the user file
   5011             */
   5012          }
   \                     HAL_I2C_AbortCpltCallback: (+1)
   \        0x0   0x4770             BX       LR
   5013          
   5014          /**
   5015            * @}
   5016            */
   5017          
   5018          /** @defgroup I2C_Exported_Functions_Group3 Peripheral State, Mode and Error functions
   5019           *  @brief   Peripheral State, Mode and Error functions
   5020            *
   5021          @verbatim
   5022           ===============================================================================
   5023                      ##### Peripheral State, Mode and Error functions #####
   5024           ===============================================================================
   5025              [..]
   5026              This subsection permit to get in run-time the status of the peripheral
   5027              and the data flow.
   5028          
   5029          @endverbatim
   5030            * @{
   5031            */
   5032          
   5033          /**
   5034            * @brief  Return the I2C handle state.
   5035            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5036            *                the configuration information for the specified I2C.
   5037            * @retval HAL state
   5038            */

   \                                 In section .text, align 2, keep-with-next
   5039          HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
   5040          {
   5041            /* Return I2C handle state */
   5042            return hi2c->State;
   \                     HAL_I2C_GetState: (+1)
   \        0x0   0xF890 0x003D      LDRB     R0,[R0, #+61]
   \        0x4   0x4770             BX       LR
   5043          }
   5044          
   5045          /**
   5046            * @brief  Returns the I2C Master, Slave, Memory or no mode.
   5047            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5048            *         the configuration information for I2C module
   5049            * @retval HAL mode
   5050            */

   \                                 In section .text, align 2, keep-with-next
   5051          HAL_I2C_ModeTypeDef HAL_I2C_GetMode(I2C_HandleTypeDef *hi2c)
   5052          {
   5053            return hi2c->Mode;
   \                     HAL_I2C_GetMode: (+1)
   \        0x0   0xF890 0x003E      LDRB     R0,[R0, #+62]
   \        0x4   0x4770             BX       LR
   5054          }
   5055          
   5056          /**
   5057            * @brief  Return the I2C error code.
   5058            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5059            *              the configuration information for the specified I2C.
   5060            * @retval I2C Error Code
   5061            */

   \                                 In section .text, align 2, keep-with-next
   5062          uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
   5063          {
   5064            return hi2c->ErrorCode;
   \                     HAL_I2C_GetError: (+1)
   \        0x0   0x6C00             LDR      R0,[R0, #+64]
   \        0x2   0x4770             BX       LR
   5065          }
   5066          
   5067          /**
   5068            * @}
   5069            */
   5070          
   5071          /**
   5072            * @}
   5073            */
   5074          
   5075          /** @addtogroup I2C_Private_Functions
   5076            * @{
   5077            */
   5078          
   5079          /**
   5080            * @brief  Handle TXE flag for Master
   5081            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5082            *         the configuration information for I2C module
   5083            * @retval None
   5084            */

   \                                 In section .text, align 2, keep-with-next
   5085          static void I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c)
   5086          {
   \                     I2C_MasterTransmit_TXE: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5087            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   5088            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   \        0x4   0xF894 0x503D      LDRB     R5,[R4, #+61]
   5089            HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
   \        0x8   0xF894 0x603E      LDRB     R6,[R4, #+62]
   5090            uint32_t CurrentXferOptions       = hi2c->XferOptions;
   \        0xC   0x6AE7             LDR      R7,[R4, #+44]
   5091          
   5092            if ((hi2c->XferSize == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
   \        0xE   0x8D20             LDRH     R0,[R4, #+40]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD140             BNE.N    ??I2C_MasterTransmit_TXE_0
   \       0x14   0x0028             MOVS     R0,R5
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0x2821             CMP      R0,#+33
   \       0x1A   0xD13C             BNE.N    ??I2C_MasterTransmit_TXE_0
   5093            {
   5094              /* Call TxCpltCallback() directly if no stop mode is set */
   5095              if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
   \       0x1C   0x2F08             CMP      R7,#+8
   \       0x1E   0xD017             BEQ.N    ??I2C_MasterTransmit_TXE_1
   \       0x20   0x2F20             CMP      R7,#+32
   \       0x22   0xD015             BEQ.N    ??I2C_MasterTransmit_TXE_1
   \       0x24   0x.... 0x....      LDR.W    R0,??DataTable31
   \       0x28   0x4287             CMP      R7,R0
   \       0x2A   0xD011             BEQ.N    ??I2C_MasterTransmit_TXE_1
   5096              {
   5097                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6840             LDR      R0,[R0, #+4]
   \       0x30   0xF430 0x60E0      BICS     R0,R0,#0x700
   \       0x34   0x6821             LDR      R1,[R4, #+0]
   \       0x36   0x6048             STR      R0,[R1, #+4]
   5098          
   5099                hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
   \       0x38   0x2011             MOVS     R0,#+17
   \       0x3A   0x6320             STR      R0,[R4, #+48]
   5100                hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xF884 0x003E      STRB     R0,[R4, #+62]
   5101                hi2c->State = HAL_I2C_STATE_READY;
   \       0x42   0x2020             MOVS     R0,#+32
   \       0x44   0xF884 0x003D      STRB     R0,[R4, #+61]
   5102          
   5103          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5104                hi2c->MasterTxCpltCallback(hi2c);
   5105          #else
   5106                HAL_I2C_MasterTxCpltCallback(hi2c);
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   \       0x4E   0xE04A             B.N      ??I2C_MasterTransmit_TXE_2
   5107          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5108              }
   5109              else /* Generate Stop condition then Call TxCpltCallback() */
   5110              {
   5111                /* Disable EVT, BUF and ERR interrupt */
   5112                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \                     ??I2C_MasterTransmit_TXE_1: (+1)
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x6840             LDR      R0,[R0, #+4]
   \       0x54   0xF430 0x60E0      BICS     R0,R0,#0x700
   \       0x58   0x6821             LDR      R1,[R4, #+0]
   \       0x5A   0x6048             STR      R0,[R1, #+4]
   5113          
   5114                /* Generate Stop */
   5115                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x6800             LDR      R0,[R0, #+0]
   \       0x60   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0x64   0x6821             LDR      R1,[R4, #+0]
   \       0x66   0x6008             STR      R0,[R1, #+0]
   5116          
   5117                hi2c->PreviousState = I2C_STATE_NONE;
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0x6320             STR      R0,[R4, #+48]
   5118                hi2c->State = HAL_I2C_STATE_READY;
   \       0x6C   0x2020             MOVS     R0,#+32
   \       0x6E   0xF884 0x003D      STRB     R0,[R4, #+61]
   5119          
   5120                if (hi2c->Mode == HAL_I2C_MODE_MEM)
   \       0x72   0xF894 0x003E      LDRB     R0,[R4, #+62]
   \       0x76   0x2840             CMP      R0,#+64
   \       0x78   0xD106             BNE.N    ??I2C_MasterTransmit_TXE_3
   5121                {
   5122                  hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0xF884 0x003E      STRB     R0,[R4, #+62]
   5123          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5124                  hi2c->MemTxCpltCallback(hi2c);
   5125          #else
   5126                  HAL_I2C_MemTxCpltCallback(hi2c);
   \       0x80   0x0020             MOVS     R0,R4
   \       0x82   0x.... 0x....      BL       HAL_I2C_MemTxCpltCallback
   \       0x86   0xE02E             B.N      ??I2C_MasterTransmit_TXE_2
   5127          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5128                }
   5129                else
   5130                {
   5131                  hi2c->Mode = HAL_I2C_MODE_NONE;
   \                     ??I2C_MasterTransmit_TXE_3: (+1)
   \       0x88   0x2000             MOVS     R0,#+0
   \       0x8A   0xF884 0x003E      STRB     R0,[R4, #+62]
   5132          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5133                  hi2c->MasterTxCpltCallback(hi2c);
   5134          #else
   5135                  HAL_I2C_MasterTxCpltCallback(hi2c);
   \       0x8E   0x0020             MOVS     R0,R4
   \       0x90   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   \       0x94   0xE027             B.N      ??I2C_MasterTransmit_TXE_2
   5136          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5137                }
   5138              }
   5139            }
   5140            else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || \
   5141                     ((CurrentMode == HAL_I2C_MODE_MEM) && (CurrentState == HAL_I2C_STATE_BUSY_RX)))
   \                     ??I2C_MasterTransmit_TXE_0: (+1)
   \       0x96   0x0028             MOVS     R0,R5
   \       0x98   0xB2C0             UXTB     R0,R0
   \       0x9A   0x2821             CMP      R0,#+33
   \       0x9C   0xD007             BEQ.N    ??I2C_MasterTransmit_TXE_4
   \       0x9E   0x0030             MOVS     R0,R6
   \       0xA0   0xB2C0             UXTB     R0,R0
   \       0xA2   0x2840             CMP      R0,#+64
   \       0xA4   0xD11F             BNE.N    ??I2C_MasterTransmit_TXE_2
   \       0xA6   0x0028             MOVS     R0,R5
   \       0xA8   0xB2C0             UXTB     R0,R0
   \       0xAA   0x2822             CMP      R0,#+34
   \       0xAC   0xD11B             BNE.N    ??I2C_MasterTransmit_TXE_2
   5142            {
   5143              if (hi2c->XferCount == 0U)
   \                     ??I2C_MasterTransmit_TXE_4: (+1)
   \       0xAE   0x8D60             LDRH     R0,[R4, #+42]
   \       0xB0   0x2800             CMP      R0,#+0
   \       0xB2   0xD106             BNE.N    ??I2C_MasterTransmit_TXE_5
   5144              {
   5145                /* Disable BUF interrupt */
   5146                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   \       0xB4   0x6820             LDR      R0,[R4, #+0]
   \       0xB6   0x6840             LDR      R0,[R0, #+4]
   \       0xB8   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0xBC   0x6821             LDR      R1,[R4, #+0]
   \       0xBE   0x6048             STR      R0,[R1, #+4]
   \       0xC0   0xE011             B.N      ??I2C_MasterTransmit_TXE_2
   5147              }
   5148              else
   5149              {
   5150                if (hi2c->Mode == HAL_I2C_MODE_MEM)
   \                     ??I2C_MasterTransmit_TXE_5: (+1)
   \       0xC2   0xF894 0x003E      LDRB     R0,[R4, #+62]
   \       0xC6   0x2840             CMP      R0,#+64
   \       0xC8   0xD103             BNE.N    ??I2C_MasterTransmit_TXE_6
   5151                {
   5152                  I2C_MemoryTransmit_TXE_BTF(hi2c);
   \       0xCA   0x0020             MOVS     R0,R4
   \       0xCC   0x.... 0x....      BL       I2C_MemoryTransmit_TXE_BTF
   \       0xD0   0xE009             B.N      ??I2C_MasterTransmit_TXE_2
   5153                }
   5154                else
   5155                {
   5156                  /* Write data to DR */
   5157                  hi2c->Instance->DR = *hi2c->pBuffPtr;
   \                     ??I2C_MasterTransmit_TXE_6: (+1)
   \       0xD2   0x6A60             LDR      R0,[R4, #+36]
   \       0xD4   0x7800             LDRB     R0,[R0, #+0]
   \       0xD6   0x6821             LDR      R1,[R4, #+0]
   \       0xD8   0x6108             STR      R0,[R1, #+16]
   5158          
   5159                  /* Increment Buffer pointer */
   5160                  hi2c->pBuffPtr++;
   \       0xDA   0x6A60             LDR      R0,[R4, #+36]
   \       0xDC   0x1C40             ADDS     R0,R0,#+1
   \       0xDE   0x6260             STR      R0,[R4, #+36]
   5161          
   5162                  /* Update counter */
   5163                  hi2c->XferCount--;
   \       0xE0   0x8D60             LDRH     R0,[R4, #+42]
   \       0xE2   0x1E40             SUBS     R0,R0,#+1
   \       0xE4   0x8560             STRH     R0,[R4, #+42]
   5164                }
   5165              }
   5166            }
   5167            else
   5168            {
   5169              /* Do nothing */
   5170            }
   5171          }
   \                     ??I2C_MasterTransmit_TXE_2: (+1)
   \       0xE6   0xBDF1             POP      {R0,R4-R7,PC}
   5172          
   5173          /**
   5174            * @brief  Handle BTF flag for Master transmitter
   5175            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5176            *         the configuration information for I2C module
   5177            * @retval None
   5178            */

   \                                 In section .text, align 2, keep-with-next
   5179          static void I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c)
   5180          {
   \                     I2C_MasterTransmit_BTF: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5181            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   5182            uint32_t CurrentXferOptions = hi2c->XferOptions;
   \        0x4   0x6AE5             LDR      R5,[R4, #+44]
   5183          
   5184            if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
   \        0x6   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \        0xA   0x2821             CMP      R0,#+33
   \        0xC   0xD13E             BNE.N    ??I2C_MasterTransmit_BTF_0
   5185            {
   5186              if (hi2c->XferCount != 0U)
   \        0xE   0x8D60             LDRH     R0,[R4, #+42]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD00A             BEQ.N    ??I2C_MasterTransmit_BTF_1
   5187              {
   5188                /* Write data to DR */
   5189                hi2c->Instance->DR = *hi2c->pBuffPtr;
   \       0x14   0x6A60             LDR      R0,[R4, #+36]
   \       0x16   0x7800             LDRB     R0,[R0, #+0]
   \       0x18   0x6821             LDR      R1,[R4, #+0]
   \       0x1A   0x6108             STR      R0,[R1, #+16]
   5190          
   5191                /* Increment Buffer pointer */
   5192                hi2c->pBuffPtr++;
   \       0x1C   0x6A60             LDR      R0,[R4, #+36]
   \       0x1E   0x1C40             ADDS     R0,R0,#+1
   \       0x20   0x6260             STR      R0,[R4, #+36]
   5193          
   5194                /* Update counter */
   5195                hi2c->XferCount--;
   \       0x22   0x8D60             LDRH     R0,[R4, #+42]
   \       0x24   0x1E40             SUBS     R0,R0,#+1
   \       0x26   0x8560             STRH     R0,[R4, #+42]
   \       0x28   0xE030             B.N      ??I2C_MasterTransmit_BTF_0
   5196              }
   5197              else
   5198              {
   5199                /* Call TxCpltCallback() directly if no stop mode is set */
   5200                if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
   \                     ??I2C_MasterTransmit_BTF_1: (+1)
   \       0x2A   0x2D08             CMP      R5,#+8
   \       0x2C   0xD017             BEQ.N    ??I2C_MasterTransmit_BTF_2
   \       0x2E   0x2D20             CMP      R5,#+32
   \       0x30   0xD015             BEQ.N    ??I2C_MasterTransmit_BTF_2
   \       0x32   0x.... 0x....      LDR.W    R0,??DataTable31
   \       0x36   0x4285             CMP      R5,R0
   \       0x38   0xD011             BEQ.N    ??I2C_MasterTransmit_BTF_2
   5201                {
   5202                  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x6840             LDR      R0,[R0, #+4]
   \       0x3E   0xF430 0x60E0      BICS     R0,R0,#0x700
   \       0x42   0x6821             LDR      R1,[R4, #+0]
   \       0x44   0x6048             STR      R0,[R1, #+4]
   5203          
   5204                  hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
   \       0x46   0x2011             MOVS     R0,#+17
   \       0x48   0x6320             STR      R0,[R4, #+48]
   5205                  hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xF884 0x003E      STRB     R0,[R4, #+62]
   5206                  hi2c->State = HAL_I2C_STATE_READY;
   \       0x50   0x2020             MOVS     R0,#+32
   \       0x52   0xF884 0x003D      STRB     R0,[R4, #+61]
   5207          
   5208          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5209                  hi2c->MasterTxCpltCallback(hi2c);
   5210          #else
   5211                  HAL_I2C_MasterTxCpltCallback(hi2c);
   \       0x56   0x0020             MOVS     R0,R4
   \       0x58   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   \       0x5C   0xE016             B.N      ??I2C_MasterTransmit_BTF_0
   5212          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5213                }
   5214                else /* Generate Stop condition then Call TxCpltCallback() */
   5215                {
   5216                  /* Disable EVT, BUF and ERR interrupt */
   5217                  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \                     ??I2C_MasterTransmit_BTF_2: (+1)
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6840             LDR      R0,[R0, #+4]
   \       0x62   0xF430 0x60E0      BICS     R0,R0,#0x700
   \       0x66   0x6821             LDR      R1,[R4, #+0]
   \       0x68   0x6048             STR      R0,[R1, #+4]
   5218          
   5219                  /* Generate Stop */
   5220                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x6800             LDR      R0,[R0, #+0]
   \       0x6E   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0x72   0x6821             LDR      R1,[R4, #+0]
   \       0x74   0x6008             STR      R0,[R1, #+0]
   5221          
   5222                  hi2c->PreviousState = I2C_STATE_NONE;
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x6320             STR      R0,[R4, #+48]
   5223                  hi2c->State = HAL_I2C_STATE_READY;
   \       0x7A   0x2020             MOVS     R0,#+32
   \       0x7C   0xF884 0x003D      STRB     R0,[R4, #+61]
   5224                  hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0xF884 0x003E      STRB     R0,[R4, #+62]
   5225          
   5226          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5227                  hi2c->MasterTxCpltCallback(hi2c);
   5228          #else
   5229                  HAL_I2C_MasterTxCpltCallback(hi2c);
   \       0x86   0x0020             MOVS     R0,R4
   \       0x88   0x.... 0x....      BL       HAL_I2C_MasterTxCpltCallback
   5230          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5231                }
   5232              }
   5233            }
   5234            else
   5235            {
   5236              /* Do nothing */
   5237            }
   5238          }
   \                     ??I2C_MasterTransmit_BTF_0: (+1)
   \       0x8C   0xBD31             POP      {R0,R4,R5,PC}
   5239          
   5240          /**
   5241            * @brief  Handle TXE and BTF flag for Memory transmitter
   5242            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5243            *         the configuration information for I2C module
   5244            * @retval None
   5245            */

   \                                 In section .text, align 2, keep-with-next
   5246          static void I2C_MemoryTransmit_TXE_BTF(I2C_HandleTypeDef *hi2c)
   5247          {
   \                     I2C_MemoryTransmit_TXE_BTF: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5248            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   5249            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   \        0x4   0xF894 0x503D      LDRB     R5,[R4, #+61]
   5250          
   5251            if (hi2c->EventCount == 0U)
   \        0x8   0x6D20             LDR      R0,[R4, #+80]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD114             BNE.N    ??I2C_MemoryTransmit_TXE_BTF_0
   5252            {
   5253              /* If Memory address size is 8Bit */
   5254              if (hi2c->MemaddSize == I2C_MEMADD_SIZE_8BIT)
   \        0xE   0x6CE0             LDR      R0,[R4, #+76]
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD107             BNE.N    ??I2C_MemoryTransmit_TXE_BTF_1
   5255              {
   5256                /* Send Memory Address */
   5257                hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
   \       0x14   0x6CA0             LDR      R0,[R4, #+72]
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0x6821             LDR      R1,[R4, #+0]
   \       0x1A   0x6108             STR      R0,[R1, #+16]
   5258          
   5259                hi2c->EventCount += 2U;
   \       0x1C   0x6D20             LDR      R0,[R4, #+80]
   \       0x1E   0x1C80             ADDS     R0,R0,#+2
   \       0x20   0x6520             STR      R0,[R4, #+80]
   \       0x22   0xE052             B.N      ??I2C_MemoryTransmit_TXE_BTF_2
   5260              }
   5261              /* If Memory address size is 16Bit */
   5262              else
   5263              {
   5264                /* Send MSB of Memory Address */
   5265                hi2c->Instance->DR = I2C_MEM_ADD_MSB(hi2c->Memaddress);
   \                     ??I2C_MemoryTransmit_TXE_BTF_1: (+1)
   \       0x24   0x6CA0             LDR      R0,[R4, #+72]
   \       0x26   0xB280             UXTH     R0,R0
   \       0x28   0x0A00             LSRS     R0,R0,#+8
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x6821             LDR      R1,[R4, #+0]
   \       0x2E   0x6108             STR      R0,[R1, #+16]
   5266          
   5267                hi2c->EventCount++;
   \       0x30   0x6D20             LDR      R0,[R4, #+80]
   \       0x32   0x1C40             ADDS     R0,R0,#+1
   \       0x34   0x6520             STR      R0,[R4, #+80]
   \       0x36   0xE048             B.N      ??I2C_MemoryTransmit_TXE_BTF_2
   5268              }
   5269            }
   5270            else if (hi2c->EventCount == 1U)
   \                     ??I2C_MemoryTransmit_TXE_BTF_0: (+1)
   \       0x38   0x6D20             LDR      R0,[R4, #+80]
   \       0x3A   0x2801             CMP      R0,#+1
   \       0x3C   0xD107             BNE.N    ??I2C_MemoryTransmit_TXE_BTF_3
   5271            {
   5272              /* Send LSB of Memory Address */
   5273              hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
   \       0x3E   0x6CA0             LDR      R0,[R4, #+72]
   \       0x40   0xB2C0             UXTB     R0,R0
   \       0x42   0x6821             LDR      R1,[R4, #+0]
   \       0x44   0x6108             STR      R0,[R1, #+16]
   5274          
   5275              hi2c->EventCount++;
   \       0x46   0x6D20             LDR      R0,[R4, #+80]
   \       0x48   0x1C40             ADDS     R0,R0,#+1
   \       0x4A   0x6520             STR      R0,[R4, #+80]
   \       0x4C   0xE03D             B.N      ??I2C_MemoryTransmit_TXE_BTF_2
   5276            }
   5277            else if (hi2c->EventCount == 2U)
   \                     ??I2C_MemoryTransmit_TXE_BTF_3: (+1)
   \       0x4E   0x6D20             LDR      R0,[R4, #+80]
   \       0x50   0x2802             CMP      R0,#+2
   \       0x52   0xD13A             BNE.N    ??I2C_MemoryTransmit_TXE_BTF_2
   5278            {
   5279              if (CurrentState == HAL_I2C_STATE_BUSY_RX)
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0xB2C0             UXTB     R0,R0
   \       0x58   0x2822             CMP      R0,#+34
   \       0x5A   0xD106             BNE.N    ??I2C_MemoryTransmit_TXE_BTF_4
   5280              {
   5281                /* Generate Restart */
   5282                hi2c->Instance->CR1 |= I2C_CR1_START;
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x6800             LDR      R0,[R0, #+0]
   \       0x60   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x64   0x6821             LDR      R1,[R4, #+0]
   \       0x66   0x6008             STR      R0,[R1, #+0]
   \       0x68   0xE02F             B.N      ??I2C_MemoryTransmit_TXE_BTF_2
   5283              }
   5284              else if ((hi2c->XferCount > 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
   \                     ??I2C_MemoryTransmit_TXE_BTF_4: (+1)
   \       0x6A   0x8D60             LDRH     R0,[R4, #+42]
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD00E             BEQ.N    ??I2C_MemoryTransmit_TXE_BTF_5
   \       0x70   0x0028             MOVS     R0,R5
   \       0x72   0xB2C0             UXTB     R0,R0
   \       0x74   0x2821             CMP      R0,#+33
   \       0x76   0xD10A             BNE.N    ??I2C_MemoryTransmit_TXE_BTF_5
   5285              {
   5286                /* Write data to DR */
   5287                hi2c->Instance->DR = *hi2c->pBuffPtr;
   \       0x78   0x6A60             LDR      R0,[R4, #+36]
   \       0x7A   0x7800             LDRB     R0,[R0, #+0]
   \       0x7C   0x6821             LDR      R1,[R4, #+0]
   \       0x7E   0x6108             STR      R0,[R1, #+16]
   5288          
   5289                /* Increment Buffer pointer */
   5290                hi2c->pBuffPtr++;
   \       0x80   0x6A60             LDR      R0,[R4, #+36]
   \       0x82   0x1C40             ADDS     R0,R0,#+1
   \       0x84   0x6260             STR      R0,[R4, #+36]
   5291          
   5292                /* Update counter */
   5293                hi2c->XferCount--;
   \       0x86   0x8D60             LDRH     R0,[R4, #+42]
   \       0x88   0x1E40             SUBS     R0,R0,#+1
   \       0x8A   0x8560             STRH     R0,[R4, #+42]
   \       0x8C   0xE01D             B.N      ??I2C_MemoryTransmit_TXE_BTF_2
   5294              }
   5295              else if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
   \                     ??I2C_MemoryTransmit_TXE_BTF_5: (+1)
   \       0x8E   0x8D60             LDRH     R0,[R4, #+42]
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD11A             BNE.N    ??I2C_MemoryTransmit_TXE_BTF_2
   \       0x94   0x0028             MOVS     R0,R5
   \       0x96   0xB2C0             UXTB     R0,R0
   \       0x98   0x2821             CMP      R0,#+33
   \       0x9A   0xD116             BNE.N    ??I2C_MemoryTransmit_TXE_BTF_2
   5296              {
   5297                /* Generate Stop condition then Call TxCpltCallback() */
   5298                /* Disable EVT, BUF and ERR interrupt */
   5299                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0x9C   0x6820             LDR      R0,[R4, #+0]
   \       0x9E   0x6840             LDR      R0,[R0, #+4]
   \       0xA0   0xF430 0x60E0      BICS     R0,R0,#0x700
   \       0xA4   0x6821             LDR      R1,[R4, #+0]
   \       0xA6   0x6048             STR      R0,[R1, #+4]
   5300          
   5301                /* Generate Stop */
   5302                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0xA8   0x6820             LDR      R0,[R4, #+0]
   \       0xAA   0x6800             LDR      R0,[R0, #+0]
   \       0xAC   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0xB0   0x6821             LDR      R1,[R4, #+0]
   \       0xB2   0x6008             STR      R0,[R1, #+0]
   5303          
   5304                hi2c->PreviousState = I2C_STATE_NONE;
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0x6320             STR      R0,[R4, #+48]
   5305                hi2c->State = HAL_I2C_STATE_READY;
   \       0xB8   0x2020             MOVS     R0,#+32
   \       0xBA   0xF884 0x003D      STRB     R0,[R4, #+61]
   5306                hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0xBE   0x2000             MOVS     R0,#+0
   \       0xC0   0xF884 0x003E      STRB     R0,[R4, #+62]
   5307          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5308                hi2c->MemTxCpltCallback(hi2c);
   5309          #else
   5310                HAL_I2C_MemTxCpltCallback(hi2c);
   \       0xC4   0x0020             MOVS     R0,R4
   \       0xC6   0x.... 0x....      BL       HAL_I2C_MemTxCpltCallback
   5311          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5312              }
   5313              else
   5314              {
   5315                /* Do nothing */
   5316              }
   5317            }
   5318            else
   5319            {
   5320              /* Do nothing */
   5321            }
   5322          }
   \                     ??I2C_MemoryTransmit_TXE_BTF_2: (+1)
   \       0xCA   0xBD31             POP      {R0,R4,R5,PC}
   5323          
   5324          /**
   5325            * @brief  Handle RXNE flag for Master
   5326            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5327            *         the configuration information for I2C module
   5328            * @retval None
   5329            */

   \                                 In section .text, align 2, keep-with-next
   5330          static void I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c)
   5331          {
   \                     I2C_MasterReceive_RXNE: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
   5332            if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
   \        0x4   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \        0x8   0x2822             CMP      R0,#+34
   \        0xA   0xD16A             BNE.N    ??I2C_MasterReceive_RXNE_0
   5333            {
   5334              uint32_t tmp;
   5335          
   5336              tmp = hi2c->XferCount;
   \        0xC   0x8D6C             LDRH     R4,[R5, #+42]
   5337              if (tmp > 3U)
   \        0xE   0x2C04             CMP      R4,#+4
   \       0x10   0xD313             BCC.N    ??I2C_MasterReceive_RXNE_1
   5338              {
   5339                /* Read data from DR */
   5340                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \       0x12   0x6828             LDR      R0,[R5, #+0]
   \       0x14   0x6900             LDR      R0,[R0, #+16]
   \       0x16   0x6A69             LDR      R1,[R5, #+36]
   \       0x18   0x7008             STRB     R0,[R1, #+0]
   5341          
   5342                /* Increment Buffer pointer */
   5343                hi2c->pBuffPtr++;
   \       0x1A   0x6A68             LDR      R0,[R5, #+36]
   \       0x1C   0x1C40             ADDS     R0,R0,#+1
   \       0x1E   0x6268             STR      R0,[R5, #+36]
   5344          
   5345                /* Update counter */
   5346                hi2c->XferCount--;
   \       0x20   0x8D68             LDRH     R0,[R5, #+42]
   \       0x22   0x1E40             SUBS     R0,R0,#+1
   \       0x24   0x8568             STRH     R0,[R5, #+42]
   5347          
   5348                if (hi2c->XferCount == (uint16_t)3)
   \       0x26   0x8D68             LDRH     R0,[R5, #+42]
   \       0x28   0x2803             CMP      R0,#+3
   \       0x2A   0xD15A             BNE.N    ??I2C_MasterReceive_RXNE_0
   5349                {
   5350                  /* Disable BUF interrupt, this help to treat correctly the last 4 bytes
   5351                  on BTF subroutine */
   5352                  /* Disable BUF interrupt */
   5353                  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   \       0x2C   0x6828             LDR      R0,[R5, #+0]
   \       0x2E   0x6840             LDR      R0,[R0, #+4]
   \       0x30   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x34   0x6829             LDR      R1,[R5, #+0]
   \       0x36   0x6048             STR      R0,[R1, #+4]
   \       0x38   0xE053             B.N      ??I2C_MasterReceive_RXNE_0
   5354                }
   5355              }
   5356              else if ((hi2c->XferOptions != I2C_FIRST_AND_NEXT_FRAME) && ((tmp == 1U) || (tmp == 0U)))
   \                     ??I2C_MasterReceive_RXNE_1: (+1)
   \       0x3A   0x6AE8             LDR      R0,[R5, #+44]
   \       0x3C   0x2802             CMP      R0,#+2
   \       0x3E   0xD050             BEQ.N    ??I2C_MasterReceive_RXNE_0
   \       0x40   0x2C01             CMP      R4,#+1
   \       0x42   0xD001             BEQ.N    ??I2C_MasterReceive_RXNE_2
   \       0x44   0x2C00             CMP      R4,#+0
   \       0x46   0xD14C             BNE.N    ??I2C_MasterReceive_RXNE_0
   5357              {
   5358                if (I2C_WaitOnSTOPRequestThroughIT(hi2c) == HAL_OK)
   \                     ??I2C_MasterReceive_RXNE_2: (+1)
   \       0x48   0x0028             MOVS     R0,R5
   \       0x4A   0x.... 0x....      BL       I2C_WaitOnSTOPRequestThroughIT
   \       0x4E   0x2800             CMP      R0,#+0
   \       0x50   0xD12E             BNE.N    ??I2C_MasterReceive_RXNE_3
   5359                {
   5360                  /* Disable Acknowledge */
   5361                  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x52   0x6828             LDR      R0,[R5, #+0]
   \       0x54   0x6800             LDR      R0,[R0, #+0]
   \       0x56   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x5A   0x6829             LDR      R1,[R5, #+0]
   \       0x5C   0x6008             STR      R0,[R1, #+0]
   5362          
   5363                  /* Disable EVT, BUF and ERR interrupt */
   5364                  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0x5E   0x6828             LDR      R0,[R5, #+0]
   \       0x60   0x6840             LDR      R0,[R0, #+4]
   \       0x62   0xF430 0x60E0      BICS     R0,R0,#0x700
   \       0x66   0x6829             LDR      R1,[R5, #+0]
   \       0x68   0x6048             STR      R0,[R1, #+4]
   5365          
   5366                  /* Read data from DR */
   5367                  *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \       0x6A   0x6828             LDR      R0,[R5, #+0]
   \       0x6C   0x6900             LDR      R0,[R0, #+16]
   \       0x6E   0x6A69             LDR      R1,[R5, #+36]
   \       0x70   0x7008             STRB     R0,[R1, #+0]
   5368          
   5369                  /* Increment Buffer pointer */
   5370                  hi2c->pBuffPtr++;
   \       0x72   0x6A68             LDR      R0,[R5, #+36]
   \       0x74   0x1C40             ADDS     R0,R0,#+1
   \       0x76   0x6268             STR      R0,[R5, #+36]
   5371          
   5372                  /* Update counter */
   5373                  hi2c->XferCount--;
   \       0x78   0x8D68             LDRH     R0,[R5, #+42]
   \       0x7A   0x1E40             SUBS     R0,R0,#+1
   \       0x7C   0x8568             STRH     R0,[R5, #+42]
   5374          
   5375                  hi2c->State = HAL_I2C_STATE_READY;
   \       0x7E   0x2020             MOVS     R0,#+32
   \       0x80   0xF885 0x003D      STRB     R0,[R5, #+61]
   5376          
   5377                  if (hi2c->Mode == HAL_I2C_MODE_MEM)
   \       0x84   0xF895 0x003E      LDRB     R0,[R5, #+62]
   \       0x88   0x2840             CMP      R0,#+64
   \       0x8A   0xD108             BNE.N    ??I2C_MasterReceive_RXNE_4
   5378                  {
   5379                    hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0xF885 0x003E      STRB     R0,[R5, #+62]
   5380                    hi2c->PreviousState = I2C_STATE_NONE;
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0x6328             STR      R0,[R5, #+48]
   5381          
   5382          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5383                    hi2c->MemRxCpltCallback(hi2c);
   5384          #else
   5385                    HAL_I2C_MemRxCpltCallback(hi2c);
   \       0x96   0x0028             MOVS     R0,R5
   \       0x98   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   \       0x9C   0xE021             B.N      ??I2C_MasterReceive_RXNE_0
   5386          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5387                  }
   5388                  else
   5389                  {
   5390                    hi2c->Mode = HAL_I2C_MODE_NONE;
   \                     ??I2C_MasterReceive_RXNE_4: (+1)
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0xF885 0x003E      STRB     R0,[R5, #+62]
   5391                    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
   \       0xA4   0x2012             MOVS     R0,#+18
   \       0xA6   0x6328             STR      R0,[R5, #+48]
   5392          
   5393          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5394                    hi2c->MasterRxCpltCallback(hi2c);
   5395          #else
   5396                    HAL_I2C_MasterRxCpltCallback(hi2c);
   \       0xA8   0x0028             MOVS     R0,R5
   \       0xAA   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   \       0xAE   0xE018             B.N      ??I2C_MasterReceive_RXNE_0
   5397          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5398                  }
   5399                }
   5400                else
   5401                {
   5402                  /* Disable EVT, BUF and ERR interrupt */
   5403                  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \                     ??I2C_MasterReceive_RXNE_3: (+1)
   \       0xB0   0x6828             LDR      R0,[R5, #+0]
   \       0xB2   0x6840             LDR      R0,[R0, #+4]
   \       0xB4   0xF430 0x60E0      BICS     R0,R0,#0x700
   \       0xB8   0x6829             LDR      R1,[R5, #+0]
   \       0xBA   0x6048             STR      R0,[R1, #+4]
   5404          
   5405                  /* Read data from DR */
   5406                  *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \       0xBC   0x6828             LDR      R0,[R5, #+0]
   \       0xBE   0x6900             LDR      R0,[R0, #+16]
   \       0xC0   0x6A69             LDR      R1,[R5, #+36]
   \       0xC2   0x7008             STRB     R0,[R1, #+0]
   5407          
   5408                  /* Increment Buffer pointer */
   5409                  hi2c->pBuffPtr++;
   \       0xC4   0x6A68             LDR      R0,[R5, #+36]
   \       0xC6   0x1C40             ADDS     R0,R0,#+1
   \       0xC8   0x6268             STR      R0,[R5, #+36]
   5410          
   5411                  /* Update counter */
   5412                  hi2c->XferCount--;
   \       0xCA   0x8D68             LDRH     R0,[R5, #+42]
   \       0xCC   0x1E40             SUBS     R0,R0,#+1
   \       0xCE   0x8568             STRH     R0,[R5, #+42]
   5413          
   5414                  hi2c->State = HAL_I2C_STATE_READY;
   \       0xD0   0x2020             MOVS     R0,#+32
   \       0xD2   0xF885 0x003D      STRB     R0,[R5, #+61]
   5415                  hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0xF885 0x003E      STRB     R0,[R5, #+62]
   5416          
   5417                  /* Call user error callback */
   5418          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5419                  hi2c->ErrorCallback(hi2c);
   5420          #else
   5421                  HAL_I2C_ErrorCallback(hi2c);
   \       0xDC   0x0028             MOVS     R0,R5
   \       0xDE   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   5422          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5423                }
   5424              }
   5425              else
   5426              {
   5427                /* Do nothing */
   5428              }
   5429            }
   5430          }
   \                     ??I2C_MasterReceive_RXNE_0: (+1)
   \       0xE2   0xBD31             POP      {R0,R4,R5,PC}
   5431          
   5432          /**
   5433            * @brief  Handle BTF flag for Master receiver
   5434            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5435            *         the configuration information for I2C module
   5436            * @retval None
   5437            */

   \                                 In section .text, align 2, keep-with-next
   5438          static void I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c)
   5439          {
   \                     I2C_MasterReceive_BTF: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5440            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   5441            uint32_t CurrentXferOptions = hi2c->XferOptions;
   \        0x4   0x6AE5             LDR      R5,[R4, #+44]
   5442          
   5443            if (hi2c->XferCount == 4U)
   \        0x6   0x8D60             LDRH     R0,[R4, #+42]
   \        0x8   0x2804             CMP      R0,#+4
   \        0xA   0xD110             BNE.N    ??I2C_MasterReceive_BTF_0
   5444            {
   5445              /* Disable BUF interrupt, this help to treat correctly the last 2 bytes
   5446                 on BTF subroutine if there is a reception delay between N-1 and N byte */
   5447              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x6840             LDR      R0,[R0, #+4]
   \       0x10   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x14   0x6821             LDR      R1,[R4, #+0]
   \       0x16   0x6048             STR      R0,[R1, #+4]
   5448          
   5449              /* Read data from DR */
   5450              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x6900             LDR      R0,[R0, #+16]
   \       0x1C   0x6A61             LDR      R1,[R4, #+36]
   \       0x1E   0x7008             STRB     R0,[R1, #+0]
   5451          
   5452              /* Increment Buffer pointer */
   5453              hi2c->pBuffPtr++;
   \       0x20   0x6A60             LDR      R0,[R4, #+36]
   \       0x22   0x1C40             ADDS     R0,R0,#+1
   \       0x24   0x6260             STR      R0,[R4, #+36]
   5454          
   5455              /* Update counter */
   5456              hi2c->XferCount--;
   \       0x26   0x8D60             LDRH     R0,[R4, #+42]
   \       0x28   0x1E40             SUBS     R0,R0,#+1
   \       0x2A   0x8560             STRH     R0,[R4, #+42]
   \       0x2C   0xE07B             B.N      ??I2C_MasterReceive_BTF_1
   5457            }
   5458            else if (hi2c->XferCount == 3U)
   \                     ??I2C_MasterReceive_BTF_0: (+1)
   \       0x2E   0x8D60             LDRH     R0,[R4, #+42]
   \       0x30   0x2803             CMP      R0,#+3
   \       0x32   0xD11A             BNE.N    ??I2C_MasterReceive_BTF_2
   5459            {
   5460              /* Disable BUF interrupt, this help to treat correctly the last 2 bytes
   5461                 on BTF subroutine if there is a reception delay between N-1 and N byte */
   5462              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x6840             LDR      R0,[R0, #+4]
   \       0x38   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x3C   0x6821             LDR      R1,[R4, #+0]
   \       0x3E   0x6048             STR      R0,[R1, #+4]
   5463          
   5464              if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME))
   \       0x40   0x2D04             CMP      R5,#+4
   \       0x42   0xD007             BEQ.N    ??I2C_MasterReceive_BTF_3
   \       0x44   0x2D02             CMP      R5,#+2
   \       0x46   0xD005             BEQ.N    ??I2C_MasterReceive_BTF_3
   5465              {
   5466                /* Disable Acknowledge */
   5467                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x6800             LDR      R0,[R0, #+0]
   \       0x4C   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x50   0x6821             LDR      R1,[R4, #+0]
   \       0x52   0x6008             STR      R0,[R1, #+0]
   5468              }
   5469          
   5470              /* Read data from DR */
   5471              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \                     ??I2C_MasterReceive_BTF_3: (+1)
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x6900             LDR      R0,[R0, #+16]
   \       0x58   0x6A61             LDR      R1,[R4, #+36]
   \       0x5A   0x7008             STRB     R0,[R1, #+0]
   5472          
   5473              /* Increment Buffer pointer */
   5474              hi2c->pBuffPtr++;
   \       0x5C   0x6A60             LDR      R0,[R4, #+36]
   \       0x5E   0x1C40             ADDS     R0,R0,#+1
   \       0x60   0x6260             STR      R0,[R4, #+36]
   5475          
   5476              /* Update counter */
   5477              hi2c->XferCount--;
   \       0x62   0x8D60             LDRH     R0,[R4, #+42]
   \       0x64   0x1E40             SUBS     R0,R0,#+1
   \       0x66   0x8560             STRH     R0,[R4, #+42]
   \       0x68   0xE05D             B.N      ??I2C_MasterReceive_BTF_1
   5478            }
   5479            else if (hi2c->XferCount == 2U)
   \                     ??I2C_MasterReceive_BTF_2: (+1)
   \       0x6A   0x8D60             LDRH     R0,[R4, #+42]
   \       0x6C   0x2802             CMP      R0,#+2
   \       0x6E   0xD150             BNE.N    ??I2C_MasterReceive_BTF_4
   5480            {
   5481              /* Prepare next transfer or stop current transfer */
   5482              if ((CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP))
   \       0x70   0x2D01             CMP      R5,#+1
   \       0x72   0xD001             BEQ.N    ??I2C_MasterReceive_BTF_5
   \       0x74   0x2D10             CMP      R5,#+16
   \       0x76   0xD106             BNE.N    ??I2C_MasterReceive_BTF_6
   5483              {
   5484                /* Disable Acknowledge */
   5485                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??I2C_MasterReceive_BTF_5: (+1)
   \       0x78   0x6820             LDR      R0,[R4, #+0]
   \       0x7A   0x6800             LDR      R0,[R0, #+0]
   \       0x7C   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x80   0x6821             LDR      R1,[R4, #+0]
   \       0x82   0x6008             STR      R0,[R1, #+0]
   \       0x84   0xE012             B.N      ??I2C_MasterReceive_BTF_7
   5486              }
   5487              else if ((CurrentXferOptions == I2C_NEXT_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_NEXT_FRAME))
   \                     ??I2C_MasterReceive_BTF_6: (+1)
   \       0x86   0x2D04             CMP      R5,#+4
   \       0x88   0xD001             BEQ.N    ??I2C_MasterReceive_BTF_8
   \       0x8A   0x2D02             CMP      R5,#+2
   \       0x8C   0xD106             BNE.N    ??I2C_MasterReceive_BTF_9
   5488              {
   5489                /* Enable Acknowledge */
   5490                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??I2C_MasterReceive_BTF_8: (+1)
   \       0x8E   0x6820             LDR      R0,[R4, #+0]
   \       0x90   0x6800             LDR      R0,[R0, #+0]
   \       0x92   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0x96   0x6821             LDR      R1,[R4, #+0]
   \       0x98   0x6008             STR      R0,[R1, #+0]
   \       0x9A   0xE007             B.N      ??I2C_MasterReceive_BTF_7
   5491              }
   5492              else if (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP)
   \                     ??I2C_MasterReceive_BTF_9: (+1)
   \       0x9C   0x2D10             CMP      R5,#+16
   \       0x9E   0xD005             BEQ.N    ??I2C_MasterReceive_BTF_7
   5493              {
   5494                /* Generate Stop */
   5495                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x6800             LDR      R0,[R0, #+0]
   \       0xA4   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0xA8   0x6821             LDR      R1,[R4, #+0]
   \       0xAA   0x6008             STR      R0,[R1, #+0]
   5496              }
   5497              else
   5498              {
   5499                /* Do nothing */
   5500              }
   5501          
   5502              /* Read data from DR */
   5503              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \                     ??I2C_MasterReceive_BTF_7: (+1)
   \       0xAC   0x6820             LDR      R0,[R4, #+0]
   \       0xAE   0x6900             LDR      R0,[R0, #+16]
   \       0xB0   0x6A61             LDR      R1,[R4, #+36]
   \       0xB2   0x7008             STRB     R0,[R1, #+0]
   5504          
   5505              /* Increment Buffer pointer */
   5506              hi2c->pBuffPtr++;
   \       0xB4   0x6A60             LDR      R0,[R4, #+36]
   \       0xB6   0x1C40             ADDS     R0,R0,#+1
   \       0xB8   0x6260             STR      R0,[R4, #+36]
   5507          
   5508              /* Update counter */
   5509              hi2c->XferCount--;
   \       0xBA   0x8D60             LDRH     R0,[R4, #+42]
   \       0xBC   0x1E40             SUBS     R0,R0,#+1
   \       0xBE   0x8560             STRH     R0,[R4, #+42]
   5510          
   5511              /* Read data from DR */
   5512              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \       0xC0   0x6820             LDR      R0,[R4, #+0]
   \       0xC2   0x6900             LDR      R0,[R0, #+16]
   \       0xC4   0x6A61             LDR      R1,[R4, #+36]
   \       0xC6   0x7008             STRB     R0,[R1, #+0]
   5513          
   5514              /* Increment Buffer pointer */
   5515              hi2c->pBuffPtr++;
   \       0xC8   0x6A60             LDR      R0,[R4, #+36]
   \       0xCA   0x1C40             ADDS     R0,R0,#+1
   \       0xCC   0x6260             STR      R0,[R4, #+36]
   5516          
   5517              /* Update counter */
   5518              hi2c->XferCount--;
   \       0xCE   0x8D60             LDRH     R0,[R4, #+42]
   \       0xD0   0x1E40             SUBS     R0,R0,#+1
   \       0xD2   0x8560             STRH     R0,[R4, #+42]
   5519          
   5520              /* Disable EVT and ERR interrupt */
   5521              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \       0xD4   0x6820             LDR      R0,[R4, #+0]
   \       0xD6   0x6840             LDR      R0,[R0, #+4]
   \       0xD8   0xF430 0x7040      BICS     R0,R0,#0x300
   \       0xDC   0x6821             LDR      R1,[R4, #+0]
   \       0xDE   0x6048             STR      R0,[R1, #+4]
   5522          
   5523              hi2c->State = HAL_I2C_STATE_READY;
   \       0xE0   0x2020             MOVS     R0,#+32
   \       0xE2   0xF884 0x003D      STRB     R0,[R4, #+61]
   5524              if (hi2c->Mode == HAL_I2C_MODE_MEM)
   \       0xE6   0xF894 0x003E      LDRB     R0,[R4, #+62]
   \       0xEA   0x2840             CMP      R0,#+64
   \       0xEC   0xD108             BNE.N    ??I2C_MasterReceive_BTF_10
   5525              {
   5526                hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0xEE   0x2000             MOVS     R0,#+0
   \       0xF0   0xF884 0x003E      STRB     R0,[R4, #+62]
   5527                hi2c->PreviousState = I2C_STATE_NONE;
   \       0xF4   0x2000             MOVS     R0,#+0
   \       0xF6   0x6320             STR      R0,[R4, #+48]
   5528          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5529                hi2c->MemRxCpltCallback(hi2c);
   5530          #else
   5531                HAL_I2C_MemRxCpltCallback(hi2c);
   \       0xF8   0x0020             MOVS     R0,R4
   \       0xFA   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   \       0xFE   0xE012             B.N      ??I2C_MasterReceive_BTF_1
   5532          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5533              }
   5534              else
   5535              {
   5536                hi2c->Mode = HAL_I2C_MODE_NONE;
   \                     ??I2C_MasterReceive_BTF_10: (+1)
   \      0x100   0x2000             MOVS     R0,#+0
   \      0x102   0xF884 0x003E      STRB     R0,[R4, #+62]
   5537                hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
   \      0x106   0x2012             MOVS     R0,#+18
   \      0x108   0x6320             STR      R0,[R4, #+48]
   5538          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5539                hi2c->MasterRxCpltCallback(hi2c);
   5540          #else
   5541                HAL_I2C_MasterRxCpltCallback(hi2c);
   \      0x10A   0x0020             MOVS     R0,R4
   \      0x10C   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   \      0x110   0xE009             B.N      ??I2C_MasterReceive_BTF_1
   5542          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5543              }
   5544            }
   5545            else
   5546            {
   5547              /* Read data from DR */
   5548              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \                     ??I2C_MasterReceive_BTF_4: (+1)
   \      0x112   0x6820             LDR      R0,[R4, #+0]
   \      0x114   0x6900             LDR      R0,[R0, #+16]
   \      0x116   0x6A61             LDR      R1,[R4, #+36]
   \      0x118   0x7008             STRB     R0,[R1, #+0]
   5549          
   5550              /* Increment Buffer pointer */
   5551              hi2c->pBuffPtr++;
   \      0x11A   0x6A60             LDR      R0,[R4, #+36]
   \      0x11C   0x1C40             ADDS     R0,R0,#+1
   \      0x11E   0x6260             STR      R0,[R4, #+36]
   5552          
   5553              /* Update counter */
   5554              hi2c->XferCount--;
   \      0x120   0x8D60             LDRH     R0,[R4, #+42]
   \      0x122   0x1E40             SUBS     R0,R0,#+1
   \      0x124   0x8560             STRH     R0,[R4, #+42]
   5555            }
   5556          }
   \                     ??I2C_MasterReceive_BTF_1: (+1)
   \      0x126   0xBD31             POP      {R0,R4,R5,PC}
   5557          
   5558          /**
   5559            * @brief  Handle SB flag for Master
   5560            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5561            *         the configuration information for I2C module
   5562            * @retval None
   5563            */

   \                                 In section .text, align 2, keep-with-next
   5564          static void I2C_Master_SB(I2C_HandleTypeDef *hi2c)
   5565          {
   5566            if (hi2c->Mode == HAL_I2C_MODE_MEM)
   \                     I2C_Master_SB: (+1)
   \        0x0   0xF890 0x103E      LDRB     R1,[R0, #+62]
   \        0x4   0x2940             CMP      R1,#+64
   \        0x6   0xD10F             BNE.N    ??I2C_Master_SB_0
   5567            {
   5568              if (hi2c->EventCount == 0U)
   \        0x8   0x6D01             LDR      R1,[R0, #+80]
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD105             BNE.N    ??I2C_Master_SB_1
   5569              {
   5570                /* Send slave address */
   5571                hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
   \        0xE   0x6C41             LDR      R1,[R0, #+68]
   \       0x10   0xF011 0x01FE      ANDS     R1,R1,#0xFE
   \       0x14   0x6802             LDR      R2,[R0, #+0]
   \       0x16   0x6111             STR      R1,[R2, #+16]
   \       0x18   0xE04A             B.N      ??I2C_Master_SB_2
   5572              }
   5573              else
   5574              {
   5575                hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
   \                     ??I2C_Master_SB_1: (+1)
   \       0x1A   0x6C41             LDR      R1,[R0, #+68]
   \       0x1C   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x20   0xB2C9             UXTB     R1,R1
   \       0x22   0x6802             LDR      R2,[R0, #+0]
   \       0x24   0x6111             STR      R1,[R2, #+16]
   \       0x26   0xE043             B.N      ??I2C_Master_SB_2
   5576              }
   5577            }
   5578            else
   5579            {
   5580              if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   \                     ??I2C_Master_SB_0: (+1)
   \       0x28   0x6901             LDR      R1,[R0, #+16]
   \       0x2A   0xF5B1 0x4F80      CMP      R1,#+16384
   \       0x2E   0xD124             BNE.N    ??I2C_Master_SB_3
   5581              {
   5582                /* Send slave 7 Bits address */
   5583                if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
   \       0x30   0xF890 0x103D      LDRB     R1,[R0, #+61]
   \       0x34   0x2921             CMP      R1,#+33
   \       0x36   0xD105             BNE.N    ??I2C_Master_SB_4
   5584                {
   5585                  hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
   \       0x38   0x6C41             LDR      R1,[R0, #+68]
   \       0x3A   0xF011 0x01FE      ANDS     R1,R1,#0xFE
   \       0x3E   0x6802             LDR      R2,[R0, #+0]
   \       0x40   0x6111             STR      R1,[R2, #+16]
   \       0x42   0xE005             B.N      ??I2C_Master_SB_5
   5586                }
   5587                else
   5588                {
   5589                  hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
   \                     ??I2C_Master_SB_4: (+1)
   \       0x44   0x6C41             LDR      R1,[R0, #+68]
   \       0x46   0xF051 0x0101      ORRS     R1,R1,#0x1
   \       0x4A   0xB2C9             UXTB     R1,R1
   \       0x4C   0x6802             LDR      R2,[R0, #+0]
   \       0x4E   0x6111             STR      R1,[R2, #+16]
   5590                }
   5591          
   5592                if (((hi2c->hdmatx != NULL) && (hi2c->hdmatx->XferCpltCallback != NULL))
   5593                    || ((hi2c->hdmarx != NULL) && (hi2c->hdmarx->XferCpltCallback != NULL)))
   \                     ??I2C_Master_SB_5: (+1)
   \       0x50   0x6B41             LDR      R1,[R0, #+52]
   \       0x52   0x2900             CMP      R1,#+0
   \       0x54   0xD003             BEQ.N    ??I2C_Master_SB_6
   \       0x56   0x6B41             LDR      R1,[R0, #+52]
   \       0x58   0x6BC9             LDR      R1,[R1, #+60]
   \       0x5A   0x2900             CMP      R1,#+0
   \       0x5C   0xD106             BNE.N    ??I2C_Master_SB_7
   \                     ??I2C_Master_SB_6: (+1)
   \       0x5E   0x6B81             LDR      R1,[R0, #+56]
   \       0x60   0x2900             CMP      R1,#+0
   \       0x62   0xD025             BEQ.N    ??I2C_Master_SB_2
   \       0x64   0x6B81             LDR      R1,[R0, #+56]
   \       0x66   0x6BC9             LDR      R1,[R1, #+60]
   \       0x68   0x2900             CMP      R1,#+0
   \       0x6A   0xD021             BEQ.N    ??I2C_Master_SB_2
   5594                {
   5595                  /* Enable DMA Request */
   5596                  SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \                     ??I2C_Master_SB_7: (+1)
   \       0x6C   0x6801             LDR      R1,[R0, #+0]
   \       0x6E   0x6849             LDR      R1,[R1, #+4]
   \       0x70   0xF451 0x6100      ORRS     R1,R1,#0x800
   \       0x74   0x6802             LDR      R2,[R0, #+0]
   \       0x76   0x6051             STR      R1,[R2, #+4]
   \       0x78   0xE01A             B.N      ??I2C_Master_SB_2
   5597                }
   5598              }
   5599              else
   5600              {
   5601                if (hi2c->EventCount == 0U)
   \                     ??I2C_Master_SB_3: (+1)
   \       0x7A   0x6D01             LDR      R1,[R0, #+80]
   \       0x7C   0x2900             CMP      R1,#+0
   \       0x7E   0xD10A             BNE.N    ??I2C_Master_SB_8
   5602                {
   5603                  /* Send header of slave address */
   5604                  hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(hi2c->Devaddress);
   \       0x80   0x6C41             LDR      R1,[R0, #+68]
   \       0x82   0xF411 0x7140      ANDS     R1,R1,#0x300
   \       0x86   0xB289             UXTH     R1,R1
   \       0x88   0x09C9             LSRS     R1,R1,#+7
   \       0x8A   0xF051 0x01F0      ORRS     R1,R1,#0xF0
   \       0x8E   0xB2C9             UXTB     R1,R1
   \       0x90   0x6802             LDR      R2,[R0, #+0]
   \       0x92   0x6111             STR      R1,[R2, #+16]
   \       0x94   0xE00C             B.N      ??I2C_Master_SB_2
   5605                }
   5606                else if (hi2c->EventCount == 1U)
   \                     ??I2C_Master_SB_8: (+1)
   \       0x96   0x6D01             LDR      R1,[R0, #+80]
   \       0x98   0x2901             CMP      R1,#+1
   \       0x9A   0xD109             BNE.N    ??I2C_Master_SB_2
   5607                {
   5608                  /* Send header of slave address */
   5609                  hi2c->Instance->DR = I2C_10BIT_HEADER_READ(hi2c->Devaddress);
   \       0x9C   0x6C41             LDR      R1,[R0, #+68]
   \       0x9E   0xF411 0x7140      ANDS     R1,R1,#0x300
   \       0xA2   0xB289             UXTH     R1,R1
   \       0xA4   0x09C9             LSRS     R1,R1,#+7
   \       0xA6   0xF051 0x01F1      ORRS     R1,R1,#0xF1
   \       0xAA   0xB2C9             UXTB     R1,R1
   \       0xAC   0x6802             LDR      R2,[R0, #+0]
   \       0xAE   0x6111             STR      R1,[R2, #+16]
   5610                }
   5611                else
   5612                {
   5613                  /* Do nothing */
   5614                }
   5615              }
   5616            }
   5617          }
   \                     ??I2C_Master_SB_2: (+1)
   \       0xB0   0x4770             BX       LR
   5618          
   5619          /**
   5620            * @brief  Handle ADD10 flag for Master
   5621            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5622            *         the configuration information for I2C module
   5623            * @retval None
   5624            */

   \                                 In section .text, align 2, keep-with-next
   5625          static void I2C_Master_ADD10(I2C_HandleTypeDef *hi2c)
   5626          {
   5627            /* Send slave address */
   5628            hi2c->Instance->DR = I2C_10BIT_ADDRESS(hi2c->Devaddress);
   \                     I2C_Master_ADD10: (+1)
   \        0x0   0x6C41             LDR      R1,[R0, #+68]
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x6802             LDR      R2,[R0, #+0]
   \        0x6   0x6111             STR      R1,[R2, #+16]
   5629          
   5630            if ((hi2c->hdmatx != NULL) || (hi2c->hdmarx != NULL))
   \        0x8   0x6B41             LDR      R1,[R0, #+52]
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD102             BNE.N    ??I2C_Master_ADD10_0
   \        0xE   0x6B81             LDR      R1,[R0, #+56]
   \       0x10   0x2900             CMP      R1,#+0
   \       0x12   0xD00D             BEQ.N    ??I2C_Master_ADD10_1
   5631            {
   5632              if ((hi2c->hdmatx->XferCpltCallback != NULL) || (hi2c->hdmarx->XferCpltCallback != NULL))
   \                     ??I2C_Master_ADD10_0: (+1)
   \       0x14   0x6B41             LDR      R1,[R0, #+52]
   \       0x16   0x6BC9             LDR      R1,[R1, #+60]
   \       0x18   0x2900             CMP      R1,#+0
   \       0x1A   0xD103             BNE.N    ??I2C_Master_ADD10_2
   \       0x1C   0x6B81             LDR      R1,[R0, #+56]
   \       0x1E   0x6BC9             LDR      R1,[R1, #+60]
   \       0x20   0x2900             CMP      R1,#+0
   \       0x22   0xD005             BEQ.N    ??I2C_Master_ADD10_1
   5633              {
   5634                /* Enable DMA Request */
   5635                SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \                     ??I2C_Master_ADD10_2: (+1)
   \       0x24   0x6801             LDR      R1,[R0, #+0]
   \       0x26   0x6849             LDR      R1,[R1, #+4]
   \       0x28   0xF451 0x6100      ORRS     R1,R1,#0x800
   \       0x2C   0x6802             LDR      R2,[R0, #+0]
   \       0x2E   0x6051             STR      R1,[R2, #+4]
   5636              }
   5637            }
   5638          }
   \                     ??I2C_Master_ADD10_1: (+1)
   \       0x30   0x4770             BX       LR
   5639          
   5640          /**
   5641            * @brief  Handle ADDR flag for Master
   5642            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5643            *         the configuration information for I2C module
   5644            * @retval None
   5645            */

   \                                 In section .text, align 2, keep-with-next
   5646          static void I2C_Master_ADDR(I2C_HandleTypeDef *hi2c)
   5647          {
   \                     I2C_Master_ADDR: (+1)
   \        0x0   0xB438             PUSH     {R3-R5}
   5648            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   5649            HAL_I2C_ModeTypeDef CurrentMode       = hi2c->Mode;
   \        0x2   0xF890 0x203E      LDRB     R2,[R0, #+62]
   5650            uint32_t CurrentXferOptions           = hi2c->XferOptions;
   \        0x6   0x6AC3             LDR      R3,[R0, #+44]
   5651            uint32_t Prev_State                   = hi2c->PreviousState;
   \        0x8   0x6B04             LDR      R4,[R0, #+48]
   5652          
   5653            if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
   \        0xA   0xF890 0x103D      LDRB     R1,[R0, #+61]
   \        0xE   0x2922             CMP      R1,#+34
   \       0x10   0xF040 0x810E      BNE.W    ??I2C_Master_ADDR_0
   5654            {
   5655              if ((hi2c->EventCount == 0U) && (CurrentMode == HAL_I2C_MODE_MEM))
   \       0x14   0x6D01             LDR      R1,[R0, #+80]
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD10D             BNE.N    ??I2C_Master_ADDR_1
   \       0x1A   0x0011             MOVS     R1,R2
   \       0x1C   0xB2C9             UXTB     R1,R1
   \       0x1E   0x2940             CMP      R1,#+64
   \       0x20   0xD109             BNE.N    ??I2C_Master_ADDR_1
   5656              {
   5657                /* Clear ADDR flag */
   5658                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \       0x22   0x2100             MOVS     R1,#+0
   \       0x24   0x9100             STR      R1,[SP, #+0]
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0x6949             LDR      R1,[R1, #+20]
   \       0x2A   0x9100             STR      R1,[SP, #+0]
   \       0x2C   0x6801             LDR      R1,[R0, #+0]
   \       0x2E   0x6989             LDR      R1,[R1, #+24]
   \       0x30   0x9100             STR      R1,[SP, #+0]
   \       0x32   0x9900             LDR      R1,[SP, #+0]
   \       0x34   0xE105             B.N      ??I2C_Master_ADDR_2
   5659              }
   5660              else if ((hi2c->EventCount == 0U) && (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT))
   \                     ??I2C_Master_ADDR_1: (+1)
   \       0x36   0x6D01             LDR      R1,[R0, #+80]
   \       0x38   0x2900             CMP      R1,#+0
   \       0x3A   0xD116             BNE.N    ??I2C_Master_ADDR_3
   \       0x3C   0x6901             LDR      R1,[R0, #+16]
   \       0x3E   0xF5B1 0x4F40      CMP      R1,#+49152
   \       0x42   0xD112             BNE.N    ??I2C_Master_ADDR_3
   5661              {
   5662                /* Clear ADDR flag */
   5663                __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \       0x44   0x2100             MOVS     R1,#+0
   \       0x46   0x9100             STR      R1,[SP, #+0]
   \       0x48   0x6801             LDR      R1,[R0, #+0]
   \       0x4A   0x6949             LDR      R1,[R1, #+20]
   \       0x4C   0x9100             STR      R1,[SP, #+0]
   \       0x4E   0x6801             LDR      R1,[R0, #+0]
   \       0x50   0x6989             LDR      R1,[R1, #+24]
   \       0x52   0x9100             STR      R1,[SP, #+0]
   \       0x54   0x9900             LDR      R1,[SP, #+0]
   5664          
   5665                /* Generate Restart */
   5666                SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \       0x56   0x6801             LDR      R1,[R0, #+0]
   \       0x58   0x6809             LDR      R1,[R1, #+0]
   \       0x5A   0xF451 0x7180      ORRS     R1,R1,#0x100
   \       0x5E   0x6805             LDR      R5,[R0, #+0]
   \       0x60   0x6029             STR      R1,[R5, #+0]
   5667          
   5668                hi2c->EventCount++;
   \       0x62   0x6D01             LDR      R1,[R0, #+80]
   \       0x64   0x1C49             ADDS     R1,R1,#+1
   \       0x66   0x6501             STR      R1,[R0, #+80]
   \       0x68   0xE0EB             B.N      ??I2C_Master_ADDR_2
   5669              }
   5670              else
   5671              {
   5672                if (hi2c->XferCount == 0U)
   \                     ??I2C_Master_ADDR_3: (+1)
   \       0x6A   0x8D41             LDRH     R1,[R0, #+42]
   \       0x6C   0x2900             CMP      R1,#+0
   \       0x6E   0xD10F             BNE.N    ??I2C_Master_ADDR_4
   5673                {
   5674                  /* Clear ADDR flag */
   5675                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \       0x70   0x2100             MOVS     R1,#+0
   \       0x72   0x9100             STR      R1,[SP, #+0]
   \       0x74   0x6801             LDR      R1,[R0, #+0]
   \       0x76   0x6949             LDR      R1,[R1, #+20]
   \       0x78   0x9100             STR      R1,[SP, #+0]
   \       0x7A   0x6801             LDR      R1,[R0, #+0]
   \       0x7C   0x6989             LDR      R1,[R1, #+24]
   \       0x7E   0x9100             STR      R1,[SP, #+0]
   \       0x80   0x9900             LDR      R1,[SP, #+0]
   5676          
   5677                  /* Generate Stop */
   5678                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0x82   0x6801             LDR      R1,[R0, #+0]
   \       0x84   0x6809             LDR      R1,[R1, #+0]
   \       0x86   0xF451 0x7100      ORRS     R1,R1,#0x200
   \       0x8A   0x6805             LDR      R5,[R0, #+0]
   \       0x8C   0x6029             STR      R1,[R5, #+0]
   \       0x8E   0xE0CC             B.N      ??I2C_Master_ADDR_5
   5679                }
   5680                else if (hi2c->XferCount == 1U)
   \                     ??I2C_Master_ADDR_4: (+1)
   \       0x90   0x8D41             LDRH     R1,[R0, #+42]
   \       0x92   0x2901             CMP      R1,#+1
   \       0x94   0xD168             BNE.N    ??I2C_Master_ADDR_6
   5681                {
   5682                  if (CurrentXferOptions == I2C_NO_OPTION_FRAME)
   \       0x96   0x.... 0x....      LDR.W    R1,??DataTable31
   \       0x9A   0x428B             CMP      R3,R1
   \       0x9C   0xD129             BNE.N    ??I2C_Master_ADDR_7
   5683                  {
   5684                    /* Disable Acknowledge */
   5685                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x9E   0x6801             LDR      R1,[R0, #+0]
   \       0xA0   0x6809             LDR      R1,[R1, #+0]
   \       0xA2   0xF431 0x6180      BICS     R1,R1,#0x400
   \       0xA6   0x6805             LDR      R5,[R0, #+0]
   \       0xA8   0x6029             STR      R1,[R5, #+0]
   5686          
   5687                    if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   \       0xAA   0x6801             LDR      R1,[R0, #+0]
   \       0xAC   0x6849             LDR      R1,[R1, #+4]
   \       0xAE   0x0509             LSLS     R1,R1,#+20
   \       0xB0   0xD50F             BPL.N    ??I2C_Master_ADDR_8
   5688                    {
   5689                      /* Disable Acknowledge */
   5690                      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0xB2   0x6801             LDR      R1,[R0, #+0]
   \       0xB4   0x6809             LDR      R1,[R1, #+0]
   \       0xB6   0xF431 0x6180      BICS     R1,R1,#0x400
   \       0xBA   0x6805             LDR      R5,[R0, #+0]
   \       0xBC   0x6029             STR      R1,[R5, #+0]
   5691          
   5692                      /* Clear ADDR flag */
   5693                      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \       0xBE   0x2100             MOVS     R1,#+0
   \       0xC0   0x9100             STR      R1,[SP, #+0]
   \       0xC2   0x6801             LDR      R1,[R0, #+0]
   \       0xC4   0x6949             LDR      R1,[R1, #+20]
   \       0xC6   0x9100             STR      R1,[SP, #+0]
   \       0xC8   0x6801             LDR      R1,[R0, #+0]
   \       0xCA   0x6989             LDR      R1,[R1, #+24]
   \       0xCC   0x9100             STR      R1,[SP, #+0]
   \       0xCE   0x9900             LDR      R1,[SP, #+0]
   \       0xD0   0xE0AB             B.N      ??I2C_Master_ADDR_5
   5694                    }
   5695                    else
   5696                    {
   5697                      /* Clear ADDR flag */
   5698                      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_Master_ADDR_8: (+1)
   \       0xD2   0x2100             MOVS     R1,#+0
   \       0xD4   0x9100             STR      R1,[SP, #+0]
   \       0xD6   0x6801             LDR      R1,[R0, #+0]
   \       0xD8   0x6949             LDR      R1,[R1, #+20]
   \       0xDA   0x9100             STR      R1,[SP, #+0]
   \       0xDC   0x6801             LDR      R1,[R0, #+0]
   \       0xDE   0x6989             LDR      R1,[R1, #+24]
   \       0xE0   0x9100             STR      R1,[SP, #+0]
   \       0xE2   0x9900             LDR      R1,[SP, #+0]
   5699          
   5700                      /* Generate Stop */
   5701                      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0xE4   0x6801             LDR      R1,[R0, #+0]
   \       0xE6   0x6809             LDR      R1,[R1, #+0]
   \       0xE8   0xF451 0x7100      ORRS     R1,R1,#0x200
   \       0xEC   0x6805             LDR      R5,[R0, #+0]
   \       0xEE   0x6029             STR      R1,[R5, #+0]
   \       0xF0   0xE09B             B.N      ??I2C_Master_ADDR_5
   5702                    }
   5703                  }
   5704                  /* Prepare next transfer or stop current transfer */
   5705                  else if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) \
   5706                           && ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (CurrentXferOptions == I2C_FIRST_FRAME)))
   \                     ??I2C_Master_ADDR_7: (+1)
   \       0xF2   0x2B08             CMP      R3,#+8
   \       0xF4   0xD022             BEQ.N    ??I2C_Master_ADDR_9
   \       0xF6   0x2B20             CMP      R3,#+32
   \       0xF8   0xD020             BEQ.N    ??I2C_Master_ADDR_9
   \       0xFA   0x2C12             CMP      R4,#+18
   \       0xFC   0xD101             BNE.N    ??I2C_Master_ADDR_10
   \       0xFE   0x2B01             CMP      R3,#+1
   \      0x100   0xD11C             BNE.N    ??I2C_Master_ADDR_9
   5707                  {
   5708                    if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
   \                     ??I2C_Master_ADDR_10: (+1)
   \      0x102   0x2B04             CMP      R3,#+4
   \      0x104   0xD00A             BEQ.N    ??I2C_Master_ADDR_11
   \      0x106   0x2B02             CMP      R3,#+2
   \      0x108   0xD008             BEQ.N    ??I2C_Master_ADDR_11
   \      0x10A   0x2B10             CMP      R3,#+16
   \      0x10C   0xD006             BEQ.N    ??I2C_Master_ADDR_11
   5709                    {
   5710                      /* Disable Acknowledge */
   5711                      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \      0x10E   0x6801             LDR      R1,[R0, #+0]
   \      0x110   0x6809             LDR      R1,[R1, #+0]
   \      0x112   0xF431 0x6180      BICS     R1,R1,#0x400
   \      0x116   0x6805             LDR      R5,[R0, #+0]
   \      0x118   0x6029             STR      R1,[R5, #+0]
   \      0x11A   0xE005             B.N      ??I2C_Master_ADDR_12
   5712                    }
   5713                    else
   5714                    {
   5715                      /* Enable Acknowledge */
   5716                      SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??I2C_Master_ADDR_11: (+1)
   \      0x11C   0x6801             LDR      R1,[R0, #+0]
   \      0x11E   0x6809             LDR      R1,[R1, #+0]
   \      0x120   0xF451 0x6180      ORRS     R1,R1,#0x400
   \      0x124   0x6805             LDR      R5,[R0, #+0]
   \      0x126   0x6029             STR      R1,[R5, #+0]
   5717                    }
   5718          
   5719                    /* Clear ADDR flag */
   5720                    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_Master_ADDR_12: (+1)
   \      0x128   0x2100             MOVS     R1,#+0
   \      0x12A   0x9100             STR      R1,[SP, #+0]
   \      0x12C   0x6801             LDR      R1,[R0, #+0]
   \      0x12E   0x6949             LDR      R1,[R1, #+20]
   \      0x130   0x9100             STR      R1,[SP, #+0]
   \      0x132   0x6801             LDR      R1,[R0, #+0]
   \      0x134   0x6989             LDR      R1,[R1, #+24]
   \      0x136   0x9100             STR      R1,[SP, #+0]
   \      0x138   0x9900             LDR      R1,[SP, #+0]
   \      0x13A   0xE076             B.N      ??I2C_Master_ADDR_5
   5721                  }
   5722                  else
   5723                  {
   5724                    /* Disable Acknowledge */
   5725                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??I2C_Master_ADDR_9: (+1)
   \      0x13C   0x6801             LDR      R1,[R0, #+0]
   \      0x13E   0x6809             LDR      R1,[R1, #+0]
   \      0x140   0xF431 0x6180      BICS     R1,R1,#0x400
   \      0x144   0x6805             LDR      R5,[R0, #+0]
   \      0x146   0x6029             STR      R1,[R5, #+0]
   5726          
   5727                    /* Clear ADDR flag */
   5728                    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \      0x148   0x2100             MOVS     R1,#+0
   \      0x14A   0x9100             STR      R1,[SP, #+0]
   \      0x14C   0x6801             LDR      R1,[R0, #+0]
   \      0x14E   0x6949             LDR      R1,[R1, #+20]
   \      0x150   0x9100             STR      R1,[SP, #+0]
   \      0x152   0x6801             LDR      R1,[R0, #+0]
   \      0x154   0x6989             LDR      R1,[R1, #+24]
   \      0x156   0x9100             STR      R1,[SP, #+0]
   \      0x158   0x9900             LDR      R1,[SP, #+0]
   5729          
   5730                    /* Generate Stop */
   5731                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \      0x15A   0x6801             LDR      R1,[R0, #+0]
   \      0x15C   0x6809             LDR      R1,[R1, #+0]
   \      0x15E   0xF451 0x7100      ORRS     R1,R1,#0x200
   \      0x162   0x6805             LDR      R5,[R0, #+0]
   \      0x164   0x6029             STR      R1,[R5, #+0]
   \      0x166   0xE060             B.N      ??I2C_Master_ADDR_5
   5732                  }
   5733                }
   5734                else if (hi2c->XferCount == 2U)
   \                     ??I2C_Master_ADDR_6: (+1)
   \      0x168   0x8D41             LDRH     R1,[R0, #+42]
   \      0x16A   0x2902             CMP      R1,#+2
   \      0x16C   0xD138             BNE.N    ??I2C_Master_ADDR_13
   5735                {
   5736                  if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
   \      0x16E   0x2B04             CMP      R3,#+4
   \      0x170   0xD010             BEQ.N    ??I2C_Master_ADDR_14
   \      0x172   0x2B02             CMP      R3,#+2
   \      0x174   0xD00E             BEQ.N    ??I2C_Master_ADDR_14
   \      0x176   0x2B10             CMP      R3,#+16
   \      0x178   0xD00C             BEQ.N    ??I2C_Master_ADDR_14
   5737                  {
   5738                    /* Disable Acknowledge */
   5739                    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \      0x17A   0x6801             LDR      R1,[R0, #+0]
   \      0x17C   0x6809             LDR      R1,[R1, #+0]
   \      0x17E   0xF431 0x6180      BICS     R1,R1,#0x400
   \      0x182   0x6805             LDR      R5,[R0, #+0]
   \      0x184   0x6029             STR      R1,[R5, #+0]
   5740          
   5741                    /* Enable Pos */
   5742                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
   \      0x186   0x6801             LDR      R1,[R0, #+0]
   \      0x188   0x6809             LDR      R1,[R1, #+0]
   \      0x18A   0xF451 0x6100      ORRS     R1,R1,#0x800
   \      0x18E   0x6805             LDR      R5,[R0, #+0]
   \      0x190   0x6029             STR      R1,[R5, #+0]
   \      0x192   0xE005             B.N      ??I2C_Master_ADDR_15
   5743                  }
   5744                  else
   5745                  {
   5746                    /* Enable Acknowledge */
   5747                    SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??I2C_Master_ADDR_14: (+1)
   \      0x194   0x6801             LDR      R1,[R0, #+0]
   \      0x196   0x6809             LDR      R1,[R1, #+0]
   \      0x198   0xF451 0x6180      ORRS     R1,R1,#0x400
   \      0x19C   0x6805             LDR      R5,[R0, #+0]
   \      0x19E   0x6029             STR      R1,[R5, #+0]
   5748                  }
   5749          
   5750                  if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
   \                     ??I2C_Master_ADDR_15: (+1)
   \      0x1A0   0x6801             LDR      R1,[R0, #+0]
   \      0x1A2   0x6849             LDR      R1,[R1, #+4]
   \      0x1A4   0x0509             LSLS     R1,R1,#+20
   \      0x1A6   0xD511             BPL.N    ??I2C_Master_ADDR_16
   \      0x1A8   0x.... 0x....      LDR.W    R1,??DataTable31
   \      0x1AC   0x428B             CMP      R3,R1
   \      0x1AE   0xD007             BEQ.N    ??I2C_Master_ADDR_17
   \      0x1B0   0x2B01             CMP      R3,#+1
   \      0x1B2   0xD005             BEQ.N    ??I2C_Master_ADDR_17
   \      0x1B4   0x2B08             CMP      R3,#+8
   \      0x1B6   0xD003             BEQ.N    ??I2C_Master_ADDR_17
   \      0x1B8   0x2B10             CMP      R3,#+16
   \      0x1BA   0xD001             BEQ.N    ??I2C_Master_ADDR_17
   \      0x1BC   0x2B20             CMP      R3,#+32
   \      0x1BE   0xD105             BNE.N    ??I2C_Master_ADDR_16
   5751                  {
   5752                    /* Enable Last DMA bit */
   5753                    SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \                     ??I2C_Master_ADDR_17: (+1)
   \      0x1C0   0x6801             LDR      R1,[R0, #+0]
   \      0x1C2   0x6849             LDR      R1,[R1, #+4]
   \      0x1C4   0xF451 0x5180      ORRS     R1,R1,#0x1000
   \      0x1C8   0x6805             LDR      R5,[R0, #+0]
   \      0x1CA   0x6069             STR      R1,[R5, #+4]
   5754                  }
   5755          
   5756                  /* Clear ADDR flag */
   5757                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_Master_ADDR_16: (+1)
   \      0x1CC   0x2100             MOVS     R1,#+0
   \      0x1CE   0x9100             STR      R1,[SP, #+0]
   \      0x1D0   0x6801             LDR      R1,[R0, #+0]
   \      0x1D2   0x6949             LDR      R1,[R1, #+20]
   \      0x1D4   0x9100             STR      R1,[SP, #+0]
   \      0x1D6   0x6801             LDR      R1,[R0, #+0]
   \      0x1D8   0x6989             LDR      R1,[R1, #+24]
   \      0x1DA   0x9100             STR      R1,[SP, #+0]
   \      0x1DC   0x9900             LDR      R1,[SP, #+0]
   \      0x1DE   0xE024             B.N      ??I2C_Master_ADDR_5
   5758                }
   5759                else
   5760                {
   5761                  /* Enable Acknowledge */
   5762                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??I2C_Master_ADDR_13: (+1)
   \      0x1E0   0x6801             LDR      R1,[R0, #+0]
   \      0x1E2   0x6809             LDR      R1,[R1, #+0]
   \      0x1E4   0xF451 0x6180      ORRS     R1,R1,#0x400
   \      0x1E8   0x6805             LDR      R5,[R0, #+0]
   \      0x1EA   0x6029             STR      R1,[R5, #+0]
   5763          
   5764                  if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
   \      0x1EC   0x6801             LDR      R1,[R0, #+0]
   \      0x1EE   0x6849             LDR      R1,[R1, #+4]
   \      0x1F0   0x0509             LSLS     R1,R1,#+20
   \      0x1F2   0xD511             BPL.N    ??I2C_Master_ADDR_18
   \      0x1F4   0x.... 0x....      LDR.W    R1,??DataTable31
   \      0x1F8   0x428B             CMP      R3,R1
   \      0x1FA   0xD007             BEQ.N    ??I2C_Master_ADDR_19
   \      0x1FC   0x2B01             CMP      R3,#+1
   \      0x1FE   0xD005             BEQ.N    ??I2C_Master_ADDR_19
   \      0x200   0x2B08             CMP      R3,#+8
   \      0x202   0xD003             BEQ.N    ??I2C_Master_ADDR_19
   \      0x204   0x2B10             CMP      R3,#+16
   \      0x206   0xD001             BEQ.N    ??I2C_Master_ADDR_19
   \      0x208   0x2B20             CMP      R3,#+32
   \      0x20A   0xD105             BNE.N    ??I2C_Master_ADDR_18
   5765                  {
   5766                    /* Enable Last DMA bit */
   5767                    SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \                     ??I2C_Master_ADDR_19: (+1)
   \      0x20C   0x6801             LDR      R1,[R0, #+0]
   \      0x20E   0x6849             LDR      R1,[R1, #+4]
   \      0x210   0xF451 0x5180      ORRS     R1,R1,#0x1000
   \      0x214   0x6805             LDR      R5,[R0, #+0]
   \      0x216   0x6069             STR      R1,[R5, #+4]
   5768                  }
   5769          
   5770                  /* Clear ADDR flag */
   5771                  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_Master_ADDR_18: (+1)
   \      0x218   0x2100             MOVS     R1,#+0
   \      0x21A   0x9100             STR      R1,[SP, #+0]
   \      0x21C   0x6801             LDR      R1,[R0, #+0]
   \      0x21E   0x6949             LDR      R1,[R1, #+20]
   \      0x220   0x9100             STR      R1,[SP, #+0]
   \      0x222   0x6801             LDR      R1,[R0, #+0]
   \      0x224   0x6989             LDR      R1,[R1, #+24]
   \      0x226   0x9100             STR      R1,[SP, #+0]
   \      0x228   0x9900             LDR      R1,[SP, #+0]
   5772                }
   5773          
   5774                /* Reset Event counter  */
   5775                hi2c->EventCount = 0U;
   \                     ??I2C_Master_ADDR_5: (+1)
   \      0x22A   0x2100             MOVS     R1,#+0
   \      0x22C   0x6501             STR      R1,[R0, #+80]
   \      0x22E   0xE008             B.N      ??I2C_Master_ADDR_2
   5776              }
   5777            }
   5778            else
   5779            {
   5780              /* Clear ADDR flag */
   5781              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_Master_ADDR_0: (+1)
   \      0x230   0x2100             MOVS     R1,#+0
   \      0x232   0x9100             STR      R1,[SP, #+0]
   \      0x234   0x6801             LDR      R1,[R0, #+0]
   \      0x236   0x6949             LDR      R1,[R1, #+20]
   \      0x238   0x9100             STR      R1,[SP, #+0]
   \      0x23A   0x6801             LDR      R1,[R0, #+0]
   \      0x23C   0x6989             LDR      R1,[R1, #+24]
   \      0x23E   0x9100             STR      R1,[SP, #+0]
   \      0x240   0x9900             LDR      R1,[SP, #+0]
   5782            }
   5783          }
   \                     ??I2C_Master_ADDR_2: (+1)
   \      0x242   0xBC31             POP      {R0,R4,R5}
   \      0x244   0x4770             BX       LR
   5784          
   5785          /**
   5786            * @brief  Handle TXE flag for Slave
   5787            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5788            *         the configuration information for I2C module
   5789            * @retval None
   5790            */

   \                                 In section .text, align 2, keep-with-next
   5791          static void I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c)
   5792          {
   \                     I2C_SlaveTransmit_TXE: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5793            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   5794            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   \        0x4   0xF894 0x503D      LDRB     R5,[R4, #+61]
   5795          
   5796            if (hi2c->XferCount != 0U)
   \        0x8   0x8D60             LDRH     R0,[R4, #+42]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD01E             BEQ.N    ??I2C_SlaveTransmit_TXE_0
   5797            {
   5798              /* Write data to DR */
   5799              hi2c->Instance->DR = *hi2c->pBuffPtr;
   \        0xE   0x6A60             LDR      R0,[R4, #+36]
   \       0x10   0x7800             LDRB     R0,[R0, #+0]
   \       0x12   0x6821             LDR      R1,[R4, #+0]
   \       0x14   0x6108             STR      R0,[R1, #+16]
   5800          
   5801              /* Increment Buffer pointer */
   5802              hi2c->pBuffPtr++;
   \       0x16   0x6A60             LDR      R0,[R4, #+36]
   \       0x18   0x1C40             ADDS     R0,R0,#+1
   \       0x1A   0x6260             STR      R0,[R4, #+36]
   5803          
   5804              /* Update counter */
   5805              hi2c->XferCount--;
   \       0x1C   0x8D60             LDRH     R0,[R4, #+42]
   \       0x1E   0x1E40             SUBS     R0,R0,#+1
   \       0x20   0x8560             STRH     R0,[R4, #+42]
   5806          
   5807              if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
   \       0x22   0x8D60             LDRH     R0,[R4, #+42]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD111             BNE.N    ??I2C_SlaveTransmit_TXE_0
   \       0x28   0x0028             MOVS     R0,R5
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x2829             CMP      R0,#+41
   \       0x2E   0xD10D             BNE.N    ??I2C_SlaveTransmit_TXE_0
   5808              {
   5809                /* Last Byte is received, disable Interrupt */
   5810                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6840             LDR      R0,[R0, #+4]
   \       0x34   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x38   0x6821             LDR      R1,[R4, #+0]
   \       0x3A   0x6048             STR      R0,[R1, #+4]
   5811          
   5812                /* Set state at HAL_I2C_STATE_LISTEN */
   5813                hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
   \       0x3C   0x2021             MOVS     R0,#+33
   \       0x3E   0x6320             STR      R0,[R4, #+48]
   5814                hi2c->State = HAL_I2C_STATE_LISTEN;
   \       0x40   0x2028             MOVS     R0,#+40
   \       0x42   0xF884 0x003D      STRB     R0,[R4, #+61]
   5815          
   5816                /* Call the corresponding callback to inform upper layer of End of Transfer */
   5817          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5818                hi2c->SlaveTxCpltCallback(hi2c);
   5819          #else
   5820                HAL_I2C_SlaveTxCpltCallback(hi2c);
   \       0x46   0x0020             MOVS     R0,R4
   \       0x48   0x.... 0x....      BL       HAL_I2C_SlaveTxCpltCallback
   5821          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5822              }
   5823            }
   5824          }
   \                     ??I2C_SlaveTransmit_TXE_0: (+1)
   \       0x4C   0xBD31             POP      {R0,R4,R5,PC}
   5825          
   5826          /**
   5827            * @brief  Handle BTF flag for Slave transmitter
   5828            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5829            *         the configuration information for I2C module
   5830            * @retval None
   5831            */

   \                                 In section .text, align 2, keep-with-next
   5832          static void I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)
   5833          {
   5834            if (hi2c->XferCount != 0U)
   \                     I2C_SlaveTransmit_BTF: (+1)
   \        0x0   0x8D41             LDRH     R1,[R0, #+42]
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD009             BEQ.N    ??I2C_SlaveTransmit_BTF_0
   5835            {
   5836              /* Write data to DR */
   5837              hi2c->Instance->DR = *hi2c->pBuffPtr;
   \        0x6   0x6A41             LDR      R1,[R0, #+36]
   \        0x8   0x7809             LDRB     R1,[R1, #+0]
   \        0xA   0x6802             LDR      R2,[R0, #+0]
   \        0xC   0x6111             STR      R1,[R2, #+16]
   5838          
   5839              /* Increment Buffer pointer */
   5840              hi2c->pBuffPtr++;
   \        0xE   0x6A41             LDR      R1,[R0, #+36]
   \       0x10   0x1C49             ADDS     R1,R1,#+1
   \       0x12   0x6241             STR      R1,[R0, #+36]
   5841          
   5842              /* Update counter */
   5843              hi2c->XferCount--;
   \       0x14   0x8D41             LDRH     R1,[R0, #+42]
   \       0x16   0x1E49             SUBS     R1,R1,#+1
   \       0x18   0x8541             STRH     R1,[R0, #+42]
   5844            }
   5845          }
   \                     ??I2C_SlaveTransmit_BTF_0: (+1)
   \       0x1A   0x4770             BX       LR
   5846          
   5847          /**
   5848            * @brief  Handle RXNE flag for Slave
   5849            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5850            *         the configuration information for I2C module
   5851            * @retval None
   5852            */

   \                                 In section .text, align 2, keep-with-next
   5853          static void I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c)
   5854          {
   \                     I2C_SlaveReceive_RXNE: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5855            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   5856            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   \        0x4   0xF894 0x503D      LDRB     R5,[R4, #+61]
   5857          
   5858            if (hi2c->XferCount != 0U)
   \        0x8   0x8D60             LDRH     R0,[R4, #+42]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD01E             BEQ.N    ??I2C_SlaveReceive_RXNE_0
   5859            {
   5860              /* Read data from DR */
   5861              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x6900             LDR      R0,[R0, #+16]
   \       0x12   0x6A61             LDR      R1,[R4, #+36]
   \       0x14   0x7008             STRB     R0,[R1, #+0]
   5862          
   5863              /* Increment Buffer pointer */
   5864              hi2c->pBuffPtr++;
   \       0x16   0x6A60             LDR      R0,[R4, #+36]
   \       0x18   0x1C40             ADDS     R0,R0,#+1
   \       0x1A   0x6260             STR      R0,[R4, #+36]
   5865          
   5866              /* Update counter */
   5867              hi2c->XferCount--;
   \       0x1C   0x8D60             LDRH     R0,[R4, #+42]
   \       0x1E   0x1E40             SUBS     R0,R0,#+1
   \       0x20   0x8560             STRH     R0,[R4, #+42]
   5868          
   5869              if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
   \       0x22   0x8D60             LDRH     R0,[R4, #+42]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD111             BNE.N    ??I2C_SlaveReceive_RXNE_0
   \       0x28   0x0028             MOVS     R0,R5
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x282A             CMP      R0,#+42
   \       0x2E   0xD10D             BNE.N    ??I2C_SlaveReceive_RXNE_0
   5870              {
   5871                /* Last Byte is received, disable Interrupt */
   5872                __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6840             LDR      R0,[R0, #+4]
   \       0x34   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x38   0x6821             LDR      R1,[R4, #+0]
   \       0x3A   0x6048             STR      R0,[R1, #+4]
   5873          
   5874                /* Set state at HAL_I2C_STATE_LISTEN */
   5875                hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
   \       0x3C   0x2022             MOVS     R0,#+34
   \       0x3E   0x6320             STR      R0,[R4, #+48]
   5876                hi2c->State = HAL_I2C_STATE_LISTEN;
   \       0x40   0x2028             MOVS     R0,#+40
   \       0x42   0xF884 0x003D      STRB     R0,[R4, #+61]
   5877          
   5878                /* Call the corresponding callback to inform upper layer of End of Transfer */
   5879          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5880                hi2c->SlaveRxCpltCallback(hi2c);
   5881          #else
   5882                HAL_I2C_SlaveRxCpltCallback(hi2c);
   \       0x46   0x0020             MOVS     R0,R4
   \       0x48   0x.... 0x....      BL       HAL_I2C_SlaveRxCpltCallback
   5883          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5884              }
   5885            }
   5886          }
   \                     ??I2C_SlaveReceive_RXNE_0: (+1)
   \       0x4C   0xBD31             POP      {R0,R4,R5,PC}
   5887          
   5888          /**
   5889            * @brief  Handle BTF flag for Slave receiver
   5890            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5891            *         the configuration information for I2C module
   5892            * @retval None
   5893            */

   \                                 In section .text, align 2, keep-with-next
   5894          static void I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)
   5895          {
   5896            if (hi2c->XferCount != 0U)
   \                     I2C_SlaveReceive_BTF: (+1)
   \        0x0   0x8D41             LDRH     R1,[R0, #+42]
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD009             BEQ.N    ??I2C_SlaveReceive_BTF_0
   5897            {
   5898              /* Read data from DR */
   5899              *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0x6909             LDR      R1,[R1, #+16]
   \        0xA   0x6A42             LDR      R2,[R0, #+36]
   \        0xC   0x7011             STRB     R1,[R2, #+0]
   5900          
   5901              /* Increment Buffer pointer */
   5902              hi2c->pBuffPtr++;
   \        0xE   0x6A41             LDR      R1,[R0, #+36]
   \       0x10   0x1C49             ADDS     R1,R1,#+1
   \       0x12   0x6241             STR      R1,[R0, #+36]
   5903          
   5904              /* Update counter */
   5905              hi2c->XferCount--;
   \       0x14   0x8D41             LDRH     R1,[R0, #+42]
   \       0x16   0x1E49             SUBS     R1,R1,#+1
   \       0x18   0x8541             STRH     R1,[R0, #+42]
   5906            }
   5907          }
   \                     ??I2C_SlaveReceive_BTF_0: (+1)
   \       0x1A   0x4770             BX       LR
   5908          
   5909          /**
   5910            * @brief  Handle ADD flag for Slave
   5911            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5912            *         the configuration information for I2C module
   5913            * @param  IT2Flags Interrupt2 flags to handle.
   5914            * @retval None
   5915            */

   \                                 In section .text, align 2, keep-with-next
   5916          static void I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c, uint32_t IT2Flags)
   5917          {
   \                     I2C_Slave_ADDR: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   5918            uint8_t TransferDirection = I2C_DIRECTION_RECEIVE;
   \        0x6   0x2700             MOVS     R7,#+0
   5919            uint16_t SlaveAddrCode;
   5920          
   5921            if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \        0x8   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \        0xC   0xF010 0x0028      ANDS     R0,R0,#0x28
   \       0x10   0x2828             CMP      R0,#+40
   \       0x12   0xD11B             BNE.N    ??I2C_Slave_ADDR_0
   5922            {
   5923              /* Disable BUF interrupt, BUF enabling is manage through slave specific interface */
   5924              __HAL_I2C_DISABLE_IT(hi2c, (I2C_IT_BUF));
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x6840             LDR      R0,[R0, #+4]
   \       0x18   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x1C   0x6829             LDR      R1,[R5, #+0]
   \       0x1E   0x6048             STR      R0,[R1, #+4]
   5925          
   5926              /* Transfer Direction requested by Master */
   5927              if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_TRA) == RESET)
   \       0x20   0x0770             LSLS     R0,R6,#+29
   \       0x22   0xD401             BMI.N    ??I2C_Slave_ADDR_1
   5928              {
   5929                TransferDirection = I2C_DIRECTION_TRANSMIT;
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0x0007             MOVS     R7,R0
   5930              }
   5931          
   5932              if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_DUALF) == RESET)
   \                     ??I2C_Slave_ADDR_1: (+1)
   \       0x28   0x0630             LSLS     R0,R6,#+24
   \       0x2A   0xD402             BMI.N    ??I2C_Slave_ADDR_2
   5933              {
   5934                SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress1;
   \       0x2C   0x68E8             LDR      R0,[R5, #+12]
   \       0x2E   0x0004             MOVS     R4,R0
   \       0x30   0xE001             B.N      ??I2C_Slave_ADDR_3
   5935              }
   5936              else
   5937              {
   5938                SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress2;
   \                     ??I2C_Slave_ADDR_2: (+1)
   \       0x32   0x69A8             LDR      R0,[R5, #+24]
   \       0x34   0x0004             MOVS     R4,R0
   5939              }
   5940          
   5941              /* Process Unlocked */
   5942              __HAL_UNLOCK(hi2c);
   \                     ??I2C_Slave_ADDR_3: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xF885 0x003C      STRB     R0,[R5, #+60]
   5943          
   5944              /* Call Slave Addr callback */
   5945          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   5946              hi2c->AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
   5947          #else
   5948              HAL_I2C_AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
   \       0x3C   0x0022             MOVS     R2,R4
   \       0x3E   0xB292             UXTH     R2,R2
   \       0x40   0x0039             MOVS     R1,R7
   \       0x42   0xB2C9             UXTB     R1,R1
   \       0x44   0x0028             MOVS     R0,R5
   \       0x46   0x.... 0x....      BL       HAL_I2C_AddrCallback
   \       0x4A   0xE006             B.N      ??I2C_Slave_ADDR_4
   5949          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   5950            }
   5951            else
   5952            {
   5953              /* Clear ADDR flag */
   5954              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
   \                     ??I2C_Slave_ADDR_0: (+1)
   \       0x4C   0xF07F 0x0002      MVNS     R0,#+2
   \       0x50   0x6829             LDR      R1,[R5, #+0]
   \       0x52   0x6148             STR      R0,[R1, #+20]
   5955          
   5956              /* Process Unlocked */
   5957              __HAL_UNLOCK(hi2c);
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xF885 0x003C      STRB     R0,[R5, #+60]
   5958            }
   5959          }
   \                     ??I2C_Slave_ADDR_4: (+1)
   \       0x5A   0xBDF1             POP      {R0,R4-R7,PC}
   5960          
   5961          /**
   5962            * @brief  Handle STOPF flag for Slave
   5963            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   5964            *         the configuration information for I2C module
   5965            * @retval None
   5966            */

   \                                 In section .text, align 2, keep-with-next
   5967          static void I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c)
   5968          {
   \                     I2C_Slave_STOPF: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5969            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   5970            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   \        0x4   0xF894 0x503D      LDRB     R5,[R4, #+61]
   5971          
   5972            /* Disable EVT, BUF and ERR interrupt */
   5973            __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x6840             LDR      R0,[R0, #+4]
   \        0xC   0xF430 0x60E0      BICS     R0,R0,#0x700
   \       0x10   0x6821             LDR      R1,[R4, #+0]
   \       0x12   0x6048             STR      R0,[R1, #+4]
   5974          
   5975            /* Clear STOPF flag */
   5976            __HAL_I2C_CLEAR_STOPFLAG(hi2c);
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x9000             STR      R0,[SP, #+0]
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x6940             LDR      R0,[R0, #+20]
   \       0x1C   0x9000             STR      R0,[SP, #+0]
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6800             LDR      R0,[R0, #+0]
   \       0x22   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0x26   0x6821             LDR      R1,[R4, #+0]
   \       0x28   0x6008             STR      R0,[R1, #+0]
   \       0x2A   0x9800             LDR      R0,[SP, #+0]
   5977          
   5978            /* Disable Acknowledge */
   5979            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6800             LDR      R0,[R0, #+0]
   \       0x30   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x34   0x6821             LDR      R1,[R4, #+0]
   \       0x36   0x6008             STR      R0,[R1, #+0]
   5980          
   5981            /* If a DMA is ongoing, Update handle size context */
   5982            if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x6840             LDR      R0,[R0, #+4]
   \       0x3C   0x0500             LSLS     R0,R0,#+20
   \       0x3E   0xD54E             BPL.N    ??I2C_Slave_STOPF_0
   5983            {
   5984              if ((CurrentState == HAL_I2C_STATE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
   \       0x40   0x0028             MOVS     R0,R5
   \       0x42   0xB2C0             UXTB     R0,R0
   \       0x44   0x2822             CMP      R0,#+34
   \       0x46   0xD003             BEQ.N    ??I2C_Slave_STOPF_1
   \       0x48   0x0028             MOVS     R0,R5
   \       0x4A   0xB2C0             UXTB     R0,R0
   \       0x4C   0x282A             CMP      R0,#+42
   \       0x4E   0xD123             BNE.N    ??I2C_Slave_STOPF_2
   5985              {
   5986                hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmarx));
   \                     ??I2C_Slave_STOPF_1: (+1)
   \       0x50   0x6BA0             LDR      R0,[R4, #+56]
   \       0x52   0x6800             LDR      R0,[R0, #+0]
   \       0x54   0x6840             LDR      R0,[R0, #+4]
   \       0x56   0x8560             STRH     R0,[R4, #+42]
   5987          
   5988                if (hi2c->XferCount != 0U)
   \       0x58   0x8D60             LDRH     R0,[R4, #+42]
   \       0x5A   0x2800             CMP      R0,#+0
   \       0x5C   0xD003             BEQ.N    ??I2C_Slave_STOPF_3
   5989                {
   5990                  /* Set ErrorCode corresponding to a Non-Acknowledge */
   5991                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \       0x5E   0x6C20             LDR      R0,[R4, #+64]
   \       0x60   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x64   0x6420             STR      R0,[R4, #+64]
   5992                }
   5993          
   5994                /* Disable, stop the current DMA */
   5995                CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \                     ??I2C_Slave_STOPF_3: (+1)
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x6840             LDR      R0,[R0, #+4]
   \       0x6A   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x6E   0x6821             LDR      R1,[R4, #+0]
   \       0x70   0x6048             STR      R0,[R1, #+4]
   5996          
   5997                /* Abort DMA Xfer if any */
   5998                if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
   \       0x72   0x6BA0             LDR      R0,[R4, #+56]
   \       0x74   0x.... 0x....      BL       HAL_DMA_GetState
   \       0x78   0x2801             CMP      R0,#+1
   \       0x7A   0xD030             BEQ.N    ??I2C_Slave_STOPF_0
   5999                {
   6000                  /* Set the I2C DMA Abort callback :
   6001                  will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   6002                  hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
   \       0x7C   0x.... 0x....      ADR.W    R0,I2C_DMAAbort
   \       0x80   0x6BA1             LDR      R1,[R4, #+56]
   \       0x82   0x6508             STR      R0,[R1, #+80]
   6003          
   6004                  /* Abort DMA RX */
   6005                  if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
   \       0x84   0x6BA0             LDR      R0,[R4, #+56]
   \       0x86   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD027             BEQ.N    ??I2C_Slave_STOPF_0
   6006                  {
   6007                    /* Call Directly XferAbortCallback function in case of error */
   6008                    hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
   \       0x8E   0x6BA0             LDR      R0,[R4, #+56]
   \       0x90   0x6BA1             LDR      R1,[R4, #+56]
   \       0x92   0x6D09             LDR      R1,[R1, #+80]
   \       0x94   0x4788             BLX      R1
   \       0x96   0xE022             B.N      ??I2C_Slave_STOPF_0
   6009                  }
   6010                }
   6011              }
   6012              else
   6013              {
   6014                hi2c->XferCount = (uint16_t)(__HAL_DMA_GET_COUNTER(hi2c->hdmatx));
   \                     ??I2C_Slave_STOPF_2: (+1)
   \       0x98   0x6B60             LDR      R0,[R4, #+52]
   \       0x9A   0x6800             LDR      R0,[R0, #+0]
   \       0x9C   0x6840             LDR      R0,[R0, #+4]
   \       0x9E   0x8560             STRH     R0,[R4, #+42]
   6015          
   6016                if (hi2c->XferCount != 0U)
   \       0xA0   0x8D60             LDRH     R0,[R4, #+42]
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD003             BEQ.N    ??I2C_Slave_STOPF_4
   6017                {
   6018                  /* Set ErrorCode corresponding to a Non-Acknowledge */
   6019                  hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \       0xA6   0x6C20             LDR      R0,[R4, #+64]
   \       0xA8   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0xAC   0x6420             STR      R0,[R4, #+64]
   6020                }
   6021          
   6022                /* Disable, stop the current DMA */
   6023                CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \                     ??I2C_Slave_STOPF_4: (+1)
   \       0xAE   0x6820             LDR      R0,[R4, #+0]
   \       0xB0   0x6840             LDR      R0,[R0, #+4]
   \       0xB2   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0xB6   0x6821             LDR      R1,[R4, #+0]
   \       0xB8   0x6048             STR      R0,[R1, #+4]
   6024          
   6025                /* Abort DMA Xfer if any */
   6026                if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
   \       0xBA   0x6B60             LDR      R0,[R4, #+52]
   \       0xBC   0x.... 0x....      BL       HAL_DMA_GetState
   \       0xC0   0x2801             CMP      R0,#+1
   \       0xC2   0xD00C             BEQ.N    ??I2C_Slave_STOPF_0
   6027                {
   6028                  /* Set the I2C DMA Abort callback :
   6029                  will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   6030                  hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
   \       0xC4   0x.... 0x....      ADR.W    R0,I2C_DMAAbort
   \       0xC8   0x6B61             LDR      R1,[R4, #+52]
   \       0xCA   0x6508             STR      R0,[R1, #+80]
   6031          
   6032                  /* Abort DMA TX */
   6033                  if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
   \       0xCC   0x6B60             LDR      R0,[R4, #+52]
   \       0xCE   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0xD2   0x2800             CMP      R0,#+0
   \       0xD4   0xD003             BEQ.N    ??I2C_Slave_STOPF_0
   6034                  {
   6035                    /* Call Directly XferAbortCallback function in case of error */
   6036                    hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
   \       0xD6   0x6B60             LDR      R0,[R4, #+52]
   \       0xD8   0x6B61             LDR      R1,[R4, #+52]
   \       0xDA   0x6D09             LDR      R1,[R1, #+80]
   \       0xDC   0x4788             BLX      R1
   6037                  }
   6038                }
   6039              }
   6040            }
   6041          
   6042            /* All data are not transferred, so set error code accordingly */
   6043            if (hi2c->XferCount != 0U)
   \                     ??I2C_Slave_STOPF_0: (+1)
   \       0xDE   0x8D60             LDRH     R0,[R4, #+42]
   \       0xE0   0x2800             CMP      R0,#+0
   \       0xE2   0xD022             BEQ.N    ??I2C_Slave_STOPF_5
   6044            {
   6045              /* Store Last receive data if any */
   6046              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
   \       0xE4   0x6820             LDR      R0,[R4, #+0]
   \       0xE6   0x6940             LDR      R0,[R0, #+20]
   \       0xE8   0x0740             LSLS     R0,R0,#+29
   \       0xEA   0xD509             BPL.N    ??I2C_Slave_STOPF_6
   6047              {
   6048                /* Read data from DR */
   6049                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \       0xEC   0x6820             LDR      R0,[R4, #+0]
   \       0xEE   0x6900             LDR      R0,[R0, #+16]
   \       0xF0   0x6A61             LDR      R1,[R4, #+36]
   \       0xF2   0x7008             STRB     R0,[R1, #+0]
   6050          
   6051                /* Increment Buffer pointer */
   6052                hi2c->pBuffPtr++;
   \       0xF4   0x6A60             LDR      R0,[R4, #+36]
   \       0xF6   0x1C40             ADDS     R0,R0,#+1
   \       0xF8   0x6260             STR      R0,[R4, #+36]
   6053          
   6054                /* Update counter */
   6055                hi2c->XferCount--;
   \       0xFA   0x8D60             LDRH     R0,[R4, #+42]
   \       0xFC   0x1E40             SUBS     R0,R0,#+1
   \       0xFE   0x8560             STRH     R0,[R4, #+42]
   6056              }
   6057          
   6058              /* Store Last receive data if any */
   6059              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   \                     ??I2C_Slave_STOPF_6: (+1)
   \      0x100   0x6820             LDR      R0,[R4, #+0]
   \      0x102   0x6940             LDR      R0,[R0, #+20]
   \      0x104   0x0640             LSLS     R0,R0,#+25
   \      0x106   0xD509             BPL.N    ??I2C_Slave_STOPF_7
   6060              {
   6061                /* Read data from DR */
   6062                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x108   0x6820             LDR      R0,[R4, #+0]
   \      0x10A   0x6900             LDR      R0,[R0, #+16]
   \      0x10C   0x6A61             LDR      R1,[R4, #+36]
   \      0x10E   0x7008             STRB     R0,[R1, #+0]
   6063          
   6064                /* Increment Buffer pointer */
   6065                hi2c->pBuffPtr++;
   \      0x110   0x6A60             LDR      R0,[R4, #+36]
   \      0x112   0x1C40             ADDS     R0,R0,#+1
   \      0x114   0x6260             STR      R0,[R4, #+36]
   6066          
   6067                /* Update counter */
   6068                hi2c->XferCount--;
   \      0x116   0x8D60             LDRH     R0,[R4, #+42]
   \      0x118   0x1E40             SUBS     R0,R0,#+1
   \      0x11A   0x8560             STRH     R0,[R4, #+42]
   6069              }
   6070          
   6071              if (hi2c->XferCount != 0U)
   \                     ??I2C_Slave_STOPF_7: (+1)
   \      0x11C   0x8D60             LDRH     R0,[R4, #+42]
   \      0x11E   0x2800             CMP      R0,#+0
   \      0x120   0xD003             BEQ.N    ??I2C_Slave_STOPF_5
   6072              {
   6073                /* Set ErrorCode corresponding to a Non-Acknowledge */
   6074                hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
   \      0x122   0x6C20             LDR      R0,[R4, #+64]
   \      0x124   0xF050 0x0004      ORRS     R0,R0,#0x4
   \      0x128   0x6420             STR      R0,[R4, #+64]
   6075              }
   6076            }
   6077          
   6078            if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \                     ??I2C_Slave_STOPF_5: (+1)
   \      0x12A   0x6C20             LDR      R0,[R4, #+64]
   \      0x12C   0x2800             CMP      R0,#+0
   \      0x12E   0xD003             BEQ.N    ??I2C_Slave_STOPF_8
   6079            {
   6080              /* Call the corresponding callback to inform upper layer of End of Transfer */
   6081              I2C_ITError(hi2c);
   \      0x130   0x0020             MOVS     R0,R4
   \      0x132   0x.... 0x....      BL       I2C_ITError
   \      0x136   0xE02F             B.N      ??I2C_Slave_STOPF_9
   6082            }
   6083            else
   6084            {
   6085              if (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN)
   \                     ??I2C_Slave_STOPF_8: (+1)
   \      0x138   0x0028             MOVS     R0,R5
   \      0x13A   0xB2C0             UXTB     R0,R0
   \      0x13C   0x282A             CMP      R0,#+42
   \      0x13E   0xD107             BNE.N    ??I2C_Slave_STOPF_10
   6086              {
   6087                /* Set state at HAL_I2C_STATE_LISTEN */
   6088                hi2c->PreviousState = I2C_STATE_NONE;
   \      0x140   0x2000             MOVS     R0,#+0
   \      0x142   0x6320             STR      R0,[R4, #+48]
   6089                hi2c->State = HAL_I2C_STATE_LISTEN;
   \      0x144   0x2028             MOVS     R0,#+40
   \      0x146   0xF884 0x003D      STRB     R0,[R4, #+61]
   6090          
   6091                /* Call the corresponding callback to inform upper layer of End of Transfer */
   6092          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6093                hi2c->SlaveRxCpltCallback(hi2c);
   6094          #else
   6095                HAL_I2C_SlaveRxCpltCallback(hi2c);
   \      0x14A   0x0020             MOVS     R0,R4
   \      0x14C   0x.... 0x....      BL       HAL_I2C_SlaveRxCpltCallback
   6096          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6097              }
   6098          
   6099              if (hi2c->State == HAL_I2C_STATE_LISTEN)
   \                     ??I2C_Slave_STOPF_10: (+1)
   \      0x150   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \      0x154   0x2828             CMP      R0,#+40
   \      0x156   0xD10D             BNE.N    ??I2C_Slave_STOPF_11
   6100              {
   6101                hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \      0x158   0x....             LDR.N    R0,??DataTable31
   \      0x15A   0x62E0             STR      R0,[R4, #+44]
   6102                hi2c->PreviousState = I2C_STATE_NONE;
   \      0x15C   0x2000             MOVS     R0,#+0
   \      0x15E   0x6320             STR      R0,[R4, #+48]
   6103                hi2c->State = HAL_I2C_STATE_READY;
   \      0x160   0x2020             MOVS     R0,#+32
   \      0x162   0xF884 0x003D      STRB     R0,[R4, #+61]
   6104                hi2c->Mode = HAL_I2C_MODE_NONE;
   \      0x166   0x2000             MOVS     R0,#+0
   \      0x168   0xF884 0x003E      STRB     R0,[R4, #+62]
   6105          
   6106                /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
   6107          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6108                hi2c->ListenCpltCallback(hi2c);
   6109          #else
   6110                HAL_I2C_ListenCpltCallback(hi2c);
   \      0x16C   0x0020             MOVS     R0,R4
   \      0x16E   0x.... 0x....      BL       HAL_I2C_ListenCpltCallback
   \      0x172   0xE011             B.N      ??I2C_Slave_STOPF_9
   6111          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6112              }
   6113              else
   6114              {
   6115                if ((hi2c->PreviousState  == I2C_STATE_SLAVE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX))
   \                     ??I2C_Slave_STOPF_11: (+1)
   \      0x174   0x6B20             LDR      R0,[R4, #+48]
   \      0x176   0x2822             CMP      R0,#+34
   \      0x178   0xD003             BEQ.N    ??I2C_Slave_STOPF_12
   \      0x17A   0x0028             MOVS     R0,R5
   \      0x17C   0xB2C0             UXTB     R0,R0
   \      0x17E   0x2822             CMP      R0,#+34
   \      0x180   0xD10A             BNE.N    ??I2C_Slave_STOPF_9
   6116                {
   6117                  hi2c->PreviousState = I2C_STATE_NONE;
   \                     ??I2C_Slave_STOPF_12: (+1)
   \      0x182   0x2000             MOVS     R0,#+0
   \      0x184   0x6320             STR      R0,[R4, #+48]
   6118                  hi2c->State = HAL_I2C_STATE_READY;
   \      0x186   0x2020             MOVS     R0,#+32
   \      0x188   0xF884 0x003D      STRB     R0,[R4, #+61]
   6119                  hi2c->Mode = HAL_I2C_MODE_NONE;
   \      0x18C   0x2000             MOVS     R0,#+0
   \      0x18E   0xF884 0x003E      STRB     R0,[R4, #+62]
   6120          
   6121          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6122                  hi2c->SlaveRxCpltCallback(hi2c);
   6123          #else
   6124                  HAL_I2C_SlaveRxCpltCallback(hi2c);
   \      0x192   0x0020             MOVS     R0,R4
   \      0x194   0x.... 0x....      BL       HAL_I2C_SlaveRxCpltCallback
   6125          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6126                }
   6127              }
   6128            }
   6129          }
   \                     ??I2C_Slave_STOPF_9: (+1)
   \      0x198   0xBD31             POP      {R0,R4,R5,PC}
   6130          
   6131          /**
   6132            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6133            *         the configuration information for I2C module
   6134            * @retval None
   6135            */

   \                                 In section .text, align 2, keep-with-next
   6136          static void I2C_Slave_AF(I2C_HandleTypeDef *hi2c)
   6137          {
   \                     I2C_Slave_AF: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   6138            /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
   6139            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   \        0x4   0xF894 0x503D      LDRB     R5,[R4, #+61]
   6140            uint32_t CurrentXferOptions       = hi2c->XferOptions;
   \        0x8   0x6AE6             LDR      R6,[R4, #+44]
   6141          
   6142            if (((CurrentXferOptions ==  I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME)) && \
   6143                (CurrentState == HAL_I2C_STATE_LISTEN))
   \        0xA   0x2E08             CMP      R6,#+8
   \        0xC   0xD001             BEQ.N    ??I2C_Slave_AF_0
   \        0xE   0x2E20             CMP      R6,#+32
   \       0x10   0xD121             BNE.N    ??I2C_Slave_AF_1
   \                     ??I2C_Slave_AF_0: (+1)
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x2828             CMP      R0,#+40
   \       0x18   0xD11D             BNE.N    ??I2C_Slave_AF_1
   6144            {
   6145              hi2c->XferOptions = I2C_NO_OPTION_FRAME;
   \       0x1A   0x....             LDR.N    R0,??DataTable31
   \       0x1C   0x62E0             STR      R0,[R4, #+44]
   6146          
   6147              /* Disable EVT, BUF and ERR interrupt */
   6148              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6840             LDR      R0,[R0, #+4]
   \       0x22   0xF430 0x60E0      BICS     R0,R0,#0x700
   \       0x26   0x6821             LDR      R1,[R4, #+0]
   \       0x28   0x6048             STR      R0,[R1, #+4]
   6149          
   6150              /* Clear AF flag */
   6151              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \       0x2A   0xF47F 0x6080      MVNS     R0,#+1024
   \       0x2E   0x6821             LDR      R1,[R4, #+0]
   \       0x30   0x6148             STR      R0,[R1, #+20]
   6152          
   6153              /* Disable Acknowledge */
   6154              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x6800             LDR      R0,[R0, #+0]
   \       0x36   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x3A   0x6821             LDR      R1,[R4, #+0]
   \       0x3C   0x6008             STR      R0,[R1, #+0]
   6155          
   6156              hi2c->PreviousState = I2C_STATE_NONE;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x6320             STR      R0,[R4, #+48]
   6157              hi2c->State         = HAL_I2C_STATE_READY;
   \       0x42   0x2020             MOVS     R0,#+32
   \       0x44   0xF884 0x003D      STRB     R0,[R4, #+61]
   6158              hi2c->Mode          = HAL_I2C_MODE_NONE;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0xF884 0x003E      STRB     R0,[R4, #+62]
   6159          
   6160              /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
   6161          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6162              hi2c->ListenCpltCallback(hi2c);
   6163          #else
   6164              HAL_I2C_ListenCpltCallback(hi2c);
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x.... 0x....      BL       HAL_I2C_ListenCpltCallback
   \       0x54   0xE025             B.N      ??I2C_Slave_AF_2
   6165          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6166            }
   6167            else if (CurrentState == HAL_I2C_STATE_BUSY_TX)
   \                     ??I2C_Slave_AF_1: (+1)
   \       0x56   0x0028             MOVS     R0,R5
   \       0x58   0xB2C0             UXTB     R0,R0
   \       0x5A   0x2821             CMP      R0,#+33
   \       0x5C   0xD11D             BNE.N    ??I2C_Slave_AF_3
   6168            {
   6169              hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
   \       0x5E   0x....             LDR.N    R0,??DataTable31
   \       0x60   0x62E0             STR      R0,[R4, #+44]
   6170              hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
   \       0x62   0x2021             MOVS     R0,#+33
   \       0x64   0x6320             STR      R0,[R4, #+48]
   6171              hi2c->State         = HAL_I2C_STATE_READY;
   \       0x66   0x2020             MOVS     R0,#+32
   \       0x68   0xF884 0x003D      STRB     R0,[R4, #+61]
   6172              hi2c->Mode          = HAL_I2C_MODE_NONE;
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0xF884 0x003E      STRB     R0,[R4, #+62]
   6173          
   6174              /* Disable EVT, BUF and ERR interrupt */
   6175              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x6840             LDR      R0,[R0, #+4]
   \       0x76   0xF430 0x60E0      BICS     R0,R0,#0x700
   \       0x7A   0x6821             LDR      R1,[R4, #+0]
   \       0x7C   0x6048             STR      R0,[R1, #+4]
   6176          
   6177              /* Clear AF flag */
   6178              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \       0x7E   0xF47F 0x6080      MVNS     R0,#+1024
   \       0x82   0x6821             LDR      R1,[R4, #+0]
   \       0x84   0x6148             STR      R0,[R1, #+20]
   6179          
   6180              /* Disable Acknowledge */
   6181              CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x6800             LDR      R0,[R0, #+0]
   \       0x8A   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x8E   0x6821             LDR      R1,[R4, #+0]
   \       0x90   0x6008             STR      R0,[R1, #+0]
   6182          
   6183          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6184              hi2c->SlaveTxCpltCallback(hi2c);
   6185          #else
   6186              HAL_I2C_SlaveTxCpltCallback(hi2c);
   \       0x92   0x0020             MOVS     R0,R4
   \       0x94   0x.... 0x....      BL       HAL_I2C_SlaveTxCpltCallback
   \       0x98   0xE003             B.N      ??I2C_Slave_AF_2
   6187          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6188            }
   6189            else
   6190            {
   6191              /* Clear AF flag only */
   6192              /* State Listen, but XferOptions == FIRST or NEXT */
   6193              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \                     ??I2C_Slave_AF_3: (+1)
   \       0x9A   0xF47F 0x6080      MVNS     R0,#+1024
   \       0x9E   0x6821             LDR      R1,[R4, #+0]
   \       0xA0   0x6148             STR      R0,[R1, #+20]
   6194            }
   6195          }
   \                     ??I2C_Slave_AF_2: (+1)
   \       0xA2   0xBD70             POP      {R4-R6,PC}
   6196          
   6197          /**
   6198            * @brief  I2C interrupts error process
   6199            * @param  hi2c I2C handle.
   6200            * @retval None
   6201            */

   \                                 In section .text, align 2, keep-with-next
   6202          static void I2C_ITError(I2C_HandleTypeDef *hi2c)
   6203          {
   \                     I2C_ITError: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   6204            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   6205            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   \        0x6   0xF894 0x503D      LDRB     R5,[R4, #+61]
   6206            HAL_I2C_ModeTypeDef CurrentMode = hi2c->Mode;
   \        0xA   0xF894 0x603E      LDRB     R6,[R4, #+62]
   6207            uint32_t CurrentError;
   6208          
   6209            if (((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM)) && (CurrentState == HAL_I2C_STATE_BUSY_RX))
   \        0xE   0x0030             MOVS     R0,R6
   \       0x10   0xB2C0             UXTB     R0,R0
   \       0x12   0x2810             CMP      R0,#+16
   \       0x14   0xD003             BEQ.N    ??I2C_ITError_0
   \       0x16   0x0030             MOVS     R0,R6
   \       0x18   0xB2C0             UXTB     R0,R0
   \       0x1A   0x2840             CMP      R0,#+64
   \       0x1C   0xD109             BNE.N    ??I2C_ITError_1
   \                     ??I2C_ITError_0: (+1)
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0x2822             CMP      R0,#+34
   \       0x24   0xD105             BNE.N    ??I2C_ITError_1
   6210            {
   6211              /* Disable Pos bit in I2C CR1 when error occurred in Master/Mem Receive IT Process */
   6212              hi2c->Instance->CR1 &= ~I2C_CR1_POS;
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x2E   0x6821             LDR      R1,[R4, #+0]
   \       0x30   0x6008             STR      R0,[R1, #+0]
   6213            }
   6214          
   6215            if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \                     ??I2C_ITError_1: (+1)
   \       0x32   0x0028             MOVS     R0,R5
   \       0x34   0xB2C0             UXTB     R0,R0
   \       0x36   0xF010 0x0028      ANDS     R0,R0,#0x28
   \       0x3A   0x2828             CMP      R0,#+40
   \       0x3C   0xD105             BNE.N    ??I2C_ITError_2
   6216            {
   6217              /* keep HAL_I2C_STATE_LISTEN */
   6218              hi2c->PreviousState = I2C_STATE_NONE;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x6320             STR      R0,[R4, #+48]
   6219              hi2c->State = HAL_I2C_STATE_LISTEN;
   \       0x42   0x2028             MOVS     R0,#+40
   \       0x44   0xF884 0x003D      STRB     R0,[R4, #+61]
   \       0x48   0xE00F             B.N      ??I2C_ITError_3
   6220            }
   6221            else
   6222            {
   6223              /* If state is an abort treatment on going, don't change state */
   6224              /* This change will be do later */
   6225              if ((READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN) && (CurrentState != HAL_I2C_STATE_ABORT))
   \                     ??I2C_ITError_2: (+1)
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x6840             LDR      R0,[R0, #+4]
   \       0x4E   0x0500             LSLS     R0,R0,#+20
   \       0x50   0xD409             BMI.N    ??I2C_ITError_4
   \       0x52   0x0028             MOVS     R0,R5
   \       0x54   0xB2C0             UXTB     R0,R0
   \       0x56   0x2860             CMP      R0,#+96
   \       0x58   0xD005             BEQ.N    ??I2C_ITError_4
   6226              {
   6227                hi2c->State = HAL_I2C_STATE_READY;
   \       0x5A   0x2020             MOVS     R0,#+32
   \       0x5C   0xF884 0x003D      STRB     R0,[R4, #+61]
   6228                hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0xF884 0x003E      STRB     R0,[R4, #+62]
   6229              }
   6230              hi2c->PreviousState = I2C_STATE_NONE;
   \                     ??I2C_ITError_4: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x6320             STR      R0,[R4, #+48]
   6231            }
   6232          
   6233            /* Abort DMA transfer */
   6234            if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
   \                     ??I2C_ITError_3: (+1)
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x6840             LDR      R0,[R0, #+4]
   \       0x6E   0x0500             LSLS     R0,R0,#+20
   \       0x70   0xD543             BPL.N    ??I2C_ITError_5
   6235            {
   6236              hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x6840             LDR      R0,[R0, #+4]
   \       0x76   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x7A   0x6821             LDR      R1,[R4, #+0]
   \       0x7C   0x6048             STR      R0,[R1, #+4]
   6237          
   6238              if (hi2c->hdmatx->State != HAL_DMA_STATE_READY)
   \       0x7E   0x6B60             LDR      R0,[R4, #+52]
   \       0x80   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \       0x84   0x2801             CMP      R0,#+1
   \       0x86   0xD016             BEQ.N    ??I2C_ITError_6
   6239              {
   6240                /* Set the DMA Abort callback :
   6241                will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   6242                hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
   \       0x88   0x.... 0x....      ADR.W    R0,I2C_DMAAbort
   \       0x8C   0x6B61             LDR      R1,[R4, #+52]
   \       0x8E   0x6508             STR      R0,[R1, #+80]
   6243          
   6244                if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
   \       0x90   0x6B60             LDR      R0,[R4, #+52]
   \       0x92   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD05B             BEQ.N    ??I2C_ITError_7
   6245                {
   6246                  /* Disable I2C peripheral to prevent dummy data in buffer */
   6247                  __HAL_I2C_DISABLE(hi2c);
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0x6800             LDR      R0,[R0, #+0]
   \       0x9E   0x0840             LSRS     R0,R0,#+1
   \       0xA0   0x0040             LSLS     R0,R0,#+1
   \       0xA2   0x6821             LDR      R1,[R4, #+0]
   \       0xA4   0x6008             STR      R0,[R1, #+0]
   6248          
   6249                  hi2c->State = HAL_I2C_STATE_READY;
   \       0xA6   0x2020             MOVS     R0,#+32
   \       0xA8   0xF884 0x003D      STRB     R0,[R4, #+61]
   6250          
   6251                  /* Call Directly XferAbortCallback function in case of error */
   6252                  hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
   \       0xAC   0x6B60             LDR      R0,[R4, #+52]
   \       0xAE   0x6B61             LDR      R1,[R4, #+52]
   \       0xB0   0x6D09             LDR      R1,[R1, #+80]
   \       0xB2   0x4788             BLX      R1
   \       0xB4   0xE04D             B.N      ??I2C_ITError_7
   6253                }
   6254              }
   6255              else
   6256              {
   6257                /* Set the DMA Abort callback :
   6258                will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
   6259                hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
   \                     ??I2C_ITError_6: (+1)
   \       0xB6   0x.... 0x....      ADR.W    R0,I2C_DMAAbort
   \       0xBA   0x6BA1             LDR      R1,[R4, #+56]
   \       0xBC   0x6508             STR      R0,[R1, #+80]
   6260          
   6261                if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
   \       0xBE   0x6BA0             LDR      R0,[R4, #+56]
   \       0xC0   0x.... 0x....      BL       HAL_DMA_Abort_IT
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xD044             BEQ.N    ??I2C_ITError_7
   6262                {
   6263                  /* Store Last receive data if any */
   6264                  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   \       0xC8   0x6820             LDR      R0,[R4, #+0]
   \       0xCA   0x6940             LDR      R0,[R0, #+20]
   \       0xCC   0x0640             LSLS     R0,R0,#+25
   \       0xCE   0xD506             BPL.N    ??I2C_ITError_8
   6265                  {
   6266                    /* Read data from DR */
   6267                    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \       0xD0   0x6820             LDR      R0,[R4, #+0]
   \       0xD2   0x6900             LDR      R0,[R0, #+16]
   \       0xD4   0x6A61             LDR      R1,[R4, #+36]
   \       0xD6   0x7008             STRB     R0,[R1, #+0]
   6268          
   6269                    /* Increment Buffer pointer */
   6270                    hi2c->pBuffPtr++;
   \       0xD8   0x6A60             LDR      R0,[R4, #+36]
   \       0xDA   0x1C40             ADDS     R0,R0,#+1
   \       0xDC   0x6260             STR      R0,[R4, #+36]
   6271                  }
   6272          
   6273                  /* Disable I2C peripheral to prevent dummy data in buffer */
   6274                  __HAL_I2C_DISABLE(hi2c);
   \                     ??I2C_ITError_8: (+1)
   \       0xDE   0x6820             LDR      R0,[R4, #+0]
   \       0xE0   0x6800             LDR      R0,[R0, #+0]
   \       0xE2   0x0840             LSRS     R0,R0,#+1
   \       0xE4   0x0040             LSLS     R0,R0,#+1
   \       0xE6   0x6821             LDR      R1,[R4, #+0]
   \       0xE8   0x6008             STR      R0,[R1, #+0]
   6275          
   6276                  hi2c->State = HAL_I2C_STATE_READY;
   \       0xEA   0x2020             MOVS     R0,#+32
   \       0xEC   0xF884 0x003D      STRB     R0,[R4, #+61]
   6277          
   6278                  /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
   6279                  hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
   \       0xF0   0x6BA0             LDR      R0,[R4, #+56]
   \       0xF2   0x6BA1             LDR      R1,[R4, #+56]
   \       0xF4   0x6D09             LDR      R1,[R1, #+80]
   \       0xF6   0x4788             BLX      R1
   \       0xF8   0xE02B             B.N      ??I2C_ITError_7
   6280                }
   6281              }
   6282            }
   6283            else if (hi2c->State == HAL_I2C_STATE_ABORT)
   \                     ??I2C_ITError_5: (+1)
   \       0xFA   0xF894 0x003D      LDRB     R0,[R4, #+61]
   \       0xFE   0x2860             CMP      R0,#+96
   \      0x100   0xD119             BNE.N    ??I2C_ITError_9
   6284            {
   6285              hi2c->State = HAL_I2C_STATE_READY;
   \      0x102   0x2020             MOVS     R0,#+32
   \      0x104   0xF884 0x003D      STRB     R0,[R4, #+61]
   6286              hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
   \      0x108   0x2000             MOVS     R0,#+0
   \      0x10A   0x6420             STR      R0,[R4, #+64]
   6287          
   6288              /* Store Last receive data if any */
   6289              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   \      0x10C   0x6820             LDR      R0,[R4, #+0]
   \      0x10E   0x6940             LDR      R0,[R0, #+20]
   \      0x110   0x0640             LSLS     R0,R0,#+25
   \      0x112   0xD506             BPL.N    ??I2C_ITError_10
   6290              {
   6291                /* Read data from DR */
   6292                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x114   0x6820             LDR      R0,[R4, #+0]
   \      0x116   0x6900             LDR      R0,[R0, #+16]
   \      0x118   0x6A61             LDR      R1,[R4, #+36]
   \      0x11A   0x7008             STRB     R0,[R1, #+0]
   6293          
   6294                /* Increment Buffer pointer */
   6295                hi2c->pBuffPtr++;
   \      0x11C   0x6A60             LDR      R0,[R4, #+36]
   \      0x11E   0x1C40             ADDS     R0,R0,#+1
   \      0x120   0x6260             STR      R0,[R4, #+36]
   6296              }
   6297          
   6298              /* Disable I2C peripheral to prevent dummy data in buffer */
   6299              __HAL_I2C_DISABLE(hi2c);
   \                     ??I2C_ITError_10: (+1)
   \      0x122   0x6820             LDR      R0,[R4, #+0]
   \      0x124   0x6800             LDR      R0,[R0, #+0]
   \      0x126   0x0840             LSRS     R0,R0,#+1
   \      0x128   0x0040             LSLS     R0,R0,#+1
   \      0x12A   0x6821             LDR      R1,[R4, #+0]
   \      0x12C   0x6008             STR      R0,[R1, #+0]
   6300          
   6301              /* Call the corresponding callback to inform upper layer of End of Transfer */
   6302          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6303              hi2c->AbortCpltCallback(hi2c);
   6304          #else
   6305              HAL_I2C_AbortCpltCallback(hi2c);
   \      0x12E   0x0020             MOVS     R0,R4
   \      0x130   0x.... 0x....      BL       HAL_I2C_AbortCpltCallback
   \      0x134   0xE00D             B.N      ??I2C_ITError_7
   6306          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6307            }
   6308            else
   6309            {
   6310              /* Store Last receive data if any */
   6311              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
   \                     ??I2C_ITError_9: (+1)
   \      0x136   0x6820             LDR      R0,[R4, #+0]
   \      0x138   0x6940             LDR      R0,[R0, #+20]
   \      0x13A   0x0640             LSLS     R0,R0,#+25
   \      0x13C   0xD506             BPL.N    ??I2C_ITError_11
   6312              {
   6313                /* Read data from DR */
   6314                *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
   \      0x13E   0x6820             LDR      R0,[R4, #+0]
   \      0x140   0x6900             LDR      R0,[R0, #+16]
   \      0x142   0x6A61             LDR      R1,[R4, #+36]
   \      0x144   0x7008             STRB     R0,[R1, #+0]
   6315          
   6316                /* Increment Buffer pointer */
   6317                hi2c->pBuffPtr++;
   \      0x146   0x6A60             LDR      R0,[R4, #+36]
   \      0x148   0x1C40             ADDS     R0,R0,#+1
   \      0x14A   0x6260             STR      R0,[R4, #+36]
   6318              }
   6319          
   6320              /* Call user error callback */
   6321          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6322              hi2c->ErrorCallback(hi2c);
   6323          #else
   6324              HAL_I2C_ErrorCallback(hi2c);
   \                     ??I2C_ITError_11: (+1)
   \      0x14C   0x0020             MOVS     R0,R4
   \      0x14E   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   6325          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6326            }
   6327          
   6328            /* STOP Flag is not set after a NACK reception, BusError, ArbitrationLost, OverRun */
   6329            CurrentError = hi2c->ErrorCode;
   \                     ??I2C_ITError_7: (+1)
   \      0x152   0x6C27             LDR      R7,[R4, #+64]
   6330          
   6331            if (((CurrentError & HAL_I2C_ERROR_BERR) == HAL_I2C_ERROR_BERR) || \
   6332                ((CurrentError & HAL_I2C_ERROR_ARLO) == HAL_I2C_ERROR_ARLO) || \
   6333                ((CurrentError & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF)     || \
   6334                ((CurrentError & HAL_I2C_ERROR_OVR) == HAL_I2C_ERROR_OVR))
   \      0x154   0xF017 0x0F0F      TST      R7,#0xF
   \      0x158   0xD005             BEQ.N    ??I2C_ITError_12
   6335            {
   6336              /* Disable EVT, BUF and ERR interrupt */
   6337              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
   \      0x15A   0x6820             LDR      R0,[R4, #+0]
   \      0x15C   0x6840             LDR      R0,[R0, #+4]
   \      0x15E   0xF430 0x60E0      BICS     R0,R0,#0x700
   \      0x162   0x6821             LDR      R1,[R4, #+0]
   \      0x164   0x6048             STR      R0,[R1, #+4]
   6338            }
   6339          
   6340            /* So may inform upper layer that listen phase is stopped */
   6341            /* during NACK error treatment */
   6342            CurrentState = hi2c->State;
   \                     ??I2C_ITError_12: (+1)
   \      0x166   0xF894 0x803D      LDRB     R8,[R4, #+61]
   6343            if (((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF) && (CurrentState == HAL_I2C_STATE_LISTEN))
   \      0x16A   0x6C20             LDR      R0,[R4, #+64]
   \      0x16C   0x0740             LSLS     R0,R0,#+29
   \      0x16E   0xD510             BPL.N    ??I2C_ITError_13
   \      0x170   0x4640             MOV      R0,R8
   \      0x172   0xB2C0             UXTB     R0,R0
   \      0x174   0x2828             CMP      R0,#+40
   \      0x176   0xD10C             BNE.N    ??I2C_ITError_13
   6344            {
   6345              hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
   \      0x178   0x....             LDR.N    R0,??DataTable31
   \      0x17A   0x62E0             STR      R0,[R4, #+44]
   6346              hi2c->PreviousState = I2C_STATE_NONE;
   \      0x17C   0x2000             MOVS     R0,#+0
   \      0x17E   0x6320             STR      R0,[R4, #+48]
   6347              hi2c->State         = HAL_I2C_STATE_READY;
   \      0x180   0x2020             MOVS     R0,#+32
   \      0x182   0xF884 0x003D      STRB     R0,[R4, #+61]
   6348              hi2c->Mode          = HAL_I2C_MODE_NONE;
   \      0x186   0x2000             MOVS     R0,#+0
   \      0x188   0xF884 0x003E      STRB     R0,[R4, #+62]
   6349          
   6350              /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
   6351          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6352              hi2c->ListenCpltCallback(hi2c);
   6353          #else
   6354              HAL_I2C_ListenCpltCallback(hi2c);
   \      0x18C   0x0020             MOVS     R0,R4
   \      0x18E   0x.... 0x....      BL       HAL_I2C_ListenCpltCallback
   6355          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6356            }
   6357          }
   \                     ??I2C_ITError_13: (+1)
   \      0x192   0xE8BD 0x81F0      POP      {R4-R8,PC}
   6358          
   6359          /**
   6360            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6361            *         the configuration information for I2C module
   6362            * @param  DevAddress Target device address: The device 7 bits address value
   6363            *         in datasheet must be shifted to the left before calling the interface
   6364            * @param  Timeout Timeout duration
   6365            * @param  Tickstart Tick start value
   6366            * @retval HAL status
   6367            */

   \                                 In section .text, align 2, keep-with-next
   6368          static HAL_StatusTypeDef I2C_MasterRequestWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart)
   6369          {
   \                     I2C_MasterRequestWrite: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   6370            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   6371            uint32_t CurrentXferOptions = hi2c->XferOptions;
   \        0xC   0xF8D4 0x802C      LDR      R8,[R4, #+44]
   6372          
   6373            /* Generate Start condition if first transfer */
   6374            if ((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
   \       0x10   0xF1B8 0x0F08      CMP      R8,#+8
   \       0x14   0xD006             BEQ.N    ??I2C_MasterRequestWrite_0
   \       0x16   0xF1B8 0x0F01      CMP      R8,#+1
   \       0x1A   0xD003             BEQ.N    ??I2C_MasterRequestWrite_0
   \       0x1C   0x.... 0x....      LDR.W    R0,??DataTable38
   \       0x20   0x4580             CMP      R8,R0
   \       0x22   0xD106             BNE.N    ??I2C_MasterRequestWrite_1
   6375            {
   6376              /* Generate Start */
   6377              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??I2C_MasterRequestWrite_0: (+1)
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x6800             LDR      R0,[R0, #+0]
   \       0x28   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x2C   0x6821             LDR      R1,[R4, #+0]
   \       0x2E   0x6008             STR      R0,[R1, #+0]
   \       0x30   0xE008             B.N      ??I2C_MasterRequestWrite_2
   6378            }
   6379            else if (hi2c->PreviousState == I2C_STATE_MASTER_BUSY_RX)
   \                     ??I2C_MasterRequestWrite_1: (+1)
   \       0x32   0x6B20             LDR      R0,[R4, #+48]
   \       0x34   0x2812             CMP      R0,#+18
   \       0x36   0xD105             BNE.N    ??I2C_MasterRequestWrite_2
   6380            {
   6381              /* Generate ReStart */
   6382              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x6800             LDR      R0,[R0, #+0]
   \       0x3C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x40   0x6821             LDR      R1,[R4, #+0]
   \       0x42   0x6008             STR      R0,[R1, #+0]
   6383            }
   6384            else
   6385            {
   6386              /* Do nothing */
   6387            }
   6388          
   6389            /* Wait until SB flag is set */
   6390            if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   \                     ??I2C_MasterRequestWrite_2: (+1)
   \       0x44   0x9700             STR      R7,[SP, #+0]
   \       0x46   0x0033             MOVS     R3,R6
   \       0x48   0x2200             MOVS     R2,#+0
   \       0x4A   0xF05F 0x1101      MOVS     R1,#+65537
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD008             BEQ.N    ??I2C_MasterRequestWrite_3
   6391            {
   6392              if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x6800             LDR      R0,[R0, #+0]
   \       0x5C   0x05C0             LSLS     R0,R0,#+23
   \       0x5E   0xD502             BPL.N    ??I2C_MasterRequestWrite_4
   6393              {
   6394                hi2c->ErrorCode = HAL_I2C_WRONG_START;
   \       0x60   0xF44F 0x7000      MOV      R0,#+512
   \       0x64   0x6420             STR      R0,[R4, #+64]
   6395              }
   6396              return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestWrite_4: (+1)
   \       0x66   0x2003             MOVS     R0,#+3
   \       0x68   0xE02C             B.N      ??I2C_MasterRequestWrite_5
   6397            }
   6398          
   6399            if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   \                     ??I2C_MasterRequestWrite_3: (+1)
   \       0x6A   0x6920             LDR      R0,[R4, #+16]
   \       0x6C   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x70   0xD104             BNE.N    ??I2C_MasterRequestWrite_6
   6400            {
   6401              /* Send slave address */
   6402              hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \       0x72   0xF015 0x00FE      ANDS     R0,R5,#0xFE
   \       0x76   0x6821             LDR      R1,[R4, #+0]
   \       0x78   0x6108             STR      R0,[R1, #+16]
   \       0x7A   0xE017             B.N      ??I2C_MasterRequestWrite_7
   6403            }
   6404            else
   6405            {
   6406              /* Send header of slave address */
   6407              hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
   \                     ??I2C_MasterRequestWrite_6: (+1)
   \       0x7C   0xF415 0x7040      ANDS     R0,R5,#0x300
   \       0x80   0xB280             UXTH     R0,R0
   \       0x82   0x09C0             LSRS     R0,R0,#+7
   \       0x84   0xF050 0x00F0      ORRS     R0,R0,#0xF0
   \       0x88   0xB2C0             UXTB     R0,R0
   \       0x8A   0x6821             LDR      R1,[R4, #+0]
   \       0x8C   0x6108             STR      R0,[R1, #+16]
   6408          
   6409              /* Wait until ADD10 flag is set */
   6410              if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout, Tickstart) != HAL_OK)
   \       0x8E   0x003B             MOVS     R3,R7
   \       0x90   0x0032             MOVS     R2,R6
   \       0x92   0x.... 0x....      LDR.W    R1,??DataTable38_1
   \       0x96   0x0020             MOVS     R0,R4
   \       0x98   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xD001             BEQ.N    ??I2C_MasterRequestWrite_8
   6411              {
   6412                return HAL_ERROR;
   \       0xA0   0x2001             MOVS     R0,#+1
   \       0xA2   0xE00F             B.N      ??I2C_MasterRequestWrite_5
   6413              }
   6414          
   6415              /* Send slave address */
   6416              hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
   \                     ??I2C_MasterRequestWrite_8: (+1)
   \       0xA4   0x0028             MOVS     R0,R5
   \       0xA6   0xB2C0             UXTB     R0,R0
   \       0xA8   0x6821             LDR      R1,[R4, #+0]
   \       0xAA   0x6108             STR      R0,[R1, #+16]
   6417            }
   6418          
   6419            /* Wait until ADDR flag is set */
   6420            if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   \                     ??I2C_MasterRequestWrite_7: (+1)
   \       0xAC   0x003B             MOVS     R3,R7
   \       0xAE   0x0032             MOVS     R2,R6
   \       0xB0   0x.... 0x....      LDR.W    R1,??DataTable38_2
   \       0xB4   0x0020             MOVS     R0,R4
   \       0xB6   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD001             BEQ.N    ??I2C_MasterRequestWrite_9
   6421            {
   6422              return HAL_ERROR;
   \       0xBE   0x2001             MOVS     R0,#+1
   \       0xC0   0xE000             B.N      ??I2C_MasterRequestWrite_5
   6423            }
   6424          
   6425            return HAL_OK;
   \                     ??I2C_MasterRequestWrite_9: (+1)
   \       0xC2   0x2000             MOVS     R0,#+0
   \                     ??I2C_MasterRequestWrite_5: (+1)
   \       0xC4   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   6426          }
   6427          
   6428          /**
   6429            * @brief  Master sends target device address for read request.
   6430            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6431            *         the configuration information for I2C module
   6432            * @param  DevAddress Target device address: The device 7 bits address value
   6433            *         in datasheet must be shifted to the left before calling the interface
   6434            * @param  Timeout Timeout duration
   6435            * @param  Tickstart Tick start value
   6436            * @retval HAL status
   6437            */

   \                                 In section .text, align 2, keep-with-next
   6438          static HAL_StatusTypeDef I2C_MasterRequestRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Timeout, uint32_t Tickstart)
   6439          {
   \                     I2C_MasterRequestRead: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   6440            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   6441            uint32_t CurrentXferOptions = hi2c->XferOptions;
   \        0xC   0xF8D4 0x802C      LDR      R8,[R4, #+44]
   6442          
   6443            /* Enable Acknowledge */
   6444            SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0x18   0x6821             LDR      R1,[R4, #+0]
   \       0x1A   0x6008             STR      R0,[R1, #+0]
   6445          
   6446            /* Generate Start condition if first transfer */
   6447            if ((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME)  || (CurrentXferOptions == I2C_NO_OPTION_FRAME))
   \       0x1C   0xF1B8 0x0F08      CMP      R8,#+8
   \       0x20   0xD006             BEQ.N    ??I2C_MasterRequestRead_0
   \       0x22   0xF1B8 0x0F01      CMP      R8,#+1
   \       0x26   0xD003             BEQ.N    ??I2C_MasterRequestRead_0
   \       0x28   0x.... 0x....      LDR.W    R0,??DataTable38
   \       0x2C   0x4580             CMP      R8,R0
   \       0x2E   0xD106             BNE.N    ??I2C_MasterRequestRead_1
   6448            {
   6449              /* Generate Start */
   6450              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??I2C_MasterRequestRead_0: (+1)
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6800             LDR      R0,[R0, #+0]
   \       0x34   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x38   0x6821             LDR      R1,[R4, #+0]
   \       0x3A   0x6008             STR      R0,[R1, #+0]
   \       0x3C   0xE008             B.N      ??I2C_MasterRequestRead_2
   6451            }
   6452            else if (hi2c->PreviousState == I2C_STATE_MASTER_BUSY_TX)
   \                     ??I2C_MasterRequestRead_1: (+1)
   \       0x3E   0x6B20             LDR      R0,[R4, #+48]
   \       0x40   0x2811             CMP      R0,#+17
   \       0x42   0xD105             BNE.N    ??I2C_MasterRequestRead_2
   6453            {
   6454              /* Generate ReStart */
   6455              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x6800             LDR      R0,[R0, #+0]
   \       0x48   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x6008             STR      R0,[R1, #+0]
   6456            }
   6457            else
   6458            {
   6459              /* Do nothing */
   6460            }
   6461          
   6462            /* Wait until SB flag is set */
   6463            if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   \                     ??I2C_MasterRequestRead_2: (+1)
   \       0x50   0x9700             STR      R7,[SP, #+0]
   \       0x52   0x0033             MOVS     R3,R6
   \       0x54   0x2200             MOVS     R2,#+0
   \       0x56   0xF05F 0x1101      MOVS     R1,#+65537
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD008             BEQ.N    ??I2C_MasterRequestRead_3
   6464            {
   6465              if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x6800             LDR      R0,[R0, #+0]
   \       0x68   0x05C0             LSLS     R0,R0,#+23
   \       0x6A   0xD502             BPL.N    ??I2C_MasterRequestRead_4
   6466              {
   6467                hi2c->ErrorCode = HAL_I2C_WRONG_START;
   \       0x6C   0xF44F 0x7000      MOV      R0,#+512
   \       0x70   0x6420             STR      R0,[R4, #+64]
   6468              }
   6469              return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestRead_4: (+1)
   \       0x72   0x2003             MOVS     R0,#+3
   \       0x74   0xE063             B.N      ??I2C_MasterRequestRead_5
   6470            }
   6471          
   6472            if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
   \                     ??I2C_MasterRequestRead_3: (+1)
   \       0x76   0x6920             LDR      R0,[R4, #+16]
   \       0x78   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x7C   0xD105             BNE.N    ??I2C_MasterRequestRead_6
   6473            {
   6474              /* Send slave address */
   6475              hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
   \       0x7E   0xF055 0x0001      ORRS     R0,R5,#0x1
   \       0x82   0xB2C0             UXTB     R0,R0
   \       0x84   0x6821             LDR      R1,[R4, #+0]
   \       0x86   0x6108             STR      R0,[R1, #+16]
   \       0x88   0xE04D             B.N      ??I2C_MasterRequestRead_7
   6476            }
   6477            else
   6478            {
   6479              /* Send header of slave address */
   6480              hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(DevAddress);
   \                     ??I2C_MasterRequestRead_6: (+1)
   \       0x8A   0xF415 0x7040      ANDS     R0,R5,#0x300
   \       0x8E   0xB280             UXTH     R0,R0
   \       0x90   0x09C0             LSRS     R0,R0,#+7
   \       0x92   0xF050 0x00F0      ORRS     R0,R0,#0xF0
   \       0x96   0xB2C0             UXTB     R0,R0
   \       0x98   0x6821             LDR      R1,[R4, #+0]
   \       0x9A   0x6108             STR      R0,[R1, #+16]
   6481          
   6482              /* Wait until ADD10 flag is set */
   6483              if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADD10, Timeout, Tickstart) != HAL_OK)
   \       0x9C   0x003B             MOVS     R3,R7
   \       0x9E   0x0032             MOVS     R2,R6
   \       0xA0   0x.... 0x....      LDR.W    R1,??DataTable38_1
   \       0xA4   0x0020             MOVS     R0,R4
   \       0xA6   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \       0xAA   0x2800             CMP      R0,#+0
   \       0xAC   0xD001             BEQ.N    ??I2C_MasterRequestRead_8
   6484              {
   6485                return HAL_ERROR;
   \       0xAE   0x2001             MOVS     R0,#+1
   \       0xB0   0xE045             B.N      ??I2C_MasterRequestRead_5
   6486              }
   6487          
   6488              /* Send slave address */
   6489              hi2c->Instance->DR = I2C_10BIT_ADDRESS(DevAddress);
   \                     ??I2C_MasterRequestRead_8: (+1)
   \       0xB2   0x0028             MOVS     R0,R5
   \       0xB4   0xB2C0             UXTB     R0,R0
   \       0xB6   0x6821             LDR      R1,[R4, #+0]
   \       0xB8   0x6108             STR      R0,[R1, #+16]
   6490          
   6491              /* Wait until ADDR flag is set */
   6492              if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   \       0xBA   0x003B             MOVS     R3,R7
   \       0xBC   0x0032             MOVS     R2,R6
   \       0xBE   0x.... 0x....      LDR.W    R1,??DataTable38_2
   \       0xC2   0x0020             MOVS     R0,R4
   \       0xC4   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \       0xC8   0x2800             CMP      R0,#+0
   \       0xCA   0xD001             BEQ.N    ??I2C_MasterRequestRead_9
   6493              {
   6494                return HAL_ERROR;
   \       0xCC   0x2001             MOVS     R0,#+1
   \       0xCE   0xE036             B.N      ??I2C_MasterRequestRead_5
   6495              }
   6496          
   6497              /* Clear ADDR flag */
   6498              __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_MasterRequestRead_9: (+1)
   \       0xD0   0x2000             MOVS     R0,#+0
   \       0xD2   0x9000             STR      R0,[SP, #+0]
   \       0xD4   0x6820             LDR      R0,[R4, #+0]
   \       0xD6   0x6940             LDR      R0,[R0, #+20]
   \       0xD8   0x9000             STR      R0,[SP, #+0]
   \       0xDA   0x6820             LDR      R0,[R4, #+0]
   \       0xDC   0x6980             LDR      R0,[R0, #+24]
   \       0xDE   0x9000             STR      R0,[SP, #+0]
   \       0xE0   0x9800             LDR      R0,[SP, #+0]
   6499          
   6500              /* Generate Restart */
   6501              SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \       0xE2   0x6820             LDR      R0,[R4, #+0]
   \       0xE4   0x6800             LDR      R0,[R0, #+0]
   \       0xE6   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0xEA   0x6821             LDR      R1,[R4, #+0]
   \       0xEC   0x6008             STR      R0,[R1, #+0]
   6502          
   6503              /* Wait until SB flag is set */
   6504              if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   \       0xEE   0x9700             STR      R7,[SP, #+0]
   \       0xF0   0x0033             MOVS     R3,R6
   \       0xF2   0x2200             MOVS     R2,#+0
   \       0xF4   0xF05F 0x1101      MOVS     R1,#+65537
   \       0xF8   0x0020             MOVS     R0,R4
   \       0xFA   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xD008             BEQ.N    ??I2C_MasterRequestRead_10
   6505              {
   6506                if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
   \      0x102   0x6820             LDR      R0,[R4, #+0]
   \      0x104   0x6800             LDR      R0,[R0, #+0]
   \      0x106   0x05C0             LSLS     R0,R0,#+23
   \      0x108   0xD502             BPL.N    ??I2C_MasterRequestRead_11
   6507                {
   6508                  hi2c->ErrorCode = HAL_I2C_WRONG_START;
   \      0x10A   0xF44F 0x7000      MOV      R0,#+512
   \      0x10E   0x6420             STR      R0,[R4, #+64]
   6509                }
   6510                return HAL_TIMEOUT;
   \                     ??I2C_MasterRequestRead_11: (+1)
   \      0x110   0x2003             MOVS     R0,#+3
   \      0x112   0xE014             B.N      ??I2C_MasterRequestRead_5
   6511              }
   6512          
   6513              /* Send header of slave address */
   6514              hi2c->Instance->DR = I2C_10BIT_HEADER_READ(DevAddress);
   \                     ??I2C_MasterRequestRead_10: (+1)
   \      0x114   0xF415 0x7040      ANDS     R0,R5,#0x300
   \      0x118   0xB280             UXTH     R0,R0
   \      0x11A   0x09C0             LSRS     R0,R0,#+7
   \      0x11C   0xF050 0x00F1      ORRS     R0,R0,#0xF1
   \      0x120   0xB2C0             UXTB     R0,R0
   \      0x122   0x6821             LDR      R1,[R4, #+0]
   \      0x124   0x6108             STR      R0,[R1, #+16]
   6515            }
   6516          
   6517            /* Wait until ADDR flag is set */
   6518            if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   \                     ??I2C_MasterRequestRead_7: (+1)
   \      0x126   0x003B             MOVS     R3,R7
   \      0x128   0x0032             MOVS     R2,R6
   \      0x12A   0x.... 0x....      LDR.W    R1,??DataTable38_2
   \      0x12E   0x0020             MOVS     R0,R4
   \      0x130   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \      0x134   0x2800             CMP      R0,#+0
   \      0x136   0xD001             BEQ.N    ??I2C_MasterRequestRead_12
   6519            {
   6520              return HAL_ERROR;
   \      0x138   0x2001             MOVS     R0,#+1
   \      0x13A   0xE000             B.N      ??I2C_MasterRequestRead_5
   6521            }
   6522          
   6523            return HAL_OK;
   \                     ??I2C_MasterRequestRead_12: (+1)
   \      0x13C   0x2000             MOVS     R0,#+0
   \                     ??I2C_MasterRequestRead_5: (+1)
   \      0x13E   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}
   6524          }
   6525          
   6526          /**
   6527            * @brief  Master sends target device address followed by internal memory address for write request.
   6528            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6529            *         the configuration information for I2C module
   6530            * @param  DevAddress Target device address: The device 7 bits address value
   6531            *         in datasheet must be shifted to the left before calling the interface
   6532            * @param  MemAddress Internal memory address
   6533            * @param  MemAddSize Size of internal memory address
   6534            * @param  Timeout Timeout duration
   6535            * @param  Tickstart Tick start value
   6536            * @retval HAL status
   6537            */

   \                                 In section .text, align 2, keep-with-next
   6538          static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
   6539          {
   \                     I2C_RequestMemoryWrite: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8020      LDR      R8,[SP, #+32]
   \       0x10   0xF8DD 0x9024      LDR      R9,[SP, #+36]
   6540            /* Generate Start */
   6541            SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x1C   0x6821             LDR      R1,[R4, #+0]
   \       0x1E   0x6008             STR      R0,[R1, #+0]
   6542          
   6543            /* Wait until SB flag is set */
   6544            if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   \       0x20   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0x24   0x4643             MOV      R3,R8
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0xF05F 0x1101      MOVS     R1,#+65537
   \       0x2C   0x0020             MOVS     R0,R4
   \       0x2E   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD008             BEQ.N    ??I2C_RequestMemoryWrite_0
   6545            {
   6546              if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0x05C0             LSLS     R0,R0,#+23
   \       0x3C   0xD502             BPL.N    ??I2C_RequestMemoryWrite_1
   6547              {
   6548                hi2c->ErrorCode = HAL_I2C_WRONG_START;
   \       0x3E   0xF44F 0x7000      MOV      R0,#+512
   \       0x42   0x6420             STR      R0,[R4, #+64]
   6549              }
   6550              return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryWrite_1: (+1)
   \       0x44   0x2003             MOVS     R0,#+3
   \       0x46   0xE04F             B.N      ??I2C_RequestMemoryWrite_2
   6551            }
   6552          
   6553            /* Send slave address */
   6554            hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \                     ??I2C_RequestMemoryWrite_0: (+1)
   \       0x48   0xF015 0x00FE      ANDS     R0,R5,#0xFE
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x6108             STR      R0,[R1, #+16]
   6555          
   6556            /* Wait until ADDR flag is set */
   6557            if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   \       0x50   0x464B             MOV      R3,R9
   \       0x52   0x4642             MOV      R2,R8
   \       0x54   0x.... 0x....      LDR.W    R1,??DataTable38_2
   \       0x58   0x0020             MOVS     R0,R4
   \       0x5A   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \       0x5E   0x2800             CMP      R0,#+0
   \       0x60   0xD001             BEQ.N    ??I2C_RequestMemoryWrite_3
   6558            {
   6559              return HAL_ERROR;
   \       0x62   0x2001             MOVS     R0,#+1
   \       0x64   0xE040             B.N      ??I2C_RequestMemoryWrite_2
   6560            }
   6561          
   6562            /* Clear ADDR flag */
   6563            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_RequestMemoryWrite_3: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x9000             STR      R0,[SP, #+0]
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x6940             LDR      R0,[R0, #+20]
   \       0x6E   0x9000             STR      R0,[SP, #+0]
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x6980             LDR      R0,[R0, #+24]
   \       0x74   0x9000             STR      R0,[SP, #+0]
   \       0x76   0x9800             LDR      R0,[SP, #+0]
   6564          
   6565            /* Wait until TXE flag is set */
   6566            if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \       0x78   0x464A             MOV      R2,R9
   \       0x7A   0x4641             MOV      R1,R8
   \       0x7C   0x0020             MOVS     R0,R4
   \       0x7E   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD00A             BEQ.N    ??I2C_RequestMemoryWrite_4
   6567            {
   6568              if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \       0x86   0x6C20             LDR      R0,[R4, #+64]
   \       0x88   0x2804             CMP      R0,#+4
   \       0x8A   0xD105             BNE.N    ??I2C_RequestMemoryWrite_5
   6569              {
   6570                /* Generate Stop */
   6571                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x6800             LDR      R0,[R0, #+0]
   \       0x90   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0x94   0x6821             LDR      R1,[R4, #+0]
   \       0x96   0x6008             STR      R0,[R1, #+0]
   6572              }
   6573              return HAL_ERROR;
   \                     ??I2C_RequestMemoryWrite_5: (+1)
   \       0x98   0x2001             MOVS     R0,#+1
   \       0x9A   0xE025             B.N      ??I2C_RequestMemoryWrite_2
   6574            }
   6575          
   6576            /* If Memory address size is 8Bit */
   6577            if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
   \                     ??I2C_RequestMemoryWrite_4: (+1)
   \       0x9C   0x0038             MOVS     R0,R7
   \       0x9E   0xB280             UXTH     R0,R0
   \       0xA0   0x2801             CMP      R0,#+1
   \       0xA2   0xD104             BNE.N    ??I2C_RequestMemoryWrite_6
   6578            {
   6579              /* Send Memory Address */
   6580              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   \       0xA4   0x0030             MOVS     R0,R6
   \       0xA6   0xB2C0             UXTB     R0,R0
   \       0xA8   0x6821             LDR      R1,[R4, #+0]
   \       0xAA   0x6108             STR      R0,[R1, #+16]
   \       0xAC   0xE01B             B.N      ??I2C_RequestMemoryWrite_7
   6581            }
   6582            /* If Memory address size is 16Bit */
   6583            else
   6584            {
   6585              /* Send MSB of Memory Address */
   6586              hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
   \                     ??I2C_RequestMemoryWrite_6: (+1)
   \       0xAE   0x0030             MOVS     R0,R6
   \       0xB0   0xB280             UXTH     R0,R0
   \       0xB2   0x0A00             LSRS     R0,R0,#+8
   \       0xB4   0xB2C0             UXTB     R0,R0
   \       0xB6   0x6821             LDR      R1,[R4, #+0]
   \       0xB8   0x6108             STR      R0,[R1, #+16]
   6587          
   6588              /* Wait until TXE flag is set */
   6589              if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \       0xBA   0x464A             MOV      R2,R9
   \       0xBC   0x4641             MOV      R1,R8
   \       0xBE   0x0020             MOVS     R0,R4
   \       0xC0   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \       0xC4   0x2800             CMP      R0,#+0
   \       0xC6   0xD00A             BEQ.N    ??I2C_RequestMemoryWrite_8
   6590              {
   6591                if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \       0xC8   0x6C20             LDR      R0,[R4, #+64]
   \       0xCA   0x2804             CMP      R0,#+4
   \       0xCC   0xD105             BNE.N    ??I2C_RequestMemoryWrite_9
   6592                {
   6593                  /* Generate Stop */
   6594                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0xCE   0x6820             LDR      R0,[R4, #+0]
   \       0xD0   0x6800             LDR      R0,[R0, #+0]
   \       0xD2   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0xD6   0x6821             LDR      R1,[R4, #+0]
   \       0xD8   0x6008             STR      R0,[R1, #+0]
   6595                }
   6596                return HAL_ERROR;
   \                     ??I2C_RequestMemoryWrite_9: (+1)
   \       0xDA   0x2001             MOVS     R0,#+1
   \       0xDC   0xE004             B.N      ??I2C_RequestMemoryWrite_2
   6597              }
   6598          
   6599              /* Send LSB of Memory Address */
   6600              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   \                     ??I2C_RequestMemoryWrite_8: (+1)
   \       0xDE   0x0030             MOVS     R0,R6
   \       0xE0   0xB2C0             UXTB     R0,R0
   \       0xE2   0x6821             LDR      R1,[R4, #+0]
   \       0xE4   0x6108             STR      R0,[R1, #+16]
   6601            }
   6602          
   6603            return HAL_OK;
   \                     ??I2C_RequestMemoryWrite_7: (+1)
   \       0xE6   0x2000             MOVS     R0,#+0
   \                     ??I2C_RequestMemoryWrite_2: (+1)
   \       0xE8   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}
   6604          }
   6605          
   6606          /**
   6607            * @brief  Master sends target device address followed by internal memory address for read request.
   6608            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   6609            *         the configuration information for I2C module
   6610            * @param  DevAddress Target device address: The device 7 bits address value
   6611            *         in datasheet must be shifted to the left before calling the interface
   6612            * @param  MemAddress Internal memory address
   6613            * @param  MemAddSize Size of internal memory address
   6614            * @param  Timeout Timeout duration
   6615            * @param  Tickstart Tick start value
   6616            * @retval HAL status
   6617            */

   \                                 In section .text, align 2, keep-with-next
   6618          static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
   6619          {
   \                     I2C_RequestMemoryRead: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x001F             MOVS     R7,R3
   \        0xC   0xF8DD 0x8028      LDR      R8,[SP, #+40]
   \       0x10   0xF8DD 0x902C      LDR      R9,[SP, #+44]
   6620            /* Enable Acknowledge */
   6621            SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0x1C   0x6821             LDR      R1,[R4, #+0]
   \       0x1E   0x6008             STR      R0,[R1, #+0]
   6622          
   6623            /* Generate Start */
   6624            SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x6800             LDR      R0,[R0, #+0]
   \       0x24   0xF450 0x7080      ORRS     R0,R0,#0x100
   \       0x28   0x6821             LDR      R1,[R4, #+0]
   \       0x2A   0x6008             STR      R0,[R1, #+0]
   6625          
   6626            /* Wait until SB flag is set */
   6627            if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   \       0x2C   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \       0x30   0x4643             MOV      R3,R8
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0xF05F 0x1101      MOVS     R1,#+65537
   \       0x38   0x0020             MOVS     R0,R4
   \       0x3A   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD008             BEQ.N    ??I2C_RequestMemoryRead_0
   6628            {
   6629              if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x6800             LDR      R0,[R0, #+0]
   \       0x46   0x05C0             LSLS     R0,R0,#+23
   \       0x48   0xD502             BPL.N    ??I2C_RequestMemoryRead_1
   6630              {
   6631                hi2c->ErrorCode = HAL_I2C_WRONG_START;
   \       0x4A   0xF44F 0x7000      MOV      R0,#+512
   \       0x4E   0x6420             STR      R0,[R4, #+64]
   6632              }
   6633              return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_1: (+1)
   \       0x50   0x2003             MOVS     R0,#+3
   \       0x52   0xE08B             B.N      ??I2C_RequestMemoryRead_2
   6634            }
   6635          
   6636            /* Send slave address */
   6637            hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
   \                     ??I2C_RequestMemoryRead_0: (+1)
   \       0x54   0xF015 0x00FE      ANDS     R0,R5,#0xFE
   \       0x58   0x6821             LDR      R1,[R4, #+0]
   \       0x5A   0x6108             STR      R0,[R1, #+16]
   6638          
   6639            /* Wait until ADDR flag is set */
   6640            if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   \       0x5C   0x.... 0x....      LDR.W    R10,??DataTable38_2
   \       0x60   0x464B             MOV      R3,R9
   \       0x62   0x4642             MOV      R2,R8
   \       0x64   0x4651             MOV      R1,R10
   \       0x66   0x0020             MOVS     R0,R4
   \       0x68   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD001             BEQ.N    ??I2C_RequestMemoryRead_3
   6641            {
   6642              return HAL_ERROR;
   \       0x70   0x2001             MOVS     R0,#+1
   \       0x72   0xE07B             B.N      ??I2C_RequestMemoryRead_2
   6643            }
   6644          
   6645            /* Clear ADDR flag */
   6646            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
   \                     ??I2C_RequestMemoryRead_3: (+1)
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0x9000             STR      R0,[SP, #+0]
   \       0x78   0x6820             LDR      R0,[R4, #+0]
   \       0x7A   0x6940             LDR      R0,[R0, #+20]
   \       0x7C   0x9000             STR      R0,[SP, #+0]
   \       0x7E   0x6820             LDR      R0,[R4, #+0]
   \       0x80   0x6980             LDR      R0,[R0, #+24]
   \       0x82   0x9000             STR      R0,[SP, #+0]
   \       0x84   0x9800             LDR      R0,[SP, #+0]
   6647          
   6648            /* Wait until TXE flag is set */
   6649            if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \       0x86   0x464A             MOV      R2,R9
   \       0x88   0x4641             MOV      R1,R8
   \       0x8A   0x0020             MOVS     R0,R4
   \       0x8C   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD00A             BEQ.N    ??I2C_RequestMemoryRead_4
   6650            {
   6651              if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \       0x94   0x6C20             LDR      R0,[R4, #+64]
   \       0x96   0x2804             CMP      R0,#+4
   \       0x98   0xD105             BNE.N    ??I2C_RequestMemoryRead_5
   6652              {
   6653                /* Generate Stop */
   6654                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0x6800             LDR      R0,[R0, #+0]
   \       0x9E   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0xA2   0x6821             LDR      R1,[R4, #+0]
   \       0xA4   0x6008             STR      R0,[R1, #+0]
   6655              }
   6656              return HAL_ERROR;
   \                     ??I2C_RequestMemoryRead_5: (+1)
   \       0xA6   0x2001             MOVS     R0,#+1
   \       0xA8   0xE060             B.N      ??I2C_RequestMemoryRead_2
   6657            }
   6658          
   6659            /* If Memory address size is 8Bit */
   6660            if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
   \                     ??I2C_RequestMemoryRead_4: (+1)
   \       0xAA   0x0038             MOVS     R0,R7
   \       0xAC   0xB280             UXTH     R0,R0
   \       0xAE   0x2801             CMP      R0,#+1
   \       0xB0   0xD104             BNE.N    ??I2C_RequestMemoryRead_6
   6661            {
   6662              /* Send Memory Address */
   6663              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   \       0xB2   0x0030             MOVS     R0,R6
   \       0xB4   0xB2C0             UXTB     R0,R0
   \       0xB6   0x6821             LDR      R1,[R4, #+0]
   \       0xB8   0x6108             STR      R0,[R1, #+16]
   \       0xBA   0xE01B             B.N      ??I2C_RequestMemoryRead_7
   6664            }
   6665            /* If Memory address size is 16Bit */
   6666            else
   6667            {
   6668              /* Send MSB of Memory Address */
   6669              hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
   \                     ??I2C_RequestMemoryRead_6: (+1)
   \       0xBC   0x0030             MOVS     R0,R6
   \       0xBE   0xB280             UXTH     R0,R0
   \       0xC0   0x0A00             LSRS     R0,R0,#+8
   \       0xC2   0xB2C0             UXTB     R0,R0
   \       0xC4   0x6821             LDR      R1,[R4, #+0]
   \       0xC6   0x6108             STR      R0,[R1, #+16]
   6670          
   6671              /* Wait until TXE flag is set */
   6672              if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \       0xC8   0x464A             MOV      R2,R9
   \       0xCA   0x4641             MOV      R1,R8
   \       0xCC   0x0020             MOVS     R0,R4
   \       0xCE   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \       0xD2   0x2800             CMP      R0,#+0
   \       0xD4   0xD00A             BEQ.N    ??I2C_RequestMemoryRead_8
   6673              {
   6674                if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \       0xD6   0x6C20             LDR      R0,[R4, #+64]
   \       0xD8   0x2804             CMP      R0,#+4
   \       0xDA   0xD105             BNE.N    ??I2C_RequestMemoryRead_9
   6675                {
   6676                  /* Generate Stop */
   6677                  SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0xDC   0x6820             LDR      R0,[R4, #+0]
   \       0xDE   0x6800             LDR      R0,[R0, #+0]
   \       0xE0   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0xE4   0x6821             LDR      R1,[R4, #+0]
   \       0xE6   0x6008             STR      R0,[R1, #+0]
   6678                }
   6679                return HAL_ERROR;
   \                     ??I2C_RequestMemoryRead_9: (+1)
   \       0xE8   0x2001             MOVS     R0,#+1
   \       0xEA   0xE03F             B.N      ??I2C_RequestMemoryRead_2
   6680              }
   6681          
   6682              /* Send LSB of Memory Address */
   6683              hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
   \                     ??I2C_RequestMemoryRead_8: (+1)
   \       0xEC   0x0030             MOVS     R0,R6
   \       0xEE   0xB2C0             UXTB     R0,R0
   \       0xF0   0x6821             LDR      R1,[R4, #+0]
   \       0xF2   0x6108             STR      R0,[R1, #+16]
   6684            }
   6685          
   6686            /* Wait until TXE flag is set */
   6687            if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
   \                     ??I2C_RequestMemoryRead_7: (+1)
   \       0xF4   0x464A             MOV      R2,R9
   \       0xF6   0x4641             MOV      R1,R8
   \       0xF8   0x0020             MOVS     R0,R4
   \       0xFA   0x.... 0x....      BL       I2C_WaitOnTXEFlagUntilTimeout
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xD00A             BEQ.N    ??I2C_RequestMemoryRead_10
   6688            {
   6689              if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
   \      0x102   0x6C20             LDR      R0,[R4, #+64]
   \      0x104   0x2804             CMP      R0,#+4
   \      0x106   0xD105             BNE.N    ??I2C_RequestMemoryRead_11
   6690              {
   6691                /* Generate Stop */
   6692                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \      0x108   0x6820             LDR      R0,[R4, #+0]
   \      0x10A   0x6800             LDR      R0,[R0, #+0]
   \      0x10C   0xF450 0x7000      ORRS     R0,R0,#0x200
   \      0x110   0x6821             LDR      R1,[R4, #+0]
   \      0x112   0x6008             STR      R0,[R1, #+0]
   6693              }
   6694              return HAL_ERROR;
   \                     ??I2C_RequestMemoryRead_11: (+1)
   \      0x114   0x2001             MOVS     R0,#+1
   \      0x116   0xE029             B.N      ??I2C_RequestMemoryRead_2
   6695            }
   6696          
   6697            /* Generate Restart */
   6698            SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
   \                     ??I2C_RequestMemoryRead_10: (+1)
   \      0x118   0x6820             LDR      R0,[R4, #+0]
   \      0x11A   0x6800             LDR      R0,[R0, #+0]
   \      0x11C   0xF450 0x7080      ORRS     R0,R0,#0x100
   \      0x120   0x6821             LDR      R1,[R4, #+0]
   \      0x122   0x6008             STR      R0,[R1, #+0]
   6699          
   6700            /* Wait until SB flag is set */
   6701            if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
   \      0x124   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \      0x128   0x4643             MOV      R3,R8
   \      0x12A   0x2200             MOVS     R2,#+0
   \      0x12C   0xF05F 0x1101      MOVS     R1,#+65537
   \      0x130   0x0020             MOVS     R0,R4
   \      0x132   0x.... 0x....      BL       I2C_WaitOnFlagUntilTimeout
   \      0x136   0x2800             CMP      R0,#+0
   \      0x138   0xD008             BEQ.N    ??I2C_RequestMemoryRead_12
   6702            {
   6703              if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
   \      0x13A   0x6820             LDR      R0,[R4, #+0]
   \      0x13C   0x6800             LDR      R0,[R0, #+0]
   \      0x13E   0x05C0             LSLS     R0,R0,#+23
   \      0x140   0xD502             BPL.N    ??I2C_RequestMemoryRead_13
   6704              {
   6705                hi2c->ErrorCode = HAL_I2C_WRONG_START;
   \      0x142   0xF44F 0x7000      MOV      R0,#+512
   \      0x146   0x6420             STR      R0,[R4, #+64]
   6706              }
   6707              return HAL_TIMEOUT;
   \                     ??I2C_RequestMemoryRead_13: (+1)
   \      0x148   0x2003             MOVS     R0,#+3
   \      0x14A   0xE00F             B.N      ??I2C_RequestMemoryRead_2
   6708            }
   6709          
   6710            /* Send slave address */
   6711            hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
   \                     ??I2C_RequestMemoryRead_12: (+1)
   \      0x14C   0xF055 0x0001      ORRS     R0,R5,#0x1
   \      0x150   0xB2C0             UXTB     R0,R0
   \      0x152   0x6821             LDR      R1,[R4, #+0]
   \      0x154   0x6108             STR      R0,[R1, #+16]
   6712          
   6713            /* Wait until ADDR flag is set */
   6714            if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
   \      0x156   0x464B             MOV      R3,R9
   \      0x158   0x4642             MOV      R2,R8
   \      0x15A   0x4651             MOV      R1,R10
   \      0x15C   0x0020             MOVS     R0,R4
   \      0x15E   0x.... 0x....      BL       I2C_WaitOnMasterAddressFlagUntilTimeout
   \      0x162   0x2800             CMP      R0,#+0
   \      0x164   0xD001             BEQ.N    ??I2C_RequestMemoryRead_14
   6715            {
   6716              return HAL_ERROR;
   \      0x166   0x2001             MOVS     R0,#+1
   \      0x168   0xE000             B.N      ??I2C_RequestMemoryRead_2
   6717            }
   6718          
   6719            return HAL_OK;
   \                     ??I2C_RequestMemoryRead_14: (+1)
   \      0x16A   0x2000             MOVS     R0,#+0
   \                     ??I2C_RequestMemoryRead_2: (+1)
   \      0x16C   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}
   6720          }
   6721          
   6722          /**
   6723            * @brief  DMA I2C process complete callback.
   6724            * @param  hdma DMA handle
   6725            * @retval None
   6726            */

   \                                 In section .text, align 2, keep-with-next
   6727          static void I2C_DMAXferCplt(DMA_HandleTypeDef *hdma)
   6728          {
   \                     I2C_DMAXferCplt: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0004             MOVS     R4,R0
   6729            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
   \        0x6   0x6BA5             LDR      R5,[R4, #+56]
   6730          
   6731            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   6732            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   \        0x8   0xF895 0x603D      LDRB     R6,[R5, #+61]
   6733            HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
   \        0xC   0xF895 0x703E      LDRB     R7,[R5, #+62]
   6734            uint32_t CurrentXferOptions       = hi2c->XferOptions;
   \       0x10   0xF8D5 0x802C      LDR      R8,[R5, #+44]
   6735          
   6736            /* Disable EVT and ERR interrupt */
   6737            __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x6840             LDR      R0,[R0, #+4]
   \       0x18   0xF430 0x7040      BICS     R0,R0,#0x300
   \       0x1C   0x6829             LDR      R1,[R5, #+0]
   \       0x1E   0x6048             STR      R0,[R1, #+4]
   6738          
   6739            /* Clear Complete callback */
   6740            if (hi2c->hdmatx != NULL)
   \       0x20   0x6B68             LDR      R0,[R5, #+52]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD002             BEQ.N    ??I2C_DMAXferCplt_0
   6741            {
   6742              hi2c->hdmatx->XferCpltCallback = NULL;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x6B69             LDR      R1,[R5, #+52]
   \       0x2A   0x63C8             STR      R0,[R1, #+60]
   6743            }
   6744            if (hi2c->hdmarx != NULL)
   \                     ??I2C_DMAXferCplt_0: (+1)
   \       0x2C   0x6BA8             LDR      R0,[R5, #+56]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD002             BEQ.N    ??I2C_DMAXferCplt_1
   6745            {
   6746              hi2c->hdmarx->XferCpltCallback = NULL;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x6BA9             LDR      R1,[R5, #+56]
   \       0x36   0x63C8             STR      R0,[R1, #+60]
   6747            }
   6748          
   6749            if ((((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_BUSY_TX) == (uint32_t)HAL_I2C_STATE_BUSY_TX) || ((((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_BUSY_RX) == (uint32_t)HAL_I2C_STATE_BUSY_RX) && (CurrentMode == HAL_I2C_MODE_SLAVE)))
   \                     ??I2C_DMAXferCplt_1: (+1)
   \       0x38   0x0030             MOVS     R0,R6
   \       0x3A   0xB2C0             UXTB     R0,R0
   \       0x3C   0xF010 0x0021      ANDS     R0,R0,#0x21
   \       0x40   0x2821             CMP      R0,#+33
   \       0x42   0xD009             BEQ.N    ??I2C_DMAXferCplt_2
   \       0x44   0x0030             MOVS     R0,R6
   \       0x46   0xB2C0             UXTB     R0,R0
   \       0x48   0xF010 0x0022      ANDS     R0,R0,#0x22
   \       0x4C   0x2822             CMP      R0,#+34
   \       0x4E   0xD12B             BNE.N    ??I2C_DMAXferCplt_3
   \       0x50   0x0038             MOVS     R0,R7
   \       0x52   0xB2C0             UXTB     R0,R0
   \       0x54   0x2820             CMP      R0,#+32
   \       0x56   0xD127             BNE.N    ??I2C_DMAXferCplt_3
   6750            {
   6751              /* Disable DMA Request */
   6752              CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \                     ??I2C_DMAXferCplt_2: (+1)
   \       0x58   0x6828             LDR      R0,[R5, #+0]
   \       0x5A   0x6840             LDR      R0,[R0, #+4]
   \       0x5C   0xF430 0x6000      BICS     R0,R0,#0x800
   \       0x60   0x6829             LDR      R1,[R5, #+0]
   \       0x62   0x6048             STR      R0,[R1, #+4]
   6753          
   6754              hi2c->XferCount = 0U;
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x8568             STRH     R0,[R5, #+42]
   6755          
   6756              if (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN)
   \       0x68   0x0030             MOVS     R0,R6
   \       0x6A   0xB2C0             UXTB     R0,R0
   \       0x6C   0x2829             CMP      R0,#+41
   \       0x6E   0xD108             BNE.N    ??I2C_DMAXferCplt_4
   6757              {
   6758                /* Set state at HAL_I2C_STATE_LISTEN */
   6759                hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
   \       0x70   0x2021             MOVS     R0,#+33
   \       0x72   0x6328             STR      R0,[R5, #+48]
   6760                hi2c->State = HAL_I2C_STATE_LISTEN;
   \       0x74   0x2028             MOVS     R0,#+40
   \       0x76   0xF885 0x003D      STRB     R0,[R5, #+61]
   6761          
   6762                /* Call the corresponding callback to inform upper layer of End of Transfer */
   6763          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6764                hi2c->SlaveTxCpltCallback(hi2c);
   6765          #else
   6766                HAL_I2C_SlaveTxCpltCallback(hi2c);
   \       0x7A   0x0028             MOVS     R0,R5
   \       0x7C   0x.... 0x....      BL       HAL_I2C_SlaveTxCpltCallback
   \       0x80   0xE00B             B.N      ??I2C_DMAXferCplt_5
   6767          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6768              }
   6769              else if (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN)
   \                     ??I2C_DMAXferCplt_4: (+1)
   \       0x82   0x0030             MOVS     R0,R6
   \       0x84   0xB2C0             UXTB     R0,R0
   \       0x86   0x282A             CMP      R0,#+42
   \       0x88   0xD107             BNE.N    ??I2C_DMAXferCplt_5
   6770              {
   6771                /* Set state at HAL_I2C_STATE_LISTEN */
   6772                hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
   \       0x8A   0x2022             MOVS     R0,#+34
   \       0x8C   0x6328             STR      R0,[R5, #+48]
   6773                hi2c->State = HAL_I2C_STATE_LISTEN;
   \       0x8E   0x2028             MOVS     R0,#+40
   \       0x90   0xF885 0x003D      STRB     R0,[R5, #+61]
   6774          
   6775                /* Call the corresponding callback to inform upper layer of End of Transfer */
   6776          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6777                hi2c->SlaveRxCpltCallback(hi2c);
   6778          #else
   6779                HAL_I2C_SlaveRxCpltCallback(hi2c);
   \       0x94   0x0028             MOVS     R0,R5
   \       0x96   0x.... 0x....      BL       HAL_I2C_SlaveRxCpltCallback
   6780          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6781              }
   6782              else
   6783              {
   6784                /* Do nothing */
   6785              }
   6786          
   6787              /* Enable EVT and ERR interrupt to treat end of transfer in IRQ handler */
   6788              __HAL_I2C_ENABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \                     ??I2C_DMAXferCplt_5: (+1)
   \       0x9A   0x6828             LDR      R0,[R5, #+0]
   \       0x9C   0x6840             LDR      R0,[R0, #+4]
   \       0x9E   0xF450 0x7040      ORRS     R0,R0,#0x300
   \       0xA2   0x6829             LDR      R1,[R5, #+0]
   \       0xA4   0x6048             STR      R0,[R1, #+4]
   \       0xA6   0xE052             B.N      ??I2C_DMAXferCplt_6
   6789            }
   6790            /* Check current Mode, in case of treatment DMA handler have been preempted by a prior interrupt */
   6791            else if (hi2c->Mode != HAL_I2C_MODE_NONE)
   \                     ??I2C_DMAXferCplt_3: (+1)
   \       0xA8   0xF895 0x003E      LDRB     R0,[R5, #+62]
   \       0xAC   0x2800             CMP      R0,#+0
   \       0xAE   0xD04E             BEQ.N    ??I2C_DMAXferCplt_6
   6792            {
   6793              if (hi2c->XferCount == (uint16_t)1)
   \       0xB0   0x8D68             LDRH     R0,[R5, #+42]
   \       0xB2   0x2801             CMP      R0,#+1
   \       0xB4   0xD105             BNE.N    ??I2C_DMAXferCplt_7
   6794              {
   6795                /* Disable Acknowledge */
   6796                CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0xB6   0x6828             LDR      R0,[R5, #+0]
   \       0xB8   0x6800             LDR      R0,[R0, #+0]
   \       0xBA   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0xBE   0x6829             LDR      R1,[R5, #+0]
   \       0xC0   0x6008             STR      R0,[R1, #+0]
   6797              }
   6798          
   6799              /* Disable EVT and ERR interrupt */
   6800              __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
   \                     ??I2C_DMAXferCplt_7: (+1)
   \       0xC2   0x6828             LDR      R0,[R5, #+0]
   \       0xC4   0x6840             LDR      R0,[R0, #+4]
   \       0xC6   0xF430 0x7040      BICS     R0,R0,#0x300
   \       0xCA   0x6829             LDR      R1,[R5, #+0]
   \       0xCC   0x6048             STR      R0,[R1, #+4]
   6801          
   6802              /* Prepare next transfer or stop current transfer */
   6803              if ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_OTHER_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME))
   \       0xCE   0x.... 0x....      LDR.W    R0,??DataTable38
   \       0xD2   0x4580             CMP      R8,R0
   \       0xD4   0xD008             BEQ.N    ??I2C_DMAXferCplt_8
   \       0xD6   0xF1B8 0x0F08      CMP      R8,#+8
   \       0xDA   0xD005             BEQ.N    ??I2C_DMAXferCplt_8
   \       0xDC   0xF1B8 0x4F2A      CMP      R8,#+2852126720
   \       0xE0   0xD002             BEQ.N    ??I2C_DMAXferCplt_8
   \       0xE2   0xF1B8 0x0F20      CMP      R8,#+32
   \       0xE6   0xD105             BNE.N    ??I2C_DMAXferCplt_9
   6804              {
   6805                /* Generate Stop */
   6806                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \                     ??I2C_DMAXferCplt_8: (+1)
   \       0xE8   0x6828             LDR      R0,[R5, #+0]
   \       0xEA   0x6800             LDR      R0,[R0, #+0]
   \       0xEC   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0xF0   0x6829             LDR      R1,[R5, #+0]
   \       0xF2   0x6008             STR      R0,[R1, #+0]
   6807              }
   6808          
   6809              /* Disable Last DMA */
   6810              CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
   \                     ??I2C_DMAXferCplt_9: (+1)
   \       0xF4   0x6828             LDR      R0,[R5, #+0]
   \       0xF6   0x6840             LDR      R0,[R0, #+4]
   \       0xF8   0xF430 0x5080      BICS     R0,R0,#0x1000
   \       0xFC   0x6829             LDR      R1,[R5, #+0]
   \       0xFE   0x6048             STR      R0,[R1, #+4]
   6811          
   6812              /* Disable DMA Request */
   6813              CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
   \      0x100   0x6828             LDR      R0,[R5, #+0]
   \      0x102   0x6840             LDR      R0,[R0, #+4]
   \      0x104   0xF430 0x6000      BICS     R0,R0,#0x800
   \      0x108   0x6829             LDR      R1,[R5, #+0]
   \      0x10A   0x6048             STR      R0,[R1, #+4]
   6814          
   6815              hi2c->XferCount = 0U;
   \      0x10C   0x2000             MOVS     R0,#+0
   \      0x10E   0x8568             STRH     R0,[R5, #+42]
   6816          
   6817              /* Check if Errors has been detected during transfer */
   6818              if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
   \      0x110   0x6C28             LDR      R0,[R5, #+64]
   \      0x112   0x2800             CMP      R0,#+0
   \      0x114   0xD003             BEQ.N    ??I2C_DMAXferCplt_10
   6819              {
   6820          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6821                hi2c->ErrorCallback(hi2c);
   6822          #else
   6823                HAL_I2C_ErrorCallback(hi2c);
   \      0x116   0x0028             MOVS     R0,R5
   \      0x118   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   \      0x11C   0xE017             B.N      ??I2C_DMAXferCplt_6
   6824          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6825              }
   6826              else
   6827              {
   6828                hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_DMAXferCplt_10: (+1)
   \      0x11E   0x2020             MOVS     R0,#+32
   \      0x120   0xF885 0x003D      STRB     R0,[R5, #+61]
   6829          
   6830                if (hi2c->Mode == HAL_I2C_MODE_MEM)
   \      0x124   0xF895 0x003E      LDRB     R0,[R5, #+62]
   \      0x128   0x2840             CMP      R0,#+64
   \      0x12A   0xD108             BNE.N    ??I2C_DMAXferCplt_11
   6831                {
   6832                  hi2c->Mode = HAL_I2C_MODE_NONE;
   \      0x12C   0x2000             MOVS     R0,#+0
   \      0x12E   0xF885 0x003E      STRB     R0,[R5, #+62]
   6833                  hi2c->PreviousState = I2C_STATE_NONE;
   \      0x132   0x2000             MOVS     R0,#+0
   \      0x134   0x6328             STR      R0,[R5, #+48]
   6834          
   6835          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6836                  hi2c->MemRxCpltCallback(hi2c);
   6837          #else
   6838                  HAL_I2C_MemRxCpltCallback(hi2c);
   \      0x136   0x0028             MOVS     R0,R5
   \      0x138   0x.... 0x....      BL       HAL_I2C_MemRxCpltCallback
   \      0x13C   0xE007             B.N      ??I2C_DMAXferCplt_6
   6839          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6840                }
   6841                else
   6842                {
   6843                  hi2c->Mode = HAL_I2C_MODE_NONE;
   \                     ??I2C_DMAXferCplt_11: (+1)
   \      0x13E   0x2000             MOVS     R0,#+0
   \      0x140   0xF885 0x003E      STRB     R0,[R5, #+62]
   6844                  hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
   \      0x144   0x2012             MOVS     R0,#+18
   \      0x146   0x6328             STR      R0,[R5, #+48]
   6845          
   6846          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6847                  hi2c->MasterRxCpltCallback(hi2c);
   6848          #else
   6849                  HAL_I2C_MasterRxCpltCallback(hi2c);
   \      0x148   0x0028             MOVS     R0,R5
   \      0x14A   0x.... 0x....      BL       HAL_I2C_MasterRxCpltCallback
   6850          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6851                }
   6852              }
   6853            }
   6854            else
   6855            {
   6856              /* Do nothing */
   6857            }
   6858          }
   \                     ??I2C_DMAXferCplt_6: (+1)
   \      0x14E   0xE8BD 0x81F0      POP      {R4-R8,PC}
   6859          
   6860          /**
   6861            * @brief  DMA I2C communication error callback.
   6862            * @param  hdma DMA handle
   6863            * @retval None
   6864            */

   \                                 In section .text, align 2, keep-with-next
   6865          static void I2C_DMAError(DMA_HandleTypeDef *hdma)
   6866          {
   \                     I2C_DMAError: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   6867            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
   \        0x4   0x6BA5             LDR      R5,[R4, #+56]
   6868          
   6869            /* Clear Complete callback */
   6870            if (hi2c->hdmatx != NULL)
   \        0x6   0x6B68             LDR      R0,[R5, #+52]
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ.N    ??I2C_DMAError_0
   6871            {
   6872              hi2c->hdmatx->XferCpltCallback = NULL;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x6B69             LDR      R1,[R5, #+52]
   \       0x10   0x63C8             STR      R0,[R1, #+60]
   6873            }
   6874            if (hi2c->hdmarx != NULL)
   \                     ??I2C_DMAError_0: (+1)
   \       0x12   0x6BA8             LDR      R0,[R5, #+56]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD002             BEQ.N    ??I2C_DMAError_1
   6875            {
   6876              hi2c->hdmarx->XferCpltCallback = NULL;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6BA9             LDR      R1,[R5, #+56]
   \       0x1C   0x63C8             STR      R0,[R1, #+60]
   6877            }
   6878          
   6879            /* Ignore DMA FIFO error */
   6880            if (HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
   \                     ??I2C_DMAError_1: (+1)
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x.... 0x....      BL       HAL_DMA_GetError
   \       0x24   0x2802             CMP      R0,#+2
   \       0x26   0xD014             BEQ.N    ??I2C_DMAError_2
   6881            {
   6882              /* Disable Acknowledge */
   6883              hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
   \       0x28   0x6828             LDR      R0,[R5, #+0]
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x30   0x6829             LDR      R1,[R5, #+0]
   \       0x32   0x6008             STR      R0,[R1, #+0]
   6884          
   6885              hi2c->XferCount = 0U;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x8568             STRH     R0,[R5, #+42]
   6886          
   6887              hi2c->State = HAL_I2C_STATE_READY;
   \       0x38   0x2020             MOVS     R0,#+32
   \       0x3A   0xF885 0x003D      STRB     R0,[R5, #+61]
   6888              hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xF885 0x003E      STRB     R0,[R5, #+62]
   6889          
   6890              hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
   \       0x44   0x6C28             LDR      R0,[R5, #+64]
   \       0x46   0xF050 0x0010      ORRS     R0,R0,#0x10
   \       0x4A   0x6428             STR      R0,[R5, #+64]
   6891          
   6892          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6893              hi2c->ErrorCallback(hi2c);
   6894          #else
   6895              HAL_I2C_ErrorCallback(hi2c);
   \       0x4C   0x0028             MOVS     R0,R5
   \       0x4E   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   6896          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6897            }
   6898          }
   \                     ??I2C_DMAError_2: (+1)
   \       0x52   0xBD31             POP      {R0,R4,R5,PC}
   6899          
   6900          /**
   6901            * @brief DMA I2C communication abort callback
   6902            *        (To be called at end of DMA Abort procedure).
   6903            * @param hdma DMA handle.
   6904            * @retval None
   6905            */

   \                                 In section .text, align 4, keep-with-next
   6906          static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
   6907          {
   \                     I2C_DMAAbort: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   6908            __IO uint32_t count = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
   6909            I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
   \        0x8   0x6BA5             LDR      R5,[R4, #+56]
   6910          
   6911            /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
   6912            HAL_I2C_StateTypeDef CurrentState = hi2c->State;
   \        0xA   0xF895 0x603D      LDRB     R6,[R5, #+61]
   6913          
   6914            /* During abort treatment, check that there is no pending STOP request */
   6915            /* Wait until STOP flag is reset */
   6916            count = I2C_TIMEOUT_FLAG * (SystemCoreClock / 25U / 1000U);
   \        0xE   0x.... 0x....      LDR.W    R0,??DataTable38_3
   \       0x12   0x6800             LDR      R0,[R0, #+0]
   \       0x14   0x2119             MOVS     R1,#+25
   \       0x16   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0x1A   0xF44F 0x717A      MOV      R1,#+1000
   \       0x1E   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \       0x22   0x200F             MOVS     R0,#+15
   \       0x24   0x4341             MULS     R1,R0,R1
   \       0x26   0x9100             STR      R1,[SP, #+0]
   6917            do
   6918            {
   6919              if (count == 0U)
   \                     ??I2C_DMAAbort_0: (+1)
   \       0x28   0x9800             LDR      R0,[SP, #+0]
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD104             BNE.N    ??I2C_DMAAbort_1
   6920              {
   6921                hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
   \       0x2E   0x6C28             LDR      R0,[R5, #+64]
   \       0x30   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x34   0x6428             STR      R0,[R5, #+64]
   6922                break;
   \       0x36   0xE006             B.N      ??I2C_DMAAbort_2
   6923              }
   6924              count--;
   \                     ??I2C_DMAAbort_1: (+1)
   \       0x38   0x9800             LDR      R0,[SP, #+0]
   \       0x3A   0x1E40             SUBS     R0,R0,#+1
   \       0x3C   0x9000             STR      R0,[SP, #+0]
   6925            }
   6926            while (READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP);
   \       0x3E   0x6828             LDR      R0,[R5, #+0]
   \       0x40   0x6800             LDR      R0,[R0, #+0]
   \       0x42   0x0580             LSLS     R0,R0,#+22
   \       0x44   0xD4F0             BMI.N    ??I2C_DMAAbort_0
   6927          
   6928            /* Clear Complete callback */
   6929            if (hi2c->hdmatx != NULL)
   \                     ??I2C_DMAAbort_2: (+1)
   \       0x46   0x6B68             LDR      R0,[R5, #+52]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD002             BEQ.N    ??I2C_DMAAbort_3
   6930            {
   6931              hi2c->hdmatx->XferCpltCallback = NULL;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x6B69             LDR      R1,[R5, #+52]
   \       0x50   0x63C8             STR      R0,[R1, #+60]
   6932            }
   6933            if (hi2c->hdmarx != NULL)
   \                     ??I2C_DMAAbort_3: (+1)
   \       0x52   0x6BA8             LDR      R0,[R5, #+56]
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD002             BEQ.N    ??I2C_DMAAbort_4
   6934            {
   6935              hi2c->hdmarx->XferCpltCallback = NULL;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x6BA9             LDR      R1,[R5, #+56]
   \       0x5C   0x63C8             STR      R0,[R1, #+60]
   6936            }
   6937          
   6938            /* Disable Acknowledge */
   6939            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \                     ??I2C_DMAAbort_4: (+1)
   \       0x5E   0x6828             LDR      R0,[R5, #+0]
   \       0x60   0x6800             LDR      R0,[R0, #+0]
   \       0x62   0xF430 0x6080      BICS     R0,R0,#0x400
   \       0x66   0x6829             LDR      R1,[R5, #+0]
   \       0x68   0x6008             STR      R0,[R1, #+0]
   6940          
   6941            hi2c->XferCount = 0U;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x8568             STRH     R0,[R5, #+42]
   6942          
   6943            /* Reset XferAbortCallback */
   6944            if (hi2c->hdmatx != NULL)
   \       0x6E   0x6B68             LDR      R0,[R5, #+52]
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD002             BEQ.N    ??I2C_DMAAbort_5
   6945            {
   6946              hi2c->hdmatx->XferAbortCallback = NULL;
   \       0x74   0x2000             MOVS     R0,#+0
   \       0x76   0x6B69             LDR      R1,[R5, #+52]
   \       0x78   0x6508             STR      R0,[R1, #+80]
   6947            }
   6948            if (hi2c->hdmarx != NULL)
   \                     ??I2C_DMAAbort_5: (+1)
   \       0x7A   0x6BA8             LDR      R0,[R5, #+56]
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD002             BEQ.N    ??I2C_DMAAbort_6
   6949            {
   6950              hi2c->hdmarx->XferAbortCallback = NULL;
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0x6BA9             LDR      R1,[R5, #+56]
   \       0x84   0x6508             STR      R0,[R1, #+80]
   6951            }
   6952          
   6953            /* Disable I2C peripheral to prevent dummy data in buffer */
   6954            __HAL_I2C_DISABLE(hi2c);
   \                     ??I2C_DMAAbort_6: (+1)
   \       0x86   0x6828             LDR      R0,[R5, #+0]
   \       0x88   0x6800             LDR      R0,[R0, #+0]
   \       0x8A   0x0840             LSRS     R0,R0,#+1
   \       0x8C   0x0040             LSLS     R0,R0,#+1
   \       0x8E   0x6829             LDR      R1,[R5, #+0]
   \       0x90   0x6008             STR      R0,[R1, #+0]
   6955          
   6956            /* Check if come from abort from user */
   6957            if (hi2c->State == HAL_I2C_STATE_ABORT)
   \       0x92   0xF895 0x003D      LDRB     R0,[R5, #+61]
   \       0x96   0x2860             CMP      R0,#+96
   \       0x98   0xD10B             BNE.N    ??I2C_DMAAbort_7
   6958            {
   6959              hi2c->State         = HAL_I2C_STATE_READY;
   \       0x9A   0x2020             MOVS     R0,#+32
   \       0x9C   0xF885 0x003D      STRB     R0,[R5, #+61]
   6960              hi2c->Mode          = HAL_I2C_MODE_NONE;
   \       0xA0   0x2000             MOVS     R0,#+0
   \       0xA2   0xF885 0x003E      STRB     R0,[R5, #+62]
   6961              hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0x6428             STR      R0,[R5, #+64]
   6962          
   6963              /* Call the corresponding callback to inform upper layer of End of Transfer */
   6964          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6965              hi2c->AbortCpltCallback(hi2c);
   6966          #else
   6967              HAL_I2C_AbortCpltCallback(hi2c);
   \       0xAA   0x0028             MOVS     R0,R5
   \       0xAC   0x.... 0x....      BL       HAL_I2C_AbortCpltCallback
   \       0xB0   0xE020             B.N      ??I2C_DMAAbort_8
   6968          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6969            }
   6970            else
   6971            {
   6972              if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
   \                     ??I2C_DMAAbort_7: (+1)
   \       0xB2   0x0030             MOVS     R0,R6
   \       0xB4   0xB2C0             UXTB     R0,R0
   \       0xB6   0xF010 0x0028      ANDS     R0,R0,#0x28
   \       0xBA   0x2828             CMP      R0,#+40
   \       0xBC   0xD111             BNE.N    ??I2C_DMAAbort_9
   6973              {
   6974                /* Renable I2C peripheral */
   6975                __HAL_I2C_ENABLE(hi2c);
   \       0xBE   0x6828             LDR      R0,[R5, #+0]
   \       0xC0   0x6800             LDR      R0,[R0, #+0]
   \       0xC2   0xF050 0x0001      ORRS     R0,R0,#0x1
   \       0xC6   0x6829             LDR      R1,[R5, #+0]
   \       0xC8   0x6008             STR      R0,[R1, #+0]
   6976          
   6977                /* Enable Acknowledge */
   6978                SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
   \       0xCA   0x6828             LDR      R0,[R5, #+0]
   \       0xCC   0x6800             LDR      R0,[R0, #+0]
   \       0xCE   0xF450 0x6080      ORRS     R0,R0,#0x400
   \       0xD2   0x6829             LDR      R1,[R5, #+0]
   \       0xD4   0x6008             STR      R0,[R1, #+0]
   6979          
   6980                /* keep HAL_I2C_STATE_LISTEN */
   6981                hi2c->PreviousState = I2C_STATE_NONE;
   \       0xD6   0x2000             MOVS     R0,#+0
   \       0xD8   0x6328             STR      R0,[R5, #+48]
   6982                hi2c->State = HAL_I2C_STATE_LISTEN;
   \       0xDA   0x2028             MOVS     R0,#+40
   \       0xDC   0xF885 0x003D      STRB     R0,[R5, #+61]
   \       0xE0   0xE005             B.N      ??I2C_DMAAbort_10
   6983              }
   6984              else
   6985              {
   6986                hi2c->State = HAL_I2C_STATE_READY;
   \                     ??I2C_DMAAbort_9: (+1)
   \       0xE2   0x2020             MOVS     R0,#+32
   \       0xE4   0xF885 0x003D      STRB     R0,[R5, #+61]
   6987                hi2c->Mode = HAL_I2C_MODE_NONE;
   \       0xE8   0x2000             MOVS     R0,#+0
   \       0xEA   0xF885 0x003E      STRB     R0,[R5, #+62]
   6988              }
   6989          
   6990              /* Call the corresponding callback to inform upper layer of End of Transfer */
   6991          #if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
   6992              hi2c->ErrorCallback(hi2c);
   6993          #else
   6994              HAL_I2C_ErrorCallback(hi2c);
   \                     ??I2C_DMAAbort_10: (+1)
   \       0xEE   0x0028             MOVS     R0,R5
   \       0xF0   0x.... 0x....      BL       HAL_I2C_ErrorCallback
   6995          #endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
   6996            }
   6997          }
   \                     ??I2C_DMAAbort_8: (+1)
   \       0xF4   0xBD73             POP      {R0,R1,R4-R6,PC}
   6998          
   6999          /**
   7000            * @brief  This function handles I2C Communication Timeout.
   7001            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   7002            *         the configuration information for I2C module
   7003            * @param  Flag specifies the I2C flag to check.
   7004            * @param  Status The new Flag status (SET or RESET).
   7005            * @param  Timeout Timeout duration
   7006            * @param  Tickstart Tick start value
   7007            * @retval HAL status
   7008            */

   \                                 In section .text, align 2, keep-with-next
   7009          static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
   7010          {
   \                     I2C_WaitOnFlagUntilTimeout: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x000E             MOVS     R6,R1
   \        0x8   0x0017             MOVS     R7,R2
   \        0xA   0x001C             MOVS     R4,R3
   \        0xC   0xF8DD 0x8018      LDR      R8,[SP, #+24]
   7011            /* Wait until flag is set */
   7012            while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
   \                     ??I2C_WaitOnFlagUntilTimeout_0: (+1)
   \       0x10   0x0030             MOVS     R0,R6
   \       0x12   0x0C00             LSRS     R0,R0,#+16
   \       0x14   0xB2C0             UXTB     R0,R0
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD10A             BNE.N    ??I2C_WaitOnFlagUntilTimeout_1
   \       0x1A   0x6828             LDR      R0,[R5, #+0]
   \       0x1C   0x6940             LDR      R0,[R0, #+20]
   \       0x1E   0x4030             ANDS     R0,R6,R0
   \       0x20   0xB280             UXTH     R0,R0
   \       0x22   0xB2B1             UXTH     R1,R6
   \       0x24   0x4288             CMP      R0,R1
   \       0x26   0xD101             BNE.N    ??I2C_WaitOnFlagUntilTimeout_2
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE00B             B.N      ??I2C_WaitOnFlagUntilTimeout_3
   \                     ??I2C_WaitOnFlagUntilTimeout_2: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0xE009             B.N      ??I2C_WaitOnFlagUntilTimeout_3
   \                     ??I2C_WaitOnFlagUntilTimeout_1: (+1)
   \       0x30   0x6828             LDR      R0,[R5, #+0]
   \       0x32   0x6980             LDR      R0,[R0, #+24]
   \       0x34   0x4030             ANDS     R0,R6,R0
   \       0x36   0xB280             UXTH     R0,R0
   \       0x38   0xB2B1             UXTH     R1,R6
   \       0x3A   0x4288             CMP      R0,R1
   \       0x3C   0xD101             BNE.N    ??I2C_WaitOnFlagUntilTimeout_4
   \       0x3E   0x2001             MOVS     R0,#+1
   \       0x40   0xE000             B.N      ??I2C_WaitOnFlagUntilTimeout_3
   \                     ??I2C_WaitOnFlagUntilTimeout_4: (+1)
   \       0x42   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnFlagUntilTimeout_3: (+1)
   \       0x44   0x0039             MOVS     R1,R7
   \       0x46   0xB2C9             UXTB     R1,R1
   \       0x48   0x4288             CMP      R0,R1
   \       0x4A   0xD11B             BNE.N    ??I2C_WaitOnFlagUntilTimeout_5
   7013            {
   7014              /* Check for the Timeout */
   7015              if (Timeout != HAL_MAX_DELAY)
   \       0x4C   0xF114 0x0F01      CMN      R4,#+1
   \       0x50   0xD0DE             BEQ.N    ??I2C_WaitOnFlagUntilTimeout_0
   7016              {
   7017                if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x52   0x.... 0x....      BL       HAL_GetTick
   \       0x56   0xEBB0 0x0008      SUBS     R0,R0,R8
   \       0x5A   0x4284             CMP      R4,R0
   \       0x5C   0xD301             BCC.N    ??I2C_WaitOnFlagUntilTimeout_6
   \       0x5E   0x2C00             CMP      R4,#+0
   \       0x60   0xD1D6             BNE.N    ??I2C_WaitOnFlagUntilTimeout_0
   7018                {
   7019                  hi2c->PreviousState     = I2C_STATE_NONE;
   \                     ??I2C_WaitOnFlagUntilTimeout_6: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0x6328             STR      R0,[R5, #+48]
   7020                  hi2c->State             = HAL_I2C_STATE_READY;
   \       0x66   0x2020             MOVS     R0,#+32
   \       0x68   0xF885 0x003D      STRB     R0,[R5, #+61]
   7021                  hi2c->Mode              = HAL_I2C_MODE_NONE;
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0xF885 0x003E      STRB     R0,[R5, #+62]
   7022                  hi2c->ErrorCode        |= HAL_I2C_ERROR_TIMEOUT;
   \       0x72   0x6C28             LDR      R0,[R5, #+64]
   \       0x74   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x78   0x6428             STR      R0,[R5, #+64]
   7023          
   7024                  /* Process Unlocked */
   7025                  __HAL_UNLOCK(hi2c);
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0xF885 0x003C      STRB     R0,[R5, #+60]
   7026          
   7027                  return HAL_ERROR;
   \       0x80   0x2001             MOVS     R0,#+1
   \       0x82   0xE000             B.N      ??I2C_WaitOnFlagUntilTimeout_7
   7028                }
   7029              }
   7030            }
   7031            return HAL_OK;
   \                     ??I2C_WaitOnFlagUntilTimeout_5: (+1)
   \       0x84   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnFlagUntilTimeout_7: (+1)
   \       0x86   0xE8BD 0x81F0      POP      {R4-R8,PC}
   7032          }
   7033          
   7034          /**
   7035            * @brief  This function handles I2C Communication Timeout for Master addressing phase.
   7036            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   7037            *         the configuration information for I2C module
   7038            * @param  Flag specifies the I2C flag to check.
   7039            * @param  Timeout Timeout duration
   7040            * @param  Tickstart Tick start value
   7041            * @retval HAL status
   7042            */

   \                                 In section .text, align 2, keep-with-next
   7043          static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout, uint32_t Tickstart)
   7044          {
   \                     I2C_WaitOnMasterAddressFlagUntilTimeout: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0014             MOVS     R4,R2
   \        0x8   0x001F             MOVS     R7,R3
   7045            while (__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_0: (+1)
   \        0xA   0x0030             MOVS     R0,R6
   \        0xC   0x0C00             LSRS     R0,R0,#+16
   \        0xE   0xB2C0             UXTB     R0,R0
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD10A             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_1
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x6940             LDR      R0,[R0, #+20]
   \       0x18   0x4030             ANDS     R0,R6,R0
   \       0x1A   0xB280             UXTH     R0,R0
   \       0x1C   0xB2B1             UXTH     R1,R6
   \       0x1E   0x4288             CMP      R0,R1
   \       0x20   0xD101             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_2
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xE00B             B.N      ??I2C_WaitOnMasterAddressFlagUntilTimeout_3
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_2: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xE009             B.N      ??I2C_WaitOnMasterAddressFlagUntilTimeout_3
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_1: (+1)
   \       0x2A   0x6828             LDR      R0,[R5, #+0]
   \       0x2C   0x6980             LDR      R0,[R0, #+24]
   \       0x2E   0x4030             ANDS     R0,R6,R0
   \       0x30   0xB280             UXTH     R0,R0
   \       0x32   0xB2B1             UXTH     R1,R6
   \       0x34   0x4288             CMP      R0,R1
   \       0x36   0xD101             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_4
   \       0x38   0x2001             MOVS     R0,#+1
   \       0x3A   0xE000             B.N      ??I2C_WaitOnMasterAddressFlagUntilTimeout_3
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_4: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_3: (+1)
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD139             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_5
   7046            {
   7047              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \       0x42   0x6828             LDR      R0,[R5, #+0]
   \       0x44   0x6940             LDR      R0,[R0, #+20]
   \       0x46   0x0540             LSLS     R0,R0,#+21
   \       0x48   0xD51A             BPL.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_6
   7048              {
   7049                /* Generate Stop */
   7050                SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
   \       0x4A   0x6828             LDR      R0,[R5, #+0]
   \       0x4C   0x6800             LDR      R0,[R0, #+0]
   \       0x4E   0xF450 0x7000      ORRS     R0,R0,#0x200
   \       0x52   0x6829             LDR      R1,[R5, #+0]
   \       0x54   0x6008             STR      R0,[R1, #+0]
   7051          
   7052                /* Clear AF Flag */
   7053                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \       0x56   0xF47F 0x6080      MVNS     R0,#+1024
   \       0x5A   0x6829             LDR      R1,[R5, #+0]
   \       0x5C   0x6148             STR      R0,[R1, #+20]
   7054          
   7055                hi2c->PreviousState       = I2C_STATE_NONE;
   \       0x5E   0x2000             MOVS     R0,#+0
   \       0x60   0x6328             STR      R0,[R5, #+48]
   7056                hi2c->State               = HAL_I2C_STATE_READY;
   \       0x62   0x2020             MOVS     R0,#+32
   \       0x64   0xF885 0x003D      STRB     R0,[R5, #+61]
   7057                hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0xF885 0x003E      STRB     R0,[R5, #+62]
   7058                hi2c->ErrorCode           |= HAL_I2C_ERROR_AF;
   \       0x6E   0x6C28             LDR      R0,[R5, #+64]
   \       0x70   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x74   0x6428             STR      R0,[R5, #+64]
   7059          
   7060                /* Process Unlocked */
   7061                __HAL_UNLOCK(hi2c);
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0xF885 0x003C      STRB     R0,[R5, #+60]
   7062          
   7063                return HAL_ERROR;
   \       0x7C   0x2001             MOVS     R0,#+1
   \       0x7E   0xE01B             B.N      ??I2C_WaitOnMasterAddressFlagUntilTimeout_7
   7064              }
   7065          
   7066              /* Check for the Timeout */
   7067              if (Timeout != HAL_MAX_DELAY)
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_6: (+1)
   \       0x80   0xF114 0x0F01      CMN      R4,#+1
   \       0x84   0xD0C1             BEQ.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_0
   7068              {
   7069                if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x86   0x.... 0x....      BL       HAL_GetTick
   \       0x8A   0x1BC0             SUBS     R0,R0,R7
   \       0x8C   0x4284             CMP      R4,R0
   \       0x8E   0xD301             BCC.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_8
   \       0x90   0x2C00             CMP      R4,#+0
   \       0x92   0xD1BA             BNE.N    ??I2C_WaitOnMasterAddressFlagUntilTimeout_0
   7070                {
   7071                  hi2c->PreviousState       = I2C_STATE_NONE;
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_8: (+1)
   \       0x94   0x2000             MOVS     R0,#+0
   \       0x96   0x6328             STR      R0,[R5, #+48]
   7072                  hi2c->State               = HAL_I2C_STATE_READY;
   \       0x98   0x2020             MOVS     R0,#+32
   \       0x9A   0xF885 0x003D      STRB     R0,[R5, #+61]
   7073                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0xF885 0x003E      STRB     R0,[R5, #+62]
   7074                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0xA4   0x6C28             LDR      R0,[R5, #+64]
   \       0xA6   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0xAA   0x6428             STR      R0,[R5, #+64]
   7075          
   7076                  /* Process Unlocked */
   7077                  __HAL_UNLOCK(hi2c);
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0xF885 0x003C      STRB     R0,[R5, #+60]
   7078          
   7079                  return HAL_ERROR;
   \       0xB2   0x2001             MOVS     R0,#+1
   \       0xB4   0xE000             B.N      ??I2C_WaitOnMasterAddressFlagUntilTimeout_7
   7080                }
   7081              }
   7082            }
   7083            return HAL_OK;
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_5: (+1)
   \       0xB6   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnMasterAddressFlagUntilTimeout_7: (+1)
   \       0xB8   0xBDF2             POP      {R1,R4-R7,PC}
   7084          }
   7085          
   7086          /**
   7087            * @brief  This function handles I2C Communication Timeout for specific usage of TXE flag.
   7088            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   7089            *                the configuration information for the specified I2C.
   7090            * @param  Timeout Timeout duration
   7091            * @param  Tickstart Tick start value
   7092            * @retval HAL status
   7093            */

   \                                 In section .text, align 2, keep-with-next
   7094          static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   7095          {
   \                     I2C_WaitOnTXEFlagUntilTimeout: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0016             MOVS     R6,R2
   7096            while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_0: (+1)
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x6940             LDR      R0,[R0, #+20]
   \        0xC   0x0600             LSLS     R0,R0,#+24
   \        0xE   0xD421             BMI.N    ??I2C_WaitOnTXEFlagUntilTimeout_1
   7097            {
   7098              /* Check if a NACK is detected */
   7099              if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD001             BEQ.N    ??I2C_WaitOnTXEFlagUntilTimeout_2
   7100              {
   7101                return HAL_ERROR;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE01B             B.N      ??I2C_WaitOnTXEFlagUntilTimeout_3
   7102              }
   7103          
   7104              /* Check for the Timeout */
   7105              if (Timeout != HAL_MAX_DELAY)
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_2: (+1)
   \       0x1E   0xF114 0x0F01      CMN      R4,#+1
   \       0x22   0xD0F1             BEQ.N    ??I2C_WaitOnTXEFlagUntilTimeout_0
   7106              {
   7107                if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x24   0x.... 0x....      BL       HAL_GetTick
   \       0x28   0x1B80             SUBS     R0,R0,R6
   \       0x2A   0x4284             CMP      R4,R0
   \       0x2C   0xD301             BCC.N    ??I2C_WaitOnTXEFlagUntilTimeout_4
   \       0x2E   0x2C00             CMP      R4,#+0
   \       0x30   0xD1EA             BNE.N    ??I2C_WaitOnTXEFlagUntilTimeout_0
   7108                {
   7109                  hi2c->PreviousState       = I2C_STATE_NONE;
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_4: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x6328             STR      R0,[R5, #+48]
   7110                  hi2c->State               = HAL_I2C_STATE_READY;
   \       0x36   0x2020             MOVS     R0,#+32
   \       0x38   0xF885 0x003D      STRB     R0,[R5, #+61]
   7111                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xF885 0x003E      STRB     R0,[R5, #+62]
   7112                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0x42   0x6C28             LDR      R0,[R5, #+64]
   \       0x44   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x48   0x6428             STR      R0,[R5, #+64]
   7113          
   7114                  /* Process Unlocked */
   7115                  __HAL_UNLOCK(hi2c);
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xF885 0x003C      STRB     R0,[R5, #+60]
   7116          
   7117                  return HAL_ERROR;
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0xE000             B.N      ??I2C_WaitOnTXEFlagUntilTimeout_3
   7118                }
   7119              }
   7120            }
   7121            return HAL_OK;
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_1: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnTXEFlagUntilTimeout_3: (+1)
   \       0x56   0xBD70             POP      {R4-R6,PC}
   7122          }
   7123          
   7124          /**
   7125            * @brief  This function handles I2C Communication Timeout for specific usage of BTF flag.
   7126            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   7127            *                the configuration information for the specified I2C.
   7128            * @param  Timeout Timeout duration
   7129            * @param  Tickstart Tick start value
   7130            * @retval HAL status
   7131            */

   \                                 In section .text, align 2, keep-with-next
   7132          static HAL_StatusTypeDef I2C_WaitOnBTFFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   7133          {
   \                     I2C_WaitOnBTFFlagUntilTimeout: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0016             MOVS     R6,R2
   7134            while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET)
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_0: (+1)
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x6940             LDR      R0,[R0, #+20]
   \        0xC   0x0740             LSLS     R0,R0,#+29
   \        0xE   0xD421             BMI.N    ??I2C_WaitOnBTFFlagUntilTimeout_1
   7135            {
   7136              /* Check if a NACK is detected */
   7137              if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD001             BEQ.N    ??I2C_WaitOnBTFFlagUntilTimeout_2
   7138              {
   7139                return HAL_ERROR;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE01B             B.N      ??I2C_WaitOnBTFFlagUntilTimeout_3
   7140              }
   7141          
   7142              /* Check for the Timeout */
   7143              if (Timeout != HAL_MAX_DELAY)
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_2: (+1)
   \       0x1E   0xF114 0x0F01      CMN      R4,#+1
   \       0x22   0xD0F1             BEQ.N    ??I2C_WaitOnBTFFlagUntilTimeout_0
   7144              {
   7145                if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \       0x24   0x.... 0x....      BL       HAL_GetTick
   \       0x28   0x1B80             SUBS     R0,R0,R6
   \       0x2A   0x4284             CMP      R4,R0
   \       0x2C   0xD301             BCC.N    ??I2C_WaitOnBTFFlagUntilTimeout_4
   \       0x2E   0x2C00             CMP      R4,#+0
   \       0x30   0xD1EA             BNE.N    ??I2C_WaitOnBTFFlagUntilTimeout_0
   7146                {
   7147                  hi2c->PreviousState       = I2C_STATE_NONE;
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_4: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x6328             STR      R0,[R5, #+48]
   7148                  hi2c->State               = HAL_I2C_STATE_READY;
   \       0x36   0x2020             MOVS     R0,#+32
   \       0x38   0xF885 0x003D      STRB     R0,[R5, #+61]
   7149                  hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x3C   0x2000             MOVS     R0,#+0
   \       0x3E   0xF885 0x003E      STRB     R0,[R5, #+62]
   7150                  hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0x42   0x6C28             LDR      R0,[R5, #+64]
   \       0x44   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x48   0x6428             STR      R0,[R5, #+64]
   7151          
   7152                  /* Process Unlocked */
   7153                  __HAL_UNLOCK(hi2c);
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xF885 0x003C      STRB     R0,[R5, #+60]
   7154          
   7155                  return HAL_ERROR;
   \       0x50   0x2001             MOVS     R0,#+1
   \       0x52   0xE000             B.N      ??I2C_WaitOnBTFFlagUntilTimeout_3
   7156                }
   7157              }
   7158            }
   7159            return HAL_OK;
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_1: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnBTFFlagUntilTimeout_3: (+1)
   \       0x56   0xBD70             POP      {R4-R6,PC}
   7160          }
   7161          
   7162          /**
   7163            * @brief  This function handles I2C Communication Timeout for specific usage of STOP flag.
   7164            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   7165            *                the configuration information for the specified I2C.
   7166            * @param  Timeout Timeout duration
   7167            * @param  Tickstart Tick start value
   7168            * @retval HAL status
   7169            */

   \                                 In section .text, align 2, keep-with-next
   7170          static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   7171          {
   \                     I2C_WaitOnSTOPFlagUntilTimeout: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0016             MOVS     R6,R2
   7172            while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_0: (+1)
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x6940             LDR      R0,[R0, #+20]
   \        0xC   0x06C0             LSLS     R0,R0,#+27
   \        0xE   0xD41E             BMI.N    ??I2C_WaitOnSTOPFlagUntilTimeout_1
   7173            {
   7174              /* Check if a NACK is detected */
   7175              if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0x.... 0x....      BL       I2C_IsAcknowledgeFailed
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD001             BEQ.N    ??I2C_WaitOnSTOPFlagUntilTimeout_2
   7176              {
   7177                return HAL_ERROR;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xE018             B.N      ??I2C_WaitOnSTOPFlagUntilTimeout_3
   7178              }
   7179          
   7180              /* Check for the Timeout */
   7181              if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_2: (+1)
   \       0x1E   0x.... 0x....      BL       HAL_GetTick
   \       0x22   0x1B80             SUBS     R0,R0,R6
   \       0x24   0x4284             CMP      R4,R0
   \       0x26   0xD301             BCC.N    ??I2C_WaitOnSTOPFlagUntilTimeout_4
   \       0x28   0x2C00             CMP      R4,#+0
   \       0x2A   0xD1ED             BNE.N    ??I2C_WaitOnSTOPFlagUntilTimeout_0
   7182              {
   7183                hi2c->PreviousState       = I2C_STATE_NONE;
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_4: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x6328             STR      R0,[R5, #+48]
   7184                hi2c->State               = HAL_I2C_STATE_READY;
   \       0x30   0x2020             MOVS     R0,#+32
   \       0x32   0xF885 0x003D      STRB     R0,[R5, #+61]
   7185                hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xF885 0x003E      STRB     R0,[R5, #+62]
   7186                hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0x3C   0x6C28             LDR      R0,[R5, #+64]
   \       0x3E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x42   0x6428             STR      R0,[R5, #+64]
   7187          
   7188                /* Process Unlocked */
   7189                __HAL_UNLOCK(hi2c);
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xF885 0x003C      STRB     R0,[R5, #+60]
   7190          
   7191                return HAL_ERROR;
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0xE000             B.N      ??I2C_WaitOnSTOPFlagUntilTimeout_3
   7192              }
   7193            }
   7194            return HAL_OK;
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_1: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnSTOPFlagUntilTimeout_3: (+1)
   \       0x50   0xBD70             POP      {R4-R6,PC}
   7195          }
   7196          
   7197          /**
   7198            * @brief  This function handles I2C Communication Timeout for specific usage of STOP request through Interrupt.
   7199            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   7200            *                the configuration information for the specified I2C.
   7201            * @retval HAL status
   7202            */

   \                                 In section .text, align 2, keep-with-next
   7203          static HAL_StatusTypeDef I2C_WaitOnSTOPRequestThroughIT(I2C_HandleTypeDef *hi2c)
   7204          {
   \                     I2C_WaitOnSTOPRequestThroughIT: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x0001             MOVS     R1,R0
   7205            __IO uint32_t count = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
   7206          
   7207            /* Wait until STOP flag is reset */
   7208            count = I2C_TIMEOUT_STOP_FLAG * (SystemCoreClock / 25U / 1000U);
   \        0x8   0x....             LDR.N    R0,??DataTable38_3
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0x2219             MOVS     R2,#+25
   \        0xE   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \       0x12   0xF44F 0x727A      MOV      R2,#+1000
   \       0x16   0xFBB0 0xF2F2      UDIV     R2,R0,R2
   \       0x1A   0x2005             MOVS     R0,#+5
   \       0x1C   0x4342             MULS     R2,R0,R2
   \       0x1E   0x9200             STR      R2,[SP, #+0]
   7209            do
   7210            {
   7211              count--;
   \                     ??I2C_WaitOnSTOPRequestThroughIT_0: (+1)
   \       0x20   0x9800             LDR      R0,[SP, #+0]
   \       0x22   0x1E40             SUBS     R0,R0,#+1
   \       0x24   0x9000             STR      R0,[SP, #+0]
   7212              if (count == 0U)
   \       0x26   0x9800             LDR      R0,[SP, #+0]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD105             BNE.N    ??I2C_WaitOnSTOPRequestThroughIT_1
   7213              {
   7214                hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0x2C   0x6C08             LDR      R0,[R1, #+64]
   \       0x2E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x32   0x6408             STR      R0,[R1, #+64]
   7215          
   7216                return HAL_ERROR;
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xE004             B.N      ??I2C_WaitOnSTOPRequestThroughIT_2
   7217              }
   7218            }
   7219            while (READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP);
   \                     ??I2C_WaitOnSTOPRequestThroughIT_1: (+1)
   \       0x38   0x6808             LDR      R0,[R1, #+0]
   \       0x3A   0x6800             LDR      R0,[R0, #+0]
   \       0x3C   0x0580             LSLS     R0,R0,#+22
   \       0x3E   0xD4EF             BMI.N    ??I2C_WaitOnSTOPRequestThroughIT_0
   7220          
   7221            return HAL_OK;
   \       0x40   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnSTOPRequestThroughIT_2: (+1)
   \       0x42   0xB001             ADD      SP,SP,#+4
   \       0x44   0x4770             BX       LR
   7222          }
   7223          
   7224          /**
   7225            * @brief  This function handles I2C Communication Timeout for specific usage of RXNE flag.
   7226            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   7227            *                the configuration information for the specified I2C.
   7228            * @param  Timeout Timeout duration
   7229            * @param  Tickstart Tick start value
   7230            * @retval HAL status
   7231            */

   \                                 In section .text, align 2, keep-with-next
   7232          static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
   7233          {
   \                     I2C_WaitOnRXNEFlagUntilTimeout: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0016             MOVS     R6,R2
   7234          
   7235            while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_0: (+1)
   \        0x8   0x6828             LDR      R0,[R5, #+0]
   \        0xA   0x6940             LDR      R0,[R0, #+20]
   \        0xC   0x0640             LSLS     R0,R0,#+25
   \        0xE   0xD42E             BMI.N    ??I2C_WaitOnRXNEFlagUntilTimeout_1
   7236            {
   7237              /* Check if a STOPF is detected */
   7238              if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
   \       0x10   0x6828             LDR      R0,[R5, #+0]
   \       0x12   0x6940             LDR      R0,[R0, #+20]
   \       0x14   0x06C0             LSLS     R0,R0,#+27
   \       0x16   0xD512             BPL.N    ??I2C_WaitOnRXNEFlagUntilTimeout_2
   7239              {
   7240                /* Clear STOP Flag */
   7241                __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
   \       0x18   0xF07F 0x0010      MVNS     R0,#+16
   \       0x1C   0x6829             LDR      R1,[R5, #+0]
   \       0x1E   0x6148             STR      R0,[R1, #+20]
   7242          
   7243                hi2c->PreviousState       = I2C_STATE_NONE;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x6328             STR      R0,[R5, #+48]
   7244                hi2c->State               = HAL_I2C_STATE_READY;
   \       0x24   0x2020             MOVS     R0,#+32
   \       0x26   0xF885 0x003D      STRB     R0,[R5, #+61]
   7245                hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xF885 0x003E      STRB     R0,[R5, #+62]
   7246                hi2c->ErrorCode           |= HAL_I2C_ERROR_NONE;
   \       0x30   0x6C28             LDR      R0,[R5, #+64]
   \       0x32   0x6428             STR      R0,[R5, #+64]
   7247          
   7248                /* Process Unlocked */
   7249                __HAL_UNLOCK(hi2c);
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xF885 0x003C      STRB     R0,[R5, #+60]
   7250          
   7251                return HAL_ERROR;
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0xE018             B.N      ??I2C_WaitOnRXNEFlagUntilTimeout_3
   7252              }
   7253          
   7254              /* Check for the Timeout */
   7255              if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_2: (+1)
   \       0x3E   0x.... 0x....      BL       HAL_GetTick
   \       0x42   0x1B80             SUBS     R0,R0,R6
   \       0x44   0x4284             CMP      R4,R0
   \       0x46   0xD301             BCC.N    ??I2C_WaitOnRXNEFlagUntilTimeout_4
   \       0x48   0x2C00             CMP      R4,#+0
   \       0x4A   0xD1DD             BNE.N    ??I2C_WaitOnRXNEFlagUntilTimeout_0
   7256              {
   7257                hi2c->PreviousState       = I2C_STATE_NONE;
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_4: (+1)
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x6328             STR      R0,[R5, #+48]
   7258                hi2c->State               = HAL_I2C_STATE_READY;
   \       0x50   0x2020             MOVS     R0,#+32
   \       0x52   0xF885 0x003D      STRB     R0,[R5, #+61]
   7259                hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xF885 0x003E      STRB     R0,[R5, #+62]
   7260                hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
   \       0x5C   0x6C28             LDR      R0,[R5, #+64]
   \       0x5E   0xF050 0x0020      ORRS     R0,R0,#0x20
   \       0x62   0x6428             STR      R0,[R5, #+64]
   7261          
   7262                /* Process Unlocked */
   7263                __HAL_UNLOCK(hi2c);
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xF885 0x003C      STRB     R0,[R5, #+60]
   7264          
   7265                return HAL_ERROR;
   \       0x6A   0x2001             MOVS     R0,#+1
   \       0x6C   0xE000             B.N      ??I2C_WaitOnRXNEFlagUntilTimeout_3
   7266              }
   7267            }
   7268            return HAL_OK;
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_1: (+1)
   \       0x6E   0x2000             MOVS     R0,#+0
   \                     ??I2C_WaitOnRXNEFlagUntilTimeout_3: (+1)
   \       0x70   0xBD70             POP      {R4-R6,PC}
   7269          }
   7270          
   7271          /**
   7272            * @brief  This function handles Acknowledge failed detection during an I2C Communication.
   7273            * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
   7274            *                the configuration information for the specified I2C.
   7275            * @retval HAL status
   7276            */

   \                                 In section .text, align 2, keep-with-next
   7277          static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c)
   7278          {
   \                     I2C_IsAcknowledgeFailed: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   7279            if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
   \        0x2   0x6808             LDR      R0,[R1, #+0]
   \        0x4   0x6940             LDR      R0,[R0, #+20]
   \        0x6   0x0540             LSLS     R0,R0,#+21
   \        0x8   0xD514             BPL.N    ??I2C_IsAcknowledgeFailed_0
   7280            {
   7281              /* Clear NACKF Flag */
   7282              __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
   \        0xA   0xF47F 0x6080      MVNS     R0,#+1024
   \        0xE   0x680A             LDR      R2,[R1, #+0]
   \       0x10   0x6150             STR      R0,[R2, #+20]
   7283          
   7284              hi2c->PreviousState       = I2C_STATE_NONE;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x6308             STR      R0,[R1, #+48]
   7285              hi2c->State               = HAL_I2C_STATE_READY;
   \       0x16   0x2020             MOVS     R0,#+32
   \       0x18   0xF881 0x003D      STRB     R0,[R1, #+61]
   7286              hi2c->Mode                = HAL_I2C_MODE_NONE;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xF881 0x003E      STRB     R0,[R1, #+62]
   7287              hi2c->ErrorCode           |= HAL_I2C_ERROR_AF;
   \       0x22   0x6C08             LDR      R0,[R1, #+64]
   \       0x24   0xF050 0x0004      ORRS     R0,R0,#0x4
   \       0x28   0x6408             STR      R0,[R1, #+64]
   7288          
   7289              /* Process Unlocked */
   7290              __HAL_UNLOCK(hi2c);
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xF881 0x003C      STRB     R0,[R1, #+60]
   7291          
   7292              return HAL_ERROR;
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0xE000             B.N      ??I2C_IsAcknowledgeFailed_1
   7293            }
   7294            return HAL_OK;
   \                     ??I2C_IsAcknowledgeFailed_0: (+1)
   \       0x34   0x2000             MOVS     R0,#+0
   \                     ??I2C_IsAcknowledgeFailed_1: (+1)
   \       0x36   0x4770             BX       LR
   7295          }
   7296          
   7297          /**
   7298            * @brief  Convert I2Cx OTHER_xxx XferOptions to functionnal XferOptions.
   7299            * @param  hi2c I2C handle.
   7300            * @retval None
   7301            */

   \                                 In section .text, align 2, keep-with-next
   7302          static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
   7303          {
   7304            /* if user set XferOptions to I2C_OTHER_FRAME            */
   7305            /* it request implicitly to generate a restart condition */
   7306            /* set XferOptions to I2C_FIRST_FRAME                    */
   7307            if (hi2c->XferOptions == I2C_OTHER_FRAME)
   \                     I2C_ConvertOtherXferOptions: (+1)
   \        0x0   0x6AC1             LDR      R1,[R0, #+44]
   \        0x2   0xF5B1 0x0F2A      CMP      R1,#+11141120
   \        0x6   0xD102             BNE.N    ??I2C_ConvertOtherXferOptions_0
   7308            {
   7309              hi2c->XferOptions = I2C_FIRST_FRAME;
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA   0x62C1             STR      R1,[R0, #+44]
   \        0xC   0xE005             B.N      ??I2C_ConvertOtherXferOptions_1
   7310            }
   7311            /* else if user set XferOptions to I2C_OTHER_AND_LAST_FRAME */
   7312            /* it request implicitly to generate a restart condition    */
   7313            /* then generate a stop condition at the end of transfer    */
   7314            /* set XferOptions to I2C_FIRST_AND_LAST_FRAME              */
   7315            else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
   \                     ??I2C_ConvertOtherXferOptions_0: (+1)
   \        0xE   0x6AC1             LDR      R1,[R0, #+44]
   \       0x10   0xF1B1 0x4F2A      CMP      R1,#+2852126720
   \       0x14   0xD101             BNE.N    ??I2C_ConvertOtherXferOptions_1
   7316            {
   7317              hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
   \       0x16   0x2108             MOVS     R1,#+8
   \       0x18   0x62C1             STR      R1,[R0, #+44]
   7318            }
   7319            else
   7320            {
   7321              /* Nothing to do */
   7322            }
   7323          }
   \                     ??I2C_ConvertOtherXferOptions_1: (+1)
   \       0x1A   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x0001'86A1        DC32     0x186a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x001E'8480        DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x003D'0900        DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x000F'4240        DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0xFFFF'3000        DC32     0xffff3000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0xFFFF'7C00        DC32     0xffff7c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x0010'0002        DC32     0x100002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0xFFFF'0000        DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0xFFFF'0000        DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x0001'0004        DC32     0x10004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x0001'0002        DC32     0x10002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x....'....        DC32     I2C_DMAXferCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \        0x0   0x....'....        DC32     I2C_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0xFFFF'0000        DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \        0x0   0x0010'0002        DC32     0x100002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \        0x0   0x0001'0004        DC32     0x10004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0x....'....        DC32     I2C_DMAXferCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \        0x0   0x....'....        DC32     I2C_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \        0x0   0x....'....        DC32     I2C_DMAAbort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \        0x0   0x....'....        DC32     I2C_DMAXferCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \        0x0   0x....'....        DC32     I2C_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \        0x0   0xFFFF'0000        DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \        0x0   0xFFFF'0000        DC32     0xffff0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_1:
   \        0x0   0x0001'0008        DC32     0x10008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_2:
   \        0x0   0x0001'0002        DC32     0x10002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_3:
   \        0x0   0x....'....        DC32     SystemCoreClock
   7324          
   7325          /**
   7326            * @}
   7327            */
   7328          
   7329          #endif /* HAL_I2C_MODULE_ENABLED */
   7330          /**
   7331            * @}
   7332            */
   7333          
   7334          /**
   7335            * @}
   7336            */
   7337          
   7338          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_I2C_AbortCpltCallback
       0   HAL_I2C_AddrCallback
       8   HAL_I2C_DeInit
         8   -> HAL_I2C_MspDeInit
       0   HAL_I2C_DisableListen_IT
      40   HAL_I2C_ER_IRQHandler
        40   -> I2C_ITError
        40   -> I2C_Slave_AF
      32   HAL_I2C_EV_IRQHandler
        32   -> I2C_ConvertOtherXferOptions
        32   -> I2C_MasterReceive_BTF
        32   -> I2C_MasterReceive_RXNE
        32   -> I2C_MasterTransmit_BTF
        32   -> I2C_MasterTransmit_TXE
        32   -> I2C_Master_ADD10
        32   -> I2C_Master_ADDR
        32   -> I2C_Master_SB
        32   -> I2C_MemoryTransmit_TXE_BTF
        32   -> I2C_SlaveReceive_BTF
        32   -> I2C_SlaveReceive_RXNE
        32   -> I2C_SlaveTransmit_BTF
        32   -> I2C_SlaveTransmit_TXE
        32   -> I2C_Slave_ADDR
        32   -> I2C_Slave_STOPF
       0   HAL_I2C_EnableListen_IT
       0   HAL_I2C_ErrorCallback
       0   HAL_I2C_GetError
       0   HAL_I2C_GetMode
       0   HAL_I2C_GetState
      16   HAL_I2C_Init
        16   -> HAL_I2C_MspInit
        16   -> HAL_RCC_GetPCLK1Freq
      48   HAL_I2C_IsDeviceReady
        48   -> HAL_GetTick
        48   -> I2C_WaitOnFlagUntilTimeout
       0   HAL_I2C_ListenCpltCallback
       0   HAL_I2C_MasterRxCpltCallback
       0   HAL_I2C_MasterTxCpltCallback
      16   HAL_I2C_Master_Abort_IT
        16   -> I2C_ITError
      40   HAL_I2C_Master_Receive
        40   -> HAL_GetTick
        40   -> I2C_MasterRequestRead
        40   -> I2C_WaitOnFlagUntilTimeout
        40   -> I2C_WaitOnRXNEFlagUntilTimeout
      32   HAL_I2C_Master_Receive_DMA
        32   -> HAL_DMA_Start_IT
      12   HAL_I2C_Master_Receive_IT
      40   HAL_I2C_Master_Seq_Receive_DMA
        40   -> HAL_DMA_Start_IT
      24   HAL_I2C_Master_Seq_Receive_IT
      40   HAL_I2C_Master_Seq_Transmit_DMA
        40   -> HAL_DMA_Start_IT
      20   HAL_I2C_Master_Seq_Transmit_IT
      32   HAL_I2C_Master_Transmit
        32   -> HAL_GetTick
        32   -> I2C_MasterRequestWrite
        32   -> I2C_WaitOnBTFFlagUntilTimeout
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnTXEFlagUntilTimeout
      32   HAL_I2C_Master_Transmit_DMA
        32   -> HAL_DMA_Start_IT
      12   HAL_I2C_Master_Transmit_IT
       0   HAL_I2C_MemRxCpltCallback
       0   HAL_I2C_MemTxCpltCallback
      48   HAL_I2C_Mem_Read
        48   -> HAL_GetTick
        48   -> I2C_RequestMemoryRead
        48   -> I2C_WaitOnFlagUntilTimeout
        48   -> I2C_WaitOnRXNEFlagUntilTimeout
      48   HAL_I2C_Mem_Read_DMA
        48   -> HAL_DMA_Abort_IT
        48   -> HAL_DMA_Start_IT
        48   -> HAL_GetTick
        48   -> I2C_RequestMemoryRead
      20   HAL_I2C_Mem_Read_IT
      48   HAL_I2C_Mem_Write
        48   -> HAL_GetTick
        48   -> I2C_RequestMemoryWrite
        48   -> I2C_WaitOnBTFFlagUntilTimeout
        48   -> I2C_WaitOnFlagUntilTimeout
        48   -> I2C_WaitOnTXEFlagUntilTimeout
      48   HAL_I2C_Mem_Write_DMA
        48   -> HAL_DMA_Abort_IT
        48   -> HAL_DMA_Start_IT
        48   -> HAL_GetTick
        48   -> I2C_RequestMemoryWrite
      20   HAL_I2C_Mem_Write_IT
       0   HAL_I2C_MspDeInit
       0   HAL_I2C_MspInit
       0   HAL_I2C_SlaveRxCpltCallback
       0   HAL_I2C_SlaveTxCpltCallback
      32   HAL_I2C_Slave_Receive
        32   -> HAL_GetTick
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnRXNEFlagUntilTimeout
        32   -> I2C_WaitOnSTOPFlagUntilTimeout
      16   HAL_I2C_Slave_Receive_DMA
        16   -> HAL_DMA_Start_IT
       4   HAL_I2C_Slave_Receive_IT
      24   HAL_I2C_Slave_Seq_Receive_DMA
        24   -- Indirect call
        24   -> HAL_DMA_Abort_IT
        24   -> HAL_DMA_Start_IT
      12   HAL_I2C_Slave_Seq_Receive_IT
      24   HAL_I2C_Slave_Seq_Transmit_DMA
        24   -- Indirect call
        24   -> HAL_DMA_Abort_IT
        24   -> HAL_DMA_Start_IT
      12   HAL_I2C_Slave_Seq_Transmit_IT
      32   HAL_I2C_Slave_Transmit
        32   -> HAL_GetTick
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnTXEFlagUntilTimeout
      16   HAL_I2C_Slave_Transmit_DMA
        16   -> HAL_DMA_Start_IT
       4   HAL_I2C_Slave_Transmit_IT
       0   I2C_ConvertOtherXferOptions
      24   I2C_DMAAbort
        24   -> HAL_I2C_AbortCpltCallback
        24   -> HAL_I2C_ErrorCallback
      16   I2C_DMAError
        16   -> HAL_DMA_GetError
        16   -> HAL_I2C_ErrorCallback
      24   I2C_DMAXferCplt
        24   -> HAL_I2C_ErrorCallback
        24   -> HAL_I2C_MasterRxCpltCallback
        24   -> HAL_I2C_MemRxCpltCallback
        24   -> HAL_I2C_SlaveRxCpltCallback
        24   -> HAL_I2C_SlaveTxCpltCallback
      24   I2C_ITError
        24   -- Indirect call
        24   -> HAL_DMA_Abort_IT
        24   -> HAL_I2C_AbortCpltCallback
        24   -> HAL_I2C_ErrorCallback
        24   -> HAL_I2C_ListenCpltCallback
       0   I2C_IsAcknowledgeFailed
      16   I2C_MasterReceive_BTF
        16   -> HAL_I2C_MasterRxCpltCallback
        16   -> HAL_I2C_MemRxCpltCallback
      16   I2C_MasterReceive_RXNE
        16   -> HAL_I2C_ErrorCallback
        16   -> HAL_I2C_MasterRxCpltCallback
        16   -> HAL_I2C_MemRxCpltCallback
        16   -> I2C_WaitOnSTOPRequestThroughIT
      32   I2C_MasterRequestRead
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnMasterAddressFlagUntilTimeout
      32   I2C_MasterRequestWrite
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnMasterAddressFlagUntilTimeout
      16   I2C_MasterTransmit_BTF
        16   -> HAL_I2C_MasterTxCpltCallback
      24   I2C_MasterTransmit_TXE
        24   -> HAL_I2C_MasterTxCpltCallback
        24   -> HAL_I2C_MemTxCpltCallback
        24   -> I2C_MemoryTransmit_TXE_BTF
       0   I2C_Master_ADD10
      12   I2C_Master_ADDR
       0   I2C_Master_SB
      16   I2C_MemoryTransmit_TXE_BTF
        16   -> HAL_I2C_MemTxCpltCallback
      40   I2C_RequestMemoryRead
        40   -> I2C_WaitOnFlagUntilTimeout
        40   -> I2C_WaitOnMasterAddressFlagUntilTimeout
        40   -> I2C_WaitOnTXEFlagUntilTimeout
      32   I2C_RequestMemoryWrite
        32   -> I2C_WaitOnFlagUntilTimeout
        32   -> I2C_WaitOnMasterAddressFlagUntilTimeout
        32   -> I2C_WaitOnTXEFlagUntilTimeout
       0   I2C_SlaveReceive_BTF
      16   I2C_SlaveReceive_RXNE
        16   -> HAL_I2C_SlaveRxCpltCallback
       0   I2C_SlaveTransmit_BTF
      16   I2C_SlaveTransmit_TXE
        16   -> HAL_I2C_SlaveTxCpltCallback
      24   I2C_Slave_ADDR
        24   -> HAL_I2C_AddrCallback
      16   I2C_Slave_AF
        16   -> HAL_I2C_ListenCpltCallback
        16   -> HAL_I2C_SlaveTxCpltCallback
      16   I2C_Slave_STOPF
        16   -- Indirect call
        16   -> HAL_DMA_Abort_IT
        16   -> HAL_DMA_GetState
        16   -> HAL_I2C_ListenCpltCallback
        16   -> HAL_I2C_SlaveRxCpltCallback
        16   -> I2C_ITError
      16   I2C_WaitOnBTFFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed
      24   I2C_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick
      24   I2C_WaitOnMasterAddressFlagUntilTimeout
        24   -> HAL_GetTick
      16   I2C_WaitOnRXNEFlagUntilTimeout
        16   -> HAL_GetTick
      16   I2C_WaitOnSTOPFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed
       4   I2C_WaitOnSTOPRequestThroughIT
      16   I2C_WaitOnTXEFlagUntilTimeout
        16   -> HAL_GetTick
        16   -> I2C_IsAcknowledgeFailed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable11
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable21
       4  ??DataTable22
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable31
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_2
       4  ??DataTable38_3
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       2  HAL_I2C_AbortCpltCallback
       2  HAL_I2C_AddrCallback
      66  HAL_I2C_DeInit
      70  HAL_I2C_DisableListen_IT
     236  HAL_I2C_ER_IRQHandler
     446  HAL_I2C_EV_IRQHandler
      68  HAL_I2C_EnableListen_IT
       2  HAL_I2C_ErrorCallback
       4  HAL_I2C_GetError
       6  HAL_I2C_GetMode
       6  HAL_I2C_GetState
     466  HAL_I2C_Init
     500  HAL_I2C_IsDeviceReady
       2  HAL_I2C_ListenCpltCallback
       2  HAL_I2C_MasterRxCpltCallback
       2  HAL_I2C_MasterTxCpltCallback
     114  HAL_I2C_Master_Abort_IT
     760  HAL_I2C_Master_Receive
     402  HAL_I2C_Master_Receive_DMA
     234  HAL_I2C_Master_Receive_IT
     634  HAL_I2C_Master_Seq_Receive_DMA
     352  HAL_I2C_Master_Seq_Receive_IT
     498  HAL_I2C_Master_Seq_Transmit_DMA
     274  HAL_I2C_Master_Seq_Transmit_IT
     362  HAL_I2C_Master_Transmit
     402  HAL_I2C_Master_Transmit_DMA
     222  HAL_I2C_Master_Transmit_IT
       2  HAL_I2C_MemRxCpltCallback
       2  HAL_I2C_MemTxCpltCallback
     768  HAL_I2C_Mem_Read
     556  HAL_I2C_Mem_Read_DMA
     260  HAL_I2C_Mem_Read_IT
     366  HAL_I2C_Mem_Write
     472  HAL_I2C_Mem_Write_DMA
     242  HAL_I2C_Mem_Write_IT
       2  HAL_I2C_MspDeInit
       2  HAL_I2C_MspInit
       2  HAL_I2C_SlaveRxCpltCallback
       2  HAL_I2C_SlaveTxCpltCallback
     378  HAL_I2C_Slave_Receive
     258  HAL_I2C_Slave_Receive_DMA
     148  HAL_I2C_Slave_Receive_IT
     402  HAL_I2C_Slave_Seq_Receive_DMA
     154  HAL_I2C_Slave_Seq_Receive_IT
     398  HAL_I2C_Slave_Seq_Transmit_DMA
     154  HAL_I2C_Slave_Seq_Transmit_IT
     410  HAL_I2C_Slave_Transmit
     256  HAL_I2C_Slave_Transmit_DMA
     148  HAL_I2C_Slave_Transmit_IT
      28  I2C_ConvertOtherXferOptions
     246  I2C_DMAAbort
      84  I2C_DMAError
     338  I2C_DMAXferCplt
     406  I2C_ITError
      56  I2C_IsAcknowledgeFailed
     296  I2C_MasterReceive_BTF
     228  I2C_MasterReceive_RXNE
     322  I2C_MasterRequestRead
     200  I2C_MasterRequestWrite
     142  I2C_MasterTransmit_BTF
     232  I2C_MasterTransmit_TXE
      50  I2C_Master_ADD10
     582  I2C_Master_ADDR
     178  I2C_Master_SB
     204  I2C_MemoryTransmit_TXE_BTF
     368  I2C_RequestMemoryRead
     236  I2C_RequestMemoryWrite
      28  I2C_SlaveReceive_BTF
      78  I2C_SlaveReceive_RXNE
      28  I2C_SlaveTransmit_BTF
      78  I2C_SlaveTransmit_TXE
      92  I2C_Slave_ADDR
     164  I2C_Slave_AF
     410  I2C_Slave_STOPF
      88  I2C_WaitOnBTFFlagUntilTimeout
     138  I2C_WaitOnFlagUntilTimeout
     186  I2C_WaitOnMasterAddressFlagUntilTimeout
     114  I2C_WaitOnRXNEFlagUntilTimeout
      82  I2C_WaitOnSTOPFlagUntilTimeout
      70  I2C_WaitOnSTOPRequestThroughIT
      88  I2C_WaitOnTXEFlagUntilTimeout

 
 17'472 bytes in section .text
 
 17'448 bytes of CODE memory (+ 24 bytes shared)

Errors: none
Warnings: none
