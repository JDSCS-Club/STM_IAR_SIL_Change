###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         15/Sep/2022  19:49:57
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\D\JDS_DATA\RFM_IAR_source_220915\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_exti.c
#    Command line      =
#        -f
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_exti.o.rsp
#        (C:\D\JDS_DATA\RFM_IAR_source_220915\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_exti.c
#        -D USE_HAL_DRIVER -D STM32F407xx -lC
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver
#        -o
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../USB_DEVICE/App\ -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Core/Inc\ -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Drivers/CMSIS/Include\
#        -I C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Drivers/radio\ -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Drivers/display\ -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM/../Library\ -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_exti.o.d
#    Locale            =  C
#    List file         =
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM\RFM\List\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_exti.lst
#    Object file       =
#        C:\D\JDS_DATA\RFM_IAR_source_220915\EWARM\RFM\Obj\Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_exti.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\D\JDS_DATA\RFM_IAR_source_220915\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_exti.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f4xx_hal_exti.c
      4            * @author  MCD Application Team
      5            * @brief   EXTI HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Extended Interrupts and events controller (EXTI) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *
     11            @verbatim
     12            ==============================================================================
     13                              ##### EXTI Peripheral features #####
     14            ==============================================================================
     15            [..]
     16              (+) Each Exti line can be configured within this driver.
     17          
     18              (+) Exti line can be configured in 3 different modes
     19                  (++) Interrupt
     20                  (++) Event
     21                  (++) Both of them
     22          
     23              (+) Configurable Exti lines can be configured with 3 different triggers
     24                  (++) Rising
     25                  (++) Falling
     26                  (++) Both of them
     27          
     28              (+) When set in interrupt mode, configurable Exti lines have two different
     29                  interrupts pending registers which allow to distinguish which transition
     30                  occurs:
     31                  (++) Rising edge pending interrupt
     32                  (++) Falling
     33          
     34              (+) Exti lines 0 to 15 are linked to gpio pin number 0 to 15. Gpio port can
     35                  be selected through multiplexer.
     36          
     37                               ##### How to use this driver #####
     38            ==============================================================================
     39            [..]
     40          
     41              (#) Configure the EXTI line using HAL_EXTI_SetConfigLine().
     42                  (++) Choose the interrupt line number by setting "Line" member from
     43                       EXTI_ConfigTypeDef structure.
     44                  (++) Configure the interrupt and/or event mode using "Mode" member from
     45                       EXTI_ConfigTypeDef structure.
     46                  (++) For configurable lines, configure rising and/or falling trigger
     47                       "Trigger" member from EXTI_ConfigTypeDef structure.
     48                  (++) For Exti lines linked to gpio, choose gpio port using "GPIOSel"
     49                       member from GPIO_InitTypeDef structure.
     50          
     51              (#) Get current Exti configuration of a dedicated line using
     52                  HAL_EXTI_GetConfigLine().
     53                  (++) Provide exiting handle as parameter.
     54                  (++) Provide pointer on EXTI_ConfigTypeDef structure as second parameter.
     55          
     56              (#) Clear Exti configuration of a dedicated line using HAL_EXTI_GetConfigLine().
     57                  (++) Provide exiting handle as parameter.
     58          
     59              (#) Register callback to treat Exti interrupts using HAL_EXTI_RegisterCallback().
     60                  (++) Provide exiting handle as first parameter.
     61                  (++) Provide which callback will be registered using one value from
     62                       EXTI_CallbackIDTypeDef.
     63                  (++) Provide callback function pointer.
     64          
     65              (#) Get interrupt pending bit using HAL_EXTI_GetPending().
     66          
     67              (#) Clear interrupt pending bit using HAL_EXTI_GetPending().
     68          
     69              (#) Generate software interrupt using HAL_EXTI_GenerateSWI().
     70          
     71            @endverbatim
     72            ******************************************************************************
     73            * @attention
     74            *
     75            * <h2><center>&copy; Copyright (c) 2018 STMicroelectronics.
     76            * All rights reserved.</center></h2>
     77            *
     78            * This software component is licensed by ST under BSD 3-Clause license,
     79            * the "License"; You may not use this file except in compliance with the
     80            * License. You may obtain a copy of the License at:
     81            *                        opensource.org/licenses/BSD-3-Clause
     82            *
     83            ******************************************************************************
     84            */
     85          
     86          /* Includes ------------------------------------------------------------------*/
     87          #include "stm32f4xx_hal.h"
     88          
     89          /** @addtogroup STM32F4xx_HAL_Driver
     90            * @{
     91            */
     92          
     93          /** @addtogroup EXTI
     94            * @{
     95            */
     96          /** MISRA C:2012 deviation rule has been granted for following rule:
     97            * Rule-18.1_b - Medium: Array `EXTICR' 1st subscript interval [0,7] may be out
     98            * of bounds [0,3] in following API :
     99            * HAL_EXTI_SetConfigLine
    100            * HAL_EXTI_GetConfigLine
    101            * HAL_EXTI_ClearConfigLine
    102            */
    103          
    104          #ifdef HAL_EXTI_MODULE_ENABLED
    105          
    106          /* Private typedef -----------------------------------------------------------*/
    107          /* Private defines -----------------------------------------------------------*/
    108          /** @defgroup EXTI_Private_Constants EXTI Private Constants
    109            * @{
    110            */
    111          
    112          /**
    113            * @}
    114            */
    115          
    116          /* Private macros ------------------------------------------------------------*/
    117          /* Private variables ---------------------------------------------------------*/
    118          /* Private function prototypes -----------------------------------------------*/
    119          /* Exported functions --------------------------------------------------------*/
    120          
    121          /** @addtogroup EXTI_Exported_Functions
    122            * @{
    123            */
    124          
    125          /** @addtogroup EXTI_Exported_Functions_Group1
    126            *  @brief    Configuration functions
    127            *
    128          @verbatim
    129           ===============================================================================
    130                        ##### Configuration functions #####
    131           ===============================================================================
    132          
    133          @endverbatim
    134            * @{
    135            */
    136          
    137          /**
    138            * @brief  Set configuration of a dedicated Exti line.
    139            * @param  hexti Exti handle.
    140            * @param  pExtiConfig Pointer on EXTI configuration to be set.
    141            * @retval HAL Status.
    142            */

   \                                 In section .text, align 2, keep-with-next
    143          HAL_StatusTypeDef HAL_EXTI_SetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
    144          {
   \                     HAL_EXTI_SetConfigLine: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   \        0x2   0x0002             MOVS     R2,R0
    145            uint32_t regval;
    146            uint32_t linepos;
    147            uint32_t maskline;
    148          
    149            /* Check null pointer */
    150            if ((hexti == NULL) || (pExtiConfig == NULL))
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD001             BEQ.N    ??HAL_EXTI_SetConfigLine_0
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD101             BNE.N    ??HAL_EXTI_SetConfigLine_1
    151            {
    152              return HAL_ERROR;
   \                     ??HAL_EXTI_SetConfigLine_0: (+1)
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE05A             B.N      ??HAL_EXTI_SetConfigLine_2
    153            }
    154          
    155            /* Check parameters */
    156            assert_param(IS_EXTI_LINE(pExtiConfig->Line));
    157            assert_param(IS_EXTI_MODE(pExtiConfig->Mode));
    158          
    159            /* Assign line number to handle */
    160            hexti->Line = pExtiConfig->Line;
   \                     ??HAL_EXTI_SetConfigLine_1: (+1)
   \       0x10   0x6808             LDR      R0,[R1, #+0]
   \       0x12   0x6010             STR      R0,[R2, #+0]
    161          
    162            /* Compute line mask */
    163            linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
   \       0x14   0x780C             LDRB     R4,[R1, #+0]
   \       0x16   0xF014 0x041F      ANDS     R4,R4,#0x1F
    164            maskline = (1uL << linepos);
   \       0x1A   0x2501             MOVS     R5,#+1
   \       0x1C   0x40A5             LSLS     R5,R5,R4
    165          
    166            /* Configure triggers for configurable lines */
    167            if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00u)
   \       0x1E   0x6808             LDR      R0,[R1, #+0]
   \       0x20   0x0180             LSLS     R0,R0,#+6
   \       0x22   0xD537             BPL.N    ??HAL_EXTI_SetConfigLine_3
    168            {
    169              assert_param(IS_EXTI_TRIGGER(pExtiConfig->Trigger));
    170          
    171              /* Configure rising trigger */
    172              /* Mask or set line */
    173              if ((pExtiConfig->Trigger & EXTI_TRIGGER_RISING) != 0x00u)
   \       0x24   0x7A08             LDRB     R0,[R1, #+8]
   \       0x26   0x07C0             LSLS     R0,R0,#+31
   \       0x28   0xD504             BPL.N    ??HAL_EXTI_SetConfigLine_4
    174              {
    175                EXTI->RTSR |= maskline;
   \       0x2A   0x....             LDR.N    R0,??DataTable6
   \       0x2C   0x6806             LDR      R6,[R0, #+0]
   \       0x2E   0x432E             ORRS     R6,R5,R6
   \       0x30   0x6006             STR      R6,[R0, #+0]
   \       0x32   0xE003             B.N      ??HAL_EXTI_SetConfigLine_5
    176              }
    177              else
    178              {
    179                EXTI->RTSR &= ~maskline;
   \                     ??HAL_EXTI_SetConfigLine_4: (+1)
   \       0x34   0x....             LDR.N    R0,??DataTable6
   \       0x36   0x6806             LDR      R6,[R0, #+0]
   \       0x38   0x43AE             BICS     R6,R6,R5
   \       0x3A   0x6006             STR      R6,[R0, #+0]
    180              }
    181          
    182              /* Configure falling trigger */
    183              /* Mask or set line */
    184              if ((pExtiConfig->Trigger & EXTI_TRIGGER_FALLING) != 0x00u)
   \                     ??HAL_EXTI_SetConfigLine_5: (+1)
   \       0x3C   0x7A08             LDRB     R0,[R1, #+8]
   \       0x3E   0x0780             LSLS     R0,R0,#+30
   \       0x40   0xD504             BPL.N    ??HAL_EXTI_SetConfigLine_6
    185              {
    186                EXTI->FTSR |= maskline;
   \       0x42   0x....             LDR.N    R0,??DataTable6_1
   \       0x44   0x6806             LDR      R6,[R0, #+0]
   \       0x46   0x432E             ORRS     R6,R5,R6
   \       0x48   0x6006             STR      R6,[R0, #+0]
   \       0x4A   0xE003             B.N      ??HAL_EXTI_SetConfigLine_7
    187              }
    188              else
    189              {
    190                EXTI->FTSR &= ~maskline;
   \                     ??HAL_EXTI_SetConfigLine_6: (+1)
   \       0x4C   0x....             LDR.N    R0,??DataTable6_1
   \       0x4E   0x6806             LDR      R6,[R0, #+0]
   \       0x50   0x43AE             BICS     R6,R6,R5
   \       0x52   0x6006             STR      R6,[R0, #+0]
    191              }
    192          
    193          
    194              /* Configure gpio port selection in case of gpio exti line */
    195              if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
   \                     ??HAL_EXTI_SetConfigLine_7: (+1)
   \       0x54   0x6808             LDR      R0,[R1, #+0]
   \       0x56   0xF010 0x60C0      ANDS     R0,R0,#0x6000000
   \       0x5A   0xF1B0 0x6FC0      CMP      R0,#+100663296
   \       0x5E   0xD119             BNE.N    ??HAL_EXTI_SetConfigLine_3
    196              {
    197                assert_param(IS_EXTI_GPIO_PORT(pExtiConfig->GPIOSel));
    198                assert_param(IS_EXTI_GPIO_PIN(linepos));
    199          
    200                regval = SYSCFG->EXTICR[linepos >> 2u];
   \       0x60   0x....             LDR.N    R6,??DataTable6_2
   \       0x62   0x0020             MOVS     R0,R4
   \       0x64   0x0880             LSRS     R0,R0,#+2
   \       0x66   0xF856 0x0020      LDR      R0,[R6, R0, LSL #+2]
    201                regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03u)));
   \       0x6A   0x270F             MOVS     R7,#+15
   \       0x6C   0xEA5F 0x0C84      LSLS     R12,R4,#+2
   \       0x70   0xF01C 0x0C0C      ANDS     R12,R12,#0xC
   \       0x74   0xFA17 0xF70C      LSLS     R7,R7,R12
   \       0x78   0x43B8             BICS     R0,R0,R7
    202                regval |= (pExtiConfig->GPIOSel << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03u)));
   \       0x7A   0x68CF             LDR      R7,[R1, #+12]
   \       0x7C   0xEA5F 0x0C84      LSLS     R12,R4,#+2
   \       0x80   0xF01C 0x0C0C      ANDS     R12,R12,#0xC
   \       0x84   0xFA17 0xF70C      LSLS     R7,R7,R12
   \       0x88   0x4338             ORRS     R0,R7,R0
   \       0x8A   0x0003             MOVS     R3,R0
    203                SYSCFG->EXTICR[linepos >> 2u] = regval;
   \       0x8C   0x0020             MOVS     R0,R4
   \       0x8E   0x0880             LSRS     R0,R0,#+2
   \       0x90   0xF846 0x3020      STR      R3,[R6, R0, LSL #+2]
    204              }
    205            }
    206          
    207            /* Configure interrupt mode : read current mode */
    208            /* Mask or set line */
    209            if ((pExtiConfig->Mode & EXTI_MODE_INTERRUPT) != 0x00u)
   \                     ??HAL_EXTI_SetConfigLine_3: (+1)
   \       0x94   0x7908             LDRB     R0,[R1, #+4]
   \       0x96   0x07C0             LSLS     R0,R0,#+31
   \       0x98   0xD504             BPL.N    ??HAL_EXTI_SetConfigLine_8
    210            {
    211              EXTI->IMR |= maskline;
   \       0x9A   0x....             LDR.N    R0,??DataTable6_3
   \       0x9C   0x6806             LDR      R6,[R0, #+0]
   \       0x9E   0x432E             ORRS     R6,R5,R6
   \       0xA0   0x6006             STR      R6,[R0, #+0]
   \       0xA2   0xE003             B.N      ??HAL_EXTI_SetConfigLine_9
    212            }
    213            else
    214            {
    215              EXTI->IMR &= ~maskline;
   \                     ??HAL_EXTI_SetConfigLine_8: (+1)
   \       0xA4   0x....             LDR.N    R0,??DataTable6_3
   \       0xA6   0x6806             LDR      R6,[R0, #+0]
   \       0xA8   0x43AE             BICS     R6,R6,R5
   \       0xAA   0x6006             STR      R6,[R0, #+0]
    216            }
    217          
    218            /* Configure event mode : read current mode */
    219            /* Mask or set line */
    220            if ((pExtiConfig->Mode & EXTI_MODE_EVENT) != 0x00u)
   \                     ??HAL_EXTI_SetConfigLine_9: (+1)
   \       0xAC   0x7908             LDRB     R0,[R1, #+4]
   \       0xAE   0x0780             LSLS     R0,R0,#+30
   \       0xB0   0xD504             BPL.N    ??HAL_EXTI_SetConfigLine_10
    221            {
    222              EXTI->EMR |= maskline;
   \       0xB2   0x....             LDR.N    R0,??DataTable6_4
   \       0xB4   0x6806             LDR      R6,[R0, #+0]
   \       0xB6   0x432E             ORRS     R6,R5,R6
   \       0xB8   0x6006             STR      R6,[R0, #+0]
   \       0xBA   0xE003             B.N      ??HAL_EXTI_SetConfigLine_11
    223            }
    224            else
    225            {
    226              EXTI->EMR &= ~maskline;
   \                     ??HAL_EXTI_SetConfigLine_10: (+1)
   \       0xBC   0x....             LDR.N    R0,??DataTable6_4
   \       0xBE   0x6806             LDR      R6,[R0, #+0]
   \       0xC0   0x43AE             BICS     R6,R6,R5
   \       0xC2   0x6006             STR      R6,[R0, #+0]
    227            }
    228          
    229            return HAL_OK;
   \                     ??HAL_EXTI_SetConfigLine_11: (+1)
   \       0xC4   0x2000             MOVS     R0,#+0
   \                     ??HAL_EXTI_SetConfigLine_2: (+1)
   \       0xC6   0xBCF0             POP      {R4-R7}
   \       0xC8   0x4770             BX       LR
    230          }
    231          
    232          /**
    233            * @brief  Get configuration of a dedicated Exti line.
    234            * @param  hexti Exti handle.
    235            * @param  pExtiConfig Pointer on structure to store Exti configuration.
    236            * @retval HAL Status.
    237            */

   \                                 In section .text, align 2, keep-with-next
    238          HAL_StatusTypeDef HAL_EXTI_GetConfigLine(EXTI_HandleTypeDef *hexti, EXTI_ConfigTypeDef *pExtiConfig)
    239          {
   \                     HAL_EXTI_GetConfigLine: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x0002             MOVS     R2,R0
    240            uint32_t regval;
    241            uint32_t linepos;
    242            uint32_t maskline;
    243          
    244            /* Check null pointer */
    245            if ((hexti == NULL) || (pExtiConfig == NULL))
   \        0x4   0x2A00             CMP      R2,#+0
   \        0x6   0xD001             BEQ.N    ??HAL_EXTI_GetConfigLine_0
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xD101             BNE.N    ??HAL_EXTI_GetConfigLine_1
    246            {
    247              return HAL_ERROR;
   \                     ??HAL_EXTI_GetConfigLine_0: (+1)
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE049             B.N      ??HAL_EXTI_GetConfigLine_2
    248            }
    249          
    250            /* Check the parameter */
    251            assert_param(IS_EXTI_LINE(hexti->Line));
    252          
    253            /* Store handle line number to configuration structure */
    254            pExtiConfig->Line = hexti->Line;
   \                     ??HAL_EXTI_GetConfigLine_1: (+1)
   \       0x10   0x6810             LDR      R0,[R2, #+0]
   \       0x12   0x6008             STR      R0,[R1, #+0]
    255          
    256            /* Compute line mask */
    257            linepos = (pExtiConfig->Line & EXTI_PIN_MASK);
   \       0x14   0x780C             LDRB     R4,[R1, #+0]
   \       0x16   0xF014 0x041F      ANDS     R4,R4,#0x1F
    258            maskline = (1uL << linepos);
   \       0x1A   0x2501             MOVS     R5,#+1
   \       0x1C   0x40A5             LSLS     R5,R5,R4
    259          
    260            /* 1] Get core mode : interrupt */
    261          
    262            /* Check if selected line is enable */
    263            if ((EXTI->IMR & maskline) != 0x00u)
   \       0x1E   0x....             LDR.N    R0,??DataTable6_3
   \       0x20   0x6800             LDR      R0,[R0, #+0]
   \       0x22   0x4228             TST      R0,R5
   \       0x24   0xD002             BEQ.N    ??HAL_EXTI_GetConfigLine_3
    264            {
    265              pExtiConfig->Mode = EXTI_MODE_INTERRUPT;
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0x6048             STR      R0,[R1, #+4]
   \       0x2A   0xE001             B.N      ??HAL_EXTI_GetConfigLine_4
    266            }
    267            else
    268            {
    269              pExtiConfig->Mode = EXTI_MODE_NONE;
   \                     ??HAL_EXTI_GetConfigLine_3: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x6048             STR      R0,[R1, #+4]
    270            }
    271          
    272            /* Get event mode */
    273            /* Check if selected line is enable */
    274            if ((EXTI->EMR & maskline) != 0x00u)
   \                     ??HAL_EXTI_GetConfigLine_4: (+1)
   \       0x30   0x....             LDR.N    R0,??DataTable6_4
   \       0x32   0x6800             LDR      R0,[R0, #+0]
   \       0x34   0x4228             TST      R0,R5
   \       0x36   0xD003             BEQ.N    ??HAL_EXTI_GetConfigLine_5
    275            {
    276              pExtiConfig->Mode |= EXTI_MODE_EVENT;
   \       0x38   0x6848             LDR      R0,[R1, #+4]
   \       0x3A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x3E   0x6048             STR      R0,[R1, #+4]
    277            }
    278          
    279            /* 2] Get trigger for configurable lines : rising */
    280            if ((pExtiConfig->Line & EXTI_CONFIG) != 0x00u)
   \                     ??HAL_EXTI_GetConfigLine_5: (+1)
   \       0x40   0x6808             LDR      R0,[R1, #+0]
   \       0x42   0x0180             LSLS     R0,R0,#+6
   \       0x44   0xD529             BPL.N    ??HAL_EXTI_GetConfigLine_6
    281            {
    282              /* Check if configuration of selected line is enable */
    283              if ((EXTI->RTSR & maskline) != 0x00u)
   \       0x46   0x....             LDR.N    R0,??DataTable6
   \       0x48   0x6800             LDR      R0,[R0, #+0]
   \       0x4A   0x4228             TST      R0,R5
   \       0x4C   0xD002             BEQ.N    ??HAL_EXTI_GetConfigLine_7
    284              {
    285                pExtiConfig->Trigger = EXTI_TRIGGER_RISING;
   \       0x4E   0x2001             MOVS     R0,#+1
   \       0x50   0x6088             STR      R0,[R1, #+8]
   \       0x52   0xE001             B.N      ??HAL_EXTI_GetConfigLine_8
    286              }
    287              else
    288              {
    289                pExtiConfig->Trigger = EXTI_TRIGGER_NONE;
   \                     ??HAL_EXTI_GetConfigLine_7: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x6088             STR      R0,[R1, #+8]
    290              }
    291          
    292              /* Get falling configuration */
    293              /* Check if configuration of selected line is enable */
    294              if ((EXTI->FTSR & maskline) != 0x00u)
   \                     ??HAL_EXTI_GetConfigLine_8: (+1)
   \       0x58   0x....             LDR.N    R0,??DataTable6_1
   \       0x5A   0x6800             LDR      R0,[R0, #+0]
   \       0x5C   0x4228             TST      R0,R5
   \       0x5E   0xD003             BEQ.N    ??HAL_EXTI_GetConfigLine_9
    295              {
    296                pExtiConfig->Trigger |= EXTI_TRIGGER_FALLING;
   \       0x60   0x6888             LDR      R0,[R1, #+8]
   \       0x62   0xF050 0x0002      ORRS     R0,R0,#0x2
   \       0x66   0x6088             STR      R0,[R1, #+8]
    297              }
    298          
    299              /* Get Gpio port selection for gpio lines */
    300              if ((pExtiConfig->Line & EXTI_GPIO) == EXTI_GPIO)
   \                     ??HAL_EXTI_GetConfigLine_9: (+1)
   \       0x68   0x6808             LDR      R0,[R1, #+0]
   \       0x6A   0xF010 0x60C0      ANDS     R0,R0,#0x6000000
   \       0x6E   0xF1B0 0x6FC0      CMP      R0,#+100663296
   \       0x72   0xD10F             BNE.N    ??HAL_EXTI_GetConfigLine_10
    301              {
    302                assert_param(IS_EXTI_GPIO_PIN(linepos));
    303          
    304                regval = SYSCFG->EXTICR[linepos >> 2u];
   \       0x74   0x....             LDR.N    R0,??DataTable6_2
   \       0x76   0x0026             MOVS     R6,R4
   \       0x78   0x08B6             LSRS     R6,R6,#+2
   \       0x7A   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \       0x7E   0x0003             MOVS     R3,R0
    305                pExtiConfig->GPIOSel = ((regval << (SYSCFG_EXTICR1_EXTI1_Pos * (3uL - (linepos & 0x03u)))) >> 24);
   \       0x80   0xF014 0x0003      ANDS     R0,R4,#0x3
   \       0x84   0xF1D0 0x0003      RSBS     R0,R0,#+3
   \       0x88   0x0080             LSLS     R0,R0,#+2
   \       0x8A   0xFA13 0xF000      LSLS     R0,R3,R0
   \       0x8E   0x0E00             LSRS     R0,R0,#+24
   \       0x90   0x60C8             STR      R0,[R1, #+12]
   \       0x92   0xE006             B.N      ??HAL_EXTI_GetConfigLine_11
    306              }
    307              else
    308              {
    309                pExtiConfig->GPIOSel = 0x00u;
   \                     ??HAL_EXTI_GetConfigLine_10: (+1)
   \       0x94   0x2000             MOVS     R0,#+0
   \       0x96   0x60C8             STR      R0,[R1, #+12]
   \       0x98   0xE003             B.N      ??HAL_EXTI_GetConfigLine_11
    310              }
    311            }
    312            else
    313            {
    314              /* No Trigger selected */
    315              pExtiConfig->Trigger = EXTI_TRIGGER_NONE;
   \                     ??HAL_EXTI_GetConfigLine_6: (+1)
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0x6088             STR      R0,[R1, #+8]
    316              pExtiConfig->GPIOSel = 0x00u;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0x60C8             STR      R0,[R1, #+12]
    317            }
    318          
    319            return HAL_OK;
   \                     ??HAL_EXTI_GetConfigLine_11: (+1)
   \       0xA2   0x2000             MOVS     R0,#+0
   \                     ??HAL_EXTI_GetConfigLine_2: (+1)
   \       0xA4   0xBC70             POP      {R4-R6}
   \       0xA6   0x4770             BX       LR
    320          }
    321          
    322          /**
    323            * @brief  Clear whole configuration of a dedicated Exti line.
    324            * @param  hexti Exti handle.
    325            * @retval HAL Status.
    326            */

   \                                 In section .text, align 2, keep-with-next
    327          HAL_StatusTypeDef HAL_EXTI_ClearConfigLine(EXTI_HandleTypeDef *hexti)
    328          {
   \                     HAL_EXTI_ClearConfigLine: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   \        0x2   0x0001             MOVS     R1,R0
    329            uint32_t regval;
    330            uint32_t linepos;
    331            uint32_t maskline;
    332          
    333            /* Check null pointer */
    334            if (hexti == NULL)
   \        0x4   0x2900             CMP      R1,#+0
   \        0x6   0xD101             BNE.N    ??HAL_EXTI_ClearConfigLine_0
    335            {
    336              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE02E             B.N      ??HAL_EXTI_ClearConfigLine_1
    337            }
    338          
    339            /* Check the parameter */
    340            assert_param(IS_EXTI_LINE(hexti->Line));
    341          
    342            /* compute line mask */
    343            linepos = (hexti->Line & EXTI_PIN_MASK);
   \                     ??HAL_EXTI_ClearConfigLine_0: (+1)
   \        0xC   0x780B             LDRB     R3,[R1, #+0]
   \        0xE   0xF013 0x031F      ANDS     R3,R3,#0x1F
    344            maskline = (1uL << linepos);
   \       0x12   0x2401             MOVS     R4,#+1
   \       0x14   0x409C             LSLS     R4,R4,R3
    345          
    346            /* 1] Clear interrupt mode */
    347            EXTI->IMR = (EXTI->IMR & ~maskline);
   \       0x16   0x....             LDR.N    R0,??DataTable6_3
   \       0x18   0x6805             LDR      R5,[R0, #+0]
   \       0x1A   0x43A5             BICS     R5,R5,R4
   \       0x1C   0x6005             STR      R5,[R0, #+0]
    348          
    349            /* 2] Clear event mode */
    350            EXTI->EMR = (EXTI->EMR & ~maskline);
   \       0x1E   0x....             LDR.N    R0,??DataTable6_4
   \       0x20   0x6805             LDR      R5,[R0, #+0]
   \       0x22   0x43A5             BICS     R5,R5,R4
   \       0x24   0x6005             STR      R5,[R0, #+0]
    351          
    352            /* 3] Clear triggers in case of configurable lines */
    353            if ((hexti->Line & EXTI_CONFIG) != 0x00u)
   \       0x26   0x6808             LDR      R0,[R1, #+0]
   \       0x28   0x0180             LSLS     R0,R0,#+6
   \       0x2A   0xD51D             BPL.N    ??HAL_EXTI_ClearConfigLine_2
    354            {
    355              EXTI->RTSR = (EXTI->RTSR & ~maskline);
   \       0x2C   0x....             LDR.N    R0,??DataTable6
   \       0x2E   0x6805             LDR      R5,[R0, #+0]
   \       0x30   0x43A5             BICS     R5,R5,R4
   \       0x32   0x6005             STR      R5,[R0, #+0]
    356              EXTI->FTSR = (EXTI->FTSR & ~maskline);
   \       0x34   0x....             LDR.N    R0,??DataTable6_1
   \       0x36   0x6805             LDR      R5,[R0, #+0]
   \       0x38   0x43A5             BICS     R5,R5,R4
   \       0x3A   0x6005             STR      R5,[R0, #+0]
    357          
    358              /* Get Gpio port selection for gpio lines */
    359              if ((hexti->Line & EXTI_GPIO) == EXTI_GPIO)
   \       0x3C   0x6808             LDR      R0,[R1, #+0]
   \       0x3E   0xF010 0x60C0      ANDS     R0,R0,#0x6000000
   \       0x42   0xF1B0 0x6FC0      CMP      R0,#+100663296
   \       0x46   0xD10F             BNE.N    ??HAL_EXTI_ClearConfigLine_2
    360              {
    361                assert_param(IS_EXTI_GPIO_PIN(linepos));
    362          
    363                regval = SYSCFG->EXTICR[linepos >> 2u];
   \       0x48   0x....             LDR.N    R5,??DataTable6_2
   \       0x4A   0x0018             MOVS     R0,R3
   \       0x4C   0x0880             LSRS     R0,R0,#+2
   \       0x4E   0xF855 0x0020      LDR      R0,[R5, R0, LSL #+2]
    364                regval &= ~(SYSCFG_EXTICR1_EXTI0 << (SYSCFG_EXTICR1_EXTI1_Pos * (linepos & 0x03u)));
   \       0x52   0x260F             MOVS     R6,#+15
   \       0x54   0x009F             LSLS     R7,R3,#+2
   \       0x56   0xF017 0x070C      ANDS     R7,R7,#0xC
   \       0x5A   0x40BE             LSLS     R6,R6,R7
   \       0x5C   0x43B0             BICS     R0,R0,R6
   \       0x5E   0x0002             MOVS     R2,R0
    365                SYSCFG->EXTICR[linepos >> 2u] = regval;
   \       0x60   0x0018             MOVS     R0,R3
   \       0x62   0x0880             LSRS     R0,R0,#+2
   \       0x64   0xF845 0x2020      STR      R2,[R5, R0, LSL #+2]
    366              }
    367            }
    368          
    369            return HAL_OK;
   \                     ??HAL_EXTI_ClearConfigLine_2: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \                     ??HAL_EXTI_ClearConfigLine_1: (+1)
   \       0x6A   0xBCF0             POP      {R4-R7}
   \       0x6C   0x4770             BX       LR
    370          }
    371          
    372          /**
    373            * @brief  Register callback for a dedicated Exti line.
    374            * @param  hexti Exti handle.
    375            * @param  CallbackID User callback identifier.
    376            *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
    377            * @param  pPendingCbfn function pointer to be stored as callback.
    378            * @retval HAL Status.
    379            */

   \                                 In section .text, align 2, keep-with-next
    380          HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
    381          {
   \                     HAL_EXTI_RegisterCallback: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0003             MOVS     R3,R0
    382            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2000             MOVS     R0,#+0
    383          
    384            switch (CallbackID)
   \        0x6   0x000C             MOVS     R4,R1
   \        0x8   0xB2E4             UXTB     R4,R4
   \        0xA   0x2C00             CMP      R4,#+0
   \        0xC   0xD101             BNE.N    ??HAL_EXTI_RegisterCallback_0
    385            {
    386              case  HAL_EXTI_COMMON_CB_ID:
    387                hexti->PendingCallback = pPendingCbfn;
   \        0xE   0x605A             STR      R2,[R3, #+4]
    388                break;
   \       0x10   0xE001             B.N      ??HAL_EXTI_RegisterCallback_1
    389          
    390              default:
    391                status = HAL_ERROR;
   \                     ??HAL_EXTI_RegisterCallback_0: (+1)
   \       0x12   0x2401             MOVS     R4,#+1
   \       0x14   0x0020             MOVS     R0,R4
    392                break;
    393            }
    394          
    395            return status;
   \                     ??HAL_EXTI_RegisterCallback_1: (+1)
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0xBC10             POP      {R4}
   \       0x1A   0x4770             BX       LR
    396          }
    397          
    398          /**
    399            * @brief  Store line number as handle private field.
    400            * @param  hexti Exti handle.
    401            * @param  ExtiLine Exti line number.
    402            *         This parameter can be from 0 to @ref EXTI_LINE_NB.
    403            * @retval HAL Status.
    404            */

   \                                 In section .text, align 2, keep-with-next
    405          HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)
    406          {
   \                     HAL_EXTI_GetHandle: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    407            /* Check the parameters */
    408            assert_param(IS_EXTI_LINE(ExtiLine));
    409          
    410            /* Check null pointer */
    411            if (hexti == NULL)
   \        0x2   0x2A00             CMP      R2,#+0
   \        0x4   0xD101             BNE.N    ??HAL_EXTI_GetHandle_0
    412            {
    413              return HAL_ERROR;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xE001             B.N      ??HAL_EXTI_GetHandle_1
    414            }
    415            else
    416            {
    417              /* Store line number as handle private field */
    418              hexti->Line = ExtiLine;
   \                     ??HAL_EXTI_GetHandle_0: (+1)
   \        0xA   0x6011             STR      R1,[R2, #+0]
    419          
    420              return HAL_OK;
   \        0xC   0x2000             MOVS     R0,#+0
   \                     ??HAL_EXTI_GetHandle_1: (+1)
   \        0xE   0x4770             BX       LR
    421            }
    422          }
    423          
    424          /**
    425            * @}
    426            */
    427          
    428          /** @addtogroup EXTI_Exported_Functions_Group2
    429            *  @brief EXTI IO functions.
    430            *
    431          @verbatim
    432           ===============================================================================
    433                                 ##### IO operation functions #####
    434           ===============================================================================
    435          
    436          @endverbatim
    437            * @{
    438            */
    439          
    440          /**
    441            * @brief  Handle EXTI interrupt request.
    442            * @param  hexti Exti handle.
    443            * @retval none.
    444            */

   \                                 In section .text, align 2, keep-with-next
    445          void HAL_EXTI_IRQHandler(EXTI_HandleTypeDef *hexti)
    446          {
   \                     HAL_EXTI_IRQHandler: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
    447            uint32_t regval;
    448            uint32_t maskline;
    449          
    450            /* Compute line mask */
    451            maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x782E             LDRB     R6,[R5, #+0]
   \        0x8   0xF016 0x061F      ANDS     R6,R6,#0x1F
   \        0xC   0xFA10 0xF606      LSLS     R6,R0,R6
    452          
    453            /* Get pending bit  */
    454            regval = (EXTI->PR & maskline);
   \       0x10   0x....             LDR.N    R0,??DataTable6_5
   \       0x12   0x6804             LDR      R4,[R0, #+0]
   \       0x14   0x4034             ANDS     R4,R6,R4
    455            if (regval != 0x00u)
   \       0x16   0x2C00             CMP      R4,#+0
   \       0x18   0xD005             BEQ.N    ??HAL_EXTI_IRQHandler_0
    456            {
    457              /* Clear pending bit */
    458              EXTI->PR = maskline;
   \       0x1A   0x6006             STR      R6,[R0, #+0]
    459          
    460              /* Call callback */
    461              if (hexti->PendingCallback != NULL)
   \       0x1C   0x6868             LDR      R0,[R5, #+4]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD001             BEQ.N    ??HAL_EXTI_IRQHandler_0
    462              {
    463                hexti->PendingCallback();
   \       0x22   0x6868             LDR      R0,[R5, #+4]
   \       0x24   0x4780             BLX      R0
    464              }
    465            }
    466          }
   \                     ??HAL_EXTI_IRQHandler_0: (+1)
   \       0x26   0xBD70             POP      {R4-R6,PC}
    467          
    468          /**
    469            * @brief  Get interrupt pending bit of a dedicated line.
    470            * @param  hexti Exti handle.
    471            * @param  Edge Specify which pending edge as to be checked.
    472            *         This parameter can be one of the following values:
    473            *           @arg @ref EXTI_TRIGGER_RISING_FALLING
    474            *         This parameter is kept for compatibility with other series.
    475            * @retval 1 if interrupt is pending else 0.
    476            */

   \                                 In section .text, align 2, keep-with-next
    477          uint32_t HAL_EXTI_GetPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)
    478          {
   \                     HAL_EXTI_GetPending: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0002             MOVS     R2,R0
    479            uint32_t regval;
    480            uint32_t linepos;
    481            uint32_t maskline;
    482          
    483            /* Check parameters */
    484            assert_param(IS_EXTI_LINE(hexti->Line));
    485            assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
    486            assert_param(IS_EXTI_PENDING_EDGE(Edge));
    487          
    488            /* Compute line mask */
    489            linepos = (hexti->Line & EXTI_PIN_MASK);
   \        0x4   0x7813             LDRB     R3,[R2, #+0]
   \        0x6   0xF013 0x031F      ANDS     R3,R3,#0x1F
    490            maskline = (1uL << linepos);
   \        0xA   0x2401             MOVS     R4,#+1
   \        0xC   0x409C             LSLS     R4,R4,R3
    491          
    492            /* return 1 if bit is set else 0 */
    493            regval = ((EXTI->PR & maskline) >> linepos);
   \        0xE   0x....             LDR.N    R0,??DataTable6_5
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x4020             ANDS     R0,R4,R0
   \       0x14   0x40D8             LSRS     R0,R0,R3
    494            return regval;
   \       0x16   0xBC10             POP      {R4}
   \       0x18   0x4770             BX       LR
    495          }
    496          
    497          /**
    498            * @brief  Clear interrupt pending bit of a dedicated line.
    499            * @param  hexti Exti handle.
    500            * @param  Edge Specify which pending edge as to be clear.
    501            *         This parameter can be one of the following values:
    502            *           @arg @ref EXTI_TRIGGER_RISING_FALLING
    503            *         This parameter is kept for compatibility with other series.
    504            * @retval None.
    505            */

   \                                 In section .text, align 2, keep-with-next
    506          void HAL_EXTI_ClearPending(EXTI_HandleTypeDef *hexti, uint32_t Edge)
    507          {
    508            uint32_t maskline;
    509          
    510            /* Check parameters */
    511            assert_param(IS_EXTI_LINE(hexti->Line));
    512            assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
    513            assert_param(IS_EXTI_PENDING_EDGE(Edge));
    514          
    515            /* Compute line mask */
    516            maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));
   \                     HAL_EXTI_ClearPending: (+1)
   \        0x0   0x2301             MOVS     R3,#+1
   \        0x2   0x7802             LDRB     R2,[R0, #+0]
   \        0x4   0xF012 0x021F      ANDS     R2,R2,#0x1F
   \        0x8   0xFA13 0xF202      LSLS     R2,R3,R2
    517          
    518            /* Clear Pending bit */
    519            EXTI->PR =  maskline;
   \        0xC   0x....             LDR.N    R3,??DataTable6_5
   \        0xE   0x601A             STR      R2,[R3, #+0]
    520          }
   \       0x10   0x4770             BX       LR
    521          
    522          /**
    523            * @brief  Generate a software interrupt for a dedicated line.
    524            * @param  hexti Exti handle.
    525            * @retval None.
    526            */

   \                                 In section .text, align 2, keep-with-next
    527          void HAL_EXTI_GenerateSWI(EXTI_HandleTypeDef *hexti)
    528          {
    529            uint32_t maskline;
    530          
    531            /* Check parameters */
    532            assert_param(IS_EXTI_LINE(hexti->Line));
    533            assert_param(IS_EXTI_CONFIG_LINE(hexti->Line));
    534          
    535            /* Compute line mask */
    536            maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));
   \                     HAL_EXTI_GenerateSWI: (+1)
   \        0x0   0x2201             MOVS     R2,#+1
   \        0x2   0x7801             LDRB     R1,[R0, #+0]
   \        0x4   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \        0x8   0xFA12 0xF101      LSLS     R1,R2,R1
    537          
    538            /* Generate Software interrupt */
    539            EXTI->SWIER = maskline;
   \        0xC   0x....             LDR.N    R2,??DataTable6_6
   \        0xE   0x6011             STR      R1,[R2, #+0]
    540          }
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x4001'3C08        DC32     0x40013c08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x4001'3C0C        DC32     0x40013c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x4001'3808        DC32     0x40013808

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \        0x0   0x4001'3C00        DC32     0x40013c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \        0x0   0x4001'3C04        DC32     0x40013c04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \        0x0   0x4001'3C14        DC32     0x40013c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \        0x0   0x4001'3C10        DC32     0x40013c10
    541          
    542          /**
    543            * @}
    544            */
    545          
    546          /**
    547            * @}
    548            */
    549          
    550          #endif /* HAL_EXTI_MODULE_ENABLED */
    551          /**
    552            * @}
    553            */
    554          
    555          /**
    556            * @}
    557            */
    558          
    559          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   HAL_EXTI_ClearConfigLine
       0   HAL_EXTI_ClearPending
       0   HAL_EXTI_GenerateSWI
      12   HAL_EXTI_GetConfigLine
       0   HAL_EXTI_GetHandle
       4   HAL_EXTI_GetPending
      16   HAL_EXTI_IRQHandler
        16   -- Indirect call
       4   HAL_EXTI_RegisterCallback
      16   HAL_EXTI_SetConfigLine


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
     110  HAL_EXTI_ClearConfigLine
      18  HAL_EXTI_ClearPending
      18  HAL_EXTI_GenerateSWI
     168  HAL_EXTI_GetConfigLine
      16  HAL_EXTI_GetHandle
      26  HAL_EXTI_GetPending
      40  HAL_EXTI_IRQHandler
      28  HAL_EXTI_RegisterCallback
     202  HAL_EXTI_SetConfigLine

 
 654 bytes in section .text
 
 654 bytes of CODE memory

Errors: none
Warnings: none
