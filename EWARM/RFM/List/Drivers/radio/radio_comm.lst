###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         27/Sep/2022  19:40:23
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode          =  thumb
#    Endian            =  little
#    Source file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\radio_comm.c
#    Command line      =
#        -f
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\radio\radio_comm.o.rsp
#        (C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\radio_comm.c -D
#        USE_HAL_DRIVER -D STM32F407xx -lC
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\radio -o
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\radio --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e
#        --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/App\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Core/Inc\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Include\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/display\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Library\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\radio\radio_comm.o.d
#    Locale            =  C
#    List file         =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Drivers\radio\radio_comm.lst
#    Object file       =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Drivers\radio\radio_comm.o
#    Runtime model:       
#      __CPP_Runtime   =  1
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\radio_comm.c
      1          /*!
      2           * File:
      3           *  radio_comm.h
      4           *
      5           * Description:
      6           *  This file contains the RADIO communication layer.
      7           *
      8           * Silicon Laboratories Confidential
      9           * Copyright 2012 Silicon Laboratories, Inc.
     10           */
     11          
     12                          /* ======================================= *
     13                           *              I N C L U D E              *
     14                           * ======================================= */
     15          
     16          #include "main.h"			//	define SILABS_RADIO_SI446X / RADIO_DRIVER_FULL_SUPPORT

  # warning unrecognized compiler
    ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\compiler_defs.h",744  Warning[Pa183]: 
          #warning directive: unrecognized compiler
     17          
     18          #include "radio_hal.h"		//	radio_hal_ClearNsel()

  typedef unsigned char       BYTE;
                              ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",73  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned short      WORD;
                              ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",77  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned char 		BIT;
                        		^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",83  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned char 		U8;
                        		^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",84  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned int 		U16;
                       		^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",85  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef unsigned long 		U32;
                        		^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",86  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed char 		S8;
                      		^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",88  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed int 			S16;
                     			^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",89  Warning[Pe301]: 
          typedef name has already been declared (with same type)

  typedef signed long 		S32;
                      		^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Core\Inc\typedef.h",90  Warning[Pe301]: 
          typedef name has already been declared (with same type)
     19          #include "radio_comm.h"
     20          
     21                          /* ======================================= *
     22                           *          D E F I N I T I O N S          *
     23                           * ======================================= */
     24          
     25                          /* ======================================= *
     26                           *     G L O B A L   V A R I A B L E S     *
     27                           * ======================================= */
     28          
     29          #if (defined SILABS_RADIO_SI446X) || (defined SILABS_RADIO_SI4455)

   \                                 In section .bss, align 1
     30          BIT ctsWentHigh = 0;
   \                     ctsWentHigh:
   \        0x0                      DS8 1
     31          #endif
     32          
     33          
     34                          /* ======================================= *
     35                           *      L O C A L   F U N C T I O N S      *
     36                           * ======================================= */
     37          
     38                          /* ======================================= *
     39                           *     P U B L I C   F U N C T I O N S     *
     40                           * ======================================= */
     41          
     42          #if (defined SILABS_RADIO_SI446X) || (defined SILABS_RADIO_SI4455)
     43          
     44          /*!
     45           * Gets a command response from the radio chip
     46           *
     47           * @param byteCount     Number of bytes to get from the radio chip
     48           * @param pData         Pointer to where to put the data
     49           *
     50           * @return CTS value
     51           */

   \                                 In section .text, align 2, keep-with-next
     52          U8 radio_comm_GetResp(U8 byteCount, U8* pData)
     53          {
   \                     radio_comm_GetResp: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
     54            SEGMENT_VARIABLE(ctsVal = 0u, U8, SEG_DATA);
   \        0x6   0x2700             MOVS     R7,#+0
     55            SEGMENT_VARIABLE(errCnt = RADIO_CTS_TIMEOUT, U16, SEG_DATA);
   \        0x8   0xF242 0x7410      MOVW     R4,#+10000
     56          
     57            while (errCnt != 0)      //wait until radio IC is ready with the data
   \                     ??radio_comm_GetResp_0: (+1)
   \        0xC   0x2C00             CMP      R4,#+0
   \        0xE   0xD01B             BEQ.N    ??radio_comm_GetResp_1
     58            {
     59              radio_hal_ClearNsel();
   \       0x10   0x.... 0x....      BL       radio_hal_ClearNsel
     60              radio_hal_SpiWriteByte(0x44);    //read CMD buffer
   \       0x14   0x2044             MOVS     R0,#+68
   \       0x16   0x.... 0x....      BL       radio_hal_SpiWriteByte
     61              ctsVal = radio_hal_SpiReadByte();
   \       0x1A   0x.... 0x....      BL       radio_hal_SpiReadByte
   \       0x1E   0x0007             MOVS     R7,R0
     62              if (ctsVal == 0xFF)
   \       0x20   0x0038             MOVS     R0,R7
   \       0x22   0xB2C0             UXTB     R0,R0
   \       0x24   0x28FF             CMP      R0,#+255
   \       0x26   0xD10B             BNE.N    ??radio_comm_GetResp_2
     63              {
     64                if (byteCount)
   \       0x28   0x0028             MOVS     R0,R5
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD004             BEQ.N    ??radio_comm_GetResp_3
     65                {
     66                  radio_hal_SpiReadData(byteCount, pData);
   \       0x30   0x0031             MOVS     R1,R6
   \       0x32   0x0028             MOVS     R0,R5
   \       0x34   0xB2C0             UXTB     R0,R0
   \       0x36   0x.... 0x....      BL       radio_hal_SpiReadData
     67                }
     68                radio_hal_SetNsel();
   \                     ??radio_comm_GetResp_3: (+1)
   \       0x3A   0x.... 0x....      BL       radio_hal_SetNsel
     69                break;
   \       0x3E   0xE003             B.N      ??radio_comm_GetResp_1
     70              }
     71              radio_hal_SetNsel();
   \                     ??radio_comm_GetResp_2: (+1)
   \       0x40   0x.... 0x....      BL       radio_hal_SetNsel
     72              errCnt--;
   \       0x44   0x1E64             SUBS     R4,R4,#+1
   \       0x46   0xE7E1             B.N      ??radio_comm_GetResp_0
     73            }
     74          
     75            if (errCnt == 0)
   \                     ??radio_comm_GetResp_1: (+1)
   \       0x48   0x2C00             CMP      R4,#+0
   \       0x4A   0xD100             BNE.N    ??radio_comm_GetResp_4
     76            {
     77              while(1)
   \                     ??radio_comm_GetResp_5: (+1)
   \       0x4C   0xE7FE             B.N      ??radio_comm_GetResp_5
     78              {
     79                /* ERROR!!!!  CTS should never take this long. */
     80                #ifdef RADIO_COMM_ERROR_CALLBACK
     81                  RADIO_COMM_ERROR_CALLBACK();
     82                #endif
     83              }
     84            }
     85          
     86            if (ctsVal == 0xFF)
   \                     ??radio_comm_GetResp_4: (+1)
   \       0x4E   0x0038             MOVS     R0,R7
   \       0x50   0xB2C0             UXTB     R0,R0
   \       0x52   0x28FF             CMP      R0,#+255
   \       0x54   0xD102             BNE.N    ??radio_comm_GetResp_6
     87            {
     88              ctsWentHigh = 1;
   \       0x56   0x2001             MOVS     R0,#+1
   \       0x58   0x....             LDR.N    R1,??DataTable4
   \       0x5A   0x7008             STRB     R0,[R1, #+0]
     89            }
     90          
     91            return ctsVal;
   \                     ??radio_comm_GetResp_6: (+1)
   \       0x5C   0x0038             MOVS     R0,R7
   \       0x5E   0xB2C0             UXTB     R0,R0
   \       0x60   0xBDF2             POP      {R1,R4-R7,PC}
     92          }
     93          
     94          /*!
     95           * Sends a command to the radio chip
     96           *
     97           * @param byteCount     Number of bytes in the command to send to the radio device
     98           * @param pData         Pointer to the command to send.
     99           */

   \                                 In section .text, align 2, keep-with-next
    100          void radio_comm_SendCmd(U8 byteCount, U8* pData)
    101          {
   \                     radio_comm_SendCmd: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    102              while (!ctsWentHigh)
   \                     ??radio_comm_SendCmd_0: (+1)
   \        0x6   0x....             LDR.N    R6,??DataTable4
   \        0x8   0x7830             LDRB     R0,[R6, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD102             BNE.N    ??radio_comm_SendCmd_1
    103              {
    104                  radio_comm_PollCTS();
   \        0xE   0x.... 0x....      BL       radio_comm_PollCTS
   \       0x12   0xE7F8             B.N      ??radio_comm_SendCmd_0
    105              }
    106              radio_hal_ClearNsel();
   \                     ??radio_comm_SendCmd_1: (+1)
   \       0x14   0x.... 0x....      BL       radio_hal_ClearNsel
    107              radio_hal_SpiWriteData(byteCount, pData);
   \       0x18   0x0029             MOVS     R1,R5
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0x.... 0x....      BL       radio_hal_SpiWriteData
    108              radio_hal_SetNsel();
   \       0x22   0x.... 0x....      BL       radio_hal_SetNsel
    109              ctsWentHigh = 0;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x7030             STRB     R0,[R6, #+0]
    110          }
   \       0x2A   0xBD70             POP      {R4-R6,PC}
    111          
    112          /*!
    113           * Gets a command response from the radio chip
    114           *
    115           * @param cmd           Command ID
    116           * @param pollCts       Set to poll CTS
    117           * @param byteCount     Number of bytes to get from the radio chip.
    118           * @param pData         Pointer to where to put the data.
    119           */

   \                                 In section .text, align 2, keep-with-next
    120          void radio_comm_ReadData(U8 cmd, BIT pollCts, U8 byteCount, U8* pData)
    121          {
   \                     radio_comm_ReadData: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
    122              if(pollCts)
   \        0xA   0x0028             MOVS     R0,R5
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD006             BEQ.N    ??radio_comm_ReadData_0
    123              {
    124                  while(!ctsWentHigh)
   \                     ??radio_comm_ReadData_1: (+1)
   \       0x12   0x....             LDR.N    R0,??DataTable4
   \       0x14   0x7800             LDRB     R0,[R0, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD102             BNE.N    ??radio_comm_ReadData_0
    125                  {
    126                      radio_comm_PollCTS();
   \       0x1A   0x.... 0x....      BL       radio_comm_PollCTS
   \       0x1E   0xE7F8             B.N      ??radio_comm_ReadData_1
    127                  }
    128              }
    129              radio_hal_ClearNsel();
   \                     ??radio_comm_ReadData_0: (+1)
   \       0x20   0x.... 0x....      BL       radio_hal_ClearNsel
    130              radio_hal_SpiWriteByte(cmd);
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0xB2C0             UXTB     R0,R0
   \       0x28   0x.... 0x....      BL       radio_hal_SpiWriteByte
    131              radio_hal_SpiReadData(byteCount, pData);
   \       0x2C   0x0039             MOVS     R1,R7
   \       0x2E   0x0030             MOVS     R0,R6
   \       0x30   0xB2C0             UXTB     R0,R0
   \       0x32   0x.... 0x....      BL       radio_hal_SpiReadData
    132              radio_hal_SetNsel();
   \       0x36   0x.... 0x....      BL       radio_hal_SetNsel
    133              ctsWentHigh = 0;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x....             LDR.N    R1,??DataTable4
   \       0x3E   0x7008             STRB     R0,[R1, #+0]
    134          }
   \       0x40   0xBDF1             POP      {R0,R4-R7,PC}
    135          
    136          
    137          /*!
    138           * Gets a command response from the radio chip
    139           *
    140           * @param cmd           Command ID
    141           * @param pollCts       Set to poll CTS
    142           * @param byteCount     Number of bytes to get from the radio chip
    143           * @param pData         Pointer to where to put the data
    144           */

   \                                 In section .text, align 2, keep-with-next
    145          void radio_comm_WriteData(U8 cmd, BIT pollCts, U8 byteCount, U8* pData)
    146          {
   \                     radio_comm_WriteData: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
    147              if(pollCts)
   \        0xA   0x0028             MOVS     R0,R5
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD006             BEQ.N    ??radio_comm_WriteData_0
    148              {
    149                  while(!ctsWentHigh)
   \                     ??radio_comm_WriteData_1: (+1)
   \       0x12   0x....             LDR.N    R0,??DataTable4
   \       0x14   0x7800             LDRB     R0,[R0, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD102             BNE.N    ??radio_comm_WriteData_0
    150                  {
    151                      radio_comm_PollCTS();
   \       0x1A   0x.... 0x....      BL       radio_comm_PollCTS
   \       0x1E   0xE7F8             B.N      ??radio_comm_WriteData_1
    152                  }
    153              }
    154              radio_hal_ClearNsel();
   \                     ??radio_comm_WriteData_0: (+1)
   \       0x20   0x.... 0x....      BL       radio_hal_ClearNsel
    155              radio_hal_SpiWriteByte(cmd);
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0xB2C0             UXTB     R0,R0
   \       0x28   0x.... 0x....      BL       radio_hal_SpiWriteByte
    156              radio_hal_SpiWriteData(byteCount, pData);
   \       0x2C   0x0039             MOVS     R1,R7
   \       0x2E   0x0030             MOVS     R0,R6
   \       0x30   0xB2C0             UXTB     R0,R0
   \       0x32   0x.... 0x....      BL       radio_hal_SpiWriteData
    157              radio_hal_SetNsel();
   \       0x36   0x.... 0x....      BL       radio_hal_SetNsel
    158              ctsWentHigh = 0;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x....             LDR.N    R1,??DataTable4
   \       0x3E   0x7008             STRB     R0,[R1, #+0]
    159          }
   \       0x40   0xBDF1             POP      {R0,R4-R7,PC}
    160          
    161          /*!
    162           * Waits for CTS to be high
    163           *
    164           * @return CTS value
    165           */

   \                                 In section .text, align 2, keep-with-next
    166          U8 radio_comm_PollCTS(void)
    167          {
   \                     radio_comm_PollCTS: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    168          #ifdef RADIO_USER_CFG_USE_GPIO1_FOR_CTS
    169              while(!radio_hal_Gpio1Level())
    170              {
    171                  /* Wait...*/
    172              }
    173              ctsWentHigh = 1;
    174              return 0xFF;
    175          #else
    176              return radio_comm_GetResp(0, 0);
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x.... 0x....      BL       radio_comm_GetResp
   \        0xA   0xBD02             POP      {R1,PC}
    177          #endif
    178          }
    179          
    180          /**
    181           * Clears the CTS state variable.
    182           */

   \                                 In section .text, align 2, keep-with-next
    183          void radio_comm_ClearCTS()
    184          {
    185            ctsWentHigh = 0;
   \                     radio_comm_ClearCTS: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x....             LDR.N    R1,??DataTable4
   \        0x4   0x7008             STRB     R0,[R1, #+0]
    186          }
   \        0x6   0x4770             BX       LR
    187          
    188          #elif (defined SILABS_RADIO_SI4012)
    189          
    190          /*!
    191           * Gets a command response from the radio chip
    192           *
    193           * @param byteCount     Number of bytes to get from the radio chip
    194           * @param pData         Pointer to where to put the data
    195           *
    196           * @return CTS value
    197           */
    198          U8 radio_comm_GetResp(U8 byteCount, U8* pData)
    199          {
    200            SEGMENT_VARIABLE(ctsVal = 0u, U8, SEG_DATA);
    201          
    202            if (qSmbus_SMBusRead(SI4012_SMBUS_ADDRESS, byteCount, pData) != \
    203                                                                    SMBUS_RX_FINISHED) {
    204              return FALSE;
    205            }
    206          
    207            if (pData[0] == 0x80) {
    208              return TRUE;
    209            }
    210          
    211            return FALSE;
    212          }
    213          
    214          /*!
    215           * Sends a command to the radio chip
    216           *
    217           * @param byteCount     Number of bytes in the command to send to the radio device
    218           * @param pData         Pointer to the command to send.
    219           */
    220          U8 radio_comm_SendCmd(U8 byteCount, U8* pData)
    221          {
    222            if (qSmbus_SMBusWrite(SI4012_SMBUS_ADDRESS, byteCount, pData) != \
    223                                                                SMBUS_TRANSMISSION_OK) {
    224              return FALSE;
    225            }
    226          
    227            return TRUE;
    228          }
    229          
    230          #endif
    231          
    232          /*!
    233           * Sends a command to the radio chip and gets a response
    234           *
    235           * @param cmdByteCount  Number of bytes in the command to send to the radio device
    236           * @param pCmdData      Pointer to the command data
    237           * @param respByteCount Number of bytes in the response to fetch
    238           * @param pRespData     Pointer to where to put the response data
    239           *
    240           * @return CTS value
    241           */

   \                                 In section .text, align 2, keep-with-next
    242          U8 radio_comm_SendCmdGetResp(U8 cmdByteCount, U8* pCmdData, U8 respByteCount, U8* pRespData)
    243          {
   \                     radio_comm_SendCmdGetResp: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001F             MOVS     R7,R3
    244              radio_comm_SendCmd(cmdByteCount, pCmdData);
   \        0xA   0x0029             MOVS     R1,R5
   \        0xC   0x0020             MOVS     R0,R4
   \        0xE   0xB2C0             UXTB     R0,R0
   \       0x10   0x.... 0x....      BL       radio_comm_SendCmd
    245              return radio_comm_GetResp(respByteCount, pRespData);
   \       0x14   0x0039             MOVS     R1,R7
   \       0x16   0x0030             MOVS     R0,R6
   \       0x18   0xB2C0             UXTB     R0,R0
   \       0x1A   0x.... 0x....      BL       radio_comm_GetResp
   \       0x1E   0xBDF2             POP      {R1,R4-R7,PC}
    246          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x....'....        DC32     ctsWentHigh
    247          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   radio_comm_ClearCTS
      24   radio_comm_GetResp
        24   -> radio_hal_ClearNsel
        24   -> radio_hal_SetNsel
        24   -> radio_hal_SpiReadByte
        24   -> radio_hal_SpiReadData
        24   -> radio_hal_SpiWriteByte
       8   radio_comm_PollCTS
         8   -> radio_comm_GetResp
      24   radio_comm_ReadData
        24   -> radio_comm_PollCTS
        24   -> radio_hal_ClearNsel
        24   -> radio_hal_SetNsel
        24   -> radio_hal_SpiReadData
        24   -> radio_hal_SpiWriteByte
      16   radio_comm_SendCmd
        16   -> radio_comm_PollCTS
        16   -> radio_hal_ClearNsel
        16   -> radio_hal_SetNsel
        16   -> radio_hal_SpiWriteData
      24   radio_comm_SendCmdGetResp
        24   -> radio_comm_GetResp
        24   -> radio_comm_SendCmd
      24   radio_comm_WriteData
        24   -> radio_comm_PollCTS
        24   -> radio_hal_ClearNsel
        24   -> radio_hal_SetNsel
        24   -> radio_hal_SpiWriteByte
        24   -> radio_hal_SpiWriteData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       1  ctsWentHigh
       8  radio_comm_ClearCTS
      98  radio_comm_GetResp
      12  radio_comm_PollCTS
      66  radio_comm_ReadData
      44  radio_comm_SendCmd
      32  radio_comm_SendCmdGetResp
      66  radio_comm_WriteData

 
   1 byte  in section .bss
 330 bytes in section .text
 
 330 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: 10
