###############################################################################
#
# IAR ANSI C/C++ Compiler V9.30.1.335/W64 for ARM         21/Sep/2022  13:06:26
# Copyright 1999-2022 IAR Systems AB.
#
#    Cpu mode                     =  thumb
#    Endian                       =  little
#    Source file                  =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\Middlewares\ST\STM32_USB_Device_Library\Class\CDC\Src\usbd_cdc.c
#    Command line                 =
#        -f
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Middlewares\USB_Device_Library\usbd_cdc.o.rsp
#        (C:\D\Git_Hub\STM_IAR_SIL_Change\Middlewares\ST\STM32_USB_Device_Library\Class\CDC\Src\usbd_cdc.c
#        -D USE_HAL_DRIVER -D STM32F407xx -lC
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Middlewares\USB_Device_Library
#        -o
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Middlewares\USB_Device_Library
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=VFPv4_sp --dlib_config "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.1\arm\inc\c\DLib_Config_Full.h" -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/App\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../USB_DEVICE/Target\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Core/Inc\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Core/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Middlewares/ST/STM32_USB_Device_Library/Class/CDC/Inc\
#        -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Device/ST/STM32F4xx/Include\
#        -I C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/CMSIS/Include\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/radio/Si446x\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Drivers/display\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM/../Library\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\display\fonts\ -I
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\..\Drivers\STM32F4xx_HAL_Driver\Src\
#        -On --use_c++_inline -I "C:\Program Files\IAR Systems\Embedded
#        Workbench 9.1\arm\CMSIS\Core\Include\\") --dependencies=n
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Middlewares\USB_Device_Library\usbd_cdc.o.d
#    Locale                       =  C
#    List file                    =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\List\Middlewares\USB_Device_Library\usbd_cdc.lst
#    Object file                  =
#        C:\D\Git_Hub\STM_IAR_SIL_Change\EWARM\RFM\Obj\Middlewares\USB_Device_Library\usbd_cdc.o
#    Runtime model:                  
#      __CPP_Runtime              =  1
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  1
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\D\Git_Hub\STM_IAR_SIL_Change\Middlewares\ST\STM32_USB_Device_Library\Class\CDC\Src\usbd_cdc.c
      1          /**
      2            ******************************************************************************
      3            * @file    usbd_cdc.c
      4            * @author  MCD Application Team
      5            * @brief   This file provides the high layer firmware functions to manage the
      6            *          following functionalities of the USB CDC Class:
      7            *           - Initialization and Configuration of high and low layer
      8            *           - Enumeration as CDC Device (and enumeration for each implemented memory interface)
      9            *           - OUT/IN data transfer
     10            *           - Command IN transfer (class requests management)
     11            *           - Error management
     12            *
     13            *  @verbatim
     14            *
     15            *          ===================================================================
     16            *                                CDC Class Driver Description
     17            *          ===================================================================
     18            *           This driver manages the "Universal Serial Bus Class Definitions for Communications Devices
     19            *           Revision 1.2 November 16, 2007" and the sub-protocol specification of "Universal Serial Bus
     20            *           Communications Class Subclass Specification for PSTN Devices Revision 1.2 February 9, 2007"
     21            *           This driver implements the following aspects of the specification:
     22            *             - Device descriptor management
     23            *             - Configuration descriptor management
     24            *             - Enumeration as CDC device with 2 data endpoints (IN and OUT) and 1 command endpoint (IN)
     25            *             - Requests management (as described in section 6.2 in specification)
     26            *             - Abstract Control Model compliant
     27            *             - Union Functional collection (using 1 IN endpoint for control)
     28            *             - Data interface class
     29            *
     30            *           These aspects may be enriched or modified for a specific user application.
     31            *
     32            *            This driver doesn't implement the following aspects of the specification
     33            *            (but it is possible to manage these features with some modifications on this driver):
     34            *             - Any class-specific aspect relative to communication classes should be managed by user application.
     35            *             - All communication classes other than PSTN are not managed
     36            *
     37            *  @endverbatim
     38            *
     39            ******************************************************************************
     40            * @attention
     41            *
     42            * <h2><center>&copy; Copyright (c) 2015 STMicroelectronics.
     43            * All rights reserved.</center></h2>
     44            *
     45            * This software component is licensed by ST under Ultimate Liberty license
     46            * SLA0044, the "License"; You may not use this file except in compliance with
     47            * the License. You may obtain a copy of the License at:
     48            *                      www.st.com/SLA0044
     49            *
     50            ******************************************************************************
     51            */
     52          
     53          /* BSPDependencies
     54          - "stm32xxxxx_{eval}{discovery}{nucleo_144}.c"
     55          - "stm32xxxxx_{eval}{discovery}_io.c"
     56          EndBSPDependencies */
     57          
     58          /* Includes ------------------------------------------------------------------*/
     59          #include "usbd_cdc.h"

  # warning unrecognized compiler
    ^
"C:\D\Git_Hub\STM_IAR_SIL_Change\Drivers\radio\compiler_defs.h",744  Warning[Pa183]: 
          #warning directive: unrecognized compiler
     60          #include "usbd_ctlreq.h"
     61          
     62          
     63          /** @addtogroup STM32_USB_DEVICE_LIBRARY
     64            * @{
     65            */
     66          
     67          
     68          /** @defgroup USBD_CDC
     69            * @brief usbd core module
     70            * @{
     71            */
     72          
     73          /** @defgroup USBD_CDC_Private_TypesDefinitions
     74            * @{
     75            */
     76          /**
     77            * @}
     78            */
     79          
     80          
     81          /** @defgroup USBD_CDC_Private_Defines
     82            * @{
     83            */
     84          /**
     85            * @}
     86            */
     87          
     88          
     89          /** @defgroup USBD_CDC_Private_Macros
     90            * @{
     91            */
     92          
     93          /**
     94            * @}
     95            */
     96          
     97          
     98          /** @defgroup USBD_CDC_Private_FunctionPrototypes
     99            * @{
    100            */
    101          
    102          static uint8_t USBD_CDC_Init(USBD_HandleTypeDef *pdev, uint8_t cfgidx);
    103          static uint8_t USBD_CDC_DeInit(USBD_HandleTypeDef *pdev, uint8_t cfgidx);
    104          static uint8_t USBD_CDC_Setup(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req);
    105          static uint8_t USBD_CDC_DataIn(USBD_HandleTypeDef *pdev, uint8_t epnum);
    106          static uint8_t USBD_CDC_DataOut(USBD_HandleTypeDef *pdev, uint8_t epnum);
    107          static uint8_t USBD_CDC_EP0_RxReady(USBD_HandleTypeDef *pdev);
    108          
    109          static uint8_t *USBD_CDC_GetFSCfgDesc(uint16_t *length);
    110          static uint8_t *USBD_CDC_GetHSCfgDesc(uint16_t *length);
    111          static uint8_t *USBD_CDC_GetOtherSpeedCfgDesc(uint16_t *length);
    112          static uint8_t *USBD_CDC_GetOtherSpeedCfgDesc(uint16_t *length);
    113          uint8_t *USBD_CDC_GetDeviceQualifierDescriptor(uint16_t *length);
    114          
    115          /* USB Standard Device Descriptor */

   \                                 In section .data, align 4
    116          __ALIGN_BEGIN static uint8_t USBD_CDC_DeviceQualifierDesc[USB_LEN_DEV_QUALIFIER_DESC] __ALIGN_END =
   \                     USBD_CDC_DeviceQualifierDesc:
   \        0x0   0x0A 0x06          DC8 10, 6, 0, 2, 0, 0, 0, 64, 1, 0

   \              0x00 0x02    

   \              0x00 0x00    

   \              0x00 0x40    

   \              0x01 0x00
   \        0xA                      DS8 2
    117          {
    118            USB_LEN_DEV_QUALIFIER_DESC,
    119            USB_DESC_TYPE_DEVICE_QUALIFIER,
    120            0x00,
    121            0x02,
    122            0x00,
    123            0x00,
    124            0x00,
    125            0x40,
    126            0x01,
    127            0x00,
    128          };
    129          
    130          /**
    131            * @}
    132            */
    133          
    134          /** @defgroup USBD_CDC_Private_Variables
    135            * @{
    136            */
    137          
    138          
    139          /* CDC interface class callbacks structure */

   \                                 In section .data, align 4
    140          USBD_ClassTypeDef  USBD_CDC =
   \                     USBD_CDC:
   \        0x0   0x....'....        DC32 USBD_CDC_Init, USBD_CDC_DeInit, USBD_CDC_Setup, 0x0

   \              0x....'....  

   \              0x....'....  

   \              0x0000'0000
   \       0x10   0x....'....        DC32 USBD_CDC_EP0_RxReady, USBD_CDC_DataIn, USBD_CDC_DataOut, 0x0, 0x0

   \              0x....'....  

   \              0x....'....  

   \              0x0000'0000  

   \              0x0000'0000
   \       0x24   0x0000'0000        DC32 0x0, USBD_CDC_GetHSCfgDesc, USBD_CDC_GetFSCfgDesc

   \              0x....'....  

   \              0x....'....
   \       0x30   0x....'....        DC32 USBD_CDC_GetOtherSpeedCfgDesc
   \       0x34   0x....'....        DC32 USBD_CDC_GetDeviceQualifierDescriptor
    141          {
    142            USBD_CDC_Init,
    143            USBD_CDC_DeInit,
    144            USBD_CDC_Setup,
    145            NULL,                 /* EP0_TxSent, */
    146            USBD_CDC_EP0_RxReady,
    147            USBD_CDC_DataIn,
    148            USBD_CDC_DataOut,
    149            NULL,
    150            NULL,
    151            NULL,
    152            USBD_CDC_GetHSCfgDesc,
    153            USBD_CDC_GetFSCfgDesc,
    154            USBD_CDC_GetOtherSpeedCfgDesc,
    155            USBD_CDC_GetDeviceQualifierDescriptor,
    156          };
    157          
    158          /* USB CDC device Configuration Descriptor */

   \                                 In section .data, align 4
    159          __ALIGN_BEGIN static uint8_t USBD_CDC_CfgHSDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END =
   \                     USBD_CDC_CfgHSDesc:
   \        0x0   0x09 0x02          DC8 9, 2, 67, 0, 2, 1, 0, 192, 50, 9, 4, 0, 0, 1, 2, 2, 1, 0, 5, 36, 0

   \              0x43 0x00    

   \              0x02 0x01    

   \              0x00 0xC0    

   \              0x32 0x09    

   \              0x04 0x00    

   \              0x00 0x01    

   \              0x02 0x02    

   \              0x01 0x00    

   \              0x05 0x24    

   \              0x00
   \       0x15   0x10 0x01          DC8 16, 1, 5, 36, 1, 0, 1, 4, 36, 2, 2, 5, 36, 6, 0, 1, 7, 5, 130, 3, 8

   \              0x05 0x24    

   \              0x01 0x00    

   \              0x01 0x04    

   \              0x24 0x02    

   \              0x02 0x05    

   \              0x24 0x06    

   \              0x00 0x01    

   \              0x07 0x05    

   \              0x82 0x03    

   \              0x08
   \       0x2A   0x00 0x10          DC8 0, 16, 9, 4, 1, 0, 2, 10, 0, 0, 0, 7, 5, 1, 2, 0, 2, 0, 7, 5, 129

   \              0x09 0x04    

   \              0x01 0x00    

   \              0x02 0x0A    

   \              0x00 0x00    

   \              0x00 0x07    

   \              0x05 0x01    

   \              0x02 0x00    

   \              0x02 0x00    

   \              0x07 0x05    

   \              0x81
   \       0x3F   0x02 0x00          DC8 2, 0, 2, 0

   \              0x02 0x00
   \       0x43                      DS8 1
    160          {
    161            /* Configuration Descriptor */
    162            0x09,                                       /* bLength: Configuration Descriptor size */
    163            USB_DESC_TYPE_CONFIGURATION,                /* bDescriptorType: Configuration */
    164            USB_CDC_CONFIG_DESC_SIZ,                    /* wTotalLength:no of returned bytes */
    165            0x00,
    166            0x02,                                       /* bNumInterfaces: 2 interface */
    167            0x01,                                       /* bConfigurationValue: Configuration value */
    168            0x00,                                       /* iConfiguration: Index of string descriptor describing the configuration */
    169            0xC0,                                       /* bmAttributes: self powered */
    170            0x32,                                       /* MaxPower 0 mA */
    171          
    172            /*---------------------------------------------------------------------------*/
    173          
    174            /* Interface Descriptor */
    175            0x09,                                       /* bLength: Interface Descriptor size */
    176            USB_DESC_TYPE_INTERFACE,                    /* bDescriptorType: Interface */
    177                                                        /* Interface descriptor type */
    178            0x00,                                       /* bInterfaceNumber: Number of Interface */
    179            0x00,                                       /* bAlternateSetting: Alternate setting */
    180            0x01,                                       /* bNumEndpoints: One endpoints used */
    181            0x02,                                       /* bInterfaceClass: Communication Interface Class */
    182            0x02,                                       /* bInterfaceSubClass: Abstract Control Model */
    183            0x01,                                       /* bInterfaceProtocol: Common AT commands */
    184            0x00,                                       /* iInterface: */
    185          
    186            /* Header Functional Descriptor */
    187            0x05,                                       /* bLength: Endpoint Descriptor size */
    188            0x24,                                       /* bDescriptorType: CS_INTERFACE */
    189            0x00,                                       /* bDescriptorSubtype: Header Func Desc */
    190            0x10,                                       /* bcdCDC: spec release number */
    191            0x01,
    192          
    193            /* Call Management Functional Descriptor */
    194            0x05,                                       /* bFunctionLength */
    195            0x24,                                       /* bDescriptorType: CS_INTERFACE */
    196            0x01,                                       /* bDescriptorSubtype: Call Management Func Desc */
    197            0x00,                                       /* bmCapabilities: D0+D1 */
    198            0x01,                                       /* bDataInterface: 1 */
    199          
    200            /* ACM Functional Descriptor */
    201            0x04,                                       /* bFunctionLength */
    202            0x24,                                       /* bDescriptorType: CS_INTERFACE */
    203            0x02,                                       /* bDescriptorSubtype: Abstract Control Management desc */
    204            0x02,                                       /* bmCapabilities */
    205          
    206            /* Union Functional Descriptor */
    207            0x05,                                       /* bFunctionLength */
    208            0x24,                                       /* bDescriptorType: CS_INTERFACE */
    209            0x06,                                       /* bDescriptorSubtype: Union func desc */
    210            0x00,                                       /* bMasterInterface: Communication class interface */
    211            0x01,                                       /* bSlaveInterface0: Data Class Interface */
    212          
    213            /* Endpoint 2 Descriptor */
    214            0x07,                                       /* bLength: Endpoint Descriptor size */
    215            USB_DESC_TYPE_ENDPOINT,                     /* bDescriptorType: Endpoint */
    216            CDC_CMD_EP,                                 /* bEndpointAddress */
    217            0x03,                                       /* bmAttributes: Interrupt */
    218            LOBYTE(CDC_CMD_PACKET_SIZE),                /* wMaxPacketSize: */
    219            HIBYTE(CDC_CMD_PACKET_SIZE),
    220            CDC_HS_BINTERVAL,                           /* bInterval: */
    221            /*---------------------------------------------------------------------------*/
    222          
    223            /* Data class interface descriptor */
    224            0x09,                                       /* bLength: Endpoint Descriptor size */
    225            USB_DESC_TYPE_INTERFACE,                    /* bDescriptorType: */
    226            0x01,                                       /* bInterfaceNumber: Number of Interface */
    227            0x00,                                       /* bAlternateSetting: Alternate setting */
    228            0x02,                                       /* bNumEndpoints: Two endpoints used */
    229            0x0A,                                       /* bInterfaceClass: CDC */
    230            0x00,                                       /* bInterfaceSubClass: */
    231            0x00,                                       /* bInterfaceProtocol: */
    232            0x00,                                       /* iInterface: */
    233          
    234            /* Endpoint OUT Descriptor */
    235            0x07,                                       /* bLength: Endpoint Descriptor size */
    236            USB_DESC_TYPE_ENDPOINT,                     /* bDescriptorType: Endpoint */
    237            CDC_OUT_EP,                                 /* bEndpointAddress */
    238            0x02,                                       /* bmAttributes: Bulk */
    239            LOBYTE(CDC_DATA_HS_MAX_PACKET_SIZE),        /* wMaxPacketSize: */
    240            HIBYTE(CDC_DATA_HS_MAX_PACKET_SIZE),
    241            0x00,                                       /* bInterval: ignore for Bulk transfer */
    242          
    243            /* Endpoint IN Descriptor */
    244            0x07,                                       /* bLength: Endpoint Descriptor size */
    245            USB_DESC_TYPE_ENDPOINT,                     /* bDescriptorType: Endpoint */
    246            CDC_IN_EP,                                  /* bEndpointAddress */
    247            0x02,                                       /* bmAttributes: Bulk */
    248            LOBYTE(CDC_DATA_HS_MAX_PACKET_SIZE),        /* wMaxPacketSize: */
    249            HIBYTE(CDC_DATA_HS_MAX_PACKET_SIZE),
    250            0x00                                        /* bInterval: ignore for Bulk transfer */
    251          };
    252          
    253          
    254          /* USB CDC device Configuration Descriptor */

   \                                 In section .data, align 4
    255          __ALIGN_BEGIN static uint8_t USBD_CDC_CfgFSDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END =
   \                     USBD_CDC_CfgFSDesc:
   \        0x0   0x09 0x02          DC8 9, 2, 67, 0, 2, 1, 0, 192, 50, 9, 4, 0, 0, 1, 2, 2, 1, 0, 5, 36, 0

   \              0x43 0x00    

   \              0x02 0x01    

   \              0x00 0xC0    

   \              0x32 0x09    

   \              0x04 0x00    

   \              0x00 0x01    

   \              0x02 0x02    

   \              0x01 0x00    

   \              0x05 0x24    

   \              0x00
   \       0x15   0x10 0x01          DC8 16, 1, 5, 36, 1, 0, 1, 4, 36, 2, 2, 5, 36, 6, 0, 1, 7, 5, 130, 3, 8

   \              0x05 0x24    

   \              0x01 0x00    

   \              0x01 0x04    

   \              0x24 0x02    

   \              0x02 0x05    

   \              0x24 0x06    

   \              0x00 0x01    

   \              0x07 0x05    

   \              0x82 0x03    

   \              0x08
   \       0x2A   0x00 0x10          DC8 0, 16, 9, 4, 1, 0, 2, 10, 0, 0, 0, 7, 5, 1, 2, 64, 0, 0, 7, 5, 129

   \              0x09 0x04    

   \              0x01 0x00    

   \              0x02 0x0A    

   \              0x00 0x00    

   \              0x00 0x07    

   \              0x05 0x01    

   \              0x02 0x40    

   \              0x00 0x00    

   \              0x07 0x05    

   \              0x81
   \       0x3F   0x02 0x40          DC8 2, 64, 0, 0

   \              0x00 0x00
   \       0x43                      DS8 1
    256          {
    257            /* Configuration Descriptor */
    258            0x09,                                       /* bLength: Configuration Descriptor size */
    259            USB_DESC_TYPE_CONFIGURATION,                /* bDescriptorType: Configuration */
    260            USB_CDC_CONFIG_DESC_SIZ,                    /* wTotalLength:no of returned bytes */
    261            0x00,
    262            0x02,                                       /* bNumInterfaces: 2 interface */
    263            0x01,                                       /* bConfigurationValue: Configuration value */
    264            0x00,                                       /* iConfiguration: Index of string descriptor describing the configuration */
    265            0xC0,                                       /* bmAttributes: self powered */
    266            0x32,                                       /* MaxPower 0 mA */
    267          
    268            /*---------------------------------------------------------------------------*/
    269          
    270            /* Interface Descriptor */
    271            0x09,                                       /* bLength: Interface Descriptor size */
    272            USB_DESC_TYPE_INTERFACE,                    /* bDescriptorType: Interface */
    273            /* Interface descriptor type */
    274            0x00,                                       /* bInterfaceNumber: Number of Interface */
    275            0x00,                                       /* bAlternateSetting: Alternate setting */
    276            0x01,                                       /* bNumEndpoints: One endpoints used */
    277            0x02,                                       /* bInterfaceClass: Communication Interface Class */
    278            0x02,                                       /* bInterfaceSubClass: Abstract Control Model */
    279            0x01,                                       /* bInterfaceProtocol: Common AT commands */
    280            0x00,                                       /* iInterface: */
    281          
    282            /* Header Functional Descriptor */
    283            0x05,                                       /* bLength: Endpoint Descriptor size */
    284            0x24,                                       /* bDescriptorType: CS_INTERFACE */
    285            0x00,                                       /* bDescriptorSubtype: Header Func Desc */
    286            0x10,                                       /* bcdCDC: spec release number */
    287            0x01,
    288          
    289            /* Call Management Functional Descriptor */
    290            0x05,                                       /* bFunctionLength */
    291            0x24,                                       /* bDescriptorType: CS_INTERFACE */
    292            0x01,                                       /* bDescriptorSubtype: Call Management Func Desc */
    293            0x00,                                       /* bmCapabilities: D0+D1 */
    294            0x01,                                       /* bDataInterface: 1 */
    295          
    296            /* ACM Functional Descriptor */
    297            0x04,                                       /* bFunctionLength */
    298            0x24,                                       /* bDescriptorType: CS_INTERFACE */
    299            0x02,                                       /* bDescriptorSubtype: Abstract Control Management desc */
    300            0x02,                                       /* bmCapabilities */
    301          
    302            /* Union Functional Descriptor */
    303            0x05,                                       /* bFunctionLength */
    304            0x24,                                       /* bDescriptorType: CS_INTERFACE */
    305            0x06,                                       /* bDescriptorSubtype: Union func desc */
    306            0x00,                                       /* bMasterInterface: Communication class interface */
    307            0x01,                                       /* bSlaveInterface0: Data Class Interface */
    308          
    309            /* Endpoint 2 Descriptor */
    310            0x07,                                       /* bLength: Endpoint Descriptor size */
    311            USB_DESC_TYPE_ENDPOINT,                     /* bDescriptorType: Endpoint */
    312            CDC_CMD_EP,                                 /* bEndpointAddress */
    313            0x03,                                       /* bmAttributes: Interrupt */
    314            LOBYTE(CDC_CMD_PACKET_SIZE),                /* wMaxPacketSize: */
    315            HIBYTE(CDC_CMD_PACKET_SIZE),
    316            CDC_FS_BINTERVAL,                           /* bInterval: */
    317            /*---------------------------------------------------------------------------*/
    318          
    319            /* Data class interface descriptor */
    320            0x09,                                       /* bLength: Endpoint Descriptor size */
    321            USB_DESC_TYPE_INTERFACE,                    /* bDescriptorType: */
    322            0x01,                                       /* bInterfaceNumber: Number of Interface */
    323            0x00,                                       /* bAlternateSetting: Alternate setting */
    324            0x02,                                       /* bNumEndpoints: Two endpoints used */
    325            0x0A,                                       /* bInterfaceClass: CDC */
    326            0x00,                                       /* bInterfaceSubClass: */
    327            0x00,                                       /* bInterfaceProtocol: */
    328            0x00,                                       /* iInterface: */
    329          
    330            /* Endpoint OUT Descriptor */
    331            0x07,                                       /* bLength: Endpoint Descriptor size */
    332            USB_DESC_TYPE_ENDPOINT,                     /* bDescriptorType: Endpoint */
    333            CDC_OUT_EP,                                 /* bEndpointAddress */
    334            0x02,                                       /* bmAttributes: Bulk */
    335            LOBYTE(CDC_DATA_FS_MAX_PACKET_SIZE),        /* wMaxPacketSize: */
    336            HIBYTE(CDC_DATA_FS_MAX_PACKET_SIZE),
    337            0x00,                                       /* bInterval: ignore for Bulk transfer */
    338          
    339            /* Endpoint IN Descriptor */
    340            0x07,                                       /* bLength: Endpoint Descriptor size */
    341            USB_DESC_TYPE_ENDPOINT,                     /* bDescriptorType: Endpoint */
    342            CDC_IN_EP,                                  /* bEndpointAddress */
    343            0x02,                                       /* bmAttributes: Bulk */
    344            LOBYTE(CDC_DATA_FS_MAX_PACKET_SIZE),        /* wMaxPacketSize: */
    345            HIBYTE(CDC_DATA_FS_MAX_PACKET_SIZE),
    346            0x00                                        /* bInterval: ignore for Bulk transfer */
    347          };
    348          

   \                                 In section .data, align 4
    349          __ALIGN_BEGIN static uint8_t USBD_CDC_OtherSpeedCfgDesc[USB_CDC_CONFIG_DESC_SIZ] __ALIGN_END =
   \                     USBD_CDC_OtherSpeedCfgDesc:
   \        0x0   0x09 0x07          DC8 9, 7, 67, 0, 2, 1, 4, 192, 50, 9, 4, 0, 0, 1, 2, 2, 1, 0, 5, 36, 0

   \              0x43 0x00    

   \              0x02 0x01    

   \              0x04 0xC0    

   \              0x32 0x09    

   \              0x04 0x00    

   \              0x00 0x01    

   \              0x02 0x02    

   \              0x01 0x00    

   \              0x05 0x24    

   \              0x00
   \       0x15   0x10 0x01          DC8 16, 1, 5, 36, 1, 0, 1, 4, 36, 2, 2, 5, 36, 6, 0, 1, 7, 5, 130, 3, 8

   \              0x05 0x24    

   \              0x01 0x00    

   \              0x01 0x04    

   \              0x24 0x02    

   \              0x02 0x05    

   \              0x24 0x06    

   \              0x00 0x01    

   \              0x07 0x05    

   \              0x82 0x03    

   \              0x08
   \       0x2A   0x00 0x10          DC8 0, 16, 9, 4, 1, 0, 2, 10, 0, 0, 0, 7, 5, 1, 2, 64, 0, 0, 7, 5, 129

   \              0x09 0x04    

   \              0x01 0x00    

   \              0x02 0x0A    

   \              0x00 0x00    

   \              0x00 0x07    

   \              0x05 0x01    

   \              0x02 0x40    

   \              0x00 0x00    

   \              0x07 0x05    

   \              0x81
   \       0x3F   0x02 0x40          DC8 2, 64, 0, 0

   \              0x00 0x00
   \       0x43                      DS8 1
    350          {
    351            0x09,                                       /* bLength: Configuation Descriptor size */
    352            USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION,
    353            USB_CDC_CONFIG_DESC_SIZ,
    354            0x00,
    355            0x02,                                       /* bNumInterfaces: 2 interfaces */
    356            0x01,                                       /* bConfigurationValue: */
    357            0x04,                                       /* iConfiguration: */
    358            0xC0,                                       /* bmAttributes: */
    359            0x32,                                       /* MaxPower 100 mA */
    360          
    361            /*Interface Descriptor */
    362            0x09,                                       /* bLength: Interface Descriptor size */
    363            USB_DESC_TYPE_INTERFACE,                    /* bDescriptorType: Interface */
    364            /* Interface descriptor type */
    365            0x00,                                       /* bInterfaceNumber: Number of Interface */
    366            0x00,                                       /* bAlternateSetting: Alternate setting */
    367            0x01,                                       /* bNumEndpoints: One endpoints used */
    368            0x02,                                       /* bInterfaceClass: Communication Interface Class */
    369            0x02,                                       /* bInterfaceSubClass: Abstract Control Model */
    370            0x01,                                       /* bInterfaceProtocol: Common AT commands */
    371            0x00,                                       /* iInterface: */
    372          
    373            /* Header Functional Descriptor */
    374            0x05,                                       /* bLength: Endpoint Descriptor size */
    375            0x24,                                       /* bDescriptorType: CS_INTERFACE */
    376            0x00,                                       /* bDescriptorSubtype: Header Func Desc */
    377            0x10,                                       /* bcdCDC: spec release number */
    378            0x01,
    379          
    380            /*Call Management Functional Descriptor*/
    381            0x05,                                       /* bFunctionLength */
    382            0x24,                                       /* bDescriptorType: CS_INTERFACE */
    383            0x01,                                       /* bDescriptorSubtype: Call Management Func Desc */
    384            0x00,                                       /* bmCapabilities: D0+D1 */
    385            0x01,                                       /* bDataInterface: 1 */
    386          
    387            /*ACM Functional Descriptor*/
    388            0x04,                                       /* bFunctionLength */
    389            0x24,                                       /* bDescriptorType: CS_INTERFACE */
    390            0x02,                                       /* bDescriptorSubtype: Abstract Control Management desc */
    391            0x02,                                       /* bmCapabilities */
    392          
    393            /*Union Functional Descriptor*/
    394            0x05,                                       /* bFunctionLength */
    395            0x24,                                       /* bDescriptorType: CS_INTERFACE */
    396            0x06,                                       /* bDescriptorSubtype: Union func desc */
    397            0x00,                                       /* bMasterInterface: Communication class interface */
    398            0x01,                                       /* bSlaveInterface0: Data Class Interface */
    399          
    400            /*Endpoint 2 Descriptor*/
    401            0x07,                                       /* bLength: Endpoint Descriptor size */
    402            USB_DESC_TYPE_ENDPOINT,                     /* bDescriptorType: Endpoint */
    403            CDC_CMD_EP,                                 /* bEndpointAddress */
    404            0x03,                                       /* bmAttributes: Interrupt */
    405            LOBYTE(CDC_CMD_PACKET_SIZE),                /* wMaxPacketSize: */
    406            HIBYTE(CDC_CMD_PACKET_SIZE),
    407            CDC_FS_BINTERVAL,                           /* bInterval: */
    408          
    409            /*---------------------------------------------------------------------------*/
    410          
    411            /*Data class interface descriptor*/
    412            0x09,                                       /* bLength: Endpoint Descriptor size */
    413            USB_DESC_TYPE_INTERFACE,                    /* bDescriptorType: */
    414            0x01,                                       /* bInterfaceNumber: Number of Interface */
    415            0x00,                                       /* bAlternateSetting: Alternate setting */
    416            0x02,                                       /* bNumEndpoints: Two endpoints used */
    417            0x0A,                                       /* bInterfaceClass: CDC */
    418            0x00,                                       /* bInterfaceSubClass: */
    419            0x00,                                       /* bInterfaceProtocol: */
    420            0x00,                                       /* iInterface: */
    421          
    422            /*Endpoint OUT Descriptor*/
    423            0x07,                                       /* bLength: Endpoint Descriptor size */
    424            USB_DESC_TYPE_ENDPOINT,                     /* bDescriptorType: Endpoint */
    425            CDC_OUT_EP,                                 /* bEndpointAddress */
    426            0x02,                                       /* bmAttributes: Bulk */
    427            0x40,                                       /* wMaxPacketSize: */
    428            0x00,
    429            0x00,                                       /* bInterval: ignore for Bulk transfer */
    430          
    431            /*Endpoint IN Descriptor*/
    432            0x07,                                       /* bLength: Endpoint Descriptor size */
    433            USB_DESC_TYPE_ENDPOINT,                     /* bDescriptorType: Endpoint */
    434            CDC_IN_EP,                                  /* bEndpointAddress */
    435            0x02,                                       /* bmAttributes: Bulk */
    436            0x40,                                       /* wMaxPacketSize: */
    437            0x00,
    438            0x00                                        /* bInterval */
    439          };
    440          
    441          /**
    442            * @}
    443            */
    444          
    445          /** @defgroup USBD_CDC_Private_Functions
    446            * @{
    447            */
    448          
    449          /**
    450            * @brief  USBD_CDC_Init
    451            *         Initialize the CDC interface
    452            * @param  pdev: device instance
    453            * @param  cfgidx: Configuration index
    454            * @retval status
    455            */

   \                                 In section .text, align 2, keep-with-next
    456          static uint8_t USBD_CDC_Init(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
    457          {
   \                     USBD_CDC_Init: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000E             MOVS     R6,R1
    458            UNUSED(cfgidx);
    459            USBD_CDC_HandleTypeDef *hcdc;
    460          
    461            hcdc = USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
   \        0x6   0xF44F 0x7007      MOV      R0,#+540
   \        0xA   0x.... 0x....      BL       malloc
   \        0xE   0x0004             MOVS     R4,R0
    462          
    463            if (hcdc == NULL)
   \       0x10   0x2C00             CMP      R4,#+0
   \       0x12   0xD104             BNE.N    ??USBD_CDC_Init_0
    464            {
    465              pdev->pClassData = NULL;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xF8C5 0x02BC      STR      R0,[R5, #+700]
    466              return (uint8_t)USBD_EMEM;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0xE056             B.N      ??USBD_CDC_Init_1
    467            }
    468          
    469            pdev->pClassData = (void *)hcdc;
   \                     ??USBD_CDC_Init_0: (+1)
   \       0x1E   0xF8C5 0x42BC      STR      R4,[R5, #+700]
    470          
    471            if (pdev->dev_speed == USBD_SPEED_HIGH)
   \       0x22   0x7C28             LDRB     R0,[R5, #+16]
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD116             BNE.N    ??USBD_CDC_Init_2
    472            {
    473              /* Open EP IN */
    474              (void)USBD_LL_OpenEP(pdev, CDC_IN_EP, USBD_EP_TYPE_BULK,
    475                                   CDC_DATA_HS_IN_PACKET_SIZE);
   \       0x28   0xF44F 0x7300      MOV      R3,#+512
   \       0x2C   0x2202             MOVS     R2,#+2
   \       0x2E   0x2181             MOVS     R1,#+129
   \       0x30   0x0028             MOVS     R0,R5
   \       0x32   0x.... 0x....      BL       USBD_LL_OpenEP
    476          
    477               pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 1U;
   \       0x36   0x2001             MOVS     R0,#+1
   \       0x38   0x8728             STRH     R0,[R5, #+56]
    478          
    479               /* Open EP OUT */
    480               (void)USBD_LL_OpenEP(pdev, CDC_OUT_EP, USBD_EP_TYPE_BULK,
    481                                    CDC_DATA_HS_OUT_PACKET_SIZE);
   \       0x3A   0xF44F 0x7300      MOV      R3,#+512
   \       0x3E   0x2202             MOVS     R2,#+2
   \       0x40   0x2101             MOVS     R1,#+1
   \       0x42   0x0028             MOVS     R0,R5
   \       0x44   0x.... 0x....      BL       USBD_LL_OpenEP
    482          
    483                pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 1U;
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0xF8A5 0x0178      STRH     R0,[R5, #+376]
    484          
    485                /* Set bInterval for CDC CMD Endpoint */
    486                pdev->ep_in[CDC_CMD_EP & 0xFU].bInterval = CDC_HS_BINTERVAL;
   \       0x4E   0x2010             MOVS     R0,#+16
   \       0x50   0xF8A5 0x004E      STRH     R0,[R5, #+78]
   \       0x54   0xE013             B.N      ??USBD_CDC_Init_3
    487            }
    488            else
    489            {
    490              /* Open EP IN */
    491              (void)USBD_LL_OpenEP(pdev, CDC_IN_EP, USBD_EP_TYPE_BULK,
    492                                   CDC_DATA_FS_IN_PACKET_SIZE);
   \                     ??USBD_CDC_Init_2: (+1)
   \       0x56   0x2340             MOVS     R3,#+64
   \       0x58   0x2202             MOVS     R2,#+2
   \       0x5A   0x2181             MOVS     R1,#+129
   \       0x5C   0x0028             MOVS     R0,R5
   \       0x5E   0x.... 0x....      BL       USBD_LL_OpenEP
    493          
    494               pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 1U;
   \       0x62   0x2001             MOVS     R0,#+1
   \       0x64   0x8728             STRH     R0,[R5, #+56]
    495          
    496               /* Open EP OUT */
    497               (void)USBD_LL_OpenEP(pdev, CDC_OUT_EP, USBD_EP_TYPE_BULK,
    498                                    CDC_DATA_FS_OUT_PACKET_SIZE);
   \       0x66   0x2340             MOVS     R3,#+64
   \       0x68   0x2202             MOVS     R2,#+2
   \       0x6A   0x2101             MOVS     R1,#+1
   \       0x6C   0x0028             MOVS     R0,R5
   \       0x6E   0x.... 0x....      BL       USBD_LL_OpenEP
    499          
    500                pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 1U;
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0xF8A5 0x0178      STRH     R0,[R5, #+376]
    501          
    502                /* Set bInterval for CMD Endpoint */
    503                pdev->ep_in[CDC_CMD_EP & 0xFU].bInterval = CDC_FS_BINTERVAL;
   \       0x78   0x2010             MOVS     R0,#+16
   \       0x7A   0xF8A5 0x004E      STRH     R0,[R5, #+78]
    504            }
    505          
    506            /* Open Command IN EP */
    507            (void)USBD_LL_OpenEP(pdev, CDC_CMD_EP, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
   \                     ??USBD_CDC_Init_3: (+1)
   \       0x7E   0x2308             MOVS     R3,#+8
   \       0x80   0x2203             MOVS     R2,#+3
   \       0x82   0x2182             MOVS     R1,#+130
   \       0x84   0x0028             MOVS     R0,R5
   \       0x86   0x.... 0x....      BL       USBD_LL_OpenEP
    508            pdev->ep_in[CDC_CMD_EP & 0xFU].is_used = 1U;
   \       0x8A   0x2001             MOVS     R0,#+1
   \       0x8C   0xF8A5 0x004C      STRH     R0,[R5, #+76]
    509          
    510            /* Init  physical Interface components */
    511            ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
   \       0x90   0xF8D5 0x02C0      LDR      R0,[R5, #+704]
   \       0x94   0x6800             LDR      R0,[R0, #+0]
   \       0x96   0x4780             BLX      R0
    512          
    513            /* Init Xfer states */
    514            hcdc->TxState = 0U;
   \       0x98   0x2000             MOVS     R0,#+0
   \       0x9A   0xF8C4 0x0214      STR      R0,[R4, #+532]
    515            hcdc->RxState = 0U;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0xF8C4 0x0218      STR      R0,[R4, #+536]
    516          
    517            if (pdev->dev_speed == USBD_SPEED_HIGH)
   \       0xA4   0x7C28             LDRB     R0,[R5, #+16]
   \       0xA6   0x2800             CMP      R0,#+0
   \       0xA8   0xD108             BNE.N    ??USBD_CDC_Init_4
    518            {
    519              /* Prepare Out endpoint to receive next packet */
    520              (void)USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
    521                                           CDC_DATA_HS_OUT_PACKET_SIZE);
   \       0xAA   0xF44F 0x7300      MOV      R3,#+512
   \       0xAE   0xF8D4 0x2204      LDR      R2,[R4, #+516]
   \       0xB2   0x2101             MOVS     R1,#+1
   \       0xB4   0x0028             MOVS     R0,R5
   \       0xB6   0x.... 0x....      BL       USBD_LL_PrepareReceive
   \       0xBA   0xE006             B.N      ??USBD_CDC_Init_5
    522            }
    523            else
    524            {
    525              /* Prepare Out endpoint to receive next packet */
    526              (void)USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
    527                                           CDC_DATA_FS_OUT_PACKET_SIZE);
   \                     ??USBD_CDC_Init_4: (+1)
   \       0xBC   0x2340             MOVS     R3,#+64
   \       0xBE   0xF8D4 0x2204      LDR      R2,[R4, #+516]
   \       0xC2   0x2101             MOVS     R1,#+1
   \       0xC4   0x0028             MOVS     R0,R5
   \       0xC6   0x.... 0x....      BL       USBD_LL_PrepareReceive
    528            }
    529          
    530            return (uint8_t)USBD_OK;
   \                     ??USBD_CDC_Init_5: (+1)
   \       0xCA   0x2000             MOVS     R0,#+0
   \                     ??USBD_CDC_Init_1: (+1)
   \       0xCC   0xBD70             POP      {R4-R6,PC}
    531          }
    532          
    533          /**
    534            * @brief  USBD_CDC_Init
    535            *         DeInitialize the CDC layer
    536            * @param  pdev: device instance
    537            * @param  cfgidx: Configuration index
    538            * @retval status
    539            */

   \                                 In section .text, align 2, keep-with-next
    540          static uint8_t USBD_CDC_DeInit(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
    541          {
   \                     USBD_CDC_DeInit: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    542            UNUSED(cfgidx);
    543            uint8_t ret = 0U;
   \        0x6   0x2600             MOVS     R6,#+0
    544          
    545            /* Close EP IN */
    546            (void)USBD_LL_CloseEP(pdev, CDC_IN_EP);
   \        0x8   0x2181             MOVS     R1,#+129
   \        0xA   0x0020             MOVS     R0,R4
   \        0xC   0x.... 0x....      BL       USBD_LL_CloseEP
    547            pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 0U;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x8720             STRH     R0,[R4, #+56]
    548          
    549            /* Close EP OUT */
    550            (void)USBD_LL_CloseEP(pdev, CDC_OUT_EP);
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x.... 0x....      BL       USBD_LL_CloseEP
    551            pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 0U;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xF8A4 0x0178      STRH     R0,[R4, #+376]
    552          
    553            /* Close Command IN EP */
    554            (void)USBD_LL_CloseEP(pdev, CDC_CMD_EP);
   \       0x22   0x2182             MOVS     R1,#+130
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       USBD_LL_CloseEP
    555            pdev->ep_in[CDC_CMD_EP & 0xFU].is_used = 0U;
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0xF8A4 0x004C      STRH     R0,[R4, #+76]
    556            pdev->ep_in[CDC_CMD_EP & 0xFU].bInterval = 0U;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xF8A4 0x004E      STRH     R0,[R4, #+78]
    557          
    558            /* DeInit  physical Interface components */
    559            if (pdev->pClassData != NULL)
   \       0x36   0xF8D4 0x02BC      LDR      R0,[R4, #+700]
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD00A             BEQ.N    ??USBD_CDC_DeInit_0
    560            {
    561              ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->DeInit();
   \       0x3E   0xF8D4 0x02C0      LDR      R0,[R4, #+704]
   \       0x42   0x6840             LDR      R0,[R0, #+4]
   \       0x44   0x4780             BLX      R0
    562              (void)USBD_free(pdev->pClassData);
   \       0x46   0xF8D4 0x02BC      LDR      R0,[R4, #+700]
   \       0x4A   0x.... 0x....      BL       free
    563              pdev->pClassData = NULL;
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xF8C4 0x02BC      STR      R0,[R4, #+700]
    564            }
    565          
    566            return ret;
   \                     ??USBD_CDC_DeInit_0: (+1)
   \       0x54   0x0030             MOVS     R0,R6
   \       0x56   0xB2C0             UXTB     R0,R0
   \       0x58   0xBD70             POP      {R4-R6,PC}
    567          }
    568          
    569          /**
    570            * @brief  USBD_CDC_Setup
    571            *         Handle the CDC specific requests
    572            * @param  pdev: instance
    573            * @param  req: usb requests
    574            * @retval status
    575            */

   \                                 In section .text, align 2, keep-with-next
    576          static uint8_t USBD_CDC_Setup(USBD_HandleTypeDef *pdev,
    577                                        USBD_SetupReqTypedef *req)
    578          {
   \                     USBD_CDC_Setup: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    579            USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
   \        0x6   0xF8D4 0x62BC      LDR      R6,[R4, #+700]
    580            uint8_t ifalt = 0U;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xF88D 0x0000      STRB     R0,[SP, #+0]
    581            uint16_t status_info = 0U;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    582            USBD_StatusTypeDef ret = USBD_OK;
   \       0x16   0x2700             MOVS     R7,#+0
    583          
    584            switch (req->bmRequest & USB_REQ_TYPE_MASK)
   \       0x18   0x7828             LDRB     R0,[R5, #+0]
   \       0x1A   0xF010 0x0060      ANDS     R0,R0,#0x60
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD028             BEQ.N    ??USBD_CDC_Setup_0
   \       0x22   0x2820             CMP      R0,#+32
   \       0x24   0xD166             BNE.N    ??USBD_CDC_Setup_1
    585            {
    586            case USB_REQ_TYPE_CLASS:
    587              if (req->wLength != 0U)
   \                     ??USBD_CDC_Setup_2: (+1)
   \       0x26   0x88E8             LDRH     R0,[R5, #+6]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD01B             BEQ.N    ??USBD_CDC_Setup_3
    588              {
    589                if ((req->bmRequest & 0x80U) != 0U)
   \       0x2C   0x7828             LDRB     R0,[R5, #+0]
   \       0x2E   0x0600             LSLS     R0,R0,#+24
   \       0x30   0xD50C             BPL.N    ??USBD_CDC_Setup_4
    590                {
    591                  ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
    592                                                                    (uint8_t *)hcdc->data,
    593                                                                    req->wLength);
   \       0x32   0x88EA             LDRH     R2,[R5, #+6]
   \       0x34   0x0031             MOVS     R1,R6
   \       0x36   0x7868             LDRB     R0,[R5, #+1]
   \       0x38   0xF8D4 0x32C0      LDR      R3,[R4, #+704]
   \       0x3C   0x689B             LDR      R3,[R3, #+8]
   \       0x3E   0x4798             BLX      R3
    594          
    595                    (void)USBD_CtlSendData(pdev, (uint8_t *)hcdc->data, req->wLength);
   \       0x40   0x88EA             LDRH     R2,[R5, #+6]
   \       0x42   0x0031             MOVS     R1,R6
   \       0x44   0x0020             MOVS     R0,R4
   \       0x46   0x.... 0x....      BL       USBD_CtlSendData
   \       0x4A   0xE012             B.N      ??USBD_CDC_Setup_5
    596                }
    597                else
    598                {
    599                  hcdc->CmdOpCode = req->bRequest;
   \                     ??USBD_CDC_Setup_4: (+1)
   \       0x4C   0x7868             LDRB     R0,[R5, #+1]
   \       0x4E   0xF886 0x0200      STRB     R0,[R6, #+512]
    600                  hcdc->CmdLength = (uint8_t)req->wLength;
   \       0x52   0x88E8             LDRH     R0,[R5, #+6]
   \       0x54   0xF886 0x0201      STRB     R0,[R6, #+513]
    601          
    602                  (void)USBD_CtlPrepareRx(pdev, (uint8_t *)hcdc->data, req->wLength);
   \       0x58   0x88EA             LDRH     R2,[R5, #+6]
   \       0x5A   0x0031             MOVS     R1,R6
   \       0x5C   0x0020             MOVS     R0,R4
   \       0x5E   0x.... 0x....      BL       USBD_CtlPrepareRx
   \       0x62   0xE006             B.N      ??USBD_CDC_Setup_5
    603                }
    604              }
    605              else
    606              {
    607                ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
    608                                                                  (uint8_t *)req, 0U);
   \                     ??USBD_CDC_Setup_3: (+1)
   \       0x64   0x2200             MOVS     R2,#+0
   \       0x66   0x0029             MOVS     R1,R5
   \       0x68   0x7868             LDRB     R0,[R5, #+1]
   \       0x6A   0xF8D4 0x32C0      LDR      R3,[R4, #+704]
   \       0x6E   0x689B             LDR      R3,[R3, #+8]
   \       0x70   0x4798             BLX      R3
    609              }
    610              break;
   \                     ??USBD_CDC_Setup_5: (+1)
   \       0x72   0xE045             B.N      ??USBD_CDC_Setup_6
    611          
    612            case USB_REQ_TYPE_STANDARD:
    613              switch (req->bRequest)
   \                     ??USBD_CDC_Setup_0: (+1)
   \       0x74   0x7868             LDRB     R0,[R5, #+1]
   \       0x76   0x2800             CMP      R0,#+0
   \       0x78   0xD006             BEQ.N    ??USBD_CDC_Setup_7
   \       0x7A   0x2801             CMP      R0,#+1
   \       0x7C   0xD032             BEQ.N    ??USBD_CDC_Setup_8
   \       0x7E   0x280A             CMP      R0,#+10
   \       0x80   0xD014             BEQ.N    ??USBD_CDC_Setup_9
   \       0x82   0x280B             CMP      R0,#+11
   \       0x84   0xD023             BEQ.N    ??USBD_CDC_Setup_10
   \       0x86   0xE02E             B.N      ??USBD_CDC_Setup_11
    614              {
    615              case USB_REQ_GET_STATUS:
    616                if (pdev->dev_state == USBD_STATE_CONFIGURED)
   \                     ??USBD_CDC_Setup_7: (+1)
   \       0x88   0xF894 0x029C      LDRB     R0,[R4, #+668]
   \       0x8C   0x2803             CMP      R0,#+3
   \       0x8E   0xD106             BNE.N    ??USBD_CDC_Setup_12
    617                {
    618                  (void)USBD_CtlSendData(pdev, (uint8_t *)&status_info, 2U);
   \       0x90   0x2202             MOVS     R2,#+2
   \       0x92   0xF10D 0x0102      ADD      R1,SP,#+2
   \       0x96   0x0020             MOVS     R0,R4
   \       0x98   0x.... 0x....      BL       USBD_CtlSendData
   \       0x9C   0xE005             B.N      ??USBD_CDC_Setup_13
    619                }
    620                else
    621                {
    622                  USBD_CtlError(pdev, req);
   \                     ??USBD_CDC_Setup_12: (+1)
   \       0x9E   0x0029             MOVS     R1,R5
   \       0xA0   0x0020             MOVS     R0,R4
   \       0xA2   0x.... 0x....      BL       USBD_CtlError
    623                  ret = USBD_FAIL;
   \       0xA6   0x2003             MOVS     R0,#+3
   \       0xA8   0x0007             MOVS     R7,R0
    624                }
    625                break;
   \                     ??USBD_CDC_Setup_13: (+1)
   \       0xAA   0xE022             B.N      ??USBD_CDC_Setup_14
    626          
    627              case USB_REQ_GET_INTERFACE:
    628                if (pdev->dev_state == USBD_STATE_CONFIGURED)
   \                     ??USBD_CDC_Setup_9: (+1)
   \       0xAC   0xF894 0x029C      LDRB     R0,[R4, #+668]
   \       0xB0   0x2803             CMP      R0,#+3
   \       0xB2   0xD105             BNE.N    ??USBD_CDC_Setup_15
    629                {
    630                  (void)USBD_CtlSendData(pdev, &ifalt, 1U);
   \       0xB4   0x2201             MOVS     R2,#+1
   \       0xB6   0x4669             MOV      R1,SP
   \       0xB8   0x0020             MOVS     R0,R4
   \       0xBA   0x.... 0x....      BL       USBD_CtlSendData
   \       0xBE   0xE005             B.N      ??USBD_CDC_Setup_16
    631                }
    632                else
    633                {
    634                  USBD_CtlError(pdev, req);
   \                     ??USBD_CDC_Setup_15: (+1)
   \       0xC0   0x0029             MOVS     R1,R5
   \       0xC2   0x0020             MOVS     R0,R4
   \       0xC4   0x.... 0x....      BL       USBD_CtlError
    635                  ret = USBD_FAIL;
   \       0xC8   0x2003             MOVS     R0,#+3
   \       0xCA   0x0007             MOVS     R7,R0
    636                }
    637                break;
   \                     ??USBD_CDC_Setup_16: (+1)
   \       0xCC   0xE011             B.N      ??USBD_CDC_Setup_14
    638          
    639              case USB_REQ_SET_INTERFACE:
    640                if (pdev->dev_state != USBD_STATE_CONFIGURED)
   \                     ??USBD_CDC_Setup_10: (+1)
   \       0xCE   0xF894 0x029C      LDRB     R0,[R4, #+668]
   \       0xD2   0x2803             CMP      R0,#+3
   \       0xD4   0xD005             BEQ.N    ??USBD_CDC_Setup_17
    641                {
    642                  USBD_CtlError(pdev, req);
   \       0xD6   0x0029             MOVS     R1,R5
   \       0xD8   0x0020             MOVS     R0,R4
   \       0xDA   0x.... 0x....      BL       USBD_CtlError
    643                  ret = USBD_FAIL;
   \       0xDE   0x2003             MOVS     R0,#+3
   \       0xE0   0x0007             MOVS     R7,R0
    644                }
    645                break;
   \                     ??USBD_CDC_Setup_17: (+1)
   \       0xE2   0xE006             B.N      ??USBD_CDC_Setup_14
    646          
    647              case USB_REQ_CLEAR_FEATURE:
    648                break;
   \                     ??USBD_CDC_Setup_8: (+1)
   \       0xE4   0xE005             B.N      ??USBD_CDC_Setup_14
    649          
    650              default:
    651                USBD_CtlError(pdev, req);
   \                     ??USBD_CDC_Setup_11: (+1)
   \       0xE6   0x0029             MOVS     R1,R5
   \       0xE8   0x0020             MOVS     R0,R4
   \       0xEA   0x.... 0x....      BL       USBD_CtlError
    652                ret = USBD_FAIL;
   \       0xEE   0x2003             MOVS     R0,#+3
   \       0xF0   0x0007             MOVS     R7,R0
    653                break;
    654              }
    655              break;
   \                     ??USBD_CDC_Setup_14: (+1)
   \       0xF2   0xE005             B.N      ??USBD_CDC_Setup_6
    656          
    657            default:
    658              USBD_CtlError(pdev, req);
   \                     ??USBD_CDC_Setup_1: (+1)
   \       0xF4   0x0029             MOVS     R1,R5
   \       0xF6   0x0020             MOVS     R0,R4
   \       0xF8   0x.... 0x....      BL       USBD_CtlError
    659              ret = USBD_FAIL;
   \       0xFC   0x2003             MOVS     R0,#+3
   \       0xFE   0x0007             MOVS     R7,R0
    660              break;
    661            }
    662          
    663            return (uint8_t)ret;
   \                     ??USBD_CDC_Setup_6: (+1)
   \      0x100   0x0038             MOVS     R0,R7
   \      0x102   0xB2C0             UXTB     R0,R0
   \      0x104   0xBDF2             POP      {R1,R4-R7,PC}
    664          }
    665          
    666          /**
    667            * @brief  USBD_CDC_DataIn
    668            *         Data sent on non-control IN endpoint
    669            * @param  pdev: device instance
    670            * @param  epnum: endpoint number
    671            * @retval status
    672            */

   \                                 In section .text, align 2, keep-with-next
    673          static uint8_t USBD_CDC_DataIn(USBD_HandleTypeDef *pdev, uint8_t epnum)
    674          {
   \                     USBD_CDC_DataIn: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    675            USBD_CDC_HandleTypeDef *hcdc;
    676            PCD_HandleTypeDef *hpcd = pdev->pData;
   \        0x6   0xF8D4 0x62C4      LDR      R6,[R4, #+708]
    677          
    678            if (pdev->pClassData == NULL)
   \        0xA   0xF8D4 0x02BC      LDR      R0,[R4, #+700]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD101             BNE.N    ??USBD_CDC_DataIn_0
    679            {
    680              return (uint8_t)USBD_FAIL;
   \       0x12   0x2003             MOVS     R0,#+3
   \       0x14   0xE039             B.N      ??USBD_CDC_DataIn_1
    681            }
    682          
    683            hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
   \                     ??USBD_CDC_DataIn_0: (+1)
   \       0x16   0xF8D4 0x72BC      LDR      R7,[R4, #+700]
    684          
    685            if ((pdev->ep_in[epnum].total_length > 0U) &&
    686                ((pdev->ep_in[epnum].total_length % hpcd->IN_ep[epnum].maxpacket) == 0U))
   \       0x1A   0x2214             MOVS     R2,#+20
   \       0x1C   0x0028             MOVS     R0,R5
   \       0x1E   0xB2C0             UXTB     R0,R0
   \       0x20   0x4350             MULS     R0,R2,R0
   \       0x22   0x4420             ADD      R0,R4,R0
   \       0x24   0x6980             LDR      R0,[R0, #+24]
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD021             BEQ.N    ??USBD_CDC_DataIn_2
   \       0x2A   0x0028             MOVS     R0,R5
   \       0x2C   0xB2C0             UXTB     R0,R0
   \       0x2E   0x4350             MULS     R0,R2,R0
   \       0x30   0x4420             ADD      R0,R4,R0
   \       0x32   0x6980             LDR      R0,[R0, #+24]
   \       0x34   0x002B             MOVS     R3,R5
   \       0x36   0xB2DB             UXTB     R3,R3
   \       0x38   0x211C             MOVS     R1,#+28
   \       0x3A   0x434B             MULS     R3,R1,R3
   \       0x3C   0xEB06 0x0103      ADD      R1,R6,R3
   \       0x40   0x6C49             LDR      R1,[R1, #+68]
   \       0x42   0xFBB0 0xF3F1      UDIV     R3,R0,R1
   \       0x46   0xFB01 0x0013      MLS      R0,R1,R3,R0
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD10F             BNE.N    ??USBD_CDC_DataIn_2
    687            {
    688              /* Update the packet total length */
    689              pdev->ep_in[epnum].total_length = 0U;
   \       0x4E   0x0028             MOVS     R0,R5
   \       0x50   0xB2C0             UXTB     R0,R0
   \       0x52   0xFB02 0xF200      MUL      R2,R2,R0
   \       0x56   0xEB04 0x0002      ADD      R0,R4,R2
   \       0x5A   0x2100             MOVS     R1,#+0
   \       0x5C   0x6181             STR      R1,[R0, #+24]
    690          
    691              /* Send ZLP */
    692              (void)USBD_LL_Transmit(pdev, epnum, NULL, 0U);
   \       0x5E   0x2300             MOVS     R3,#+0
   \       0x60   0x2200             MOVS     R2,#+0
   \       0x62   0x0029             MOVS     R1,R5
   \       0x64   0xB2C9             UXTB     R1,R1
   \       0x66   0x0020             MOVS     R0,R4
   \       0x68   0x.... 0x....      BL       USBD_LL_Transmit
   \       0x6C   0xE00C             B.N      ??USBD_CDC_DataIn_3
    693            }
    694            else
    695            {
    696              hcdc->TxState = 0U;
   \                     ??USBD_CDC_DataIn_2: (+1)
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xF8C7 0x0214      STR      R0,[R7, #+532]
    697              ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->TransmitCplt(hcdc->TxBuffer, &hcdc->TxLength, epnum);
   \       0x74   0x002A             MOVS     R2,R5
   \       0x76   0xB2D2             UXTB     R2,R2
   \       0x78   0xF517 0x7104      ADDS     R1,R7,#+528
   \       0x7C   0xF8D7 0x0208      LDR      R0,[R7, #+520]
   \       0x80   0xF8D4 0x32C0      LDR      R3,[R4, #+704]
   \       0x84   0x691B             LDR      R3,[R3, #+16]
   \       0x86   0x4798             BLX      R3
    698            }
    699          
    700            return (uint8_t)USBD_OK;
   \                     ??USBD_CDC_DataIn_3: (+1)
   \       0x88   0x2000             MOVS     R0,#+0
   \                     ??USBD_CDC_DataIn_1: (+1)
   \       0x8A   0xBDF2             POP      {R1,R4-R7,PC}
    701          }
    702          
    703          /**
    704            * @brief  USBD_CDC_DataOut
    705            *         Data received on non-control Out endpoint
    706            * @param  pdev: device instance
    707            * @param  epnum: endpoint number
    708            * @retval status
    709            */

   \                                 In section .text, align 2, keep-with-next
    710          static uint8_t USBD_CDC_DataOut(USBD_HandleTypeDef *pdev, uint8_t epnum)
    711          {
   \                     USBD_CDC_DataOut: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    712            USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
   \        0x6   0xF8D4 0x62BC      LDR      R6,[R4, #+700]
    713          
    714            if (pdev->pClassData == NULL)
   \        0xA   0xF8D4 0x02BC      LDR      R0,[R4, #+700]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD101             BNE.N    ??USBD_CDC_DataOut_0
    715            {
    716              return (uint8_t)USBD_FAIL;
   \       0x12   0x2003             MOVS     R0,#+3
   \       0x14   0xE00F             B.N      ??USBD_CDC_DataOut_1
    717            }
    718          
    719            /* Get the received data length */
    720            hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
   \                     ??USBD_CDC_DataOut_0: (+1)
   \       0x16   0x0029             MOVS     R1,R5
   \       0x18   0xB2C9             UXTB     R1,R1
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x.... 0x....      BL       USBD_LL_GetRxDataSize
   \       0x20   0xF8C6 0x020C      STR      R0,[R6, #+524]
    721          
    722            /* USB data will be immediately processed, this allow next USB traffic being
    723            NAKed till the end of the application Xfer */
    724          
    725            ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Receive(hcdc->RxBuffer, &hcdc->RxLength);
   \       0x24   0xF516 0x7103      ADDS     R1,R6,#+524
   \       0x28   0xF8D6 0x0204      LDR      R0,[R6, #+516]
   \       0x2C   0xF8D4 0x22C0      LDR      R2,[R4, #+704]
   \       0x30   0x68D2             LDR      R2,[R2, #+12]
   \       0x32   0x4790             BLX      R2
    726          
    727            return (uint8_t)USBD_OK;
   \       0x34   0x2000             MOVS     R0,#+0
   \                     ??USBD_CDC_DataOut_1: (+1)
   \       0x36   0xBD70             POP      {R4-R6,PC}
    728          }
    729          
    730          /**
    731            * @brief  USBD_CDC_EP0_RxReady
    732            *         Handle EP0 Rx Ready event
    733            * @param  pdev: device instance
    734            * @retval status
    735            */

   \                                 In section .text, align 2, keep-with-next
    736          static uint8_t USBD_CDC_EP0_RxReady(USBD_HandleTypeDef *pdev)
    737          {
   \                     USBD_CDC_EP0_RxReady: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    738            USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
   \        0x4   0xF8D4 0x52BC      LDR      R5,[R4, #+700]
    739          
    740            if ((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFFU))
   \        0x8   0xF8D4 0x02C0      LDR      R0,[R4, #+704]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD010             BEQ.N    ??USBD_CDC_EP0_RxReady_0
   \       0x10   0xF895 0x0200      LDRB     R0,[R5, #+512]
   \       0x14   0x28FF             CMP      R0,#+255
   \       0x16   0xD00C             BEQ.N    ??USBD_CDC_EP0_RxReady_0
    741            {
    742              ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(hcdc->CmdOpCode,
    743                                                                (uint8_t *)hcdc->data,
    744                                                                (uint16_t)hcdc->CmdLength);
   \       0x18   0xF895 0x2201      LDRB     R2,[R5, #+513]
   \       0x1C   0xB292             UXTH     R2,R2
   \       0x1E   0x0029             MOVS     R1,R5
   \       0x20   0xF895 0x0200      LDRB     R0,[R5, #+512]
   \       0x24   0xF8D4 0x32C0      LDR      R3,[R4, #+704]
   \       0x28   0x689B             LDR      R3,[R3, #+8]
   \       0x2A   0x4798             BLX      R3
    745              hcdc->CmdOpCode = 0xFFU;
   \       0x2C   0x20FF             MOVS     R0,#+255
   \       0x2E   0xF885 0x0200      STRB     R0,[R5, #+512]
    746          
    747            }
    748          
    749            return (uint8_t)USBD_OK;
   \                     ??USBD_CDC_EP0_RxReady_0: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xBD32             POP      {R1,R4,R5,PC}
    750          }
    751          
    752          /**
    753            * @brief  USBD_CDC_GetFSCfgDesc
    754            *         Return configuration descriptor
    755            * @param  speed : current device speed
    756            * @param  length : pointer data length
    757            * @retval pointer to descriptor buffer
    758            */

   \                                 In section .text, align 2, keep-with-next
    759          static uint8_t *USBD_CDC_GetFSCfgDesc(uint16_t *length)
    760          {
   \                     USBD_CDC_GetFSCfgDesc: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    761            *length = (uint16_t)sizeof(USBD_CDC_CfgFSDesc);
   \        0x2   0x2043             MOVS     R0,#+67
   \        0x4   0x8008             STRH     R0,[R1, #+0]
    762          
    763            return USBD_CDC_CfgFSDesc;
   \        0x6   0x....             LDR.N    R0,??DataTable4
   \        0x8   0x4770             BX       LR
    764          }
    765          
    766          /**
    767            * @brief  USBD_CDC_GetHSCfgDesc
    768            *         Return configuration descriptor
    769            * @param  speed : current device speed
    770            * @param  length : pointer data length
    771            * @retval pointer to descriptor buffer
    772            */

   \                                 In section .text, align 2, keep-with-next
    773          static uint8_t *USBD_CDC_GetHSCfgDesc(uint16_t *length)
    774          {
   \                     USBD_CDC_GetHSCfgDesc: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    775            *length = (uint16_t)sizeof(USBD_CDC_CfgHSDesc);
   \        0x2   0x2043             MOVS     R0,#+67
   \        0x4   0x8008             STRH     R0,[R1, #+0]
    776          
    777            return USBD_CDC_CfgHSDesc;
   \        0x6   0x....             LDR.N    R0,??DataTable4_1
   \        0x8   0x4770             BX       LR
    778          }
    779          
    780          /**
    781            * @brief  USBD_CDC_GetCfgDesc
    782            *         Return configuration descriptor
    783            * @param  speed : current device speed
    784            * @param  length : pointer data length
    785            * @retval pointer to descriptor buffer
    786            */

   \                                 In section .text, align 2, keep-with-next
    787          static uint8_t *USBD_CDC_GetOtherSpeedCfgDesc(uint16_t *length)
    788          {
   \                     USBD_CDC_GetOtherSpeedCfgDesc: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    789            *length = (uint16_t)sizeof(USBD_CDC_OtherSpeedCfgDesc);
   \        0x2   0x2043             MOVS     R0,#+67
   \        0x4   0x8008             STRH     R0,[R1, #+0]
    790          
    791            return USBD_CDC_OtherSpeedCfgDesc;
   \        0x6   0x....             LDR.N    R0,??DataTable4_2
   \        0x8   0x4770             BX       LR
    792          }
    793          
    794          /**
    795          * @brief  DeviceQualifierDescriptor
    796          *         return Device Qualifier descriptor
    797          * @param  length : pointer data length
    798          * @retval pointer to descriptor buffer
    799          */

   \                                 In section .text, align 2, keep-with-next
    800          uint8_t *USBD_CDC_GetDeviceQualifierDescriptor(uint16_t *length)
    801          {
   \                     USBD_CDC_GetDeviceQualifierDescriptor: (+1)
   \        0x0   0x0001             MOVS     R1,R0
    802            *length = (uint16_t)sizeof(USBD_CDC_DeviceQualifierDesc);
   \        0x2   0x200A             MOVS     R0,#+10
   \        0x4   0x8008             STRH     R0,[R1, #+0]
    803          
    804            return USBD_CDC_DeviceQualifierDesc;
   \        0x6   0x....             LDR.N    R0,??DataTable4_3
   \        0x8   0x4770             BX       LR
    805          }
    806          
    807          /**
    808          * @brief  USBD_CDC_RegisterInterface
    809            * @param  pdev: device instance
    810            * @param  fops: CD  Interface callback
    811            * @retval status
    812            */

   \                                 In section .text, align 2, keep-with-next
    813          uint8_t USBD_CDC_RegisterInterface(USBD_HandleTypeDef *pdev,
    814                                             USBD_CDC_ItfTypeDef *fops)
    815          {
   \                     USBD_CDC_RegisterInterface: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    816            if (fops == NULL)
   \        0x2   0x2900             CMP      R1,#+0
   \        0x4   0xD101             BNE.N    ??USBD_CDC_RegisterInterface_0
    817            {
    818              return (uint8_t)USBD_FAIL;
   \        0x6   0x2003             MOVS     R0,#+3
   \        0x8   0xE002             B.N      ??USBD_CDC_RegisterInterface_1
    819            }
    820          
    821            pdev->pUserData = fops;
   \                     ??USBD_CDC_RegisterInterface_0: (+1)
   \        0xA   0xF8C2 0x12C0      STR      R1,[R2, #+704]
    822          
    823            return (uint8_t)USBD_OK;
   \        0xE   0x2000             MOVS     R0,#+0
   \                     ??USBD_CDC_RegisterInterface_1: (+1)
   \       0x10   0x4770             BX       LR
    824          }
    825          
    826          /**
    827            * @brief  USBD_CDC_SetTxBuffer
    828            * @param  pdev: device instance
    829            * @param  pbuff: Tx Buffer
    830            * @retval status
    831            */

   \                                 In section .text, align 2, keep-with-next
    832          uint8_t USBD_CDC_SetTxBuffer(USBD_HandleTypeDef *pdev,
    833                                       uint8_t *pbuff, uint32_t length)
    834          {
   \                     USBD_CDC_SetTxBuffer: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0003             MOVS     R3,R0
    835            USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
   \        0x4   0xF8D3 0x42BC      LDR      R4,[R3, #+700]
    836          
    837            hcdc->TxBuffer = pbuff;
   \        0x8   0xF8C4 0x1208      STR      R1,[R4, #+520]
    838            hcdc->TxLength = length;
   \        0xC   0xF8C4 0x2210      STR      R2,[R4, #+528]
    839          
    840            return (uint8_t)USBD_OK;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xBC10             POP      {R4}
   \       0x14   0x4770             BX       LR
    841          }
    842          
    843          
    844          /**
    845            * @brief  USBD_CDC_SetRxBuffer
    846            * @param  pdev: device instance
    847            * @param  pbuff: Rx Buffer
    848            * @retval status
    849            */

   \                                 In section .text, align 2, keep-with-next
    850          uint8_t USBD_CDC_SetRxBuffer(USBD_HandleTypeDef *pdev, uint8_t *pbuff)
    851          {
   \                     USBD_CDC_SetRxBuffer: (+1)
   \        0x0   0x0002             MOVS     R2,R0
    852            USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
   \        0x2   0xF8D2 0x32BC      LDR      R3,[R2, #+700]
    853          
    854            hcdc->RxBuffer = pbuff;
   \        0x6   0xF8C3 0x1204      STR      R1,[R3, #+516]
    855          
    856            return (uint8_t)USBD_OK;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0x4770             BX       LR
    857          }
    858          
    859          /**
    860            * @brief  USBD_CDC_TransmitPacket
    861            *         Transmit packet on IN endpoint
    862            * @param  pdev: device instance
    863            * @retval status
    864            */

   \                                 In section .text, align 2, keep-with-next
    865          uint8_t USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
    866          {
   \                     USBD_CDC_TransmitPacket: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    867            USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
   \        0x4   0xF8D4 0x52BC      LDR      R5,[R4, #+700]
    868            USBD_StatusTypeDef ret = USBD_BUSY;
   \        0x8   0x2601             MOVS     R6,#+1
    869          
    870            if (pdev->pClassData == NULL)
   \        0xA   0xF8D4 0x02BC      LDR      R0,[R4, #+700]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD101             BNE.N    ??USBD_CDC_TransmitPacket_0
    871            {
    872              return (uint8_t)USBD_FAIL;
   \       0x12   0x2003             MOVS     R0,#+3
   \       0x14   0xE015             B.N      ??USBD_CDC_TransmitPacket_1
    873            }
    874          
    875            if (hcdc->TxState == 0U)
   \                     ??USBD_CDC_TransmitPacket_0: (+1)
   \       0x16   0xF8D5 0x0214      LDR      R0,[R5, #+532]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD10F             BNE.N    ??USBD_CDC_TransmitPacket_2
    876            {
    877              /* Tx Transfer in progress */
    878              hcdc->TxState = 1U;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xF8C5 0x0214      STR      R0,[R5, #+532]
    879          
    880              /* Update the packet total length */
    881              pdev->ep_in[CDC_IN_EP & 0xFU].total_length = hcdc->TxLength;
   \       0x24   0xF8D5 0x0210      LDR      R0,[R5, #+528]
   \       0x28   0x62E0             STR      R0,[R4, #+44]
    882          
    883              /* Transmit next packet */
    884              (void)USBD_LL_Transmit(pdev, CDC_IN_EP, hcdc->TxBuffer, hcdc->TxLength);
   \       0x2A   0xF8D5 0x3210      LDR      R3,[R5, #+528]
   \       0x2E   0xF8D5 0x2208      LDR      R2,[R5, #+520]
   \       0x32   0x2181             MOVS     R1,#+129
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       USBD_LL_Transmit
    885          
    886              ret = USBD_OK;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x0006             MOVS     R6,R0
    887            }
    888          
    889            return (uint8_t)ret;
   \                     ??USBD_CDC_TransmitPacket_2: (+1)
   \       0x3E   0x0030             MOVS     R0,R6
   \       0x40   0xB2C0             UXTB     R0,R0
   \                     ??USBD_CDC_TransmitPacket_1: (+1)
   \       0x42   0xBD70             POP      {R4-R6,PC}
    890          }
    891          
    892          
    893          /**
    894            * @brief  USBD_CDC_ReceivePacket
    895            *         prepare OUT Endpoint for reception
    896            * @param  pdev: device instance
    897            * @retval status
    898            */

   \                                 In section .text, align 2, keep-with-next
    899          uint8_t USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
    900          {
   \                     USBD_CDC_ReceivePacket: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
    901            USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
   \        0x4   0xF8D4 0x52BC      LDR      R5,[R4, #+700]
    902          
    903            if (pdev->pClassData == NULL)
   \        0x8   0xF8D4 0x02BC      LDR      R0,[R4, #+700]
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD101             BNE.N    ??USBD_CDC_ReceivePacket_0
    904            {
    905              return (uint8_t)USBD_FAIL;
   \       0x10   0x2003             MOVS     R0,#+3
   \       0x12   0xE013             B.N      ??USBD_CDC_ReceivePacket_1
    906            }
    907          
    908            if (pdev->dev_speed == USBD_SPEED_HIGH)
   \                     ??USBD_CDC_ReceivePacket_0: (+1)
   \       0x14   0x7C20             LDRB     R0,[R4, #+16]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD108             BNE.N    ??USBD_CDC_ReceivePacket_2
    909            {
    910              /* Prepare Out endpoint to receive next packet */
    911              (void)USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
    912                                           CDC_DATA_HS_OUT_PACKET_SIZE);
   \       0x1A   0xF44F 0x7300      MOV      R3,#+512
   \       0x1E   0xF8D5 0x2204      LDR      R2,[R5, #+516]
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x.... 0x....      BL       USBD_LL_PrepareReceive
   \       0x2A   0xE006             B.N      ??USBD_CDC_ReceivePacket_3
    913            }
    914            else
    915            {
    916              /* Prepare Out endpoint to receive next packet */
    917              (void)USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
    918                                           CDC_DATA_FS_OUT_PACKET_SIZE);
   \                     ??USBD_CDC_ReceivePacket_2: (+1)
   \       0x2C   0x2340             MOVS     R3,#+64
   \       0x2E   0xF8D5 0x2204      LDR      R2,[R5, #+516]
   \       0x32   0x2101             MOVS     R1,#+1
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x.... 0x....      BL       USBD_LL_PrepareReceive
    919            }
    920          
    921            return (uint8_t)USBD_OK;
   \                     ??USBD_CDC_ReceivePacket_3: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \                     ??USBD_CDC_ReceivePacket_1: (+1)
   \       0x3C   0xBD32             POP      {R1,R4,R5,PC}
    922          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x....'....        DC32     USBD_CDC_CfgFSDesc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x....'....        DC32     USBD_CDC_CfgHSDesc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x....'....        DC32     USBD_CDC_OtherSpeedCfgDesc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0x....'....        DC32     USBD_CDC_DeviceQualifierDesc
    923          /**
    924            * @}
    925            */
    926          
    927          /**
    928            * @}
    929            */
    930          
    931          /**
    932            * @}
    933            */
    934          
    935          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   USBD_CDC_DataIn
        24   -- Indirect call
        24   -> USBD_LL_Transmit
      16   USBD_CDC_DataOut
        16   -- Indirect call
        16   -> USBD_LL_GetRxDataSize
      16   USBD_CDC_DeInit
        16   -- Indirect call
        16   -> USBD_LL_CloseEP
        16   -> free
      16   USBD_CDC_EP0_RxReady
        16   -- Indirect call
       0   USBD_CDC_GetDeviceQualifierDescriptor
       0   USBD_CDC_GetFSCfgDesc
       0   USBD_CDC_GetHSCfgDesc
       0   USBD_CDC_GetOtherSpeedCfgDesc
      16   USBD_CDC_Init
        16   -- Indirect call
        16   -> USBD_LL_OpenEP
        16   -> USBD_LL_PrepareReceive
        16   -> malloc
      16   USBD_CDC_ReceivePacket
        16   -> USBD_LL_PrepareReceive
       0   USBD_CDC_RegisterInterface
       0   USBD_CDC_SetRxBuffer
       4   USBD_CDC_SetTxBuffer
      24   USBD_CDC_Setup
        24   -- Indirect call
        24   -> USBD_CtlError
        24   -> USBD_CtlPrepareRx
        24   -> USBD_CtlSendData
      16   USBD_CDC_TransmitPacket
        16   -> USBD_LL_Transmit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
      56  USBD_CDC
      68  USBD_CDC_CfgFSDesc
      68  USBD_CDC_CfgHSDesc
     140  USBD_CDC_DataIn
      56  USBD_CDC_DataOut
      90  USBD_CDC_DeInit
      12  USBD_CDC_DeviceQualifierDesc
      54  USBD_CDC_EP0_RxReady
      10  USBD_CDC_GetDeviceQualifierDescriptor
      10  USBD_CDC_GetFSCfgDesc
      10  USBD_CDC_GetHSCfgDesc
      10  USBD_CDC_GetOtherSpeedCfgDesc
     206  USBD_CDC_Init
      68  USBD_CDC_OtherSpeedCfgDesc
      62  USBD_CDC_ReceivePacket
      18  USBD_CDC_RegisterInterface
      14  USBD_CDC_SetRxBuffer
      22  USBD_CDC_SetTxBuffer
     262  USBD_CDC_Setup
      68  USBD_CDC_TransmitPacket

 
   272 bytes in section .data
 1'048 bytes in section .text
 
 1'048 bytes of CODE memory
   272 bytes of DATA memory

Errors: none
Warnings: 1
